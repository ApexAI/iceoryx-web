{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p>  </p> <p>Eclipse iceoryx\u2122 is an inter-process-communication middleware that enables virtually limitless data transmissions at constant time.</p>     Fast  Flexible  Dependable     <ul><li>True zero-copy shared memory communication</li><li>Message transfers with a latency of less than 1 \u00b5s</li><li>Made to handle GBytes/sec data transfers</li></ul> <ul><li>Support of various operating systems, communication patterns and APIs</li><li>Service discovery enables the design of dynamic systems</li><li>Easy to integrate into frameworks like ROS 2 or AUTOSAR Adaptive</li></ul> <ul><li>Developed according to automotive requirements</li><li>Implementation based on static memory and lock-free algorithms</li><li>Huge C++ library with safe STL implementations</li></ul>   Learn more Learn more  Learn more","title":"Welcome to iceoryx.io"},{"location":"FAQ/","text":"<p>In this document are tips and hints documented which can help for troubleshooting on RouDi.</p>","title":"FAQ"},{"location":"FAQ/#does-iceoryx-run-in-a-docker-environment","text":"<p>Yes. Take a look at the icedocker example</p>","title":"Does iceoryx run in a docker environment"},{"location":"FAQ/#iox-roudi-fails-on-startup","text":"<p>An error message like</p> <pre><code>user@iceoryx-host:/# iox-roudi\nLog level set to: [Warning]\nSharedMemory still there, doing an unlink of /iceoryx_mgmt\nReserving 59736448 bytes in the shared memory [/iceoryx_mgmt]\n[ Reserving shared memory successful ]\nSharedMemory still there, doing an unlink of /root\nReserving 27902400 bytes in the shared memory [/root]\nWhile setting the acquired shared memory to zero a fatal SIGBUS signal appeared\ncaused by memset. The shared memory object with the following properties\n[ name = /root, sizeInBytes = 27902400, access mode = AccessMode::READ_WRITE,\nownership = OwnerShip::MINE, baseAddressHint = (nil), permissions = 0 ] maybe\nrequires more memory than it is currently available in the system.\n</code></pre> <p>indicates that there is not enough shared memory available. Check with</p> <pre><code>df -H /dev/shm\n</code></pre> <p>if you have enough memory available. In this exemplary error message we require <code>59736448</code> (iceoryx management data) + <code>27902400</code> (user samples) ~ <code>83.57mb</code> of shared memory.</p>","title":"iox-roudi fails on startup"},{"location":"FAQ/#stack-size-handling","text":"<p>The iceoryx middleware utilize stack memory from the system for book-keeping of internal structures. Most Linux distributions offers 8 Megabyte of stack memory for a process which is enough for iceoryx. You can check this with the output from <code>ulimit -a</code>.</p> <p>On other platforms like windows other rules apply for the stack memory. On windows there is only 1 Megabyte of stack available. Increasing the stack size generally on iceoryx is not recommended since <code>Roudi</code> could consume lots of memory without using it. Especially using RouDi in a multi-threaded context can run out the stack memory and lead to memory errors.</p> <p>The <code>Single process</code> example shows that when compiling and executing it on windows. Without setting the stack size the application will throw a <code>Stack overflow</code> exception when entering the <code>main()</code> method.</p> <p>This can be solved in CMake by adding a linker flag:</p> <pre><code>target_link_options(single_process BEFORE PRIVATE /STACK:3500000)\n</code></pre> <p>For other platforms apply other flags or solutions.</p>","title":"Stack size handling"},{"location":"FAQ/#ci-fails-but-error-is-locally-not-reproducable","text":"<p>One can use <code>tools/scripts/ice_env.sh</code> to create an iceoryx development environment with a configuration very similar to the CI target. When for instance the target ubuntu 18.04 fails one can create a docker container with</p> <pre><code>cd tools/scripts\n./ice-env.sh enter ubuntu:18.04\n</code></pre> <p>This starts the container, installs all dependencies which iceoryx requires and enters the environment.</p>","title":"CI fails but error is locally not reproducable"},{"location":"FAQ/#docker","text":"<p>When you are in a docker environment check if there is enough memory available in your docker.</p> <pre><code># docker stats\nCONTAINER ID   NAME            CPU %     MEM USAGE / LIMIT   MEM %     NET I/O       BLOCK I/O     PIDS\n367b9fae6c2f   nifty_galileo   0.00%     4.48MiB / 1GiB      0.44%     11.6kB / 0B   17.6MB / 0B   1\n</code></pre> <p>If not you can restart the docker container with <code>--shm-size=\"2g\"</code> to increase the total amount of available shared memory.</p> <pre><code>docker run -it --shm-size=\"2g\" ubuntu\n</code></pre>","title":"docker"},{"location":"FAQ/#termination-of-roudi-and-processes","text":"<p>To avoid undefined behavior of iceoryx posh it is recommended to terminate RouDi and the corresponding middleware processes with SIGINT or SIGTERM. In RouDi, we have integrated a sighandler that catches the signals and gives RouDi the chance to exit and clean-up everything. This also applies for processes. Therefore, we recommend adding a signalhandler to your process (see this example).</p>","title":"Termination of RouDi and processes"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/","text":"<p>The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application.  <code>#include &lt;iceoryx_dds/dds/cyclone_context.hpp&gt;</code></p>","title":"iox::dds::CycloneContext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#public-functions","text":"Name     ::dds::domain::DomainParticipant &amp; getParticipant()getParticipant Get the DDS Domain Participant for the current runtime.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#function-getparticipant","text":"<pre><code>static ::dds::domain::DomainParticipant &amp; getParticipant()\n</code></pre> <p>getParticipant Get the DDS Domain Participant for the current runtime. </p> <p>Return: The DDS Domain Participant. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getParticipant"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/","text":"<p>Implementation of the DataReader abstraction using the cyclonedds implementation.  <code>#include &lt;iceoryx_dds/dds/cyclone_data_reader.hpp&gt;</code></p> <p>Inherits from iox::dds::DataReader</p>","title":"iox::dds::CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#public-functions","text":"Name      CycloneDataReader()    CycloneDataReader(const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId)Constructor to set cyclone data reader object from given IDs.   virtual ~CycloneDataReader()    CycloneDataReader(const CycloneDataReader &amp; )   CycloneDataReader &amp; operator=(const CycloneDataReader &amp; )    CycloneDataReader(CycloneDataReader &amp;&amp; )   CycloneDataReader &amp; operator=(CycloneDataReader &amp;&amp; )   virtual void connect() overrideConnect cylcone data reader to the underlying DDS network.   virtual iox::cxx::optional&lt; IoxChunkDatagramHeader &gt; peekNextIoxChunkDatagramHeader() overridepeekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available.   virtual bool hasSamples() overrideChecks if new samples are ready to take.   virtual iox::cxx::expected&lt; DataReaderError &gt; takeNext(const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) overridetake Take the next available sample from the DDS data space.   virtual capro::IdString_t getServiceId() const overrideget ID of the service   virtual capro::IdString_t getInstanceId() const overrideget ID of the instance   virtual capro::IdString_t getEventId() const overrideget ID of the event","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#additional-inherited-members","text":"<p>Protected Functions inherited from iox::dds::DataReader</p>     Name      DataReader() =default","title":"Additional inherited members"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader","text":"<pre><code>CycloneDataReader()\n</code></pre>","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_1","text":"<pre><code>CycloneDataReader(\n    const capro::IdString_t serviceId,\n    const capro::IdString_t instanceId,\n    const capro::IdString_t eventId\n)\n</code></pre> <p>Constructor to set cyclone data reader object from given IDs. </p> <p>Parameters: </p> <ul> <li>serviceId ID of the service </li> <li>instanceId ID of the instance of the service </li> <li>eventId ID of the event </li> </ul>","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_2","text":"<pre><code>virtual ~CycloneDataReader()\n</code></pre>","title":"function ~CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_3","text":"<pre><code>CycloneDataReader(\n    const CycloneDataReader &amp; \n)\n</code></pre>","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-operator","text":"<pre><code>CycloneDataReader &amp; operator=(\n    const CycloneDataReader &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_4","text":"<pre><code>CycloneDataReader(\n    CycloneDataReader &amp;&amp; \n)\n</code></pre>","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-operator_1","text":"<pre><code>CycloneDataReader &amp; operator=(\n    CycloneDataReader &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-connect","text":"<pre><code>virtual void connect() override\n</code></pre> <p>Connect cylcone data reader to the underlying DDS network. </p> <p>Reimplements: iox::dds::DataReader::connect</p>","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-peeknextioxchunkdatagramheader","text":"<pre><code>virtual iox::cxx::optional&lt; IoxChunkDatagramHeader &gt; peekNextIoxChunkDatagramHeader() override\n</code></pre> <p>peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. </p> <p>Return: The IoxChunkDatagramHeader of the next sample if one is available. </p> <p>Reimplements: iox::dds::DataReader::peekNextIoxChunkDatagramHeader</p>","title":"function peekNextIoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-hassamples","text":"<pre><code>virtual bool hasSamples() override\n</code></pre> <p>Checks if new samples are ready to take. </p> <p>Return: True if new samples are available. </p> <p>Reimplements: iox::dds::DataReader::hasSamples</p>","title":"function hasSamples"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-takenext","text":"<pre><code>virtual iox::cxx::expected&lt; DataReaderError &gt; takeNext(\n    const IoxChunkDatagramHeader datagramHeader,\n    uint8_t *const userHeaderBuffer,\n    uint8_t *const userPayloadBuffer\n) override\n</code></pre> <p>take Take the next available sample from the DDS data space. </p> <p>Parameters: </p> <ul> <li>datagramHeader with size information </li> <li>userHeaderBuffer buffer for the user-header </li> <li>userPayloadBuffer buffer for the user-payload </li> </ul> <p>Return: Error if unsuccessful. </p> <p>Reimplements: iox::dds::DataReader::takeNext</p>","title":"function takeNext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-getserviceid","text":"<pre><code>virtual capro::IdString_t getServiceId() const override\n</code></pre> <p>get ID of the service </p> <p>Reimplements: iox::dds::DataReader::getServiceId</p>","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-getinstanceid","text":"<pre><code>virtual capro::IdString_t getInstanceId() const override\n</code></pre> <p>get ID of the instance </p> <p>Reimplements: iox::dds::DataReader::getInstanceId</p>","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-geteventid","text":"<pre><code>virtual capro::IdString_t getEventId() const override\n</code></pre> <p>get ID of the event </p> <p>Reimplements: iox::dds::DataReader::getEventId</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/","text":"<p>Implementation of the DataWriter abstraction using the cyclonedds implementation.  <code>#include &lt;iceoryx_dds/dds/cyclone_data_writer.hpp&gt;</code></p> <p>Inherits from iox::dds::DataWriter</p>","title":"iox::dds::CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#public-functions","text":"Name      CycloneDataWriter()    CycloneDataWriter(const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId)Constructor to set cyclone data writer object from given IDs.   virtual ~CycloneDataWriter()    CycloneDataWriter(const CycloneDataWriter &amp; )   CycloneDataWriter &amp; operator=(const CycloneDataWriter &amp; )    CycloneDataWriter(CycloneDataWriter &amp;&amp; rhs) =default   CycloneDataWriter &amp; operator=(CycloneDataWriter &amp;&amp; rhs) =default   virtual void connect() overrideconnect cyclone data writer to the underlying DDS network   virtual void write(iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) overridewrite Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId   virtual capro::IdString_t getServiceId() const overrideGet ID of the service.   virtual capro::IdString_t getInstanceId() const overrideGet ID of the instance.   virtual capro::IdString_t getEventId() const overrideGet ID of the event.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#additional-inherited-members","text":"<p>Public Functions inherited from iox::dds::DataWriter</p>     Name     virtual ~DataWriter() =default    <p>Protected Functions inherited from iox::dds::DataWriter</p>     Name      DataWriter() =default","title":"Additional inherited members"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter","text":"<pre><code>CycloneDataWriter()\n</code></pre>","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_1","text":"<pre><code>CycloneDataWriter(\n    const capro::IdString_t serviceId,\n    const capro::IdString_t instanceId,\n    const capro::IdString_t eventId\n)\n</code></pre> <p>Constructor to set cyclone data writer object from given IDs. </p> <p>Parameters: </p> <ul> <li>serviceId ID of the service </li> <li>instanceId ID of the instance of the service </li> <li>eventId ID of the event </li> </ul>","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_2","text":"<pre><code>virtual ~CycloneDataWriter()\n</code></pre>","title":"function ~CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_3","text":"<pre><code>CycloneDataWriter(\n    const CycloneDataWriter &amp; \n)\n</code></pre>","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-operator","text":"<pre><code>CycloneDataWriter &amp; operator=(\n    const CycloneDataWriter &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_4","text":"<pre><code>CycloneDataWriter(\n    CycloneDataWriter &amp;&amp; rhs\n) =default\n</code></pre>","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-operator_1","text":"<pre><code>CycloneDataWriter &amp; operator=(\n    CycloneDataWriter &amp;&amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-connect","text":"<pre><code>virtual void connect() override\n</code></pre> <p>connect cyclone data writer to the underlying DDS network </p> <p>Reimplements: iox::dds::DataWriter::connect</p>","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-write","text":"<pre><code>virtual void write(\n    iox::dds::IoxChunkDatagramHeader datagramHeader,\n    const uint8_t *const userHeaderBytes,\n    const uint8_t *const userPayloadBytes\n) override\n</code></pre> <p>write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId </p> <p>Parameters: </p> <ul> <li>datagramHeader with size information </li> <li>userHeaderBytes buffer with the user-header </li> <li>userPayloadBytes buffer with the user-payload </li> </ul> <p>Reimplements: iox::dds::DataWriter::write</p>","title":"function write"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-getserviceid","text":"<pre><code>virtual capro::IdString_t getServiceId() const override\n</code></pre> <p>Get ID of the service. </p> <p>Reimplements: iox::dds::DataWriter::getServiceId</p>","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-getinstanceid","text":"<pre><code>virtual capro::IdString_t getInstanceId() const override\n</code></pre> <p>Get ID of the instance. </p> <p>Reimplements: iox::dds::DataWriter::getInstanceId</p>","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-geteventid","text":"<pre><code>virtual capro::IdString_t getEventId() const override\n</code></pre> <p>Get ID of the event. </p> <p>Reimplements: iox::dds::DataWriter::getEventId</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/","text":"<p>DDS Gateway implementation for the DDS to iceoryx direction.  More...</p> <p><code>#include &lt;iceoryx_dds/gateway/dds_to_iox.hpp&gt;</code></p> <p>Inherits from gw::GatewayGeneric&lt; gw::Channel&lt; popo::UntypedPublisher, dds::data_reader_t &gt; &gt;</p>","title":"iox::dds::DDS2IceoryxGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#public-functions","text":"Name      DDS2IceoryxGateway()Creates a gateway with DDS set as interface.   void loadConfiguration(const config::GatewayConfig &amp; config)   void discover(const capro::CaproMessage &amp; msg)   void forward(const channel_t &amp; channel)","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#detailed-description","text":"<pre><code>template &lt;typename channel_t  =gw::Channel&lt;popo::UntypedPublisher, dds::data_reader_t&gt;,\ntypename gateway_t  =gw::GatewayGeneric&lt;channel_t&gt;&gt;\nclass iox::dds::DDS2IceoryxGateway;\n</code></pre> <p>DDS Gateway implementation for the DDS to iceoryx direction. </p>","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-dds2iceoryxgateway","text":"<pre><code>DDS2IceoryxGateway()\n</code></pre> <p>Creates a gateway with DDS set as interface. </p>","title":"function DDS2IceoryxGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-loadconfiguration","text":"<pre><code>void loadConfiguration(\n    const config::GatewayConfig &amp; config\n)\n</code></pre>","title":"function loadConfiguration"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-discover","text":"<pre><code>void discover(\n    const capro::CaproMessage &amp; msg\n)\n</code></pre>","title":"function discover"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-forward","text":"<pre><code>void forward(\n    const channel_t &amp; channel\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function forward"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/","text":"<p>Abstraction for DDS Data Readers.  <code>#include &lt;iceoryx_dds/dds/data_reader.hpp&gt;</code></p> <p>Inherited by iox::dds::CycloneDataReader</p>","title":"iox::dds::DataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#public-functions","text":"Name     virtual void connect() =0Connect the DataReader to the underlying DDS network.   virtual iox::cxx::optional&lt; IoxChunkDatagramHeader &gt; peekNextIoxChunkDatagramHeader() =0peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available.   virtual bool hasSamples() =0Checks if new samples are ready to take.   virtual iox::cxx::expected&lt; DataReaderError &gt; takeNext(const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) =0take Take the next available sample from the DDS data space.   virtual capro::IdString_t getServiceId() const =0get ID of the service   virtual capro::IdString_t getInstanceId() const =0get ID of the instance   virtual capro::IdString_t getEventId() const =0get ID of the event","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#protected-functions","text":"Name      DataReader() =default","title":"Protected Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-connect","text":"<pre><code>virtual void connect() =0\n</code></pre> <p>Connect the DataReader to the underlying DDS network. </p> <p>Reimplemented by: iox::dds::CycloneDataReader::connect</p>","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-peeknextioxchunkdatagramheader","text":"<pre><code>virtual iox::cxx::optional&lt; IoxChunkDatagramHeader &gt; peekNextIoxChunkDatagramHeader() =0\n</code></pre> <p>peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. </p> <p>Return: The IoxChunkDatagramHeader of the next sample if one is available. </p> <p>Reimplemented by: iox::dds::CycloneDataReader::peekNextIoxChunkDatagramHeader</p>","title":"function peekNextIoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-hassamples","text":"<pre><code>virtual bool hasSamples() =0\n</code></pre> <p>Checks if new samples are ready to take. </p> <p>Return: True if new samples are available. </p> <p>Reimplemented by: iox::dds::CycloneDataReader::hasSamples</p>","title":"function hasSamples"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-takenext","text":"<pre><code>virtual iox::cxx::expected&lt; DataReaderError &gt; takeNext(\n    const IoxChunkDatagramHeader datagramHeader,\n    uint8_t *const userHeaderBuffer,\n    uint8_t *const userPayloadBuffer\n) =0\n</code></pre> <p>take Take the next available sample from the DDS data space. </p> <p>Parameters: </p> <ul> <li>datagramHeader with size information </li> <li>userHeaderBuffer buffer for the user-header </li> <li>userPayloadBuffer buffer for the user-payload </li> </ul> <p>Return: Error if unsuccessful. </p> <p>Reimplemented by: iox::dds::CycloneDataReader::takeNext</p>","title":"function takeNext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-getserviceid","text":"<pre><code>virtual capro::IdString_t getServiceId() const =0\n</code></pre> <p>get ID of the service </p> <p>Reimplemented by: iox::dds::CycloneDataReader::getServiceId</p>","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-getinstanceid","text":"<pre><code>virtual capro::IdString_t getInstanceId() const =0\n</code></pre> <p>get ID of the instance </p> <p>Reimplemented by: iox::dds::CycloneDataReader::getInstanceId</p>","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-geteventid","text":"<pre><code>virtual capro::IdString_t getEventId() const =0\n</code></pre> <p>get ID of the event </p> <p>Reimplemented by: iox::dds::CycloneDataReader::getEventId</p>","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-datareader","text":"<pre><code>DataReader() =default\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function DataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/","text":"<p>Abstraction for DDS Data Writers.  More...</p> <p><code>#include &lt;iceoryx_dds/dds/data_writer.hpp&gt;</code></p> <p>Inherited by iox::dds::CycloneDataWriter</p>","title":"iox::dds::DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#public-functions","text":"Name     virtual ~DataWriter() =default   virtual void connect() =0Connect the DataWriter to the underlying DDS network.   virtual void write(iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) =0write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId   virtual capro::IdString_t getServiceId() const =0Get ID of the service.   virtual capro::IdString_t getInstanceId() const =0Get ID of the instance.   virtual capro::IdString_t getEventId() const =0Get ID of the event.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#protected-functions","text":"Name      DataWriter() =default","title":"Protected Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#detailed-description","text":"<pre><code>class iox::dds::DataWriter;\n</code></pre> <p>Abstraction for DDS Data Writers. </p> <p>Note: Provides the minimum functionality required for posh-dds gateway implementations. </p>","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-datawriter","text":"<pre><code>virtual ~DataWriter() =default\n</code></pre>","title":"function ~DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-connect","text":"<pre><code>virtual void connect() =0\n</code></pre> <p>Connect the DataWriter to the underlying DDS network. </p> <p>Reimplemented by: iox::dds::CycloneDataWriter::connect</p>","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-write","text":"<pre><code>virtual void write(\n    iox::dds::IoxChunkDatagramHeader datagramHeader,\n    const uint8_t *const userHeaderBytes,\n    const uint8_t *const userPayloadBytes\n) =0\n</code></pre> <p>write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId </p> <p>Parameters: </p> <ul> <li>datagramHeader with size information </li> <li>userHeaderBytes buffer with the user-header </li> <li>userPayloadBytes buffer with the user-payload </li> </ul> <p>Reimplemented by: iox::dds::CycloneDataWriter::write</p>","title":"function write"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-getserviceid","text":"<pre><code>virtual capro::IdString_t getServiceId() const =0\n</code></pre> <p>Get ID of the service. </p> <p>Reimplemented by: iox::dds::CycloneDataWriter::getServiceId</p>","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-getinstanceid","text":"<pre><code>virtual capro::IdString_t getInstanceId() const =0\n</code></pre> <p>Get ID of the instance. </p> <p>Reimplemented by: iox::dds::CycloneDataWriter::getInstanceId</p>","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-geteventid","text":"<pre><code>virtual capro::IdString_t getEventId() const =0\n</code></pre> <p>Get ID of the event. </p> <p>Reimplemented by: iox::dds::CycloneDataWriter::getEventId</p>","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-datawriter_1","text":"<pre><code>DataWriter() =default\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/","text":"<p>DDS Gateway implementation for the iceoryx to DDS direction.  More...</p> <p><code>#include &lt;iceoryx_dds/gateway/iox_to_dds.hpp&gt;</code></p> <p>Inherits from gw::GatewayGeneric&lt; gw::Channel&lt; popo::UntypedSubscriber, dds::data_writer_t &gt; &gt;</p>","title":"iox::dds::Iceoryx2DDSGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#public-functions","text":"Name      Iceoryx2DDSGateway()Creates a gateway with DDS set as interface.   void loadConfiguration(const config::GatewayConfig &amp; config)   void discover(const capro::CaproMessage &amp; msg)   void forward(const channel_t &amp; channel)","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#detailed-description","text":"<pre><code>template &lt;typename channel_t  =gw::Channel&lt;popo::UntypedSubscriber, dds::data_writer_t&gt;,\ntypename gateway_t  =gw::GatewayGeneric&lt;channel_t&gt;&gt;\nclass iox::dds::Iceoryx2DDSGateway;\n</code></pre> <p>DDS Gateway implementation for the iceoryx to DDS direction. </p>","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-iceoryx2ddsgateway","text":"<pre><code>Iceoryx2DDSGateway()\n</code></pre> <p>Creates a gateway with DDS set as interface. </p>","title":"function Iceoryx2DDSGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-loadconfiguration","text":"<pre><code>void loadConfiguration(\n    const config::GatewayConfig &amp; config\n)\n</code></pre>","title":"function loadConfiguration"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-discover","text":"<pre><code>void discover(\n    const capro::CaproMessage &amp; msg\n)\n</code></pre>","title":"function discover"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-forward","text":"<pre><code>void forward(\n    const channel_t &amp; channel\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function forward"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/","text":"<p>The datagram header with chunk metadata for user-header and user-payload.  <code>#include &lt;iceoryx_dds/dds/iox_chunk_datagram_header.hpp&gt;</code></p>","title":"iox::dds::IoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-types","text":"Name     using iox::cxx::vector&lt; uint8_t, 16U &gt; Serialized_t","title":"Public Types"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-functions","text":"Name     Serialized_t serialize(const IoxChunkDatagramHeader &amp; datagramHeader)Serializes a IoxChunkDatagramHeader into a vector of uint8_t.   IoxChunkDatagramHeader deserialize(const Serialized_t &amp; serializedDatagramHeader)Deserializes a vector of uint8_t into a IoxChunkDatagramHeader.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-attributes","text":"Name     constexpr uint8_t DATAGRAM_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g.   uint8_t datagramVersion   Endianess endianness   uint16_t userHeaderId   uint32_t userHeaderSize   uint32_t userPayloadSize   uint32_t userPayloadAlignment","title":"Public Attributes"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#using-serialized_t","text":"<pre><code>using iox::dds::IoxChunkDatagramHeader::Serialized_t =  iox::cxx::vector&lt;uint8_t, 16U&gt;;\n</code></pre>","title":"using Serialized_t"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#function-serialize","text":"<pre><code>static Serialized_t serialize(\n    const IoxChunkDatagramHeader &amp; datagramHeader\n)\n</code></pre> <p>Serializes a IoxChunkDatagramHeader into a vector of uint8_t. </p> <p>Parameters: </p> <ul> <li>datagramHeader to serialize </li> </ul> <p>Return: the serialized IoxChunkDatagramHeader</p>","title":"function serialize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#function-deserialize","text":"<pre><code>static IoxChunkDatagramHeader deserialize(\n    const Serialized_t &amp; serializedDatagramHeader\n)\n</code></pre> <p>Deserializes a vector of uint8_t into a IoxChunkDatagramHeader. </p> <p>Parameters: </p> <ul> <li>serializedDatagram is the serialized IoxChunkDatagramHeader</li> </ul> <p>Return: the deserialized IoxChunkDatagramHeader</p>","title":"function deserialize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-datagram_version","text":"<pre><code>static constexpr uint8_t DATAGRAM_VERSION {1U};\n</code></pre> <p>From the 1.0 release onward, this must be incremented for each incompatible change, e.g. </p> <ul> <li>data width of members changes</li> <li>members are rearranged</li> <li>semantic meaning of a member changes </li> </ul>","title":"variable DATAGRAM_VERSION"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-datagramversion","text":"<pre><code>uint8_t datagramVersion {[DATAGRAM_VERSION](/v2.0.0/API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-datagram_version)};\n</code></pre> <p>Note: This must always be the first member and always 1 bytes in order to prevent issues with endianess when deserialized or incorrectly detected versions due to different size </p>","title":"variable datagramVersion"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-endianness","text":"<pre><code>Endianess endianness {Endianess::UNDEFINED};\n</code></pre> <p>Note: This must always be 1 byte in order to prevent issues with endianess when deserialized </p>","title":"variable endianness"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userheaderid","text":"<pre><code>uint16_t userHeaderId {0xFFFF};\n</code></pre>","title":"variable userHeaderId"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userheadersize","text":"<pre><code>uint32_t userHeaderSize {0U};\n</code></pre>","title":"variable userHeaderSize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userpayloadsize","text":"<pre><code>uint32_t userPayloadSize {0U};\n</code></pre>","title":"variable userPayloadSize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userpayloadalignment","text":"<pre><code>uint32_t userPayloadAlignment {0U};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable userPayloadAlignment"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/","text":"","title":"iceoryx_dds/dds/cyclone_context.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#classes","text":"Name     class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef CYCLONE_CONTEXT_HPP\n#define CYCLONE_CONTEXT_HPP\n\n#include &lt;dds/dds.hpp&gt;\n\nnamespace iox\n{\nnamespace dds\n{\nclass CycloneContext\n{\n  public:\n    static ::dds::domain::DomainParticipant&amp; getParticipant() noexcept;\n};\n\n} // namespace dds\n} // namespace iox\n\n#endif // CYCLONE_CONTEXT_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/","text":"","title":"iceoryx_dds/dds/cyclone_data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#classes","text":"Name     class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_CYCLONE_DATA_READER_HPP\n#define IOX_DDS_DDS_CYCLONE_DATA_READER_HPP\n\n#include \"iceoryx_dds/Mempool.hpp\"\n#include \"iceoryx_dds/dds/data_reader.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;dds/dds.hpp&gt;\n\nnamespace iox\n{\nnamespace dds\n{\nclass CycloneDataReader : public DataReader\n{\n  public:\n    CycloneDataReader() = delete;\n\n    CycloneDataReader(const capro::IdString_t serviceId,\n                      const capro::IdString_t instanceId,\n                      const capro::IdString_t eventId) noexcept;\n\n    virtual ~CycloneDataReader();\n\n    CycloneDataReader(const CycloneDataReader&amp;) = delete;\n    CycloneDataReader&amp; operator=(const CycloneDataReader&amp;) = delete;\n    CycloneDataReader(CycloneDataReader&amp;&amp;) = delete;\n    CycloneDataReader&amp; operator=(CycloneDataReader&amp;&amp;) = delete;\n\n    void connect() noexcept override;\n\n    iox::cxx::optional&lt;IoxChunkDatagramHeader&gt; peekNextIoxChunkDatagramHeader() noexcept override;\n    bool hasSamples() noexcept override;\n    iox::cxx::expected&lt;DataReaderError&gt; takeNext(const IoxChunkDatagramHeader datagramHeader,\n                                                 uint8_t* const userHeaderBuffer,\n                                                 uint8_t* const userPayloadBuffer) noexcept override;\n\n    capro::IdString_t getServiceId() const noexcept override;\n    capro::IdString_t getInstanceId() const noexcept override;\n    capro::IdString_t getEventId() const noexcept override;\n\n  private:\n    capro::IdString_t m_serviceId{\"\"};\n    capro::IdString_t m_instanceId{\"\"};\n    capro::IdString_t m_eventId{\"\"};\n\n    ::dds::sub::DataReader&lt;Mempool::Chunk&gt; m_impl = ::dds::core::null;\n\n    std::atomic_bool m_isConnected{false};\n};\n\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_CYCLONE_DATA_READER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/","text":"","title":"iceoryx_dds/dds/cyclone_data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#classes","text":"Name     class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP\n#define IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP\n\n#include \"iceoryx_dds/Mempool.hpp\"\n#include \"iceoryx_dds/dds/data_writer.hpp\"\n\n#include &lt;dds/dds.hpp&gt;\n\nnamespace iox\n{\nnamespace dds\n{\nclass CycloneDataWriter : public iox::dds::DataWriter\n{\n  public:\n    CycloneDataWriter() = delete;\n\n    CycloneDataWriter(const capro::IdString_t serviceId,\n                      const capro::IdString_t instanceId,\n                      const capro::IdString_t eventId) noexcept;\n\n    virtual ~CycloneDataWriter();\n\n    CycloneDataWriter(const CycloneDataWriter&amp;) = delete;\n    CycloneDataWriter&amp; operator=(const CycloneDataWriter&amp;) = delete;\n    CycloneDataWriter(CycloneDataWriter&amp;&amp; rhs) = default;\n    CycloneDataWriter&amp; operator=(CycloneDataWriter&amp;&amp; rhs) = default;\n\n    void connect() noexcept override;\n    void write(iox::dds::IoxChunkDatagramHeader datagramHeader,\n               const uint8_t* const userHeaderBytes,\n               const uint8_t* const userPayloadBytes) noexcept override;\n\n    capro::IdString_t getServiceId() const noexcept override;\n    capro::IdString_t getInstanceId() const noexcept override;\n    capro::IdString_t getEventId() const noexcept override;\n\n  private:\n    capro::IdString_t m_serviceId{\"\"};\n    capro::IdString_t m_instanceId{\"\"};\n    capro::IdString_t m_eventId{\"\"};\n\n    ::dds::pub::Publisher m_publisher = ::dds::core::null;\n    ::dds::topic::Topic&lt;Mempool::Chunk&gt; m_topic = ::dds::core::null;\n    ::dds::pub::DataWriter&lt;Mempool::Chunk&gt; m_writer = ::dds::core::null;\n};\n\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/","text":"","title":"iceoryx_dds/dds/data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#classes","text":"Name     class iox::dds::DataReader Abstraction for DDS Data Readers.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_DATA_READER_HPP\n#define IOX_DDS_DDS_DATA_READER_HPP\n\n#include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\"\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace dds\n{\nenum class DataReaderError : uint8_t\n{\n    NOT_CONNECTED,\n    INVALID_DATAGRAM_HEADER_SIZE,\n    INVALID_BUFFER_PARAMETER_FOR_USER_HEADER,\n    INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD,\n    INVALID_DATA,\n    BUFFER_SIZE_MISMATCH\n};\n\nconstexpr const char* DataReaderErrorString[] = {\"NOT_CONNECTED\",\n                                                 \"INVALID_DATAGRAM_HEADER_SIZE\",\n                                                 \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\",\n                                                 \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\",\n                                                 \"INVALID_DATA\",\n                                                 \"BUFFER_SIZE_MISMATCH\"};\n\nclass DataReader\n{\n  public:\n    virtual void connect() noexcept = 0;\n\n    virtual iox::cxx::optional&lt;IoxChunkDatagramHeader&gt; peekNextIoxChunkDatagramHeader() noexcept = 0;\n\n    virtual bool hasSamples() noexcept = 0;\n\n    virtual iox::cxx::expected&lt;DataReaderError&gt; takeNext(const IoxChunkDatagramHeader datagramHeader,\n                                                         uint8_t* const userHeaderBuffer,\n                                                         uint8_t* const userPayloadBuffer) noexcept = 0;\n\n    virtual capro::IdString_t getServiceId() const noexcept = 0;\n\n    virtual capro::IdString_t getInstanceId() const noexcept = 0;\n\n    virtual capro::IdString_t getEventId() const noexcept = 0;\n\n  protected:\n    DataReader() noexcept = default;\n};\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_DATA_READER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/","text":"","title":"iceoryx_dds/dds/data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#classes","text":"Name     class iox::dds::DataWriter Abstraction for DDS Data Writers.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_DATA_WRITER_HPP\n#define IOX_DDS_DDS_DATA_WRITER_HPP\n\n#include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\"\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace dds\n{\nclass DataWriter\n{\n  public:\n    virtual ~DataWriter() = default;\n\n    virtual void connect() noexcept = 0;\n\n    virtual void write(iox::dds::IoxChunkDatagramHeader datagramHeader,\n                       const uint8_t* const userHeaderBytes,\n                       const uint8_t* const userPayloadBytes) noexcept = 0;\n\n    virtual capro::IdString_t getServiceId() const noexcept = 0;\n\n    virtual capro::IdString_t getInstanceId() const noexcept = 0;\n\n    virtual capro::IdString_t getEventId() const noexcept = 0;\n\n  protected:\n    DataWriter() = default;\n};\n\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_DATA_WRITER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/","text":"","title":"iceoryx_dds/dds/dds_config.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/#namespaces","text":"Name     iox   iox::dds   units::duration_literals","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_CONFIG_HPP\n#define IOX_DDS_DDS_CONFIG_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace dds\n{\nusing namespace units::duration_literals;\nstatic constexpr units::Duration DISCOVERY_PERIOD = 1000_ms;\nstatic constexpr units::Duration FORWARDING_PERIOD = 50_ms;\nstatic constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u;\n\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/","text":"","title":"iceoryx_dds/gateway/dds_to_iox.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#classes","text":"Name     class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_TO_IOX_HPP\n#define IOX_DDS_DDS_TO_IOX_HPP\n\n#include \"iceoryx_dds/dds/dds_types.hpp\"\n#include \"iceoryx_posh/gateway/channel.hpp\"\n#include \"iceoryx_posh/gateway/gateway_config.hpp\"\n#include \"iceoryx_posh/gateway/gateway_generic.hpp\"\n#include \"iceoryx_posh/popo/untyped_publisher.hpp\"\n\nnamespace iox\n{\nnamespace dds\n{\ntemplate &lt;typename channel_t = gw::Channel&lt;popo::UntypedPublisher, dds::data_reader_t&gt;,\n          typename gateway_t = gw::GatewayGeneric&lt;channel_t&gt;&gt;\nclass DDS2IceoryxGateway : public gateway_t\n{\n  public:\n    DDS2IceoryxGateway() noexcept;\n\n    void loadConfiguration(const config::GatewayConfig&amp; config) noexcept;\n    void discover(const capro::CaproMessage&amp; msg) noexcept;\n    void forward(const channel_t&amp; channel) noexcept;\n\n  private:\n    void* m_reservedChunk = nullptr;\n\n    cxx::expected&lt;channel_t, gw::GatewayError&gt; setupChannel(const capro::ServiceDescription&amp; service,\n                                                            const popo::PublisherOptions&amp; publisherOptions) noexcept;\n};\n\n} // namespace dds\n} // namespace iox\n\n#include \"iceoryx_dds/internal/gateway/dds_to_iox.inl\"\n\n#endif // IOX_DDS_DDS_TO_IOX_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/","text":"","title":"iceoryx_dds/dds/dds_types.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_DDS_TYPES_HPP\n#define IOX_DDS_DDS_DDS_TYPES_HPP\n\n#ifdef USE_CYCLONE_DDS\n#include \"iceoryx_dds/dds/cyclone_data_reader.hpp\"\n#include \"iceoryx_dds/dds/cyclone_data_writer.hpp\"\n#else\n#error \"A DDS implementation must be provided.\"\n#endif\n\nnamespace iox\n{\nnamespace dds\n{\n// DDS implementation defined with compiler flags\n#ifdef USE_CYCLONE_DDS\nusing data_reader_t = iox::dds::CycloneDataReader;\nusing data_writer_t = iox::dds::CycloneDataWriter;\n#else\n#error \"A DDS implementation must be set.\"\n#endif\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_DDS_TYPES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dir_1a82753d8824303b9a4093edfd2a02d7/","text":"","title":"iceoryx_dds/dds"},{"location":"API-reference/DDS-gateway/Files/dir_1a82753d8824303b9a4093edfd2a02d7/#files","text":"Name     iceoryx_dds/dds/cyclone_context.hpp   iceoryx_dds/dds/cyclone_data_reader.hpp   iceoryx_dds/dds/cyclone_data_writer.hpp   iceoryx_dds/dds/data_reader.hpp   iceoryx_dds/dds/data_writer.hpp   iceoryx_dds/dds/dds_config.hpp   iceoryx_dds/dds/dds_types.hpp   iceoryx_dds/dds/iox_chunk_datagram_header.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/DDS-gateway/Files/dir_afbf8928646817b6b649ce75b30863ef/","text":"","title":"iceoryx_dds"},{"location":"API-reference/DDS-gateway/Files/dir_afbf8928646817b6b649ce75b30863ef/#directories","text":"Name     iceoryx_dds/dds   iceoryx_dds/gateway     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Directories"},{"location":"API-reference/DDS-gateway/Files/dir_d89b9f530a1a11760f613e54bce77e1a/","text":"","title":"iceoryx_dds/gateway"},{"location":"API-reference/DDS-gateway/Files/dir_d89b9f530a1a11760f613e54bce77e1a/#files","text":"Name     iceoryx_dds/gateway/dds_to_iox.hpp   iceoryx_dds/gateway/iox_to_dds.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/","text":"","title":"iceoryx_dds/dds/iox_chunk_datagram_header.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#classes","text":"Name     struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP\n#define IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP\n\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace dds\n{\nenum class Endianess : uint8_t\n{\n    UNDEFINED,\n    LITTLE,\n    BIG,\n    MIXED,\n};\n\nconstexpr const char* EndianessString[] = {\"UNDEFINED\", \"LITTLE\", \"BIG\", \"MIXED\"};\n\nEndianess getEndianess();\n\nstruct IoxChunkDatagramHeader\n{\n    using Serialized_t = iox::cxx::vector&lt;uint8_t, 16U&gt;;\n\n    static Serialized_t serialize(const IoxChunkDatagramHeader&amp; datagramHeader);\n\n    static IoxChunkDatagramHeader deserialize(const Serialized_t&amp; serializedDatagramHeader);\n\n    static constexpr uint8_t DATAGRAM_VERSION{1U};\n\n    uint8_t datagramVersion{DATAGRAM_VERSION};\n    Endianess endianness{Endianess::UNDEFINED};\n    uint16_t userHeaderId{0xFFFF};\n    uint32_t userHeaderSize{0U};\n    uint32_t userPayloadSize{0U};\n    uint32_t userPayloadAlignment{0U};\n};\n\n} // namespace dds\n} // namespace iox\n\n#endif // IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/","text":"","title":"iceoryx_dds/gateway/iox_to_dds.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#namespaces","text":"Name     iox   iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#classes","text":"Name     class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_DDS_IOX_TO_DDS_HPP\n#define IOX_DDS_IOX_TO_DDS_HPP\n\n#include \"iceoryx_dds/dds/dds_types.hpp\"\n#include \"iceoryx_posh/gateway/channel.hpp\"\n#include \"iceoryx_posh/gateway/gateway_generic.hpp\"\n#include \"iceoryx_posh/popo/untyped_subscriber.hpp\"\n\nnamespace iox\n{\nnamespace dds\n{\ntemplate &lt;typename channel_t = gw::Channel&lt;popo::UntypedSubscriber, dds::data_writer_t&gt;,\n          typename gateway_t = gw::GatewayGeneric&lt;channel_t&gt;&gt;\nclass Iceoryx2DDSGateway : public gateway_t\n{\n  public:\n    Iceoryx2DDSGateway() noexcept;\n\n    void loadConfiguration(const config::GatewayConfig&amp; config) noexcept;\n    void discover(const capro::CaproMessage&amp; msg) noexcept;\n    void forward(const channel_t&amp; channel) noexcept;\n\n  private:\n    cxx::expected&lt;channel_t, gw::GatewayError&gt; setupChannel(const capro::ServiceDescription&amp; service,\n                                                            const popo::SubscriberOptions&amp; subscriberOptions) noexcept;\n};\n\n} // namespace dds\n} // namespace iox\n\n#include \"iceoryx_dds/internal/gateway/iox_to_dds.inl\"\n\n#endif // IOX_DDS_IOX_TO_DDS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/DDS-gateway/Namespaces/namespacegw/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"gw"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox/","text":"","title":"iox"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox/#namespaces","text":"Name     iox::dds     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/","text":"","title":"iox::dds"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#classes","text":"Name     class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application.   class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation.   class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation.   class iox::dds::DataReader Abstraction for DDS Data Readers.   class iox::dds::DataWriter Abstraction for DDS Data Writers.   struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload.   class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction.   class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction.","title":"Classes"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#types","text":"Name     enum uint8_t DataReaderError   enum uint8_t Endianess { UNDEFINED, LITTLE, BIG, MIXED}the endianess of the serialized data","title":"Types"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#functions","text":"Name     Endianess getEndianess()Detects the endianness of the system.","title":"Functions"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#attributes","text":"Name     constexpr const char * DataReaderErrorString   constexpr units::Duration DISCOVERY_PERIOD   constexpr units::Duration FORWARDING_PERIOD   constexpr uint32_t SUBSCRIBER_CACHE_SIZE   constexpr const char * EndianessString","title":"Attributes"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#enum-datareadererror","text":"Enumerator Value Description     NOT_CONNECTED     INVALID_DATAGRAM_HEADER_SIZE     INVALID_BUFFER_PARAMETER_FOR_USER_HEADER     INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD     INVALID_DATA     BUFFER_SIZE_MISMATCH","title":"enum DataReaderError"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#enum-endianess","text":"Enumerator Value Description     UNDEFINED     LITTLE     BIG     MIXED      <p>the endianess of the serialized data </p>","title":"enum Endianess"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#function-getendianess","text":"<pre><code>Endianess getEndianess()\n</code></pre> <p>Detects the endianness of the system. </p>","title":"function getEndianess"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-datareadererrorstring","text":"<pre><code>constexpr const char * DataReaderErrorString = {\"NOT_CONNECTED\",\n                                                 \"INVALID_DATAGRAM_HEADER_SIZE\",\n                                                 \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\",\n                                                 \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\",\n                                                 \"INVALID_DATA\",\n                                                 \"BUFFER_SIZE_MISMATCH\"};\n</code></pre>","title":"variable DataReaderErrorString"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-discovery_period","text":"<pre><code>static constexpr units::Duration DISCOVERY_PERIOD = 1000_ms;\n</code></pre>","title":"variable DISCOVERY_PERIOD"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-forwarding_period","text":"<pre><code>static constexpr units::Duration FORWARDING_PERIOD = 50_ms;\n</code></pre>","title":"variable FORWARDING_PERIOD"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-subscriber_cache_size","text":"<pre><code>static constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u;\n</code></pre>","title":"variable SUBSCRIBER_CACHE_SIZE"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-endianessstring","text":"<pre><code>constexpr const char * EndianessString = {\"UNDEFINED\", \"LITTLE\", \"BIG\", \"MIXED\"};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable EndianessString"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceunits_1_1duration__literals/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"units::duration_literals"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/","text":"<p>handle of the chunk header  <code>#include &lt;iceoryx_binding_c/types.h&gt;</code></p>","title":"iox_chunk_header_t"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#public-attributes","text":"Name     uint8_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#variable-do_not_touch_me","text":"<pre><code>uint8_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/","text":"<p>options to be set for a client  <code>#include &lt;iceoryx_binding_c/client.h&gt;</code></p>","title":"iox_client_options_t"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#public-attributes","text":"Name     uint64_t responseQueueCapacity size of the response queue   char nodeName name of the node the client belongs to   bool connectOnCreate Indicates if the client should be connected when created.   ENUM iox_QueueFullPolicy responseQueueFullPolicy Sets whether the server blocks when the client response queue is full.   ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy Sets whether the client blocks when the server request queue is full.   uint64_t initCheck this value will be set exclusively by <code>iox_client_options_init</code> and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-responsequeuecapacity","text":"<pre><code>uint64_t responseQueueCapacity;\n</code></pre> <p>size of the response queue </p>","title":"variable responseQueueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-nodename","text":"<pre><code>char nodeName;\n</code></pre> <p>name of the node the client belongs to </p>","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-connectoncreate","text":"<pre><code>bool connectOnCreate;\n</code></pre> <p>Indicates if the client should be connected when created. </p>","title":"variable connectOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-responsequeuefullpolicy","text":"<pre><code>ENUM iox_QueueFullPolicy responseQueueFullPolicy;\n</code></pre> <p>Sets whether the server blocks when the client response queue is full. </p>","title":"variable responseQueueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-servertooslowpolicy","text":"<pre><code>ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy;\n</code></pre> <p>Sets whether the client blocks when the server request queue is full. </p>","title":"variable serverTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-initcheck","text":"<pre><code>uint64_t initCheck;\n</code></pre> <p>this value will be set exclusively by <code>iox_client_options_init</code> and is not supposed to be modified otherwise </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/","text":"<p>has exactly the size required to store the underlying object of iox_client_t  <code>#include &lt;iceoryx_binding_c/types.h&gt;</code></p>","title":"iox_client_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/","text":"","title":"iox_listener_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/","text":"<p>options to be set for a publisher  <code>#include &lt;iceoryx_binding_c/publisher.h&gt;</code></p>","title":"iox_pub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#public-attributes","text":"Name     uint64_t historyCapacity Size of the history chunk queue.   const char * nodeName Name of the node the publisher belongs to.   bool offerOnCreate The option whether the publisher should already be offered when creating it.   ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy describes whether a publisher blocks when subscriber queue is full   uint64_t initCheck this value will be set exclusively by <code>iox_pub_options_init</code> and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-historycapacity","text":"<pre><code>uint64_t historyCapacity;\n</code></pre> <p>Size of the history chunk queue. </p>","title":"variable historyCapacity"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-nodename","text":"<pre><code>const char * nodeName;\n</code></pre> <p>Name of the node the publisher belongs to. </p> <p>Note: nullptr indicates that the default node name is used </p>","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-offeroncreate","text":"<pre><code>bool offerOnCreate;\n</code></pre> <p>The option whether the publisher should already be offered when creating it. </p>","title":"variable offerOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-subscribertooslowpolicy","text":"<pre><code>ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy;\n</code></pre> <p>describes whether a publisher blocks when subscriber queue is full </p>","title":"variable subscriberTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-initcheck","text":"<pre><code>uint64_t initCheck;\n</code></pre> <p>this value will be set exclusively by <code>iox_pub_options_init</code> and is not supposed to be modified otherwise </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/","text":"","title":"iox_pub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/","text":"<p>options to be set for a server  <code>#include &lt;iceoryx_binding_c/server.h&gt;</code></p>","title":"iox_server_options_t"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#public-attributes","text":"Name     uint64_t requestQueueCapacity size of the request queue   char nodeName name of the node the server belongs to   bool offerOnCreate Indicates if the server should be connected when created.   ENUM iox_QueueFullPolicy requestQueueFullPolicy Sets whether the client blocks when the server request queue is full.   ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy Sets whether the server blocks when the client response queue is full.   uint64_t initCheck this value will be set exclusively by <code>iox_server_options_init</code> and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-requestqueuecapacity","text":"<pre><code>uint64_t requestQueueCapacity;\n</code></pre> <p>size of the request queue </p>","title":"variable requestQueueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-nodename","text":"<pre><code>char nodeName;\n</code></pre> <p>name of the node the server belongs to </p>","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-offeroncreate","text":"<pre><code>bool offerOnCreate;\n</code></pre> <p>Indicates if the server should be connected when created. </p>","title":"variable offerOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-requestqueuefullpolicy","text":"<pre><code>ENUM iox_QueueFullPolicy requestQueueFullPolicy;\n</code></pre> <p>Sets whether the client blocks when the server request queue is full. </p>","title":"variable requestQueueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-clienttooslowpolicy","text":"<pre><code>ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy;\n</code></pre> <p>Sets whether the server blocks when the client response queue is full. </p>","title":"variable clientTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-initcheck","text":"<pre><code>uint64_t initCheck;\n</code></pre> <p>this value will be set exclusively by <code>iox_server_options_init</code> and is not supposed to be modified otherwise </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/","text":"<p>has exactly the size required to store the underlying object of iox_server_t  <code>#include &lt;iceoryx_binding_c/types.h&gt;</code></p>","title":"iox_server_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/","text":"","title":"iox_service_description_t"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#public-attributes","text":"Name     char serviceString   char instanceString   char eventString","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-servicestring","text":"<pre><code>char serviceString;\n</code></pre>","title":"variable serviceString"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-instancestring","text":"<pre><code>char instanceString;\n</code></pre>","title":"variable instanceString"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-eventstring","text":"<pre><code>char eventString;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable eventString"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/","text":"<p>has exactly the size required to store the underlying object of iox_service_discovery_t  <code>#include &lt;iceoryx_binding_c/types.h&gt;</code></p>","title":"iox_service_discovery_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/","text":"<p>options to be set for a subscriber  <code>#include &lt;iceoryx_binding_c/subscriber.h&gt;</code></p>","title":"iox_sub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#public-attributes","text":"Name     uint64_t queueCapacity size of the history chunk queue   uint64_t historyRequest number of chunks received after subscription if chunks are available   const char * nodeName name of the node the subscriber belongs to   bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it.   ENUM iox_QueueFullPolicy queueFullPolicy describes whether a publisher blocks when subscriber queue is full   bool requirePublisherHistorySupport Indicates whether we require the publisher to have historyCapacity &gt; 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher.   uint64_t initCheck this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-queuecapacity","text":"<pre><code>uint64_t queueCapacity;\n</code></pre> <p>size of the history chunk queue </p>","title":"variable queueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-historyrequest","text":"<pre><code>uint64_t historyRequest;\n</code></pre> <p>number of chunks received after subscription if chunks are available </p>","title":"variable historyRequest"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-nodename","text":"<pre><code>const char * nodeName;\n</code></pre> <p>name of the node the subscriber belongs to </p> <p>Note: nullptr indicates that the default node name is used </p>","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-subscribeoncreate","text":"<pre><code>bool subscribeOnCreate;\n</code></pre> <p>The option whether the subscriber shall try to subscribe when creating it. </p>","title":"variable subscribeOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-queuefullpolicy","text":"<pre><code>ENUM iox_QueueFullPolicy queueFullPolicy;\n</code></pre> <p>describes whether a publisher blocks when subscriber queue is full </p>","title":"variable queueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-requirepublisherhistorysupport","text":"<pre><code>bool requirePublisherHistorySupport;\n</code></pre> <p>Indicates whether we require the publisher to have historyCapacity &gt; 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher. </p>","title":"variable requirePublisherHistorySupport"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-initcheck","text":"<pre><code>uint64_t initCheck;\n</code></pre> <p>this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/","text":"","title":"iox_sub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/","text":"","title":"iox_user_trigger_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/","text":"<p>More...</p> <p><code>#include &lt;iceoryx_binding_c/types.h&gt;</code></p>","title":"iox_ws_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#public-attributes","text":"Name     uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#detailed-description","text":"<pre><code>struct iox_ws_storage_t;\n</code></pre> <p>The issue iox-308: https://github.com/eclipse-iceoryx/iceoryx/issues/308 was created to explore other options then a magic number to create the structs of a specific size in C. The size and the alignment of all structs are verified by the binding c integration test iox_types_test </p>","title":"Detailed Description"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#variable-do_not_touch_me","text":"<pre><code>uint64_t do_not_touch_me;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Files/api_8h/","text":"","title":"iceoryx_binding_c/api.h"},{"location":"API-reference/c-binding/Files/api_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_API_H\n#define IOX_BINDING_C_API_H\n\n// Provides the complete iceoryx C API in one header.\n\n#include \"chunk.h\"\n#include \"client.h\"\n#include \"config.h\"\n#include \"enums.h\"\n#include \"listener.h\"\n#include \"log.h\"\n#include \"node.h\"\n#include \"notification_info.h\"\n#include \"publisher.h\"\n#include \"request_header.h\"\n#include \"response_header.h\"\n#include \"runtime.h\"\n#include \"server.h\"\n#include \"service_description.h\"\n#include \"service_discovery.h\"\n#include \"subscriber.h\"\n#include \"types.h\"\n#include \"user_trigger.h\"\n#include \"wait_set.h\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/chunk_8h/","text":"","title":"iceoryx_binding_c/chunk.h"},{"location":"API-reference/c-binding/Files/chunk_8h/#functions","text":"Name     void * iox_chunk_header_to_user_payload(iox_chunk_header_t *const chunkHeader)gets the user-payload from the chunk-header   const void * iox_chunk_header_to_user_payload_const(const iox_chunk_header_t *const chunkHeader)gets the const user-payload from the const chunk-header   void * iox_chunk_header_to_user_header(iox_chunk_header_t *const chunkHeader)gets the user-header from the chunk-header   const void * iox_chunk_header_to_user_header_const(const iox_chunk_header_t *const chunkHeader)gets the const user-payload from the const chunk-header   iox_chunk_header_t * iox_chunk_header_from_user_payload(void *const userPayload)gets the chunk-header from the user-payload   const iox_chunk_header_t * iox_chunk_header_from_user_payload_const(const void *const userPayload)gets the const chunk-header from the const user-payload","title":"Functions"},{"location":"API-reference/c-binding/Files/chunk_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_payload","text":"<pre><code>void * iox_chunk_header_to_user_payload(\n    iox_chunk_header_t *const chunkHeader\n)\n</code></pre> <p>gets the user-payload from the chunk-header </p> <p>Parameters: </p> <ul> <li>chunkHeader pointer to the chunk-header </li> </ul> <p>Return: pointer to the user-payload </p>","title":"function iox_chunk_header_to_user_payload"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_payload_const","text":"<pre><code>const void * iox_chunk_header_to_user_payload_const(\n    const iox_chunk_header_t *const chunkHeader\n)\n</code></pre> <p>gets the const user-payload from the const chunk-header </p> <p>Parameters: </p> <ul> <li>chunkHeader const pointer to the chunk-header </li> </ul> <p>Return: const pointer to the user-payload </p>","title":"function iox_chunk_header_to_user_payload_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_header","text":"<pre><code>void * iox_chunk_header_to_user_header(\n    iox_chunk_header_t *const chunkHeader\n)\n</code></pre> <p>gets the user-header from the chunk-header </p> <p>Parameters: </p> <ul> <li>chunkHeader pointer to the chunk-header </li> </ul> <p>Return: pointer to the user-header </p>","title":"function iox_chunk_header_to_user_header"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_header_const","text":"<pre><code>const void * iox_chunk_header_to_user_header_const(\n    const iox_chunk_header_t *const chunkHeader\n)\n</code></pre> <p>gets the const user-payload from the const chunk-header </p> <p>Parameters: </p> <ul> <li>chunkHeader const pointer to the chunk-header </li> </ul> <p>Return: const pointer to the user-header </p>","title":"function iox_chunk_header_to_user_header_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_from_user_payload","text":"<pre><code>iox_chunk_header_t * iox_chunk_header_from_user_payload(\n    void *const userPayload\n)\n</code></pre> <p>gets the chunk-header from the user-payload </p> <p>Parameters: </p> <ul> <li>userPayload pointer to the user-payload </li> </ul> <p>Return: pointer to the chunk-header </p>","title":"function iox_chunk_header_from_user_payload"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_from_user_payload_const","text":"<pre><code>const iox_chunk_header_t * iox_chunk_header_from_user_payload_const(\n    const void *const userPayload\n)\n</code></pre> <p>gets the const chunk-header from the const user-payload </p> <p>Parameters: </p> <ul> <li>userPayload const pointer to the user-payload </li> </ul> <p>Return: const pointer to the chunk-header </p>","title":"function iox_chunk_header_from_user_payload_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_CHUNK_H\n#define IOX_BINDING_C_CHUNK_H\n\n#include \"iceoryx_binding_c/types.h\"\n\nvoid* iox_chunk_header_to_user_payload(iox_chunk_header_t* const chunkHeader);\n\nconst void* iox_chunk_header_to_user_payload_const(const iox_chunk_header_t* const chunkHeader);\n\nvoid* iox_chunk_header_to_user_header(iox_chunk_header_t* const chunkHeader);\n\nconst void* iox_chunk_header_to_user_header_const(const iox_chunk_header_t* const chunkHeader);\n\niox_chunk_header_t* iox_chunk_header_from_user_payload(void* const userPayload);\n\nconst iox_chunk_header_t* iox_chunk_header_from_user_payload_const(const void* const userPayload);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/client_8h/","text":"","title":"iceoryx_binding_c/client.h"},{"location":"API-reference/c-binding/Files/client_8h/#classes","text":"Name     struct iox_client_options_t options to be set for a client","title":"Classes"},{"location":"API-reference/c-binding/Files/client_8h/#types","text":"Name     typedef CLASS UntypedClient * iox_client_t client handle","title":"Types"},{"location":"API-reference/c-binding/Files/client_8h/#functions","text":"Name     void iox_client_options_init(iox_client_options_t * options)initialize client options to default values   bool iox_client_options_is_initialized(const iox_client_options_t *const options)check whether the client options were initialized by iox_client_options_init   iox_client_t iox_client_init(iox_client_storage_t * self, const char const service, const char const instance, const char const event, const iox_client_options_t const options)creates a client handle   void iox_client_deinit(iox_client_t const self)removes a client handle   ENUM iox_AllocationResult iox_client_loan_request(iox_client_t const self, void **const payload, const uint32_t payloadSize)allocates a request in the shared memory   ENUM iox_AllocationResult iox_client_loan_aligned_request(iox_client_t const self, void **const payload, const uint32_t payloadSize, const uint32_t payloadAlignment)allocates a request in the shared memory with a custom alignment for the user-payload   void iox_client_release_request(iox_client_t const self, void *const payload)releases ownership of a previously allocated loaned request without sending it   ENUM iox_ClientSendResult iox_client_send(iox_client_t const self, void *const payload)sends a previously loaned request   void iox_client_connect(iox_client_t const self)connects to the service   void iox_client_disconnect(iox_client_t const self)disconnects from the service   ENUM iox_ConnectionState iox_client_get_connection_state(iox_client_t const self)what is the connection state?   ENUM iox_ChunkReceiveResult iox_client_take_response(iox_client_t const self, const void **const payload)retrieve a received respone   void iox_client_release_response(iox_client_t const self, const void *const payload)release a previously acquired response (via iox_client_take_response)   void iox_client_release_queued_responses(iox_client_t const self)release all responses which are stored in the chunk queue   bool iox_client_has_responses(iox_client_t const self)are new responses available?   bool iox_client_has_missed_responses(iox_client_t const self)were responses missed?   iox_service_description_t iox_client_get_service_description(iox_client_t const self)returns the service description of the client","title":"Functions"},{"location":"API-reference/c-binding/Files/client_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/client_8h/#typedef-iox_client_t","text":"<pre><code>typedef CLASS UntypedClient* iox_client_t;\n</code></pre> <p>client handle </p>","title":"typedef iox_client_t"},{"location":"API-reference/c-binding/Files/client_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_options_init","text":"<pre><code>void iox_client_options_init(\n    iox_client_options_t * options\n)\n</code></pre> <p>initialize client options to default values </p> <p>Parameters: </p> <ul> <li>options pointer to options to be initialized, emit warning if it is a null pointer </li> </ul> <p>Attention: This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. </p>","title":"function iox_client_options_init"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_options_is_initialized","text":"<pre><code>bool iox_client_options_is_initialized(\n    const iox_client_options_t *const options\n)\n</code></pre> <p>check whether the client options were initialized by iox_client_options_init </p> <p>Parameters: </p> <ul> <li>options pointer to options to be checked </li> </ul> <p>Return: true if options are not null and were initialized, false otherwise </p>","title":"function iox_client_options_is_initialized"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_init","text":"<pre><code>iox_client_t iox_client_init(\n    iox_client_storage_t * self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    const iox_client_options_t *const options\n)\n</code></pre> <p>creates a client handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_client_storage_t) </li> <li>service serviceString </li> <li>instance instanceString </li> <li>event eventString </li> <li>options client options set by the user, if it is a null pointer default options are used </li> </ul> <p>Return: handle of the client </p>","title":"function iox_client_init"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_deinit","text":"<pre><code>void iox_client_deinit(\n    iox_client_t const self\n)\n</code></pre> <p>removes a client handle </p> <p>Parameters: </p> <ul> <li>self the handle which should be removed </li> </ul>","title":"function iox_client_deinit"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_loan_request","text":"<pre><code>ENUM iox_AllocationResult iox_client_loan_request(\n    iox_client_t const self,\n    void **const payload,\n    const uint32_t payloadSize\n)\n</code></pre> <p>allocates a request in the shared memory </p> <p>Parameters: </p> <ul> <li>self handle of the client </li> <li>payload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>payloadSize user-payload size of the allocated request </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p> <p>Note: for the user-payload alignment <code>IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT</code> is used for a custom user-payload alignment please use <code>iox_client_loan_aligned_request</code></p>","title":"function iox_client_loan_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_loan_aligned_request","text":"<pre><code>ENUM iox_AllocationResult iox_client_loan_aligned_request(\n    iox_client_t const self,\n    void **const payload,\n    const uint32_t payloadSize,\n    const uint32_t payloadAlignment\n)\n</code></pre> <p>allocates a request in the shared memory with a custom alignment for the user-payload </p> <p>Parameters: </p> <ul> <li>self handle of the client </li> <li>payload pointer in which a pointer to the user-payload of the allocated request is stored </li> <li>payloadSize user-payload size of the allocated request </li> <li>payloadAlignment user-payload alignment of the allocated request </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_client_loan_aligned_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_request","text":"<pre><code>void iox_client_release_request(\n    iox_client_t const self,\n    void *const payload\n)\n</code></pre> <p>releases ownership of a previously allocated loaned request without sending it </p> <p>Parameters: </p> <ul> <li>self handle of the client </li> <li>payload pointer to the user-payload of the loaned request which should be free'd </li> </ul>","title":"function iox_client_release_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_send","text":"<pre><code>ENUM iox_ClientSendResult iox_client_send(\n    iox_client_t const self,\n    void *const payload\n)\n</code></pre> <p>sends a previously loaned request </p> <p>Parameters: </p> <ul> <li>self handle of the client </li> <li>payload pointer to the user-payload of the request which should be send </li> </ul> <p>Return: on success it returns ClientSendResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_client_send"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_connect","text":"<pre><code>void iox_client_connect(\n    iox_client_t const self\n)\n</code></pre> <p>connects to the service </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul>","title":"function iox_client_connect"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_disconnect","text":"<pre><code>void iox_client_disconnect(\n    iox_client_t const self\n)\n</code></pre> <p>disconnects from the service </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul>","title":"function iox_client_disconnect"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_get_connection_state","text":"<pre><code>ENUM iox_ConnectionState iox_client_get_connection_state(\n    iox_client_t const self\n)\n</code></pre> <p>what is the connection state? </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul> <p>Return: ConnectionState_CONNECTED when successfully connected otherwise an enum which describes the current state </p>","title":"function iox_client_get_connection_state"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_take_response","text":"<pre><code>ENUM iox_ChunkReceiveResult iox_client_take_response(\n    iox_client_t const self,\n    const void **const payload\n)\n</code></pre> <p>retrieve a received respone </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> <li>payload pointer in which the pointer to the user-payload of the response is stored </li> </ul> <p>Return: if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_client_take_response"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_response","text":"<pre><code>void iox_client_release_response(\n    iox_client_t const self,\n    const void *const payload\n)\n</code></pre> <p>release a previously acquired response (via iox_client_take_response) </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> <li>payload pointer to the user-payload of chunk which should be released </li> </ul>","title":"function iox_client_release_response"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_queued_responses","text":"<pre><code>void iox_client_release_queued_responses(\n    iox_client_t const self\n)\n</code></pre> <p>release all responses which are stored in the chunk queue </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul>","title":"function iox_client_release_queued_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_has_responses","text":"<pre><code>bool iox_client_has_responses(\n    iox_client_t const self\n)\n</code></pre> <p>are new responses available? </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul> <p>Return: true if there are responses, otherwise false </p>","title":"function iox_client_has_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_has_missed_responses","text":"<pre><code>bool iox_client_has_missed_responses(\n    iox_client_t const self\n)\n</code></pre> <p>were responses missed? </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul> <p>Return: true if there are lost responses due to overflowing queue, otherwise false </p>","title":"function iox_client_has_missed_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_get_service_description","text":"<pre><code>iox_service_description_t iox_client_get_service_description(\n    iox_client_t const self\n)\n</code></pre> <p>returns the service description of the client </p> <p>Parameters: </p> <ul> <li>self handle to the client </li> </ul> <p>Return: the service description </p>","title":"function iox_client_get_service_description"},{"location":"API-reference/c-binding/Files/client_8h/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_CLIENT_H\n#define IOX_BINDING_C_CLIENT_H\n\n#include \"iceoryx_binding_c/config.h\"\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/service_description.h\"\n#include \"iceoryx_binding_c/types.h\"\n\ntypedef CLASS UntypedClient* iox_client_t;\n\ntypedef struct\n{\n    uint64_t responseQueueCapacity;\n\n    char nodeName[IOX_CONFIG_NODE_NAME_SIZE];\n\n    bool connectOnCreate;\n\n    ENUM iox_QueueFullPolicy responseQueueFullPolicy;\n\n    ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy;\n\n    uint64_t initCheck;\n} iox_client_options_t;\n\nvoid iox_client_options_init(iox_client_options_t* options);\n\nbool iox_client_options_is_initialized(const iox_client_options_t* const options);\n\niox_client_t iox_client_init(iox_client_storage_t* self,\n                             const char* const service,\n                             const char* const instance,\n                             const char* const event,\n                             const iox_client_options_t* const options);\n\nvoid iox_client_deinit(iox_client_t const self);\n\nENUM iox_AllocationResult iox_client_loan_request(iox_client_t const self,\n                                                  void** const payload,\n                                                  const uint32_t payloadSize);\n\nENUM iox_AllocationResult iox_client_loan_aligned_request(iox_client_t const self,\n                                                          void** const payload,\n                                                          const uint32_t payloadSize,\n                                                          const uint32_t payloadAlignment);\n\n\nvoid iox_client_release_request(iox_client_t const self, void* const payload);\n\nENUM iox_ClientSendResult iox_client_send(iox_client_t const self, void* const payload);\n\nvoid iox_client_connect(iox_client_t const self);\n\nvoid iox_client_disconnect(iox_client_t const self);\n\nENUM iox_ConnectionState iox_client_get_connection_state(iox_client_t const self);\n\nENUM iox_ChunkReceiveResult iox_client_take_response(iox_client_t const self, const void** const payload);\n\nvoid iox_client_release_response(iox_client_t const self, const void* const payload);\n\nvoid iox_client_release_queued_responses(iox_client_t const self);\n\nbool iox_client_has_responses(iox_client_t const self);\n\nbool iox_client_has_missed_responses(iox_client_t const self);\n\niox_service_description_t iox_client_get_service_description(iox_client_t const self);\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/config_8h/","text":"","title":"iceoryx_binding_c/config.h"},{"location":"API-reference/c-binding/Files/config_8h/#functions","text":"Name     uint32_t iox_cfg_max_publishers(void )returns maximum supported amount of publishers   uint32_t iox_cfg_max_subscribers_per_publisher(void )returns maximum amount of subscribers which can be subscribed to one publisher   uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously(void )returns maximum amount of samples a publisher can acquire at the same time with loan   uint64_t iox_cfg_max_publisher_history(void )returns maximum history size for a publisher (e.g. samples which are hold back so   uint32_t iox_cfg_max_subscribers(void )returns maximum supported amount of subscribers   uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously(void )returns the maximum amount of samples which a subscriber can hold without releasing them   uint32_t iox_cfg_max_subscriber_queue_capacity(void )returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples   uint32_t iox_cfg_max_number_of_condition_variables(void )returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system   uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable(void )returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have   uint32_t iox_cfg_max_number_of_attachments_per_waitset(void )returns the maximum amount of attachments per waitset   uint32_t iox_cfg_max_number_of_events_per_listener(void )returns the maximum amount of evens per listener   uint32_t iox_cfg_max_number_of_mempools(void )returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file   uint32_t iox_cfg_max_shm_segments(void )returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file   uint32_t iox_cfg_max_number_of_memory_provider(void )returns the maximum supported amount of shared memory providers   uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider(void )returns the maximum supported amount of memory blocks per shared memory provider   uint32_t iox_cfg_chunk_default_user_payload_alignment(void )returns the alignment of the user payload when it is not set explicitly   uint32_t iox_cfg_no_user_header_size(void )returns the size of the user header when no user header is requested by the user   uint32_t iox_cfg_no_user_header_alignment(void )returns the alignment of the user header when no user header is requested by the user   uint32_t iox_cfg_max_process_number(void )returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime   uint32_t iox_cfg_service_registry_capacity(void )returns the maximum number of services that are supported byt the service registry   uint32_t iox_cfg_max_findservice_result_size(void )returns the maximum number of services a findservice call can return   uint32_t iox_cfg_max_runtime_name_length(void )returns the maximum runtime name length","title":"Functions"},{"location":"API-reference/c-binding/Files/config_8h/#defines","text":"Name      IOX_CONFIG_NODE_NAME_SIZE the maximum size of a node name string + \\0 terminator    IOX_CONFIG_SERVICE_STRING_SIZE the maximum size of a service description string identifier + \\0 terminator","title":"Defines"},{"location":"API-reference/c-binding/Files/config_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_publishers","text":"<pre><code>uint32_t iox_cfg_max_publishers(\n    void \n)\n</code></pre> <p>returns maximum supported amount of publishers </p>","title":"function iox_cfg_max_publishers"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscribers_per_publisher","text":"<pre><code>uint32_t iox_cfg_max_subscribers_per_publisher(\n    void \n)\n</code></pre> <p>returns maximum amount of subscribers which can be subscribed to one publisher </p>","title":"function iox_cfg_max_subscribers_per_publisher"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_chunks_allocated_per_publisher_simultaneously","text":"<pre><code>uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously(\n    void \n)\n</code></pre> <p>returns maximum amount of samples a publisher can acquire at the same time with loan </p>","title":"function iox_cfg_max_chunks_allocated_per_publisher_simultaneously"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_publisher_history","text":"<pre><code>uint64_t iox_cfg_max_publisher_history(\n    void \n)\n</code></pre> <p>returns maximum history size for a publisher (e.g. samples which are hold back so </p>","title":"function iox_cfg_max_publisher_history"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscribers","text":"<pre><code>uint32_t iox_cfg_max_subscribers(\n    void \n)\n</code></pre> <p>returns maximum supported amount of subscribers </p>","title":"function iox_cfg_max_subscribers"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_chunks_held_per_subscriber_simultaneously","text":"<pre><code>uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously(\n    void \n)\n</code></pre> <p>returns the maximum amount of samples which a subscriber can hold without releasing them </p>","title":"function iox_cfg_max_chunks_held_per_subscriber_simultaneously"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscriber_queue_capacity","text":"<pre><code>uint32_t iox_cfg_max_subscriber_queue_capacity(\n    void \n)\n</code></pre> <p>returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples </p>","title":"function iox_cfg_max_subscriber_queue_capacity"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_condition_variables","text":"<pre><code>uint32_t iox_cfg_max_number_of_condition_variables(\n    void \n)\n</code></pre> <p>returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system </p>","title":"function iox_cfg_max_number_of_condition_variables"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_notifiers_per_condition_variable","text":"<pre><code>uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable(\n    void \n)\n</code></pre> <p>returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have </p>","title":"function iox_cfg_max_number_of_notifiers_per_condition_variable"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_attachments_per_waitset","text":"<pre><code>uint32_t iox_cfg_max_number_of_attachments_per_waitset(\n    void \n)\n</code></pre> <p>returns the maximum amount of attachments per waitset </p> <p>Note: is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable </p>","title":"function iox_cfg_max_number_of_attachments_per_waitset"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_events_per_listener","text":"<pre><code>uint32_t iox_cfg_max_number_of_events_per_listener(\n    void \n)\n</code></pre> <p>returns the maximum amount of evens per listener </p> <p>Note: is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable </p>","title":"function iox_cfg_max_number_of_events_per_listener"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_mempools","text":"<pre><code>uint32_t iox_cfg_max_number_of_mempools(\n    void \n)\n</code></pre> <p>returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file </p>","title":"function iox_cfg_max_number_of_mempools"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_shm_segments","text":"<pre><code>uint32_t iox_cfg_max_shm_segments(\n    void \n)\n</code></pre> <p>returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file </p>","title":"function iox_cfg_max_shm_segments"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_memory_provider","text":"<pre><code>uint32_t iox_cfg_max_number_of_memory_provider(\n    void \n)\n</code></pre> <p>returns the maximum supported amount of shared memory providers </p>","title":"function iox_cfg_max_number_of_memory_provider"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_memory_blocks_per_memory_provider","text":"<pre><code>uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider(\n    void \n)\n</code></pre> <p>returns the maximum supported amount of memory blocks per shared memory provider </p>","title":"function iox_cfg_max_number_of_memory_blocks_per_memory_provider"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_chunk_default_user_payload_alignment","text":"<pre><code>uint32_t iox_cfg_chunk_default_user_payload_alignment(\n    void \n)\n</code></pre> <p>returns the alignment of the user payload when it is not set explicitly </p>","title":"function iox_cfg_chunk_default_user_payload_alignment"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_no_user_header_size","text":"<pre><code>uint32_t iox_cfg_no_user_header_size(\n    void \n)\n</code></pre> <p>returns the size of the user header when no user header is requested by the user </p>","title":"function iox_cfg_no_user_header_size"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_no_user_header_alignment","text":"<pre><code>uint32_t iox_cfg_no_user_header_alignment(\n    void \n)\n</code></pre> <p>returns the alignment of the user header when no user header is requested by the user </p>","title":"function iox_cfg_no_user_header_alignment"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_process_number","text":"<pre><code>uint32_t iox_cfg_max_process_number(\n    void \n)\n</code></pre> <p>returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime </p>","title":"function iox_cfg_max_process_number"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_service_registry_capacity","text":"<pre><code>uint32_t iox_cfg_service_registry_capacity(\n    void \n)\n</code></pre> <p>returns the maximum number of services that are supported byt the service registry </p>","title":"function iox_cfg_service_registry_capacity"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_findservice_result_size","text":"<pre><code>uint32_t iox_cfg_max_findservice_result_size(\n    void \n)\n</code></pre> <p>returns the maximum number of services a findservice call can return </p>","title":"function iox_cfg_max_findservice_result_size"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_runtime_name_length","text":"<pre><code>uint32_t iox_cfg_max_runtime_name_length(\n    void \n)\n</code></pre> <p>returns the maximum runtime name length </p>","title":"function iox_cfg_max_runtime_name_length"},{"location":"API-reference/c-binding/Files/config_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/c-binding/Files/config_8h/#define-iox_config_node_name_size","text":"<pre><code>#define IOX_CONFIG_NODE_NAME_SIZE 101\n</code></pre> <p>the maximum size of a node name string + \\0 terminator </p>","title":"define IOX_CONFIG_NODE_NAME_SIZE"},{"location":"API-reference/c-binding/Files/config_8h/#define-iox_config_service_string_size","text":"<pre><code>#define IOX_CONFIG_SERVICE_STRING_SIZE 101\n</code></pre> <p>the maximum size of a service description string identifier + \\0 terminator </p>","title":"define IOX_CONFIG_SERVICE_STRING_SIZE"},{"location":"API-reference/c-binding/Files/config_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_CONFIG_H\n#define IOX_BINDING_C_CONFIG_H\n\n#include &lt;stdint.h&gt;\n\nuint32_t iox_cfg_max_publishers(void);\n\nuint32_t iox_cfg_max_subscribers_per_publisher(void);\n\nuint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously(void);\n\n//         that new subscribers can acquire past data)\nuint64_t iox_cfg_max_publisher_history(void);\n\nuint32_t iox_cfg_max_subscribers(void);\n\nuint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously(void);\n\nuint32_t iox_cfg_max_subscriber_queue_capacity(void);\n\nuint32_t iox_cfg_max_number_of_condition_variables(void);\n\nuint32_t iox_cfg_max_number_of_notifiers_per_condition_variable(void);\n\nuint32_t iox_cfg_max_number_of_attachments_per_waitset(void);\n\nuint32_t iox_cfg_max_number_of_events_per_listener(void);\n\nuint32_t iox_cfg_max_number_of_mempools(void);\n\nuint32_t iox_cfg_max_shm_segments(void);\n\nuint32_t iox_cfg_max_number_of_memory_provider(void);\n\nuint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider(void);\n\nuint32_t iox_cfg_chunk_default_user_payload_alignment(void);\n\nuint32_t iox_cfg_no_user_header_size(void);\n\nuint32_t iox_cfg_no_user_header_alignment(void);\n\nuint32_t iox_cfg_max_process_number(void);\n\nuint32_t iox_cfg_service_registry_capacity(void);\n\nuint32_t iox_cfg_max_findservice_result_size(void);\n\nuint32_t iox_cfg_max_runtime_name_length(void);\n\n#define IOX_CONFIG_NODE_NAME_SIZE 101\n\n#define IOX_CONFIG_SERVICE_STRING_SIZE 101\n\n#endif // IOX_BINDING_C_CONFIG_H\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/dir_f58c26ce9a5339347f1023a5792ba649/","text":"","title":"iceoryx_binding_c"},{"location":"API-reference/c-binding/Files/dir_f58c26ce9a5339347f1023a5792ba649/#files","text":"Name     iceoryx_binding_c/api.h   iceoryx_binding_c/chunk.h   iceoryx_binding_c/client.h   iceoryx_binding_c/config.h   iceoryx_binding_c/enums.h   iceoryx_binding_c/listener.h   iceoryx_binding_c/log.h   iceoryx_binding_c/node.h   iceoryx_binding_c/notification_info.h   iceoryx_binding_c/publisher.h   iceoryx_binding_c/request_header.h   iceoryx_binding_c/response_header.h   iceoryx_binding_c/runtime.h   iceoryx_binding_c/server.h   iceoryx_binding_c/service_description.h   iceoryx_binding_c/service_discovery.h   iceoryx_binding_c/subscriber.h   iceoryx_binding_c/types.h   iceoryx_binding_c/user_trigger.h   iceoryx_binding_c/wait_set.h     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/c-binding/Files/enums_8h/","text":"","title":"iceoryx_binding_c/enums.h"},{"location":"API-reference/c-binding/Files/enums_8h/#types","text":"Name     enum iox_SubscriberState { SubscriberState_HAS_DATA}describes states which can be triggered by a subscriber   enum iox_SubscriberEvent { SubscriberEvent_DATA_RECEIVED}describes events which can be triggered by a subscriber   enum iox_SubscribeState { SubscribeState_NOT_SUBSCRIBED = 0, SubscribeState_SUBSCRIBE_REQUESTED, SubscribeState_SUBSCRIBED, SubscribeState_UNSUBSCRIBE_REQUESTED, SubscribeState_WAIT_FOR_OFFER, SubscribeState_UNDEFINED_ERROR}describes the current state of a subscriber   enum iox_ClientEvent { ClientEvent_RESPONSE_RECEIVED}describes events which can be triggered by a client   enum iox_ClientState { ClientState_HAS_RESPONSE}describes states which can be triggered by a client   enum iox_ServerEvent { ServerEvent_REQUEST_RECEIVED}describes events which can be triggered by a server   enum iox_ServerState { ServerState_HAS_REQUEST}describes states which can be triggered by a server   enum iox_ConnectionState { ConnectionState_NOT_CONNECTED = 0, ConnectionState_CONNECT_REQUESTED, ConnectionState_CONNECTED, ConnectionState_DISCONNECT_REQUESTED, ConnectionState_WAIT_FOR_OFFER}describes the current connection state of a client   enum iox_ChunkReceiveResult { ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL, ChunkReceiveResult_NO_CHUNK_AVAILABLE, ChunkReceiveResult_UNDEFINED_ERROR, ChunkReceiveResult_SUCCESS}describes the state of getChunk in the subscriber   enum iox_ServiceDiscoveryEvent { ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED}describes events which can be triggered by a service discovery   enum iox_QueueFullPolicy { QueueFullPolicy_BLOCK_PRODUCER, QueueFullPolicy_DISCARD_OLDEST_DATA}Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full.   enum iox_ConsumerTooSlowPolicy { ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER, ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA}Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full.   enum iox_AllocationResult { AllocationResult_NO_MEMPOOLS_AVAILABLE, AllocationResult_RUNNING_OUT_OF_CHUNKS, AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL, AllocationResult_INVALID_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER, AllocationResult_UNDEFINED_ERROR, AllocationResult_INVALID_PARAMETER_FOR_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER, AllocationResult_SUCCESS}state of allocateChunk   enum iox_ClientSendResult { ClientSendResult_SUCCESS, ClientSendResult_UNDEFINED_ERROR, ClientSendResult_NO_CONNECT_REQUESTED, ClientSendResult_SERVER_NOT_AVAILABLE, ClientSendResult_INVALID_REQUEST}client send result   enum iox_ServerSendResult { ServerSendResult_SUCCESS, ServerSendResult_UNDEFINED_ERROR, ServerSendResult_NOT_OFFERED, ServerSendResult_CLIENT_NOT_AVAILABLE, ServerSendResult_INVALID_RESPONSE}server send result   enum iox_WaitSetResult { WaitSetResult_WAIT_SET_FULL, WaitSetResult_ALREADY_ATTACHED, WaitSetResult_UNDEFINED_ERROR, WaitSetResult_SUCCESS}used to describe if attaching an object to a waitset was successful or the kind of attachment error   enum iox_ListenerResult { ListenerResult_LISTENER_FULL, ListenerResult_EVENT_ALREADY_ATTACHED, ListenerResult_EMPTY_EVENT_CALLBACK, ListenerResult_EMPTY_INVALIDATION_CALLBACK, ListenerResult_UNDEFINED_ERROR, ListenerResult_SUCCESS}used to describe if attaching an object to a listener was successful or the kind of attachment error   enum iox_ServerRequestResult   enum iox_MessagingPattern { MessagingPattern_PUB_SUB, MessagingPattern_REQ_RES}used to describe the messaging pattern","title":"Types"},{"location":"API-reference/c-binding/Files/enums_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscriberstate","text":"Enumerator Value Description     SubscriberState_HAS_DATA      <p>describes states which can be triggered by a subscriber </p>","title":"enum iox_SubscriberState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscriberevent","text":"Enumerator Value Description     SubscriberEvent_DATA_RECEIVED      <p>describes events which can be triggered by a subscriber </p>","title":"enum iox_SubscriberEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscribestate","text":"Enumerator Value Description     SubscribeState_NOT_SUBSCRIBED 0    SubscribeState_SUBSCRIBE_REQUESTED     SubscribeState_SUBSCRIBED     SubscribeState_UNSUBSCRIBE_REQUESTED     SubscribeState_WAIT_FOR_OFFER     SubscribeState_UNDEFINED_ERROR      <p>describes the current state of a subscriber </p>","title":"enum iox_SubscribeState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientevent","text":"Enumerator Value Description     ClientEvent_RESPONSE_RECEIVED      <p>describes events which can be triggered by a client </p>","title":"enum iox_ClientEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientstate","text":"Enumerator Value Description     ClientState_HAS_RESPONSE      <p>describes states which can be triggered by a client </p>","title":"enum iox_ClientState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverevent","text":"Enumerator Value Description     ServerEvent_REQUEST_RECEIVED      <p>describes events which can be triggered by a server </p>","title":"enum iox_ServerEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverstate","text":"Enumerator Value Description     ServerState_HAS_REQUEST      <p>describes states which can be triggered by a server </p>","title":"enum iox_ServerState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_connectionstate","text":"Enumerator Value Description     ConnectionState_NOT_CONNECTED 0    ConnectionState_CONNECT_REQUESTED     ConnectionState_CONNECTED     ConnectionState_DISCONNECT_REQUESTED     ConnectionState_WAIT_FOR_OFFER      <p>describes the current connection state of a client </p>","title":"enum iox_ConnectionState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_chunkreceiveresult","text":"Enumerator Value Description     ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL     ChunkReceiveResult_NO_CHUNK_AVAILABLE     ChunkReceiveResult_UNDEFINED_ERROR     ChunkReceiveResult_SUCCESS      <p>describes the state of getChunk in the subscriber </p>","title":"enum iox_ChunkReceiveResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_servicediscoveryevent","text":"Enumerator Value Description     ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED      <p>describes events which can be triggered by a service discovery </p>","title":"enum iox_ServiceDiscoveryEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_queuefullpolicy","text":"Enumerator Value Description     QueueFullPolicy_BLOCK_PRODUCER     QueueFullPolicy_DISCARD_OLDEST_DATA      <p>Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full. </p>","title":"enum iox_QueueFullPolicy"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_consumertooslowpolicy","text":"Enumerator Value Description     ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER     ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA      <p>Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full. </p>","title":"enum iox_ConsumerTooSlowPolicy"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_allocationresult","text":"Enumerator Value Description     AllocationResult_NO_MEMPOOLS_AVAILABLE     AllocationResult_RUNNING_OUT_OF_CHUNKS     AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL     AllocationResult_INVALID_CHUNK     AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER     AllocationResult_UNDEFINED_ERROR     AllocationResult_INVALID_PARAMETER_FOR_CHUNK     AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER     AllocationResult_SUCCESS      <p>state of allocateChunk </p>","title":"enum iox_AllocationResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientsendresult","text":"Enumerator Value Description     ClientSendResult_SUCCESS     ClientSendResult_UNDEFINED_ERROR     ClientSendResult_NO_CONNECT_REQUESTED     ClientSendResult_SERVER_NOT_AVAILABLE     ClientSendResult_INVALID_REQUEST      <p>client send result </p>","title":"enum iox_ClientSendResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serversendresult","text":"Enumerator Value Description     ServerSendResult_SUCCESS     ServerSendResult_UNDEFINED_ERROR     ServerSendResult_NOT_OFFERED     ServerSendResult_CLIENT_NOT_AVAILABLE     ServerSendResult_INVALID_RESPONSE      <p>server send result </p>","title":"enum iox_ServerSendResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_waitsetresult","text":"Enumerator Value Description     WaitSetResult_WAIT_SET_FULL     WaitSetResult_ALREADY_ATTACHED     WaitSetResult_UNDEFINED_ERROR     WaitSetResult_SUCCESS      <p>used to describe if attaching an object to a waitset was successful or the kind of attachment error </p>","title":"enum iox_WaitSetResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_listenerresult","text":"Enumerator Value Description     ListenerResult_LISTENER_FULL     ListenerResult_EVENT_ALREADY_ATTACHED     ListenerResult_EMPTY_EVENT_CALLBACK     ListenerResult_EMPTY_INVALIDATION_CALLBACK     ListenerResult_UNDEFINED_ERROR     ListenerResult_SUCCESS      <p>used to describe if attaching an object to a listener was successful or the kind of attachment error </p>","title":"enum iox_ListenerResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverrequestresult","text":"Enumerator Value Description     ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL     ServerRequestResult_NO_PENDING_REQUESTS     ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR     ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER     ServerRequestResult_SUCCESS","title":"enum iox_ServerRequestResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_messagingpattern","text":"Enumerator Value Description     MessagingPattern_PUB_SUB     MessagingPattern_REQ_RES      <p>used to describe the messaging pattern </p>","title":"enum iox_MessagingPattern"},{"location":"API-reference/c-binding/Files/enums_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_ENUMS_H\n#define IOX_BINDING_C_ENUMS_H\n\nenum iox_SubscriberState\n{\n    SubscriberState_HAS_DATA,\n};\n\nenum iox_SubscriberEvent\n{\n    SubscriberEvent_DATA_RECEIVED,\n};\n\nenum iox_SubscribeState\n{\n    SubscribeState_NOT_SUBSCRIBED = 0,\n    SubscribeState_SUBSCRIBE_REQUESTED,\n    SubscribeState_SUBSCRIBED,\n    SubscribeState_UNSUBSCRIBE_REQUESTED,\n    SubscribeState_WAIT_FOR_OFFER,\n    SubscribeState_UNDEFINED_ERROR,\n};\n\nenum iox_ClientEvent\n{\n    ClientEvent_RESPONSE_RECEIVED\n};\n\nenum iox_ClientState\n{\n    ClientState_HAS_RESPONSE\n};\n\nenum iox_ServerEvent\n{\n    ServerEvent_REQUEST_RECEIVED\n};\n\nenum iox_ServerState\n{\n    ServerState_HAS_REQUEST\n};\n\nenum iox_ConnectionState\n{\n    ConnectionState_NOT_CONNECTED = 0,\n    ConnectionState_CONNECT_REQUESTED,\n    ConnectionState_CONNECTED,\n    ConnectionState_DISCONNECT_REQUESTED,\n    ConnectionState_WAIT_FOR_OFFER\n};\n\nenum iox_ChunkReceiveResult\n{\n    ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL,\n    ChunkReceiveResult_NO_CHUNK_AVAILABLE,\n    ChunkReceiveResult_UNDEFINED_ERROR,\n    ChunkReceiveResult_SUCCESS,\n};\n\nenum iox_ServiceDiscoveryEvent\n{\n    ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED\n};\n\nenum iox_QueueFullPolicy\n{\n    QueueFullPolicy_BLOCK_PRODUCER,\n    QueueFullPolicy_DISCARD_OLDEST_DATA,\n};\n\nenum iox_ConsumerTooSlowPolicy\n{\n    ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER,\n    ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA,\n};\n\nenum iox_AllocationResult\n{\n    AllocationResult_NO_MEMPOOLS_AVAILABLE,\n    AllocationResult_RUNNING_OUT_OF_CHUNKS,\n    AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL,\n    AllocationResult_INVALID_CHUNK,\n    AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER,\n    AllocationResult_UNDEFINED_ERROR,\n    AllocationResult_INVALID_PARAMETER_FOR_CHUNK,\n    AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER,\n    AllocationResult_SUCCESS,\n};\n\nenum iox_ClientSendResult\n{\n    ClientSendResult_SUCCESS,\n    ClientSendResult_UNDEFINED_ERROR,\n    ClientSendResult_NO_CONNECT_REQUESTED,\n    ClientSendResult_SERVER_NOT_AVAILABLE,\n    ClientSendResult_INVALID_REQUEST,\n};\n\nenum iox_ServerSendResult\n{\n    ServerSendResult_SUCCESS,\n    ServerSendResult_UNDEFINED_ERROR,\n    ServerSendResult_NOT_OFFERED,\n    ServerSendResult_CLIENT_NOT_AVAILABLE,\n    ServerSendResult_INVALID_RESPONSE,\n};\n\nenum iox_WaitSetResult\n{\n    WaitSetResult_WAIT_SET_FULL,\n    WaitSetResult_ALREADY_ATTACHED,\n    WaitSetResult_UNDEFINED_ERROR,\n    WaitSetResult_SUCCESS\n};\n\nenum iox_ListenerResult\n{\n    ListenerResult_LISTENER_FULL,\n    ListenerResult_EVENT_ALREADY_ATTACHED,\n    ListenerResult_EMPTY_EVENT_CALLBACK,\n    ListenerResult_EMPTY_INVALIDATION_CALLBACK,\n    ListenerResult_UNDEFINED_ERROR,\n    ListenerResult_SUCCESS\n};\n\nenum iox_ServerRequestResult\n{\n    ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL,\n    ServerRequestResult_NO_PENDING_REQUESTS,\n    ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR,\n    ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER,\n    ServerRequestResult_SUCCESS\n};\n\nenum iox_MessagingPattern\n{\n    MessagingPattern_PUB_SUB,\n    MessagingPattern_REQ_RES\n};\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/listener_8h/","text":"","title":"iceoryx_binding_c/listener.h"},{"location":"API-reference/c-binding/Files/listener_8h/#types","text":"Name     typedef CLASS Listener * iox_listener_t","title":"Types"},{"location":"API-reference/c-binding/Files/listener_8h/#functions","text":"Name     iox_listener_t iox_listener_init(iox_listener_storage_t * self)initializes a listener struct from a storage struct pointer   void iox_listener_deinit(iox_listener_t const self)after using an iox_listener_t it must be cleaned up with this function   ENUM iox_ListenerResult iox_listener_attach_subscriber_event(iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void(*)(iox_sub_t) callback)Attaches a subscriber event to the listener.   ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data(iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void()(iox_sub_t, void ) callback, void *const contextData)Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data.   ENUM iox_ListenerResult iox_listener_attach_user_trigger_event(iox_listener_t const self, iox_user_trigger_t const userTrigger, void(*)(iox_user_trigger_t) callback)Attaches a user trigger to the listener.   ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data(iox_listener_t const self, iox_user_trigger_t const userTrigger, void()(iox_user_trigger_t, void ) callback, void *const contextData)Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data.   void iox_listener_detach_subscriber_event(iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent)Detaches a subscriber event from the listener.   void iox_listener_detach_user_trigger_event(iox_listener_t const self, iox_user_trigger_t const userTrigger)Detaches a user trigger from the listener.   uint64_t iox_listener_size(iox_listener_t const self)Returns the size, the number of attached events of a listener.   uint64_t iox_listener_capacity(iox_listener_t const self)Returns the capacity of a listener (how many events can be attached).   ENUM iox_ListenerResult iox_listener_attach_client_event(iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void(*)(iox_client_t) callback)Attaches a client event to the listener.   ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data(iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void()(iox_client_t, void ) callback, void *const contextData)Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data.   void iox_listener_detach_client_event(iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent)Detaches a client from the listener.   ENUM iox_ListenerResult iox_listener_attach_server_event(iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void(*)(iox_server_t) callback)Attaches a server event to the listener.   ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data(iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void()(iox_server_t, void ) callback, void *const contextData)Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data.   void iox_listener_detach_server_event(iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent)Detaches a server from the listener.   ENUM iox_ListenerResult iox_listener_attach_service_discovery_event(iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void(*)(iox_service_discovery_t) callback)Attaches a service discovery event to the listener.   ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data(iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void()(iox_service_discovery_t, void ) callback, void *const contextData)Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data.   void iox_listener_detach_service_discovery_event(iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent)Detaches a service discovery event from the listener.","title":"Functions"},{"location":"API-reference/c-binding/Files/listener_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/listener_8h/#typedef-iox_listener_t","text":"<pre><code>typedef CLASS Listener* iox_listener_t;\n</code></pre>","title":"typedef iox_listener_t"},{"location":"API-reference/c-binding/Files/listener_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_init","text":"<pre><code>iox_listener_t iox_listener_init(\n    iox_listener_storage_t * self\n)\n</code></pre> <p>initializes a listener struct from a storage struct pointer </p> <p>Parameters: </p> <ul> <li>self pointer to raw memory which can hold a listener </li> </ul> <p>Return: an initialized iox_listener_t </p>","title":"function iox_listener_init"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_deinit","text":"<pre><code>void iox_listener_deinit(\n    iox_listener_t const self\n)\n</code></pre> <p>after using an iox_listener_t it must be cleaned up with this function </p> <p>Parameters: </p> <ul> <li>self the listener which should be deinitialized </li> </ul>","title":"function iox_listener_deinit"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_subscriber_event","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_subscriber_event(\n    iox_listener_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent,\n    void(*)(iox_sub_t) callback\n)\n</code></pre> <p>Attaches a subscriber event to the listener. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>subscriber subscriber which emits the event </li> <li>subscriberEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_subscriber_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_subscriber_event_with_context_data","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data(\n    iox_listener_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent,\n    void(*)(iox_sub_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>subscriber subscriber which emits the event </li> <li>subscriberEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_subscriber_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_user_trigger_event","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_user_trigger_event(\n    iox_listener_t const self,\n    iox_user_trigger_t const userTrigger,\n    void(*)(iox_user_trigger_t) callback\n)\n</code></pre> <p>Attaches a user trigger to the listener. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>userTrigger user trigger which emits the event </li> <li>callback the callback which is called when the user trigger triggers the listener </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_user_trigger_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_user_trigger_event_with_context_data","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data(\n    iox_listener_t const self,\n    iox_user_trigger_t const userTrigger,\n    void(*)(iox_user_trigger_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>userTrigger user trigger which emits the event </li> <li>callback the callback which is called when the user trigger triggers the listener </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_user_trigger_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_subscriber_event","text":"<pre><code>void iox_listener_detach_subscriber_event(\n    iox_listener_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent\n)\n</code></pre> <p>Detaches a subscriber event from the listener. </p> <p>Parameters: </p> <ul> <li>self listener from which the event should be detached </li> <li>subscriber the subscriber which emits the event </li> <li>subscriberEvent the subscriber event which is registered at the listener </li> </ul>","title":"function iox_listener_detach_subscriber_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_user_trigger_event","text":"<pre><code>void iox_listener_detach_user_trigger_event(\n    iox_listener_t const self,\n    iox_user_trigger_t const userTrigger\n)\n</code></pre> <p>Detaches a user trigger from the listener. </p> <p>Parameters: </p> <ul> <li>self listener from which the event should be detached </li> <li>userTrigger the user trigger which emits the event </li> </ul>","title":"function iox_listener_detach_user_trigger_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_size","text":"<pre><code>uint64_t iox_listener_size(\n    iox_listener_t const self\n)\n</code></pre> <p>Returns the size, the number of attached events of a listener. </p> <p>Parameters: </p> <ul> <li>self listener where the size should be acquired </li> </ul> <p>Return: the size of the listener </p>","title":"function iox_listener_size"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_capacity","text":"<pre><code>uint64_t iox_listener_capacity(\n    iox_listener_t const self\n)\n</code></pre> <p>Returns the capacity of a listener (how many events can be attached). </p> <p>Parameters: </p> <ul> <li>self listener where the capacity should be acquired </li> </ul> <p>Return: the capacity of the listener </p>","title":"function iox_listener_capacity"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_client_event","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_client_event(\n    iox_listener_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientEvent clientEvent,\n    void(*)(iox_client_t) callback\n)\n</code></pre> <p>Attaches a client event to the listener. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>client client which emits the event </li> <li>clientEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_client_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_client_event_with_context_data","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data(\n    iox_listener_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientEvent clientEvent,\n    void(*)(iox_client_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>client client which emits the event </li> <li>clientEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_client_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_client_event","text":"<pre><code>void iox_listener_detach_client_event(\n    iox_listener_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientEvent clientEvent\n)\n</code></pre> <p>Detaches a client from the listener. </p> <p>Parameters: </p> <ul> <li>self listener from which the event should be detached </li> <li>client the client which emits the event </li> <li>clientEvent the event which should be removed from the listener </li> </ul>","title":"function iox_listener_detach_client_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_server_event","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_server_event(\n    iox_listener_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerEvent serverEvent,\n    void(*)(iox_server_t) callback\n)\n</code></pre> <p>Attaches a server event to the listener. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>server the server which emits the event </li> <li>serverEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_server_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_server_event_with_context_data","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data(\n    iox_listener_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerEvent serverEvent,\n    void(*)(iox_server_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>server the server which emits the event </li> <li>serverEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_server_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_server_event","text":"<pre><code>void iox_listener_detach_server_event(\n    iox_listener_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerEvent serverEvent\n)\n</code></pre> <p>Detaches a server from the listener. </p> <p>Parameters: </p> <ul> <li>self listener from which the event should be detached </li> <li>server the server which emits the event </li> <li>serverEvent the event which should be removed from the listener </li> </ul>","title":"function iox_listener_detach_server_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_service_discovery_event","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_service_discovery_event(\n    iox_listener_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n    void(*)(iox_service_discovery_t) callback\n)\n</code></pre> <p>Attaches a service discovery event to the listener. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>serviceDiscovery service discovery which emits the event </li> <li>serviceDiscoveryEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_service_discovery_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_service_discovery_event_with_context_data","text":"<pre><code>ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data(\n    iox_listener_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n    void(*)(iox_service_discovery_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self listener to which the event should be attached to </li> <li>serviceDiscovery service discovery which emits the event </li> <li>serviceDiscoveryEvent the event which should trigger the listener </li> <li>callback the callback which is called when an event triggers the listener </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_listener_attach_service_discovery_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_service_discovery_event","text":"<pre><code>void iox_listener_detach_service_discovery_event(\n    iox_listener_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent\n)\n</code></pre> <p>Detaches a service discovery event from the listener. </p> <p>Parameters: </p> <ul> <li>self listener from which the event should be detached </li> <li>serviceDiscovery the service discovery which emits the event </li> <li>serviceDiscoveryEvent the service discovery event which should be removed from the listener </li> </ul>","title":"function iox_listener_detach_service_discovery_event"},{"location":"API-reference/c-binding/Files/listener_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_LISTENER_H\n#define IOX_BINDING_C_LISTENER_H\n\n#include \"iceoryx_binding_c/client.h\"\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/server.h\"\n#include \"iceoryx_binding_c/service_discovery.h\"\n#include \"iceoryx_binding_c/subscriber.h\"\n#include \"iceoryx_binding_c/types.h\"\n#include \"iceoryx_binding_c/user_trigger.h\"\n\ntypedef CLASS Listener* iox_listener_t;\n\n\niox_listener_t iox_listener_init(iox_listener_storage_t* self);\n\nvoid iox_listener_deinit(iox_listener_t const self);\n\nENUM iox_ListenerResult iox_listener_attach_subscriber_event(iox_listener_t const self,\n                                                             iox_sub_t const subscriber,\n                                                             const ENUM iox_SubscriberEvent subscriberEvent,\n                                                             void (*callback)(iox_sub_t));\n\nENUM iox_ListenerResult\niox_listener_attach_subscriber_event_with_context_data(iox_listener_t const self,\n                                                       iox_sub_t const subscriber,\n                                                       const ENUM iox_SubscriberEvent subscriberEvent,\n                                                       void (*callback)(iox_sub_t, void*),\n                                                       void* const contextData);\n\nENUM iox_ListenerResult iox_listener_attach_user_trigger_event(iox_listener_t const self,\n                                                               iox_user_trigger_t const userTrigger,\n                                                               void (*callback)(iox_user_trigger_t));\n\nENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data(iox_listener_t const self,\n                                                                                 iox_user_trigger_t const userTrigger,\n                                                                                 void (*callback)(iox_user_trigger_t,\n                                                                                                  void*),\n                                                                                 void* const contextData);\n\nvoid iox_listener_detach_subscriber_event(iox_listener_t const self,\n                                          iox_sub_t const subscriber,\n                                          const ENUM iox_SubscriberEvent subscriberEvent);\n\nvoid iox_listener_detach_user_trigger_event(iox_listener_t const self, iox_user_trigger_t const userTrigger);\n\n\nuint64_t iox_listener_size(iox_listener_t const self);\n\nuint64_t iox_listener_capacity(iox_listener_t const self);\n\nENUM iox_ListenerResult iox_listener_attach_client_event(iox_listener_t const self,\n                                                         iox_client_t const client,\n                                                         const ENUM iox_ClientEvent clientEvent,\n                                                         void (*callback)(iox_client_t));\n\nENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data(iox_listener_t const self,\n                                                                           iox_client_t const client,\n                                                                           const ENUM iox_ClientEvent clientEvent,\n                                                                           void (*callback)(iox_client_t, void*),\n                                                                           void* const contextData);\n\nvoid iox_listener_detach_client_event(iox_listener_t const self,\n                                      iox_client_t const client,\n                                      const ENUM iox_ClientEvent clientEvent);\n\nENUM iox_ListenerResult iox_listener_attach_server_event(iox_listener_t const self,\n                                                         iox_server_t const server,\n                                                         const ENUM iox_ServerEvent serverEvent,\n                                                         void (*callback)(iox_server_t));\n\nENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data(iox_listener_t const self,\n                                                                           iox_server_t const server,\n                                                                           const ENUM iox_ServerEvent serverEvent,\n                                                                           void (*callback)(iox_server_t, void*),\n                                                                           void* const contextData);\n\nvoid iox_listener_detach_server_event(iox_listener_t const self,\n                                      iox_server_t const server,\n                                      const ENUM iox_ServerEvent serverEvent);\n\nENUM iox_ListenerResult\niox_listener_attach_service_discovery_event(iox_listener_t const self,\n                                            iox_service_discovery_t const serviceDiscovery,\n                                            const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n                                            void (*callback)(iox_service_discovery_t));\n\nENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data(\n    iox_listener_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n    void (*callback)(iox_service_discovery_t, void*),\n    void* const contextData);\n\nvoid iox_listener_detach_service_discovery_event(iox_listener_t const self,\n                                                 iox_service_discovery_t const serviceDiscovery,\n                                                 const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/log_8h/","text":"","title":"iceoryx_binding_c/log.h"},{"location":"API-reference/c-binding/Files/log_8h/#types","text":"Name     enum iox_LogLevel { Iceoryx_LogLevel_Off = 0, Iceoryx_LogLevel_Verbose, Iceoryx_LogLevel_Debug, Iceoryx_LogLevel_Info, Iceoryx_LogLevel_Warn, Iceoryx_LogLevel_Error, Iceoryx_LogLevel_Fatal}available log levels of the iceoryx runtime","title":"Types"},{"location":"API-reference/c-binding/Files/log_8h/#functions","text":"Name     void iox_set_loglevel(enum iox_LogLevel level)set the log level of the iceoryx runtime","title":"Functions"},{"location":"API-reference/c-binding/Files/log_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/log_8h/#enum-iox_loglevel","text":"Enumerator Value Description     Iceoryx_LogLevel_Off 0    Iceoryx_LogLevel_Verbose     Iceoryx_LogLevel_Debug     Iceoryx_LogLevel_Info     Iceoryx_LogLevel_Warn     Iceoryx_LogLevel_Error     Iceoryx_LogLevel_Fatal      <p>available log levels of the iceoryx runtime </p>","title":"enum iox_LogLevel"},{"location":"API-reference/c-binding/Files/log_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/log_8h/#function-iox_set_loglevel","text":"<pre><code>void iox_set_loglevel(\n    enum iox_LogLevel level\n)\n</code></pre> <p>set the log level of the iceoryx runtime </p> <p>Parameters: </p> <ul> <li>level log level to be set </li> </ul> <p>Note: must be called before the runtime is initialized </p>","title":"function iox_set_loglevel"},{"location":"API-reference/c-binding/Files/log_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_LOG_H\n#define IOX_BINDING_C_LOG_H\n\nenum iox_LogLevel\n{\n    Iceoryx_LogLevel_Off = 0,\n    Iceoryx_LogLevel_Verbose,\n    Iceoryx_LogLevel_Debug,\n    Iceoryx_LogLevel_Info,\n    Iceoryx_LogLevel_Warn,\n    Iceoryx_LogLevel_Error,\n    Iceoryx_LogLevel_Fatal\n};\n\nvoid iox_set_loglevel(enum iox_LogLevel level);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/node_8h/","text":"","title":"iceoryx_binding_c/node.h"},{"location":"API-reference/c-binding/Files/node_8h/#types","text":"Name     typedef CLASS NodeData * iox_node_t","title":"Types"},{"location":"API-reference/c-binding/Files/node_8h/#functions","text":"Name     iox_node_t iox_node_create(const char *const nodeName)creates a node in the shared memory   void iox_node_destroy(iox_node_t const self)removes a node from the shared memory   uint64_t iox_node_get_name(iox_node_t const self, char *const name, const uint64_t nameCapacity)acquires the name of the node   uint64_t iox_node_get_runtime_name(iox_node_t const self, char *const name, const uint64_t nameCapacity)acquires the name of the application's runtime in which the node is stored","title":"Functions"},{"location":"API-reference/c-binding/Files/node_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/node_8h/#typedef-iox_node_t","text":"<pre><code>typedef CLASS NodeData* iox_node_t;\n</code></pre>","title":"typedef iox_node_t"},{"location":"API-reference/c-binding/Files/node_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_create","text":"<pre><code>iox_node_t iox_node_create(\n    const char *const nodeName\n)\n</code></pre> <p>creates a node in the shared memory </p> <p>Parameters: </p> <ul> <li>nodeName name of the node </li> </ul> <p>Return: handle to the node </p>","title":"function iox_node_create"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_destroy","text":"<pre><code>void iox_node_destroy(\n    iox_node_t const self\n)\n</code></pre> <p>removes a node from the shared memory </p> <p>Parameters: </p> <ul> <li>self handle to the node </li> </ul>","title":"function iox_node_destroy"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_get_name","text":"<pre><code>uint64_t iox_node_get_name(\n    iox_node_t const self,\n    char *const name,\n    const uint64_t nameCapacity\n)\n</code></pre> <p>acquires the name of the node </p> <p>Parameters: </p> <ul> <li>self handle to the node </li> <li>name pointer to a memory location where the name can be written to </li> <li>nameCapacity size of the memory location where the name is written to </li> </ul> <p>Return: the actual length of the node name, if the return value is greater then nameCapacity the name is truncated. If name is a nullptr, 0 will be returned. </p>","title":"function iox_node_get_name"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_get_runtime_name","text":"<pre><code>uint64_t iox_node_get_runtime_name(\n    iox_node_t const self,\n    char *const name,\n    const uint64_t nameCapacity\n)\n</code></pre> <p>acquires the name of the application's runtime in which the node is stored </p> <p>Parameters: </p> <ul> <li>self handle to the node </li> <li>name pointer to a memory location where the name can be written to </li> <li>nameCapacity size of the memory location where the name is written to </li> </ul> <p>Return: the actual length of the runtime name, if the return value is greater than nameCapacity the name is truncated. If name is a nullptr, 0 will be returned. </p>","title":"function iox_node_get_runtime_name"},{"location":"API-reference/c-binding/Files/node_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_NODE_H\n#define IOX_BINDING_C_NODE_H\n\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n\ntypedef CLASS NodeData* iox_node_t;\n\niox_node_t iox_node_create(const char* const nodeName);\n\nvoid iox_node_destroy(iox_node_t const self);\n\nuint64_t iox_node_get_name(iox_node_t const self, char* const name, const uint64_t nameCapacity);\n\nuint64_t iox_node_get_runtime_name(iox_node_t const self, char* const name, const uint64_t nameCapacity);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/notification__info_8h/","text":"","title":"iceoryx_binding_c/notification_info.h"},{"location":"API-reference/c-binding/Files/notification__info_8h/#types","text":"Name     typedef const CLASS NotificationInfo * iox_notification_info_t notification info handle","title":"Types"},{"location":"API-reference/c-binding/Files/notification__info_8h/#functions","text":"Name     uint64_t iox_notification_info_get_notification_id(iox_notification_info_t const self)returns the id of the notification   bool iox_notification_info_does_originate_from_subscriber(iox_notification_info_t const self, iox_sub_t const subscriber)does the notification originate from a certain subscriber   bool iox_notification_info_does_originate_from_user_trigger(iox_notification_info_t const self, iox_user_trigger_t const user_trigger)does the notification originate from a certain user trigger   bool iox_notification_info_does_originate_from_client(iox_notification_info_t const self, iox_client_t const client)does the notification originate from a certain client   bool iox_notification_info_does_originate_from_server(iox_notification_info_t const self, iox_server_t const server)does the notification originate from a certain server   bool iox_notification_info_does_originate_from_service_discovery(iox_notification_info_t const self, iox_service_discovery_t const serviceDiscovery)does the notification originate from a certain service discovery   iox_sub_t iox_notification_info_get_subscriber_origin(iox_notification_info_t const self)acquires the handle of the subscriber origin   iox_user_trigger_t iox_notification_info_get_user_trigger_origin(iox_notification_info_t const self)acquires the handle of the user trigger origin   iox_client_t iox_notification_info_get_client_origin(iox_notification_info_t const self)acquires the handle of the client origin   iox_server_t iox_notification_info_get_server_origin(iox_notification_info_t const self)acquires the handle of the server origin   iox_service_discovery_t iox_notification_info_get_service_discovery_origin(iox_notification_info_t const self)acquires the handle of the service discovery origin   void iox_notification_info_call(iox_notification_info_t const self)calls the callback of the notification","title":"Functions"},{"location":"API-reference/c-binding/Files/notification__info_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/notification__info_8h/#typedef-iox_notification_info_t","text":"<pre><code>typedef const CLASS NotificationInfo* iox_notification_info_t;\n</code></pre> <p>notification info handle </p>","title":"typedef iox_notification_info_t"},{"location":"API-reference/c-binding/Files/notification__info_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_notification_id","text":"<pre><code>uint64_t iox_notification_info_get_notification_id(\n    iox_notification_info_t const self\n)\n</code></pre> <p>returns the id of the notification </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul> <p>Return: notificationId </p>","title":"function iox_notification_info_get_notification_id"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_subscriber","text":"<pre><code>bool iox_notification_info_does_originate_from_subscriber(\n    iox_notification_info_t const self,\n    iox_sub_t const subscriber\n)\n</code></pre> <p>does the notification originate from a certain subscriber </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> <li>subscriber handle to the subscriber in question </li> </ul> <p>Return: true if the notification originates from the subscriber, otherwise false </p>","title":"function iox_notification_info_does_originate_from_subscriber"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_user_trigger","text":"<pre><code>bool iox_notification_info_does_originate_from_user_trigger(\n    iox_notification_info_t const self,\n    iox_user_trigger_t const user_trigger\n)\n</code></pre> <p>does the notification originate from a certain user trigger </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> <li>user_trigger handle to the user trigger in question </li> </ul> <p>Return: true if the notification originates from the user trigger, otherwise false </p>","title":"function iox_notification_info_does_originate_from_user_trigger"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_client","text":"<pre><code>bool iox_notification_info_does_originate_from_client(\n    iox_notification_info_t const self,\n    iox_client_t const client\n)\n</code></pre> <p>does the notification originate from a certain client </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> <li>client handle to the client in question </li> </ul> <p>Return: true if the notification originates from the client, otherwise false </p>","title":"function iox_notification_info_does_originate_from_client"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_server","text":"<pre><code>bool iox_notification_info_does_originate_from_server(\n    iox_notification_info_t const self,\n    iox_server_t const server\n)\n</code></pre> <p>does the notification originate from a certain server </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> <li>server handle to the server in question </li> </ul> <p>Return: true if the notification originates from the server, otherwise false </p>","title":"function iox_notification_info_does_originate_from_server"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_service_discovery","text":"<pre><code>bool iox_notification_info_does_originate_from_service_discovery(\n    iox_notification_info_t const self,\n    iox_service_discovery_t const serviceDiscovery\n)\n</code></pre> <p>does the notification originate from a certain service discovery </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> <li>serviceDiscovery handle to serviceDiscovery in question </li> </ul> <p>Return: true if the notifiaction originates from the service discovery, otherwise false </p>","title":"function iox_notification_info_does_originate_from_service_discovery"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_subscriber_origin","text":"<pre><code>iox_sub_t iox_notification_info_get_subscriber_origin(\n    iox_notification_info_t const self\n)\n</code></pre> <p>acquires the handle of the subscriber origin </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul> <p>Return: the handle to the subscriber if the notification originated from a subscriber, otherwise NULL </p>","title":"function iox_notification_info_get_subscriber_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_user_trigger_origin","text":"<pre><code>iox_user_trigger_t iox_notification_info_get_user_trigger_origin(\n    iox_notification_info_t const self\n)\n</code></pre> <p>acquires the handle of the user trigger origin </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul> <p>Return: the handle to the user trigger if the notification originated from a user trigger, otherwise NULL </p>","title":"function iox_notification_info_get_user_trigger_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_client_origin","text":"<pre><code>iox_client_t iox_notification_info_get_client_origin(\n    iox_notification_info_t const self\n)\n</code></pre> <p>acquires the handle of the client origin </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul> <p>Return: the handle to the client if the notification originated from a client, otherwise NULL </p>","title":"function iox_notification_info_get_client_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_server_origin","text":"<pre><code>iox_server_t iox_notification_info_get_server_origin(\n    iox_notification_info_t const self\n)\n</code></pre> <p>acquires the handle of the server origin </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul> <p>Return: the handle to the server if the notification originated from a server, otherwise NULL </p>","title":"function iox_notification_info_get_server_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_service_discovery_origin","text":"<pre><code>iox_service_discovery_t iox_notification_info_get_service_discovery_origin(\n    iox_notification_info_t const self\n)\n</code></pre> <p>acquires the handle of the service discovery origin </p> <p>Parameters: </p> <ul> <li>self handle to the notification info </li> </ul> <p>Return: the handle to the service discovery if the notification originated from a service discovery, otherwise NULL </p>","title":"function iox_notification_info_get_service_discovery_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_call","text":"<pre><code>void iox_notification_info_call(\n    iox_notification_info_t const self\n)\n</code></pre> <p>calls the callback of the notification </p> <p>Parameters: </p> <ul> <li>self handle to notification info </li> </ul>","title":"function iox_notification_info_call"},{"location":"API-reference/c-binding/Files/notification__info_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_EVENT_INFO_H\n#define IOX_BINDING_C_EVENT_INFO_H\n\n#include \"iceoryx_binding_c/client.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/server.h\"\n#include \"iceoryx_binding_c/service_discovery.h\"\n#include \"iceoryx_binding_c/subscriber.h\"\n#include \"iceoryx_binding_c/user_trigger.h\"\n\ntypedef const CLASS NotificationInfo* iox_notification_info_t;\n\nuint64_t iox_notification_info_get_notification_id(iox_notification_info_t const self);\n\nbool iox_notification_info_does_originate_from_subscriber(iox_notification_info_t const self,\n                                                          iox_sub_t const subscriber);\n\nbool iox_notification_info_does_originate_from_user_trigger(iox_notification_info_t const self,\n                                                            iox_user_trigger_t const user_trigger);\n\nbool iox_notification_info_does_originate_from_client(iox_notification_info_t const self, iox_client_t const client);\n\nbool iox_notification_info_does_originate_from_server(iox_notification_info_t const self, iox_server_t const server);\n\nbool iox_notification_info_does_originate_from_service_discovery(iox_notification_info_t const self,\n                                                                 iox_service_discovery_t const serviceDiscovery);\n\niox_sub_t iox_notification_info_get_subscriber_origin(iox_notification_info_t const self);\n\niox_user_trigger_t iox_notification_info_get_user_trigger_origin(iox_notification_info_t const self);\n\niox_client_t iox_notification_info_get_client_origin(iox_notification_info_t const self);\n\niox_server_t iox_notification_info_get_server_origin(iox_notification_info_t const self);\n\niox_service_discovery_t iox_notification_info_get_service_discovery_origin(iox_notification_info_t const self);\n\nvoid iox_notification_info_call(iox_notification_info_t const self);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/publisher_8h/","text":"","title":"iceoryx_binding_c/publisher.h"},{"location":"API-reference/c-binding/Files/publisher_8h/#classes","text":"Name     struct iox_pub_options_t options to be set for a publisher","title":"Classes"},{"location":"API-reference/c-binding/Files/publisher_8h/#types","text":"Name     typedef struct cpp2c_Publisher * iox_pub_t publisher handle","title":"Types"},{"location":"API-reference/c-binding/Files/publisher_8h/#functions","text":"Name     void iox_pub_options_init(iox_pub_options_t * options)initialize publisher options to default values   bool iox_pub_options_is_initialized(const iox_pub_options_t *const options)check whether the publisher options were initialized by iox_pub_options_init   iox_pub_t iox_pub_init(iox_pub_storage_t * self, const char const service, const char const instance, const char const event, const iox_pub_options_t const options)creates a publisher handle   void iox_pub_deinit(iox_pub_t const self)removes a publisher handle   ENUM iox_AllocationResult iox_pub_loan_chunk(iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize)allocates a chunk in the shared memory   ENUM iox_AllocationResult iox_pub_loan_aligned_chunk(iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment)allocates a chunk in the shared memory with a custom alignment for the user-payload   ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header(iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment, const uint32_t userHeaderSize, const uint32_t userHeaderAlignment)allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload   void iox_pub_release_chunk(iox_pub_t const self, void *const userPayload)releases ownership of a previously allocated chunk without sending it   void iox_pub_publish_chunk(iox_pub_t const self, void *const userPayload)sends a previously allocated chunk   void iox_pub_offer(iox_pub_t const self)offers the service   void iox_pub_stop_offer(iox_pub_t const self)stop offering the service   bool iox_pub_is_offered(iox_pub_t const self)is the service still offered   bool iox_pub_has_subscribers(iox_pub_t const self)does the service have subscribers   iox_service_description_t iox_pub_get_service_description(iox_pub_t const self)returns the service description of the publisher","title":"Functions"},{"location":"API-reference/c-binding/Files/publisher_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/publisher_8h/#typedef-iox_pub_t","text":"<pre><code>typedef struct cpp2c_Publisher* iox_pub_t;\n</code></pre> <p>publisher handle </p>","title":"typedef iox_pub_t"},{"location":"API-reference/c-binding/Files/publisher_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_options_init","text":"<pre><code>void iox_pub_options_init(\n    iox_pub_options_t * options\n)\n</code></pre> <p>initialize publisher options to default values </p> <p>Parameters: </p> <ul> <li>options pointer to options to be initialized, emit warning if it is a null pointer </li> </ul> <p>Attention: This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. </p>","title":"function iox_pub_options_init"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_options_is_initialized","text":"<pre><code>bool iox_pub_options_is_initialized(\n    const iox_pub_options_t *const options\n)\n</code></pre> <p>check whether the publisher options were initialized by iox_pub_options_init </p> <p>Parameters: </p> <ul> <li>options pointer to options to be checked </li> </ul> <p>Return: true if options are not null and were initialized, false otherwise </p>","title":"function iox_pub_options_is_initialized"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_init","text":"<pre><code>iox_pub_t iox_pub_init(\n    iox_pub_storage_t * self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    const iox_pub_options_t *const options\n)\n</code></pre> <p>creates a publisher handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_pub_storage_t) </li> <li>service serviceString </li> <li>instance instanceString </li> <li>event eventString </li> <li>options publisher options set by the user, if it is a null pointer default options are used </li> </ul> <p>Return: handle of the publisher </p>","title":"function iox_pub_init"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_deinit","text":"<pre><code>void iox_pub_deinit(\n    iox_pub_t const self\n)\n</code></pre> <p>removes a publisher handle </p> <p>Parameters: </p> <ul> <li>self the handle which should be removed </li> </ul>","title":"function iox_pub_deinit"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_chunk","text":"<pre><code>ENUM iox_AllocationResult iox_pub_loan_chunk(\n    iox_pub_t const self,\n    void **const userPayload,\n    const uint32_t userPayloadSize\n)\n</code></pre> <p>allocates a chunk in the shared memory </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> <li>userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>userPayloadSize user-payload size of the allocated chunk </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p> <p>Note: for the user-payload alignment <code>IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT</code> is used for a custom user-payload alignment please use <code>iox_pub_loan_aligned_chunk</code></p>","title":"function iox_pub_loan_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_aligned_chunk","text":"<pre><code>ENUM iox_AllocationResult iox_pub_loan_aligned_chunk(\n    iox_pub_t const self,\n    void **const userPayload,\n    const uint32_t userPayloadSize,\n    const uint32_t userPayloadAlignment\n)\n</code></pre> <p>allocates a chunk in the shared memory with a custom alignment for the user-payload </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> <li>userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>userPayloadSize user-payload size of the allocated chunk </li> <li>userPayloadAlignment user-payload alignment of the allocated chunk </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_pub_loan_aligned_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_aligned_chunk_with_user_header","text":"<pre><code>ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header(\n    iox_pub_t const self,\n    void **const userPayload,\n    const uint32_t userPayloadSize,\n    const uint32_t userPayloadAlignment,\n    const uint32_t userHeaderSize,\n    const uint32_t userHeaderAlignment\n)\n</code></pre> <p>allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> <li>userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>userPayloadSize user-payload size of the allocated chunk </li> <li>userPayloadAlignment user-payload alignment of the allocated chunk </li> <li>userHeaderSize user-header size of the allocated chunk </li> <li>userHeaderAlignment user-header alignment of the allocated chunk </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_pub_loan_aligned_chunk_with_user_header"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_release_chunk","text":"<pre><code>void iox_pub_release_chunk(\n    iox_pub_t const self,\n    void *const userPayload\n)\n</code></pre> <p>releases ownership of a previously allocated chunk without sending it </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> <li>userPayload pointer to the user-payload of the chunk which should be free'd </li> </ul>","title":"function iox_pub_release_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_publish_chunk","text":"<pre><code>void iox_pub_publish_chunk(\n    iox_pub_t const self,\n    void *const userPayload\n)\n</code></pre> <p>sends a previously allocated chunk </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> <li>userPayload pointer to the user-payload of the chunk which should be send </li> </ul>","title":"function iox_pub_publish_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_offer","text":"<pre><code>void iox_pub_offer(\n    iox_pub_t const self\n)\n</code></pre> <p>offers the service </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> </ul>","title":"function iox_pub_offer"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_stop_offer","text":"<pre><code>void iox_pub_stop_offer(\n    iox_pub_t const self\n)\n</code></pre> <p>stop offering the service </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> </ul>","title":"function iox_pub_stop_offer"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_is_offered","text":"<pre><code>bool iox_pub_is_offered(\n    iox_pub_t const self\n)\n</code></pre> <p>is the service still offered </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> </ul> <p>Return: true is the service is offered otherwise false </p>","title":"function iox_pub_is_offered"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_has_subscribers","text":"<pre><code>bool iox_pub_has_subscribers(\n    iox_pub_t const self\n)\n</code></pre> <p>does the service have subscribers </p> <p>Parameters: </p> <ul> <li>self handle of the publisher </li> </ul> <p>Return: true if there are subscribers otherwise false </p>","title":"function iox_pub_has_subscribers"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_get_service_description","text":"<pre><code>iox_service_description_t iox_pub_get_service_description(\n    iox_pub_t const self\n)\n</code></pre> <p>returns the service description of the publisher </p> <p>Parameters: </p> <ul> <li>self handle to the publisher </li> </ul> <p>Return: the service description </p>","title":"function iox_pub_get_service_description"},{"location":"API-reference/c-binding/Files/publisher_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_PUBLISHER_H\n#define IOX_BINDING_C_PUBLISHER_H\n\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/service_description.h\"\n#include \"iceoryx_binding_c/types.h\"\n\ntypedef struct cpp2c_Publisher* iox_pub_t;\n\ntypedef struct\n{\n    uint64_t historyCapacity;\n\n    const char* nodeName;\n\n    bool offerOnCreate;\n\n    ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy;\n\n    uint64_t initCheck;\n} iox_pub_options_t;\n\nvoid iox_pub_options_init(iox_pub_options_t* options);\n\nbool iox_pub_options_is_initialized(const iox_pub_options_t* const options);\n\niox_pub_t iox_pub_init(iox_pub_storage_t* self,\n                       const char* const service,\n                       const char* const instance,\n                       const char* const event,\n                       const iox_pub_options_t* const options);\n\nvoid iox_pub_deinit(iox_pub_t const self);\n\nENUM iox_AllocationResult iox_pub_loan_chunk(iox_pub_t const self,\n                                             void** const userPayload,\n                                             const uint32_t userPayloadSize);\n\nENUM iox_AllocationResult iox_pub_loan_aligned_chunk(iox_pub_t const self,\n                                                     void** const userPayload,\n                                                     const uint32_t userPayloadSize,\n                                                     const uint32_t userPayloadAlignment);\n\nENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header(iox_pub_t const self,\n                                                                      void** const userPayload,\n                                                                      const uint32_t userPayloadSize,\n                                                                      const uint32_t userPayloadAlignment,\n                                                                      const uint32_t userHeaderSize,\n                                                                      const uint32_t userHeaderAlignment);\n\nvoid iox_pub_release_chunk(iox_pub_t const self, void* const userPayload);\n\nvoid iox_pub_publish_chunk(iox_pub_t const self, void* const userPayload);\n\nvoid iox_pub_offer(iox_pub_t const self);\n\nvoid iox_pub_stop_offer(iox_pub_t const self);\n\nbool iox_pub_is_offered(iox_pub_t const self);\n\nbool iox_pub_has_subscribers(iox_pub_t const self);\n\niox_service_description_t iox_pub_get_service_description(iox_pub_t const self);\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/request__header_8h/","text":"","title":"iceoryx_binding_c/request_header.h"},{"location":"API-reference/c-binding/Files/request__header_8h/#types","text":"Name     typedef CLASS RequestHeader * iox_request_header_t request header handle   typedef const CLASS RequestHeader * iox_const_request_header_t const request header handle","title":"Types"},{"location":"API-reference/c-binding/Files/request__header_8h/#functions","text":"Name     iox_request_header_t iox_request_header_from_payload(void *const payload)extract the request header from a given payload   iox_const_request_header_t iox_request_header_from_payload_const(const void *const payload)extract the request header from a given payload   void iox_request_header_set_sequence_id(iox_request_header_t const self, const int64_t sequenceId)set the sequence id of the request header   uint8_t iox_request_header_get_rpc_header_version(iox_request_header_t const self)returns the rpc header version   uint8_t iox_request_header_get_rpc_header_version_const(iox_const_request_header_t const self)returns the rpc header version   int64_t iox_request_header_get_sequence_id(iox_request_header_t const self)returns the sequence id   int64_t iox_request_header_get_sequence_id_const(iox_const_request_header_t const self)returns the sequence id   void * iox_request_header_get_user_payload(iox_request_header_t const self)returns a pointer to the user payload   const void * iox_request_header_get_user_payload_const(iox_const_request_header_t const self)returns a pointer to the user payload   iox_chunk_header_t * iox_request_header_get_chunk_header(iox_request_header_t const self)returns a pointer to the chunk header   const iox_chunk_header_t * iox_request_header_get_chunk_header_const(iox_const_request_header_t const self)returns a pointer to the chunk header","title":"Functions"},{"location":"API-reference/c-binding/Files/request__header_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/request__header_8h/#typedef-iox_request_header_t","text":"<pre><code>typedef CLASS RequestHeader* iox_request_header_t;\n</code></pre> <p>request header handle </p>","title":"typedef iox_request_header_t"},{"location":"API-reference/c-binding/Files/request__header_8h/#typedef-iox_const_request_header_t","text":"<pre><code>typedef const CLASS RequestHeader* iox_const_request_header_t;\n</code></pre> <p>const request header handle </p>","title":"typedef iox_const_request_header_t"},{"location":"API-reference/c-binding/Files/request__header_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_from_payload","text":"<pre><code>iox_request_header_t iox_request_header_from_payload(\n    void *const payload\n)\n</code></pre> <p>extract the request header from a given payload </p> <p>Parameters: </p> <ul> <li>payload the pointer to the payload </li> </ul> <p>Return: a handle to the request header </p>","title":"function iox_request_header_from_payload"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_from_payload_const","text":"<pre><code>iox_const_request_header_t iox_request_header_from_payload_const(\n    const void *const payload\n)\n</code></pre> <p>extract the request header from a given payload </p> <p>Parameters: </p> <ul> <li>payload the pointer to the payload </li> </ul> <p>Return: a handle to the request header </p>","title":"function iox_request_header_from_payload_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_set_sequence_id","text":"<pre><code>void iox_request_header_set_sequence_id(\n    iox_request_header_t const self,\n    const int64_t sequenceId\n)\n</code></pre> <p>set the sequence id of the request header </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> <li>sequenceId the new sequence id value </li> </ul>","title":"function iox_request_header_set_sequence_id"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_rpc_header_version","text":"<pre><code>uint8_t iox_request_header_get_rpc_header_version(\n    iox_request_header_t const self\n)\n</code></pre> <p>returns the rpc header version </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: rpc header version </p>","title":"function iox_request_header_get_rpc_header_version"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_rpc_header_version_const","text":"<pre><code>uint8_t iox_request_header_get_rpc_header_version_const(\n    iox_const_request_header_t const self\n)\n</code></pre> <p>returns the rpc header version </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: rpc header version </p>","title":"function iox_request_header_get_rpc_header_version_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_sequence_id","text":"<pre><code>int64_t iox_request_header_get_sequence_id(\n    iox_request_header_t const self\n)\n</code></pre> <p>returns the sequence id </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: sequence id </p>","title":"function iox_request_header_get_sequence_id"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_sequence_id_const","text":"<pre><code>int64_t iox_request_header_get_sequence_id_const(\n    iox_const_request_header_t const self\n)\n</code></pre> <p>returns the sequence id </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: sequence id </p>","title":"function iox_request_header_get_sequence_id_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_user_payload","text":"<pre><code>void * iox_request_header_get_user_payload(\n    iox_request_header_t const self\n)\n</code></pre> <p>returns a pointer to the user payload </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: pointer to the payload </p>","title":"function iox_request_header_get_user_payload"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_user_payload_const","text":"<pre><code>const void * iox_request_header_get_user_payload_const(\n    iox_const_request_header_t const self\n)\n</code></pre> <p>returns a pointer to the user payload </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: pointer to the payload </p>","title":"function iox_request_header_get_user_payload_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_chunk_header","text":"<pre><code>iox_chunk_header_t * iox_request_header_get_chunk_header(\n    iox_request_header_t const self\n)\n</code></pre> <p>returns a pointer to the chunk header </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: pointer to the chunk header </p>","title":"function iox_request_header_get_chunk_header"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_chunk_header_const","text":"<pre><code>const iox_chunk_header_t * iox_request_header_get_chunk_header_const(\n    iox_const_request_header_t const self\n)\n</code></pre> <p>returns a pointer to the chunk header </p> <p>Parameters: </p> <ul> <li>self handle to the request header </li> </ul> <p>Return: pointer to the chunk header </p>","title":"function iox_request_header_get_chunk_header_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_REQUEST_HEADER_H\n#define IOX_BINDING_C_REQUEST_HEADER_H\n\n#include \"iceoryx_binding_c/chunk.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n\ntypedef CLASS RequestHeader* iox_request_header_t;\n\ntypedef const CLASS RequestHeader* iox_const_request_header_t;\n\niox_request_header_t iox_request_header_from_payload(void* const payload);\n\niox_const_request_header_t iox_request_header_from_payload_const(const void* const payload);\n\nvoid iox_request_header_set_sequence_id(iox_request_header_t const self, const int64_t sequenceId);\n\nuint8_t iox_request_header_get_rpc_header_version(iox_request_header_t const self);\n\nuint8_t iox_request_header_get_rpc_header_version_const(iox_const_request_header_t const self);\n\nint64_t iox_request_header_get_sequence_id(iox_request_header_t const self);\n\nint64_t iox_request_header_get_sequence_id_const(iox_const_request_header_t const self);\n\nvoid* iox_request_header_get_user_payload(iox_request_header_t const self);\n\nconst void* iox_request_header_get_user_payload_const(iox_const_request_header_t const self);\n\niox_chunk_header_t* iox_request_header_get_chunk_header(iox_request_header_t const self);\n\nconst iox_chunk_header_t* iox_request_header_get_chunk_header_const(iox_const_request_header_t const self);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/response__header_8h/","text":"","title":"iceoryx_binding_c/response_header.h"},{"location":"API-reference/c-binding/Files/response__header_8h/#types","text":"Name     typedef CLASS ResponseHeader * iox_response_header_t response header handle   typedef const CLASS ResponseHeader * iox_const_response_header_t const response header handle","title":"Types"},{"location":"API-reference/c-binding/Files/response__header_8h/#functions","text":"Name     iox_response_header_t iox_response_header_from_payload(void *const payload)extract the response header from a given payload   iox_const_response_header_t iox_response_header_from_payload_const(const void *const payload)extract the response header from a given payload   void iox_response_header_set_server_error(iox_response_header_t const self)set the response header into server error state   bool iox_response_header_has_server_error(iox_response_header_t const self)is the response header in an error state   bool iox_response_header_has_server_error_const(iox_const_response_header_t const self)is the response header in an error state   uint8_t iox_response_header_get_rpc_header_version(iox_response_header_t const self)returns the rpc header version   uint8_t iox_response_header_get_rpc_header_version_const(iox_const_response_header_t const self)returns the rpc header version   int64_t iox_response_header_get_sequence_id(iox_response_header_t const self)returns the sequence id   int64_t iox_response_header_get_sequence_id_const(iox_const_response_header_t const self)returns the sequence id   void * iox_response_header_get_user_payload(iox_response_header_t const self)returns a pointer to the user payload   const void * iox_response_header_get_user_payload_const(iox_const_response_header_t const self)returns a pointer to the user payload   iox_chunk_header_t * iox_response_header_get_chunk_header(iox_response_header_t const self)returns a pointer to the chunk header   const iox_chunk_header_t * iox_response_header_get_chunk_header_const(iox_const_response_header_t const self)returns a pointer to the chunk header","title":"Functions"},{"location":"API-reference/c-binding/Files/response__header_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/response__header_8h/#typedef-iox_response_header_t","text":"<pre><code>typedef CLASS ResponseHeader* iox_response_header_t;\n</code></pre> <p>response header handle </p>","title":"typedef iox_response_header_t"},{"location":"API-reference/c-binding/Files/response__header_8h/#typedef-iox_const_response_header_t","text":"<pre><code>typedef const CLASS ResponseHeader* iox_const_response_header_t;\n</code></pre> <p>const response header handle </p>","title":"typedef iox_const_response_header_t"},{"location":"API-reference/c-binding/Files/response__header_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_from_payload","text":"<pre><code>iox_response_header_t iox_response_header_from_payload(\n    void *const payload\n)\n</code></pre> <p>extract the response header from a given payload </p> <p>Parameters: </p> <ul> <li>payload the pointer to the payload </li> </ul> <p>Return: a handle to the response header </p>","title":"function iox_response_header_from_payload"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_from_payload_const","text":"<pre><code>iox_const_response_header_t iox_response_header_from_payload_const(\n    const void *const payload\n)\n</code></pre> <p>extract the response header from a given payload </p> <p>Parameters: </p> <ul> <li>payload the pointer to the payload </li> </ul> <p>Return: a handle to the response header </p>","title":"function iox_response_header_from_payload_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_set_server_error","text":"<pre><code>void iox_response_header_set_server_error(\n    iox_response_header_t const self\n)\n</code></pre> <p>set the response header into server error state </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul>","title":"function iox_response_header_set_server_error"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_has_server_error","text":"<pre><code>bool iox_response_header_has_server_error(\n    iox_response_header_t const self\n)\n</code></pre> <p>is the response header in an error state </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: true if it is in an error state, otherwise false </p>","title":"function iox_response_header_has_server_error"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_has_server_error_const","text":"<pre><code>bool iox_response_header_has_server_error_const(\n    iox_const_response_header_t const self\n)\n</code></pre> <p>is the response header in an error state </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: true if it is in an error state, otherwise false </p>","title":"function iox_response_header_has_server_error_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_rpc_header_version","text":"<pre><code>uint8_t iox_response_header_get_rpc_header_version(\n    iox_response_header_t const self\n)\n</code></pre> <p>returns the rpc header version </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: rpc header version </p>","title":"function iox_response_header_get_rpc_header_version"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_rpc_header_version_const","text":"<pre><code>uint8_t iox_response_header_get_rpc_header_version_const(\n    iox_const_response_header_t const self\n)\n</code></pre> <p>returns the rpc header version </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: rpc header version </p>","title":"function iox_response_header_get_rpc_header_version_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_sequence_id","text":"<pre><code>int64_t iox_response_header_get_sequence_id(\n    iox_response_header_t const self\n)\n</code></pre> <p>returns the sequence id </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: sequence id </p>","title":"function iox_response_header_get_sequence_id"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_sequence_id_const","text":"<pre><code>int64_t iox_response_header_get_sequence_id_const(\n    iox_const_response_header_t const self\n)\n</code></pre> <p>returns the sequence id </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: sequence id </p>","title":"function iox_response_header_get_sequence_id_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_user_payload","text":"<pre><code>void * iox_response_header_get_user_payload(\n    iox_response_header_t const self\n)\n</code></pre> <p>returns a pointer to the user payload </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: pointer to the payload </p>","title":"function iox_response_header_get_user_payload"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_user_payload_const","text":"<pre><code>const void * iox_response_header_get_user_payload_const(\n    iox_const_response_header_t const self\n)\n</code></pre> <p>returns a pointer to the user payload </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: pointer to the payload </p>","title":"function iox_response_header_get_user_payload_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_chunk_header","text":"<pre><code>iox_chunk_header_t * iox_response_header_get_chunk_header(\n    iox_response_header_t const self\n)\n</code></pre> <p>returns a pointer to the chunk header </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: pointer to the chunk header </p>","title":"function iox_response_header_get_chunk_header"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_chunk_header_const","text":"<pre><code>const iox_chunk_header_t * iox_response_header_get_chunk_header_const(\n    iox_const_response_header_t const self\n)\n</code></pre> <p>returns a pointer to the chunk header </p> <p>Parameters: </p> <ul> <li>self handle to the response header </li> </ul> <p>Return: pointer to the chunk header </p>","title":"function iox_response_header_get_chunk_header_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_RESPONSE_HEADER_H\n#define IOX_BINDING_C_RESPONSE_HEADER_H\n\n#include \"iceoryx_binding_c/chunk.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n\ntypedef CLASS ResponseHeader* iox_response_header_t;\n\ntypedef const CLASS ResponseHeader* iox_const_response_header_t;\n\niox_response_header_t iox_response_header_from_payload(void* const payload);\n\niox_const_response_header_t iox_response_header_from_payload_const(const void* const payload);\n\nvoid iox_response_header_set_server_error(iox_response_header_t const self);\n\nbool iox_response_header_has_server_error(iox_response_header_t const self);\n\nbool iox_response_header_has_server_error_const(iox_const_response_header_t const self);\n\nuint8_t iox_response_header_get_rpc_header_version(iox_response_header_t const self);\n\nuint8_t iox_response_header_get_rpc_header_version_const(iox_const_response_header_t const self);\n\nint64_t iox_response_header_get_sequence_id(iox_response_header_t const self);\n\nint64_t iox_response_header_get_sequence_id_const(iox_const_response_header_t const self);\n\nvoid* iox_response_header_get_user_payload(iox_response_header_t const self);\n\nconst void* iox_response_header_get_user_payload_const(iox_const_response_header_t const self);\n\niox_chunk_header_t* iox_response_header_get_chunk_header(iox_response_header_t const self);\n\nconst iox_chunk_header_t* iox_response_header_get_chunk_header_const(iox_const_response_header_t const self);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/runtime_8h/","text":"","title":"iceoryx_binding_c/runtime.h"},{"location":"API-reference/c-binding/Files/runtime_8h/#functions","text":"Name     void iox_runtime_init(const char *const name)initializes a new posh runtime with a given name   uint64_t iox_runtime_get_instance_name(char *const name, const uint64_t nameLength)retrieves the instance-name of the current posh runtime instance   void iox_runtime_shutdown()initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set","title":"Functions"},{"location":"API-reference/c-binding/Files/runtime_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_init","text":"<pre><code>void iox_runtime_init(\n    const char *const name\n)\n</code></pre> <p>initializes a new posh runtime with a given name </p> <p>Parameters: </p> <ul> <li>name name of the posh runtime </li> </ul>","title":"function iox_runtime_init"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_get_instance_name","text":"<pre><code>uint64_t iox_runtime_get_instance_name(\n    char *const name,\n    const uint64_t nameLength\n)\n</code></pre> <p>retrieves the instance-name of the current posh runtime instance </p> <p>Parameters: </p> <ul> <li>name char pointer to preallocated memory </li> <li>nameLength size of the preallocated memory. </li> </ul> <p>Return: The length of the instance-name. If the instance-name is longer then nameLength a number greater nameLength is returned and the instance-name, truncated to nameLength, is written into the memory location of name. If name is a nullptr, 0 will be returned. </p>","title":"function iox_runtime_get_instance_name"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_shutdown","text":"<pre><code>void iox_runtime_shutdown()\n</code></pre> <p>initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set </p>","title":"function iox_runtime_shutdown"},{"location":"API-reference/c-binding/Files/runtime_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_POSH_RUNTIME_H\n#define IOX_BINDING_C_POSH_RUNTIME_H\n\n#include \"internal/c2cpp_binding.h\"\n\nvoid iox_runtime_init(const char* const name);\n\nuint64_t iox_runtime_get_instance_name(char* const name, const uint64_t nameLength);\n\nvoid iox_runtime_shutdown();\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/server_8h/","text":"","title":"iceoryx_binding_c/server.h"},{"location":"API-reference/c-binding/Files/server_8h/#classes","text":"Name     struct iox_server_options_t options to be set for a server","title":"Classes"},{"location":"API-reference/c-binding/Files/server_8h/#types","text":"Name     typedef CLASS UntypedServer * iox_server_t server handle","title":"Types"},{"location":"API-reference/c-binding/Files/server_8h/#functions","text":"Name     void iox_server_options_init(iox_server_options_t *const options)initialize server options to default values   bool iox_server_options_is_initialized(const iox_server_options_t *const options)check whether the server options were initialized by iox_server_options_init   iox_server_t iox_server_init(iox_server_storage_t * self, const char const service, const char const instance, const char const event, const iox_server_options_t const options)creates a server handle   void iox_server_deinit(iox_server_t const self)removes a server handle   ENUM iox_ServerRequestResult iox_server_take_request(iox_server_t const self, const void **const payload)retrieve a received request   void iox_server_release_request(iox_server_t const self, const void *const payload)release a previously acquired request (via iox_server_take_request)   ENUM iox_AllocationResult iox_server_loan_response(iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize)allocates a response in the shared memory   ENUM iox_AllocationResult iox_server_loan_aligned_response(iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize, const uint32_t payloadAlignment)allocates a response in the shared memory   ENUM iox_ServerSendResult iox_server_send(iox_server_t const self, void *const payload)sends a previously loaned response   void iox_server_release_response(iox_server_t const self, void *const payload)releases ownership of a previously allocated loaned response without sending it   iox_service_description_t iox_server_get_service_description(iox_server_t const self)returns the service description of the server   void iox_server_offer(iox_server_t const self)offers the servers service   void iox_server_stop_offer(iox_server_t const self)stops offering the servers service   bool iox_server_is_offered(iox_server_t const self)is the server currently offering?   bool iox_server_has_clients(iox_server_t const self)are clients connected to the server?   bool iox_server_has_requests(iox_server_t const self)are requests from clients available?   bool iox_server_has_missed_requests(iox_server_t const self)were requests missed?   void iox_server_release_queued_requests(iox_server_t const self)release a previously acquired request (via iox_server_take_request)","title":"Functions"},{"location":"API-reference/c-binding/Files/server_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/server_8h/#typedef-iox_server_t","text":"<pre><code>typedef CLASS UntypedServer* iox_server_t;\n</code></pre> <p>server handle </p>","title":"typedef iox_server_t"},{"location":"API-reference/c-binding/Files/server_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_options_init","text":"<pre><code>void iox_server_options_init(\n    iox_server_options_t *const options\n)\n</code></pre> <p>initialize server options to default values </p> <p>Parameters: </p> <ul> <li>options pointer to options to be initialized, emit warning if it is a null pointer </li> </ul> <p>Attention: This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. </p>","title":"function iox_server_options_init"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_options_is_initialized","text":"<pre><code>bool iox_server_options_is_initialized(\n    const iox_server_options_t *const options\n)\n</code></pre> <p>check whether the server options were initialized by iox_server_options_init </p> <p>Parameters: </p> <ul> <li>options pointer to options to be checked </li> </ul> <p>Return: true if options are not null and were initialized, false otherwise </p>","title":"function iox_server_options_is_initialized"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_init","text":"<pre><code>iox_server_t iox_server_init(\n    iox_server_storage_t * self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    const iox_server_options_t *const options\n)\n</code></pre> <p>creates a server handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_server_storage_t) </li> <li>service serviceString </li> <li>instance instanceString </li> <li>event eventString </li> <li>options server options set by the user, if it is a null pointer default options are used </li> </ul> <p>Return: handle of the server </p>","title":"function iox_server_init"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_deinit","text":"<pre><code>void iox_server_deinit(\n    iox_server_t const self\n)\n</code></pre> <p>removes a server handle </p> <p>Parameters: </p> <ul> <li>self the handle which should be removed </li> </ul>","title":"function iox_server_deinit"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_take_request","text":"<pre><code>ENUM iox_ServerRequestResult iox_server_take_request(\n    iox_server_t const self,\n    const void **const payload\n)\n</code></pre> <p>retrieve a received request </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> <li>payload pointer in which the pointer to the user-payload of the request is stored </li> </ul> <p>Return: if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_server_take_request"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_request","text":"<pre><code>void iox_server_release_request(\n    iox_server_t const self,\n    const void *const payload\n)\n</code></pre> <p>release a previously acquired request (via iox_server_take_request) </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> <li>payload pointer to the user-payload of chunk which should be released </li> </ul>","title":"function iox_server_release_request"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_loan_response","text":"<pre><code>ENUM iox_AllocationResult iox_server_loan_response(\n    iox_server_t const self,\n    const void *const requestPayload,\n    void **const payload,\n    const uint32_t payloadSize\n)\n</code></pre> <p>allocates a response in the shared memory </p> <p>Parameters: </p> <ul> <li>self handle of the server </li> <li>requestPayload pointer to the payload of the received request </li> <li>payload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>payloadSize user-payload size of the allocated request </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p> <p>Note: for the user-payload alignment <code>IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT</code> is used for a custom user-payload alignment please use <code>iox_server_loan_aligned_response</code></p>","title":"function iox_server_loan_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_loan_aligned_response","text":"<pre><code>ENUM iox_AllocationResult iox_server_loan_aligned_response(\n    iox_server_t const self,\n    const void *const requestPayload,\n    void **const payload,\n    const uint32_t payloadSize,\n    const uint32_t payloadAlignment\n)\n</code></pre> <p>allocates a response in the shared memory </p> <p>Parameters: </p> <ul> <li>self handle of the server </li> <li>requestPayload pointer to the payload of the received request </li> <li>payload pointer in which a pointer to the user-payload of the allocated chunk is stored </li> <li>payloadSize user-payload size of the allocated request </li> <li>payloadAlignment user-payload alignment of the allocated request </li> </ul> <p>Return: on success it returns AllocationResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_server_loan_aligned_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_send","text":"<pre><code>ENUM iox_ServerSendResult iox_server_send(\n    iox_server_t const self,\n    void *const payload\n)\n</code></pre> <p>sends a previously loaned response </p> <p>Parameters: </p> <ul> <li>self handle of the server </li> <li>payload pointer to the user-payload of the response which should be send </li> </ul> <p>Return: on success it returns ServerSendResult_SUCCESS otherwise a value which describes the error </p>","title":"function iox_server_send"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_response","text":"<pre><code>void iox_server_release_response(\n    iox_server_t const self,\n    void *const payload\n)\n</code></pre> <p>releases ownership of a previously allocated loaned response without sending it </p> <p>Parameters: </p> <ul> <li>self handle of the server </li> <li>payload pointer to the user-payload of the loaned request which should be free'd </li> </ul>","title":"function iox_server_release_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_get_service_description","text":"<pre><code>iox_service_description_t iox_server_get_service_description(\n    iox_server_t const self\n)\n</code></pre> <p>returns the service description of the server </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul> <p>Return: the service description </p>","title":"function iox_server_get_service_description"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_offer","text":"<pre><code>void iox_server_offer(\n    iox_server_t const self\n)\n</code></pre> <p>offers the servers service </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul>","title":"function iox_server_offer"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_stop_offer","text":"<pre><code>void iox_server_stop_offer(\n    iox_server_t const self\n)\n</code></pre> <p>stops offering the servers service </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul>","title":"function iox_server_stop_offer"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_is_offered","text":"<pre><code>bool iox_server_is_offered(\n    iox_server_t const self\n)\n</code></pre> <p>is the server currently offering? </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul> <p>Return: true if the server is offering, otherwise false </p>","title":"function iox_server_is_offered"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_clients","text":"<pre><code>bool iox_server_has_clients(\n    iox_server_t const self\n)\n</code></pre> <p>are clients connected to the server? </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul> <p>Return: true if the server has connected clients, otherwise false </p>","title":"function iox_server_has_clients"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_requests","text":"<pre><code>bool iox_server_has_requests(\n    iox_server_t const self\n)\n</code></pre> <p>are requests from clients available? </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul> <p>Return: true if the requests are available to take, otherwise false </p>","title":"function iox_server_has_requests"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_missed_requests","text":"<pre><code>bool iox_server_has_missed_requests(\n    iox_server_t const self\n)\n</code></pre> <p>were requests missed? </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul> <p>Return: true if there are lost requests due to overflowing queue, otherwise false </p>","title":"function iox_server_has_missed_requests"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_queued_requests","text":"<pre><code>void iox_server_release_queued_requests(\n    iox_server_t const self\n)\n</code></pre> <p>release a previously acquired request (via iox_server_take_request) </p> <p>Parameters: </p> <ul> <li>self handle to the server </li> </ul>","title":"function iox_server_release_queued_requests"},{"location":"API-reference/c-binding/Files/server_8h/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_SERVER_H\n#define IOX_BINDING_C_SERVER_H\n\n#include \"iceoryx_binding_c/config.h\"\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/service_description.h\"\n#include \"iceoryx_binding_c/types.h\"\n\ntypedef CLASS UntypedServer* iox_server_t;\n\ntypedef struct\n{\n    uint64_t requestQueueCapacity;\n\n    char nodeName[IOX_CONFIG_NODE_NAME_SIZE];\n\n    bool offerOnCreate;\n\n    ENUM iox_QueueFullPolicy requestQueueFullPolicy;\n\n    ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy;\n\n    uint64_t initCheck;\n} iox_server_options_t;\n\nvoid iox_server_options_init(iox_server_options_t* const options);\n\nbool iox_server_options_is_initialized(const iox_server_options_t* const options);\n\niox_server_t iox_server_init(iox_server_storage_t* self,\n                             const char* const service,\n                             const char* const instance,\n                             const char* const event,\n                             const iox_server_options_t* const options);\n\nvoid iox_server_deinit(iox_server_t const self);\n\nENUM iox_ServerRequestResult iox_server_take_request(iox_server_t const self, const void** const payload);\n\nvoid iox_server_release_request(iox_server_t const self, const void* const payload);\n\nENUM iox_AllocationResult iox_server_loan_response(iox_server_t const self,\n                                                   const void* const requestPayload,\n                                                   void** const payload,\n                                                   const uint32_t payloadSize);\n\nENUM iox_AllocationResult iox_server_loan_aligned_response(iox_server_t const self,\n                                                           const void* const requestPayload,\n                                                           void** const payload,\n                                                           const uint32_t payloadSize,\n                                                           const uint32_t payloadAlignment);\n\nENUM iox_ServerSendResult iox_server_send(iox_server_t const self, void* const payload);\n\nvoid iox_server_release_response(iox_server_t const self, void* const payload);\n\niox_service_description_t iox_server_get_service_description(iox_server_t const self);\n\nvoid iox_server_offer(iox_server_t const self);\n\nvoid iox_server_stop_offer(iox_server_t const self);\n\nbool iox_server_is_offered(iox_server_t const self);\n\nbool iox_server_has_clients(iox_server_t const self);\n\nbool iox_server_has_requests(iox_server_t const self);\n\nbool iox_server_has_missed_requests(iox_server_t const self);\n\nvoid iox_server_release_queued_requests(iox_server_t const self);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/service__description_8h/","text":"","title":"iceoryx_binding_c/service_description.h"},{"location":"API-reference/c-binding/Files/service__description_8h/#classes","text":"Name     struct iox_service_description_t","title":"Classes"},{"location":"API-reference/c-binding/Files/service__description_8h/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_SERVICE_DESCRIPTION_H\n#define IOX_BINDING_C_SERVICE_DESCRIPTION_H\n\n#include \"iceoryx_binding_c/config.h\"\n\n#include &lt;stdint.h&gt;\n\ntypedef struct\n{\n    char serviceString[IOX_CONFIG_SERVICE_STRING_SIZE];\n    char instanceString[IOX_CONFIG_SERVICE_STRING_SIZE];\n    char eventString[IOX_CONFIG_SERVICE_STRING_SIZE];\n} iox_service_description_t;\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/service__discovery_8h/","text":"","title":"iceoryx_binding_c/service_discovery.h"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#types","text":"Name     typedef CLASS ServiceDiscovery * iox_service_discovery_t service discovery handle","title":"Types"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#functions","text":"Name     iox_service_discovery_t iox_service_discovery_init(iox_service_discovery_storage_t * self)initializes a service discovery from a storage struct pointer   void iox_service_discovery_deinit(iox_service_discovery_t const self)after using an iox_service_discovery_t it must be cleaned up with this function   uint64_t iox_service_discovery_find_service(iox_service_discovery_t const self, const char const service, const char const instance, const char const event, iox_service_description_t const serviceContainer, const uint64_t serviceContainerCapacity, uint64_t * missedServices, const ENUM iox_MessagingPattern pattern)Searches all services with the given messaging pattern that match the provided service description.   void iox_service_discovery_find_service_apply_callable(iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void()(const iox_service_description_t) callable, const ENUM iox_MessagingPattern pattern)Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them.   void iox_service_discovery_find_service_apply_callable_with_context_data(iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void()(const iox_service_description_t, void ) callable, void const contextData, const ENUM iox_MessagingPattern pattern)Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData.","title":"Functions"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#typedef-iox_service_discovery_t","text":"<pre><code>typedef CLASS ServiceDiscovery* iox_service_discovery_t;\n</code></pre> <p>service discovery handle </p>","title":"typedef iox_service_discovery_t"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_init","text":"<pre><code>iox_service_discovery_t iox_service_discovery_init(\n    iox_service_discovery_storage_t * self\n)\n</code></pre> <p>initializes a service discovery from a storage struct pointer </p> <p>Parameters: </p> <ul> <li>self pointer to raw memory which can hold a service discovery </li> </ul> <p>Return: an initialized iox_service_discovery_t </p>","title":"function iox_service_discovery_init"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_deinit","text":"<pre><code>void iox_service_discovery_deinit(\n    iox_service_discovery_t const self\n)\n</code></pre> <p>after using an iox_service_discovery_t it must be cleaned up with this function </p> <p>Parameters: </p> <ul> <li>self the service discovery which should be deinitialized </li> </ul>","title":"function iox_service_discovery_deinit"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service","text":"<pre><code>uint64_t iox_service_discovery_find_service(\n    iox_service_discovery_t const self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    iox_service_description_t *const serviceContainer,\n    const uint64_t serviceContainerCapacity,\n    uint64_t * missedServices,\n    const ENUM iox_MessagingPattern pattern\n)\n</code></pre> <p>Searches all services with the given messaging pattern that match the provided service description. </p> <p>Parameters: </p> <ul> <li>self handle of the service discovery </li> <li>service service string to search for, a nullptr corresponds to a wildcard </li> <li>instance instance string to search for, a nullptr corresponds to a wildcard </li> <li>event event string to search for, a nullptr corresponds to a wildcard </li> <li>serviceContainer preallocated memory to an array of iox_service_description_t in which the matching services can be written </li> <li>serviceContainerCapacity the capacity of the preallocated serviceContainer </li> <li>missedServices if the serviceContainer has insufficient size the number of missed services which could not be written into the serviceContainer are stored here </li> <li>pattern messaging pattern of the service to search </li> </ul> <p>Return: the number of services which were written into the serviceContainer </p>","title":"function iox_service_discovery_find_service"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service_apply_callable","text":"<pre><code>void iox_service_discovery_find_service_apply_callable(\n    iox_service_discovery_t const self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    void(*)(const iox_service_description_t) callable,\n    const ENUM iox_MessagingPattern pattern\n)\n</code></pre> <p>Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. </p> <p>Parameters: </p> <ul> <li>self handle of the service discovery </li> <li>service service string to search for, a nullptr corresponds to a wildcard </li> <li>instance instance string to search for, a nullptr corresponds to a wildcard </li> <li>event event string to search for, a nullptr corresponds to a wildcard </li> <li>callable to apply to all matching services </li> <li>pattern messaging pattern of the service to search </li> </ul>","title":"function iox_service_discovery_find_service_apply_callable"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service_apply_callable_with_context_data","text":"<pre><code>void iox_service_discovery_find_service_apply_callable_with_context_data(\n    iox_service_discovery_t const self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    void(*)(const iox_service_description_t, void *) callable,\n    void *const contextData,\n    const ENUM iox_MessagingPattern pattern\n)\n</code></pre> <p>Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData. </p> <p>Parameters: </p> <ul> <li>self handle of the service discovery </li> <li>service service string to search for, a nullptr corresponds to a wildcard </li> <li>instance instance string to search for, a nullptr corresponds to a wildcard </li> <li>event event string to search for, a nullptr corresponds to a wildcard </li> <li>callable to apply to all matching services </li> <li>contextData a void pointer which is provided as second argument to the callback </li> <li>pattern messaging pattern of the service to search </li> </ul>","title":"function iox_service_discovery_find_service_apply_callable_with_context_data"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_SERVICE_DISCOVERY_H\n#define IOX_BINDING_C_SERVICE_DISCOVERY_H\n\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/types.h\"\n#include \"service_description.h\"\n\ntypedef CLASS ServiceDiscovery* iox_service_discovery_t;\n\niox_service_discovery_t iox_service_discovery_init(iox_service_discovery_storage_t* self);\n\nvoid iox_service_discovery_deinit(iox_service_discovery_t const self);\n\nuint64_t iox_service_discovery_find_service(iox_service_discovery_t const self,\n                                            const char* const service,\n                                            const char* const instance,\n                                            const char* const event,\n                                            iox_service_description_t* const serviceContainer,\n                                            const uint64_t serviceContainerCapacity,\n                                            uint64_t* missedServices,\n                                            const ENUM iox_MessagingPattern pattern);\n\nvoid iox_service_discovery_find_service_apply_callable(iox_service_discovery_t const self,\n                                                       const char* const service,\n                                                       const char* const instance,\n                                                       const char* const event,\n                                                       void (*callable)(const iox_service_description_t),\n                                                       const ENUM iox_MessagingPattern pattern);\n\nvoid iox_service_discovery_find_service_apply_callable_with_context_data(\n    iox_service_discovery_t const self,\n    const char* const service,\n    const char* const instance,\n    const char* const event,\n    void (*callable)(const iox_service_description_t, void*),\n    void* const contextData,\n    const ENUM iox_MessagingPattern pattern);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/subscriber_8h/","text":"","title":"iceoryx_binding_c/subscriber.h"},{"location":"API-reference/c-binding/Files/subscriber_8h/#classes","text":"Name     struct iox_sub_options_t options to be set for a subscriber","title":"Classes"},{"location":"API-reference/c-binding/Files/subscriber_8h/#types","text":"Name     typedef struct cpp2c_Subscriber * iox_sub_t Subscriber handle.","title":"Types"},{"location":"API-reference/c-binding/Files/subscriber_8h/#functions","text":"Name     void iox_sub_options_init(iox_sub_options_t *const options)initialize subscriber options to default values   bool iox_sub_options_is_initialized(const iox_sub_options_t *const options)check whether the subscriber options were initialized by iox_sub_options_init   iox_sub_t iox_sub_init(iox_sub_storage_t * self, const char const service, const char const instance, const char const event, const iox_sub_options_t const options)initialize subscriber handle   void iox_sub_deinit(iox_sub_t const self)deinitialize a subscriber handle   void iox_sub_subscribe(iox_sub_t const self)subscribes to the service   void iox_sub_unsubscribe(iox_sub_t const self)unsubscribes from a service   ENUM iox_SubscribeState iox_sub_get_subscription_state(iox_sub_t const self)what is the subscription state?   ENUM iox_ChunkReceiveResult iox_sub_take_chunk(iox_sub_t const self, const void **const userPayload)retrieve a received chunk   void iox_sub_release_chunk(iox_sub_t const self, const void *const userPayload)release a previously acquired chunk (via iox_sub_take_chunk)   void iox_sub_release_queued_chunks(iox_sub_t const self)release all chunks which are stored in the chunk queue   bool iox_sub_has_chunks(iox_sub_t const self)are new chunks available?   bool iox_sub_has_lost_chunks(iox_sub_t const self)are chunks lost?   iox_service_description_t iox_sub_get_service_description(iox_sub_t const self)returns the service description of the subscriber","title":"Functions"},{"location":"API-reference/c-binding/Files/subscriber_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/subscriber_8h/#typedef-iox_sub_t","text":"<pre><code>typedef struct cpp2c_Subscriber* iox_sub_t;\n</code></pre> <p>Subscriber handle. </p>","title":"typedef iox_sub_t"},{"location":"API-reference/c-binding/Files/subscriber_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_options_init","text":"<pre><code>void iox_sub_options_init(\n    iox_sub_options_t *const options\n)\n</code></pre> <p>initialize subscriber options to default values </p> <p>Parameters: </p> <ul> <li>options pointer to options to be initialized, emit warning if it is a null pointer </li> </ul> <p>Attention: This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. </p>","title":"function iox_sub_options_init"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_options_is_initialized","text":"<pre><code>bool iox_sub_options_is_initialized(\n    const iox_sub_options_t *const options\n)\n</code></pre> <p>check whether the subscriber options were initialized by iox_sub_options_init </p> <p>Parameters: </p> <ul> <li>options pointer to options to be checked </li> </ul> <p>Return: true if options are not null and were initialized, false otherwise </p>","title":"function iox_sub_options_is_initialized"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_init","text":"<pre><code>iox_sub_t iox_sub_init(\n    iox_sub_storage_t * self,\n    const char *const service,\n    const char *const instance,\n    const char *const event,\n    const iox_sub_options_t *const options\n)\n</code></pre> <p>initialize subscriber handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_sub_storage_t) </li> <li>service serviceString </li> <li>instance instanceString </li> <li>event eventString </li> <li>options subscriber options set by the user, if it is a null pointer default options are used </li> </ul> <p>Return: handle of the subscriber </p>","title":"function iox_sub_init"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_deinit","text":"<pre><code>void iox_sub_deinit(\n    iox_sub_t const self\n)\n</code></pre> <p>deinitialize a subscriber handle </p> <p>Parameters: </p> <ul> <li>self the handle which should be removed </li> </ul>","title":"function iox_sub_deinit"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_subscribe","text":"<pre><code>void iox_sub_subscribe(\n    iox_sub_t const self\n)\n</code></pre> <p>subscribes to the service </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul>","title":"function iox_sub_subscribe"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_unsubscribe","text":"<pre><code>void iox_sub_unsubscribe(\n    iox_sub_t const self\n)\n</code></pre> <p>unsubscribes from a service </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul>","title":"function iox_sub_unsubscribe"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_get_subscription_state","text":"<pre><code>ENUM iox_SubscribeState iox_sub_get_subscription_state(\n    iox_sub_t const self\n)\n</code></pre> <p>what is the subscription state? </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul> <p>Return: SubscribeState_SUBSCRIBED when successfully subscribed otherwise an enum which describes the current state </p>","title":"function iox_sub_get_subscription_state"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_take_chunk","text":"<pre><code>ENUM iox_ChunkReceiveResult iox_sub_take_chunk(\n    iox_sub_t const self,\n    const void **const userPayload\n)\n</code></pre> <p>retrieve a received chunk </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> <li>userPayload pointer in which the pointer to the user-payload of the chunk is stored </li> </ul> <p>Return: if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error </p>","title":"function iox_sub_take_chunk"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_release_chunk","text":"<pre><code>void iox_sub_release_chunk(\n    iox_sub_t const self,\n    const void *const userPayload\n)\n</code></pre> <p>release a previously acquired chunk (via iox_sub_take_chunk) </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> <li>userPayload pointer to the user-payload of chunk which should be released </li> </ul>","title":"function iox_sub_release_chunk"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_release_queued_chunks","text":"<pre><code>void iox_sub_release_queued_chunks(\n    iox_sub_t const self\n)\n</code></pre> <p>release all chunks which are stored in the chunk queue </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul>","title":"function iox_sub_release_queued_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_has_chunks","text":"<pre><code>bool iox_sub_has_chunks(\n    iox_sub_t const self\n)\n</code></pre> <p>are new chunks available? </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul> <p>Return: true if there are chunks, otherwise false </p>","title":"function iox_sub_has_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_has_lost_chunks","text":"<pre><code>bool iox_sub_has_lost_chunks(\n    iox_sub_t const self\n)\n</code></pre> <p>are chunks lost? </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul> <p>Return: true if there are lost chunks due to overflowing queue, otherwise false </p>","title":"function iox_sub_has_lost_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_get_service_description","text":"<pre><code>iox_service_description_t iox_sub_get_service_description(\n    iox_sub_t const self\n)\n</code></pre> <p>returns the service description of the subscriber </p> <p>Parameters: </p> <ul> <li>self handle to the subscriber </li> </ul> <p>Return: the service description </p>","title":"function iox_sub_get_service_description"},{"location":"API-reference/c-binding/Files/subscriber_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_SUBSCRIBER_H\n#define IOX_BINDING_C_SUBSCRIBER_H\n\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/service_description.h\"\n#include \"iceoryx_binding_c/types.h\"\n\ntypedef struct cpp2c_Subscriber* iox_sub_t;\n\ntypedef struct\n{\n    uint64_t queueCapacity;\n\n    uint64_t historyRequest;\n\n    const char* nodeName;\n\n    bool subscribeOnCreate;\n\n    ENUM iox_QueueFullPolicy queueFullPolicy;\n\n    bool requirePublisherHistorySupport;\n\n    uint64_t initCheck;\n} iox_sub_options_t;\n\nvoid iox_sub_options_init(iox_sub_options_t* const options);\n\nbool iox_sub_options_is_initialized(const iox_sub_options_t* const options);\n\niox_sub_t iox_sub_init(iox_sub_storage_t* self,\n                       const char* const service,\n                       const char* const instance,\n                       const char* const event,\n                       const iox_sub_options_t* const options);\n\nvoid iox_sub_deinit(iox_sub_t const self);\n\nvoid iox_sub_subscribe(iox_sub_t const self);\n\nvoid iox_sub_unsubscribe(iox_sub_t const self);\n\nENUM iox_SubscribeState iox_sub_get_subscription_state(iox_sub_t const self);\n\nENUM iox_ChunkReceiveResult iox_sub_take_chunk(iox_sub_t const self, const void** const userPayload);\n\nvoid iox_sub_release_chunk(iox_sub_t const self, const void* const userPayload);\n\nvoid iox_sub_release_queued_chunks(iox_sub_t const self);\n\nbool iox_sub_has_chunks(iox_sub_t const self);\n\nbool iox_sub_has_lost_chunks(iox_sub_t const self);\n\niox_service_description_t iox_sub_get_service_description(iox_sub_t const self);\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/types_8h/","text":"","title":"iceoryx_binding_c/types.h"},{"location":"API-reference/c-binding/Files/types_8h/#classes","text":"Name     struct iox_ws_storage_t   struct iox_user_trigger_storage_t   struct iox_sub_storage_t   struct iox_pub_storage_t   struct iox_listener_storage_t   struct iox_chunk_header_t handle of the chunk header   struct iox_client_storage_t has exactly the size required to store the underlying object of iox_client_t   struct iox_server_storage_t has exactly the size required to store the underlying object of iox_server_t   struct iox_service_discovery_storage_t has exactly the size required to store the underlying object of iox_service_discovery_t","title":"Classes"},{"location":"API-reference/c-binding/Files/types_8h/#defines","text":"Name      IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT    IOX_C_CHUNK_NO_USER_HEADER_SIZE    IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT","title":"Defines"},{"location":"API-reference/c-binding/Files/types_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_default_user_payload_alignment","text":"<pre><code>#define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8\n</code></pre>","title":"define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_no_user_header_size","text":"<pre><code>#define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0\n</code></pre>","title":"define IOX_C_CHUNK_NO_USER_HEADER_SIZE"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_no_user_header_alignment","text":"<pre><code>#define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1\n</code></pre>","title":"define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT"},{"location":"API-reference/c-binding/Files/types_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_TYPES_H\n#define IOX_BINDING_C_TYPES_H\n\n#include \"internal/c2cpp_binding.h\"\n\n#define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8\n#define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0\n#define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1\n\n\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_ws_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_user_trigger_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_sub_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_pub_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_listener_storage_t;\n\ntypedef struct\n{\n    // could be empty but then we get `struct has no members` warning\n    uint8_t do_not_touch_me[1];\n} iox_chunk_header_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_client_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_server_storage_t;\n\ntypedef struct\n{\n    // only size for pointer is necessary\n    uint64_t do_not_touch_me[1];\n} iox_service_discovery_storage_t;\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/user__trigger_8h/","text":"","title":"iceoryx_binding_c/user_trigger.h"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#types","text":"Name     typedef CLASS UserTrigger * iox_user_trigger_t user trigger handle","title":"Types"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#functions","text":"Name     iox_user_trigger_t iox_user_trigger_init(iox_user_trigger_storage_t * self)initialize user trigger handle   void iox_user_trigger_deinit(iox_user_trigger_t const self)deinitialize user trigger handle   void iox_user_trigger_trigger(iox_user_trigger_t const self)trigger a user trigger   bool iox_user_trigger_has_triggered(iox_user_trigger_t const self)was the user trigger triggered","title":"Functions"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#typedef-iox_user_trigger_t","text":"<pre><code>typedef CLASS UserTrigger* iox_user_trigger_t;\n</code></pre> <p>user trigger handle </p>","title":"typedef iox_user_trigger_t"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_init","text":"<pre><code>iox_user_trigger_t iox_user_trigger_init(\n    iox_user_trigger_storage_t * self\n)\n</code></pre> <p>initialize user trigger handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_user_trigger_storage_t) </li> </ul> <p>Return: handle to user trigger </p>","title":"function iox_user_trigger_init"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_deinit","text":"<pre><code>void iox_user_trigger_deinit(\n    iox_user_trigger_t const self\n)\n</code></pre> <p>deinitialize user trigger handle </p> <p>Parameters: </p> <ul> <li>self handle to user trigger </li> </ul>","title":"function iox_user_trigger_deinit"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_trigger","text":"<pre><code>void iox_user_trigger_trigger(\n    iox_user_trigger_t const self\n)\n</code></pre> <p>trigger a user trigger </p> <p>Parameters: </p> <ul> <li>self handle to user trigger </li> </ul> <p>Note: a user trigger cannot be triggered when it is not attached </p>","title":"function iox_user_trigger_trigger"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_has_triggered","text":"<pre><code>bool iox_user_trigger_has_triggered(\n    iox_user_trigger_t const self\n)\n</code></pre> <p>was the user trigger triggered </p> <p>Parameters: </p> <ul> <li>self handle to user trigger </li> </ul> <p>Return: returns true if the user trigger was triggered, otherwise false </p> <p>Note: The hasTrigger state will be reset after it was handled by a WaitSet/Listener </p>","title":"function iox_user_trigger_has_triggered"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_USER_TRIGGER_H\n#define IOX_BINDING_C_USER_TRIGGER_H\n\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/types.h\"\n\ntypedef CLASS UserTrigger* iox_user_trigger_t;\n\niox_user_trigger_t iox_user_trigger_init(iox_user_trigger_storage_t* self);\n\nvoid iox_user_trigger_deinit(iox_user_trigger_t const self);\n\nvoid iox_user_trigger_trigger(iox_user_trigger_t const self);\n\nbool iox_user_trigger_has_triggered(iox_user_trigger_t const self);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/c-binding/Files/wait__set_8h/","text":"","title":"iceoryx_binding_c/wait_set.h"},{"location":"API-reference/c-binding/Files/wait__set_8h/#types","text":"Name     typedef CLASS cpp2c_WaitSet * iox_ws_t wait set handle","title":"Types"},{"location":"API-reference/c-binding/Files/wait__set_8h/#functions","text":"Name     iox_ws_t iox_ws_init(iox_ws_storage_t * self)initialize wait set handle   void iox_ws_deinit(iox_ws_t const self)deinitialize wait set handle   uint64_t iox_ws_timed_wait(iox_ws_t const self, struct timespec timeout, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements)waits until an event occurred or the timeout was reached   uint64_t iox_ws_wait(iox_ws_t const self, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements)waits until an event occurred   uint64_t iox_ws_size(iox_ws_t const self)returns the number of registered events/states   uint64_t iox_ws_capacity(iox_ws_t const self)returns the maximum amount of events/states which can be registered at the waitset   void iox_ws_mark_for_destruction(iox_ws_t const self)Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait().   ENUM iox_WaitSetResult iox_ws_attach_subscriber_state(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void(*)(iox_sub_t) callback)attaches a subscriber state to a waitset   ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void()(iox_sub_t, void ) callback, void *const contextData)attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data.   ENUM iox_WaitSetResult iox_ws_attach_subscriber_event(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void(*)(iox_sub_t) callback)attaches a subscriber event to a waitset   ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void()(iox_sub_t, void ) callback, void *const contextData)attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data.   ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event(iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void(*)(iox_user_trigger_t) callback)attaches a user trigger event to a waitset   ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data(iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void()(iox_user_trigger_t, void ) callback, void *const contextData)attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data.   void iox_ws_detach_subscriber_event(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent)detaches a subscriber event from a waitset   void iox_ws_detach_subscriber_state(iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState)detaches a subscriber state from a waitset   void iox_ws_detach_user_trigger_event(iox_ws_t const self, iox_user_trigger_t const userTrigger)detaches a user trigger event from a waitset   ENUM iox_WaitSetResult iox_ws_attach_client_event(const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void(*)(iox_client_t) callback)attaches a client event to a waitset   ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void()(iox_client_t, void ) callback, void *const contextData)attaches a client event to a waitset with additional context data for the callback   ENUM iox_WaitSetResult iox_ws_attach_client_state(const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientState clientState, const uint64_t eventId, void(*)(iox_client_t) callback)attaches a client state to a waitset   ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState, const uint64_t eventId, void()(iox_client_t, void ) callback, void *const contextData)attaches a client state to a waitset with additional context data for the callback   void iox_ws_detach_client_event(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent)detaches a client event from a waitset   void iox_ws_detach_client_state(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState)detaches a client state from a waitset   ENUM iox_WaitSetResult iox_ws_attach_server_event(const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void(*)(iox_server_t) callback)attaches a server event to a waitset   ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void()(iox_server_t, void ) callback, void *const contextData)attaches a server event to a waitset with additional context data for the callback   ENUM iox_WaitSetResult iox_ws_attach_server_state(const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerState serverState, const uint64_t eventId, void(*)(iox_server_t) callback)attaches a server state to a waitset   ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState, const uint64_t eventId, void()(iox_server_t, void ) callback, void *const contextData)attaches a server state to a waitset with additional context data for the callback   void iox_ws_detach_server_event(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent)detaches a server event from a waitset   void iox_ws_detach_server_state(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState)detaches a server state from a waitset   ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event(const iox_ws_t self, const iox_service_discovery_t serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void(*)(iox_service_discovery_t) callback)attaches a service discovery event to a waitset   ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data(iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void()(iox_service_discovery_t, void ) callback, void *const contextData)attaches a service discovery event to a waitset with additional context data for the callback   void iox_ws_detach_service_discovery_event(iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent)detaches a service discovery event from a waitset","title":"Functions"},{"location":"API-reference/c-binding/Files/wait__set_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/wait__set_8h/#typedef-iox_ws_t","text":"<pre><code>typedef CLASS cpp2c_WaitSet* iox_ws_t;\n</code></pre> <p>wait set handle </p>","title":"typedef iox_ws_t"},{"location":"API-reference/c-binding/Files/wait__set_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_init","text":"<pre><code>iox_ws_t iox_ws_init(\n    iox_ws_storage_t * self\n)\n</code></pre> <p>initialize wait set handle </p> <p>Parameters: </p> <ul> <li>self pointer to preallocated memory of size = sizeof(iox_ws_storage_t) </li> </ul> <p>Return: handle to wait set </p>","title":"function iox_ws_init"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_deinit","text":"<pre><code>void iox_ws_deinit(\n    iox_ws_t const self\n)\n</code></pre> <p>deinitialize wait set handle </p> <p>Parameters: </p> <ul> <li>self the handle which should be deinitialized </li> </ul>","title":"function iox_ws_deinit"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_timed_wait","text":"<pre><code>uint64_t iox_ws_timed_wait(\n    iox_ws_t const self,\n    struct timespec timeout,\n    iox_notification_info_t *const notificationInfoArray,\n    const uint64_t notificationInfoArrayCapacity,\n    uint64_t * missedElements\n)\n</code></pre> <p>waits until an event occurred or the timeout was reached </p> <p>Parameters: </p> <ul> <li>self handle to the wait set </li> <li>timeout duration how long this method should wait </li> <li>notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to </li> <li>notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray </li> <li>missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here </li> </ul> <p>Return: number of elements which were written into the notificationInfoArray </p>","title":"function iox_ws_timed_wait"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_wait","text":"<pre><code>uint64_t iox_ws_wait(\n    iox_ws_t const self,\n    iox_notification_info_t *const notificationInfoArray,\n    const uint64_t notificationInfoArrayCapacity,\n    uint64_t * missedElements\n)\n</code></pre> <p>waits until an event occurred </p> <p>Parameters: </p> <ul> <li>self handle to the wait set </li> <li>notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to </li> <li>notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray </li> <li>missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here </li> </ul> <p>Return: number of elements which were written into the notificationInfoArray </p>","title":"function iox_ws_wait"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_size","text":"<pre><code>uint64_t iox_ws_size(\n    iox_ws_t const self\n)\n</code></pre> <p>returns the number of registered events/states </p>","title":"function iox_ws_size"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_capacity","text":"<pre><code>uint64_t iox_ws_capacity(\n    iox_ws_t const self\n)\n</code></pre> <p>returns the maximum amount of events/states which can be registered at the waitset </p>","title":"function iox_ws_capacity"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_mark_for_destruction","text":"<pre><code>void iox_ws_mark_for_destruction(\n    iox_ws_t const self\n)\n</code></pre> <p>Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait(). </p>","title":"function iox_ws_mark_for_destruction"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_state","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_subscriber_state(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberState subscriberState,\n    const uint64_t id,\n    void(*)(iox_sub_t) callback\n)\n</code></pre> <p>attaches a subscriber state to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber of the state which should be attached </li> <li>subscriberState the state which should be attached </li> <li>id an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_subscriber_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_state_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberState subscriberState,\n    const uint64_t id,\n    void(*)(iox_sub_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber of the state which should be attached </li> <li>subscriberState the state which should be attached </li> <li>id an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_subscriber_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_event","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_subscriber_event(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent,\n    const uint64_t eventId,\n    void(*)(iox_sub_t) callback\n)\n</code></pre> <p>attaches a subscriber event to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber of the event which should be attached </li> <li>subscriberEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_subscriber_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_event_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent,\n    const uint64_t eventId,\n    void(*)(iox_sub_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber of the event which should be attached </li> <li>subscriberEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_subscriber_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_user_trigger_event","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event(\n    iox_ws_t const self,\n    iox_user_trigger_t const userTrigger,\n    const uint64_t eventId,\n    void(*)(iox_user_trigger_t) callback\n)\n</code></pre> <p>attaches a user trigger event to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>userTrigger the user trigger of the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_user_trigger_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_user_trigger_event_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data(\n    iox_ws_t const self,\n    iox_user_trigger_t const userTrigger,\n    const uint64_t eventId,\n    void(*)(iox_user_trigger_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data. </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>userTrigger the user trigger of the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_user_trigger_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_subscriber_event","text":"<pre><code>void iox_ws_detach_subscriber_event(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberEvent subscriberEvent\n)\n</code></pre> <p>detaches a subscriber event from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber from which the event should be detached </li> <li>subscriberEvent the event which should be detached from the subscriber </li> </ul>","title":"function iox_ws_detach_subscriber_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_subscriber_state","text":"<pre><code>void iox_ws_detach_subscriber_state(\n    iox_ws_t const self,\n    iox_sub_t const subscriber,\n    const ENUM iox_SubscriberState subscriberState\n)\n</code></pre> <p>detaches a subscriber state from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>subscriber the subscriber from which the state should be detached </li> <li>subscriberState the state which should be detached from the subscriber </li> </ul>","title":"function iox_ws_detach_subscriber_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_user_trigger_event","text":"<pre><code>void iox_ws_detach_user_trigger_event(\n    iox_ws_t const self,\n    iox_user_trigger_t const userTrigger\n)\n</code></pre> <p>detaches a user trigger event from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>usertrigger the user trigger which should be detached </li> </ul>","title":"function iox_ws_detach_user_trigger_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_event","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_client_event(\n    const iox_ws_t self,\n    const iox_client_t client,\n    const ENUM iox_ClientEvent clientEvent,\n    const uint64_t eventId,\n    void(*)(iox_client_t) callback\n)\n</code></pre> <p>attaches a client event to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client of the event which should be attached </li> <li>clientEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_client_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_event_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data(\n    iox_ws_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientEvent clientEvent,\n    const uint64_t eventId,\n    void(*)(iox_client_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a client event to a waitset with additional context data for the callback </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client of the event which should be attached </li> <li>clientEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_client_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_state","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_client_state(\n    const iox_ws_t self,\n    const iox_client_t client,\n    const ENUM iox_ClientState clientState,\n    const uint64_t eventId,\n    void(*)(iox_client_t) callback\n)\n</code></pre> <p>attaches a client state to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client of the state which should be attached </li> <li>clientState the state which should be attached </li> <li>eventId an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_client_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_state_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data(\n    iox_ws_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientState clientState,\n    const uint64_t eventId,\n    void(*)(iox_client_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a client state to a waitset with additional context data for the callback </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client of the state which should be attached </li> <li>clientState the state which should be attached </li> <li>eventId an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_client_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_client_event","text":"<pre><code>void iox_ws_detach_client_event(\n    iox_ws_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientEvent clientEvent\n)\n</code></pre> <p>detaches a client event from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client which should be detached </li> <li>clientEvent the event which should be detached from the client </li> </ul>","title":"function iox_ws_detach_client_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_client_state","text":"<pre><code>void iox_ws_detach_client_state(\n    iox_ws_t const self,\n    iox_client_t const client,\n    const ENUM iox_ClientState clientState\n)\n</code></pre> <p>detaches a client state from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>client the client which should be detached </li> <li>clientState the state which should be detached from the client </li> </ul>","title":"function iox_ws_detach_client_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_event","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_server_event(\n    const iox_ws_t self,\n    const iox_server_t server,\n    const ENUM iox_ServerEvent serverEvent,\n    const uint64_t eventId,\n    void(*)(iox_server_t) callback\n)\n</code></pre> <p>attaches a server event to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server of the event which should be attached </li> <li>serverEvent the server which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_server_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_event_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data(\n    iox_ws_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerEvent serverEvent,\n    const uint64_t eventId,\n    void(*)(iox_server_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a server event to a waitset with additional context data for the callback </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server of the event which should be attached </li> <li>serverEvent the server which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_server_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_state","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_server_state(\n    const iox_ws_t self,\n    const iox_server_t server,\n    const ENUM iox_ServerState serverState,\n    const uint64_t eventId,\n    void(*)(iox_server_t) callback\n)\n</code></pre> <p>attaches a server state to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server of the state which should be attached </li> <li>serverState the state which should be attached </li> <li>eventId an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_server_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_state_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data(\n    iox_ws_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerState serverState,\n    const uint64_t eventId,\n    void(*)(iox_server_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a server state to a waitset with additional context data for the callback </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server of the state which should be attached </li> <li>serverState the state which should be attached </li> <li>eventId an arbitrary id which will be tagged to the state </li> <li>callback a callback which is attached to the state </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_server_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_server_event","text":"<pre><code>void iox_ws_detach_server_event(\n    iox_ws_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerEvent serverEvent\n)\n</code></pre> <p>detaches a server event from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server which should be detached </li> <li>serverEvent the event which should be detached from the server </li> </ul>","title":"function iox_ws_detach_server_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_server_state","text":"<pre><code>void iox_ws_detach_server_state(\n    iox_ws_t const self,\n    iox_server_t const server,\n    const ENUM iox_ServerState serverState\n)\n</code></pre> <p>detaches a server state from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>server the server which should be detached </li> <li>serverState the state which should be detached from the server </li> </ul>","title":"function iox_ws_detach_server_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_service_discovery_event","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event(\n    const iox_ws_t self,\n    const iox_service_discovery_t serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n    const uint64_t eventId,\n    void(*)(iox_service_discovery_t) callback\n)\n</code></pre> <p>attaches a service discovery event to a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>serviceDiscovery service discovery which emits the event </li> <li>serviceDiscoveryEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_service_discovery_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_service_discovery_event_with_context_data","text":"<pre><code>ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data(\n    iox_ws_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n    const uint64_t eventId,\n    void(*)(iox_service_discovery_t, void *) callback,\n    void *const contextData\n)\n</code></pre> <p>attaches a service discovery event to a waitset with additional context data for the callback </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>serviceDiscovery service discovery which emits the event </li> <li>serviceDiscoveryEvent the event which should be attached </li> <li>eventId an arbitrary id which will be tagged to the event </li> <li>callback a callback which is attached to the event </li> <li>contextData a void pointer which is provided as second argument to the callback </li> </ul> <p>Return: if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error </p>","title":"function iox_ws_attach_service_discovery_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_service_discovery_event","text":"<pre><code>void iox_ws_detach_service_discovery_event(\n    iox_ws_t const self,\n    iox_service_discovery_t const serviceDiscovery,\n    const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent\n)\n</code></pre> <p>detaches a service discovery event from a waitset </p> <p>Parameters: </p> <ul> <li>self handle to the waitset </li> <li>serviceDiscovery the service discovery which should be detached </li> <li>serviceDiscoveryEvent the event which should be detached from the service discovery </li> </ul>","title":"function iox_ws_detach_service_discovery_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_BINDING_C_WAIT_SET_H\n#define IOX_BINDING_C_WAIT_SET_H\n\n#include \"iceoryx_binding_c/client.h\"\n#include \"iceoryx_binding_c/enums.h\"\n#include \"iceoryx_binding_c/internal/c2cpp_binding.h\"\n#include \"iceoryx_binding_c/notification_info.h\"\n#include \"iceoryx_binding_c/service_discovery.h\"\n#include \"iceoryx_binding_c/subscriber.h\"\n#include \"iceoryx_binding_c/types.h\"\n#include \"iceoryx_binding_c/user_trigger.h\"\n\n#include &lt;time.h&gt;\n\ntypedef CLASS cpp2c_WaitSet* iox_ws_t;\n\niox_ws_t iox_ws_init(iox_ws_storage_t* self);\n\nvoid iox_ws_deinit(iox_ws_t const self);\n\nuint64_t iox_ws_timed_wait(iox_ws_t const self,\n                           struct timespec timeout,\n                           iox_notification_info_t* const notificationInfoArray,\n                           const uint64_t notificationInfoArrayCapacity,\n                           uint64_t* missedElements);\n\nuint64_t iox_ws_wait(iox_ws_t const self,\n                     iox_notification_info_t* const notificationInfoArray,\n                     const uint64_t notificationInfoArrayCapacity,\n                     uint64_t* missedElements);\n\nuint64_t iox_ws_size(iox_ws_t const self);\n\nuint64_t iox_ws_capacity(iox_ws_t const self);\n\nvoid iox_ws_mark_for_destruction(iox_ws_t const self);\n\nENUM iox_WaitSetResult iox_ws_attach_subscriber_state(iox_ws_t const self,\n                                                      iox_sub_t const subscriber,\n                                                      const ENUM iox_SubscriberState subscriberState,\n                                                      const uint64_t id,\n                                                      void (*callback)(iox_sub_t));\n\nENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data(iox_ws_t const self,\n                                                                        iox_sub_t const subscriber,\n                                                                        const ENUM iox_SubscriberState subscriberState,\n                                                                        const uint64_t id,\n                                                                        void (*callback)(iox_sub_t, void*),\n                                                                        void* const contextData);\n\nENUM iox_WaitSetResult iox_ws_attach_subscriber_event(iox_ws_t const self,\n                                                      iox_sub_t const subscriber,\n                                                      const ENUM iox_SubscriberEvent subscriberEvent,\n                                                      const uint64_t eventId,\n                                                      void (*callback)(iox_sub_t));\n\nENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data(iox_ws_t const self,\n                                                                        iox_sub_t const subscriber,\n                                                                        const ENUM iox_SubscriberEvent subscriberEvent,\n                                                                        const uint64_t eventId,\n                                                                        void (*callback)(iox_sub_t, void*),\n                                                                        void* const contextData);\n\nENUM iox_WaitSetResult iox_ws_attach_user_trigger_event(iox_ws_t const self,\n                                                        iox_user_trigger_t const userTrigger,\n                                                        const uint64_t eventId,\n                                                        void (*callback)(iox_user_trigger_t));\n\nENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data(iox_ws_t const self,\n                                                                          iox_user_trigger_t const userTrigger,\n                                                                          const uint64_t eventId,\n                                                                          void (*callback)(iox_user_trigger_t, void*),\n                                                                          void* const contextData);\n\nvoid iox_ws_detach_subscriber_event(iox_ws_t const self,\n                                    iox_sub_t const subscriber,\n                                    const ENUM iox_SubscriberEvent subscriberEvent);\n\nvoid iox_ws_detach_subscriber_state(iox_ws_t const self,\n                                    iox_sub_t const subscriber,\n                                    const ENUM iox_SubscriberState subscriberState);\n\nvoid iox_ws_detach_user_trigger_event(iox_ws_t const self, iox_user_trigger_t const userTrigger);\n\nENUM iox_WaitSetResult iox_ws_attach_client_event(const iox_ws_t self,\n                                                  const iox_client_t client,\n                                                  const ENUM iox_ClientEvent clientEvent,\n                                                  const uint64_t eventId,\n                                                  void (*callback)(iox_client_t));\n\nENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data(iox_ws_t const self,\n                                                                    iox_client_t const client,\n                                                                    const ENUM iox_ClientEvent clientEvent,\n                                                                    const uint64_t eventId,\n                                                                    void (*callback)(iox_client_t, void*),\n                                                                    void* const contextData);\n\nENUM iox_WaitSetResult iox_ws_attach_client_state(const iox_ws_t self,\n                                                  const iox_client_t client,\n                                                  const ENUM iox_ClientState clientState,\n                                                  const uint64_t eventId,\n                                                  void (*callback)(iox_client_t));\n\nENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data(iox_ws_t const self,\n                                                                    iox_client_t const client,\n                                                                    const ENUM iox_ClientState clientState,\n                                                                    const uint64_t eventId,\n                                                                    void (*callback)(iox_client_t, void*),\n                                                                    void* const contextData);\n\nvoid iox_ws_detach_client_event(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent);\n\nvoid iox_ws_detach_client_state(iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState);\n\nENUM iox_WaitSetResult iox_ws_attach_server_event(const iox_ws_t self,\n                                                  const iox_server_t server,\n                                                  const ENUM iox_ServerEvent serverEvent,\n                                                  const uint64_t eventId,\n                                                  void (*callback)(iox_server_t));\n\nENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data(iox_ws_t const self,\n                                                                    iox_server_t const server,\n                                                                    const ENUM iox_ServerEvent serverEvent,\n                                                                    const uint64_t eventId,\n                                                                    void (*callback)(iox_server_t, void*),\n                                                                    void* const contextData);\n\nENUM iox_WaitSetResult iox_ws_attach_server_state(const iox_ws_t self,\n                                                  const iox_server_t server,\n                                                  const ENUM iox_ServerState serverState,\n                                                  const uint64_t eventId,\n                                                  void (*callback)(iox_server_t));\n\nENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data(iox_ws_t const self,\n                                                                    iox_server_t const server,\n                                                                    const ENUM iox_ServerState serverState,\n                                                                    const uint64_t eventId,\n                                                                    void (*callback)(iox_server_t, void*),\n                                                                    void* const contextData);\n\nvoid iox_ws_detach_server_event(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent);\n\nvoid iox_ws_detach_server_state(iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState);\n\nENUM iox_WaitSetResult iox_ws_attach_service_discovery_event(const iox_ws_t self,\n                                                             const iox_service_discovery_t serviceDiscovery,\n                                                             const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n                                                             const uint64_t eventId,\n                                                             void (*callback)(iox_service_discovery_t));\n\nENUM iox_WaitSetResult\niox_ws_attach_service_discovery_event_with_context_data(iox_ws_t const self,\n                                                        iox_service_discovery_t const serviceDiscovery,\n                                                        const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent,\n                                                        const uint64_t eventId,\n                                                        void (*callback)(iox_service_discovery_t, void*),\n                                                        void* const contextData);\n\nvoid iox_ws_detach_service_discovery_event(iox_ws_t const self,\n                                           iox_service_discovery_t const serviceDiscovery,\n                                           const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent);\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/","text":"<p>This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from <code>[Creation]()</code> and your class has three more static factory methods - <code>create</code>, <code>placementCreate</code> and <code>verify</code>. <code>create</code> forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables <code>m_isInitialized</code> and <code>m_errorValue</code>. The user always has to set <code>m_isInitialized</code> to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided <code>m_errorValue</code> variable which is then returned to the user.  More...</p> <p><code>#include &lt;iceoryx_hoofs/design_pattern/creation.hpp&gt;</code></p>","title":"DesignPattern::Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-types","text":"Name     using Creation&lt; DerivedClass, ErrorType &gt; CreationPattern_t   using iox::cxx::expected&lt; DerivedClass, ErrorType &gt; result_t   using ErrorType errorType_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-functions","text":"Name     template &lt;typename... Targs&gt; result_t create(Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction   result_t verify(DerivedClass &amp;&amp; newObject)verifies if a class was created successfully   template &lt;typename... Targs&gt; iox::cxx::expected&lt; ErrorType &gt; placementCreate(void *const memory, Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction    Creation() =default    Creation(Creation &amp;&amp; rhs)   Creation &amp; operator=(Creation &amp;&amp; rhs)    Creation(const Creation &amp; rhs) =default   Creation &amp; operator=(const Creation &amp; rhs) =default   bool isInitialized() constreturns true if the object was constructed successfully, otherwise false","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#protected-attributes","text":"Name     bool m_isInitialized   ErrorType m_errorValue","title":"Protected Attributes"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#detailed-description","text":"<pre><code>template &lt;typename DerivedClass ,\ntypename ErrorType &gt;\nclass DesignPattern::Creation;\n</code></pre> <p>This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from <code>[Creation]()</code> and your class has three more static factory methods - <code>create</code>, <code>placementCreate</code> and <code>verify</code>. <code>create</code> forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables <code>m_isInitialized</code> and <code>m_errorValue</code>. The user always has to set <code>m_isInitialized</code> to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided <code>m_errorValue</code> variable which is then returned to the user. </p> <p>Template Parameters: </p> <ul> <li>DerivedClass the class which inherits from the creation pattern </li> <li>ErrorType the error type which is going to be used when an error occurs </li> </ul> <pre><code>enum class MyResourceAbstractionError {\n  ResourceNotAvailable,\n  BlaBlubError\n};\nclass MyResourceAbstraction : public Creation&lt;MyResourceAbstraction, MyResourceAbstractionError&gt; {\n  public:\n    // some public methods\n    MyResourceAbstraction &amp; operator=(MyResourceAbstraction &amp;&amp; rhs) noexcept {\n      if ( this != &amp;rhs ) {\n        // always call the creation move assignment operator when you have a user defined\n        // move operation\n        CreationPattern_t::operator=(std::move(rhs));\n\n        // user move code\n      }\n      return *this;\n    }\n\n    // the creation pattern is the only one which should be allowed to construct\n    // the class, therefore it has to be friend of that class\n    friend class Creation&lt;MyResourceAbstraction, MyResourceAbstractionError&gt;;\n  private:\n    MyResourceAbstraction(int a) {\n      if ( a &gt; 0) {\n        // we are able to initialize the class an set m_isInitialized to true\n        m_isInitialized = true;\n      } else {\n        // we are unable to construct the class therefore we have to set\n        // m_isInitialized to false and store the error code in the\n        // provided m_errorValue member\n        m_errorValue = MyResourceAbstractionError::ResourceNotAvailable;\n        m_isInitialized = false;\n      }\n    }\n}\n\n// if the system resource is movable\nauto resource = MyResourceAbstraction::Create(123);\nif ( resource.has_error() &amp;&amp; resource.get_error() == MyResourceAbstractionError::ResourceNotAvailable )\n  // perform error handling\nelse\n  // perform some work\n\n// if the system resource is not movable\nMyResourceAbstraction * resource = malloc(sizeof(MyResourceAbstraction));\nauto result = MyResourceAbstraction::placementCreate(resource, 123);\nif ( result.has_error() )\n  // perform error handling\nelse\n  resource-&gt;DoStuff();\n\ndelete resource;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-creationpattern_t","text":"<pre><code>using DesignPattern::Creation&lt; DerivedClass, ErrorType &gt;::CreationPattern_t =  Creation&lt;DerivedClass, ErrorType&gt;;\n</code></pre>","title":"using CreationPattern_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-result_t","text":"<pre><code>using DesignPattern::Creation&lt; DerivedClass, ErrorType &gt;::result_t =  iox::cxx::expected&lt;DerivedClass, ErrorType&gt;;\n</code></pre>","title":"using result_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-errortype_t","text":"<pre><code>using DesignPattern::Creation&lt; DerivedClass, ErrorType &gt;::errorType_t =  ErrorType;\n</code></pre>","title":"using errorType_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-create","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic result_t create(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>factory method which guarantees that either a working object is produced or an error value describing the error during construction </p> <p>Parameters: </p> <ul> <li>args the argument values which will be forwarded to the ctor </li> </ul> <p>Template Parameters: </p> <ul> <li>Targs the argument types which will be forwarded to the ctor </li> </ul> <p>Return: returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed. </p>","title":"function create"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-verify","text":"<pre><code>static result_t verify(\n    DerivedClass &amp;&amp; newObject\n)\n</code></pre> <p>verifies if a class was created successfully </p> <p>Parameters: </p> <ul> <li>newObject rvalue of the object which should be verified </li> </ul> <p>Return: returns an expected which either contains the object in a valid constructed state or an error value stating why it was in an invalid state. </p>","title":"function verify"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-placementcreate","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic iox::cxx::expected&lt; ErrorType &gt; placementCreate(\n    void *const memory,\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>factory method which guarantees that either a working object is produced or an error value describing the error during construction </p> <p>Parameters: </p> <ul> <li>memory a piece of memory where the object is created into with placement new </li> <li>args the argument values which will be forwarded to the ctor </li> </ul> <p>Template Parameters: </p> <ul> <li>Targs the argument types which will be forwarded to the ctor </li> </ul> <p>Return: returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed. </p>","title":"function placementCreate"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation","text":"<pre><code>Creation() =default\n</code></pre>","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation_1","text":"<pre><code>Creation(\n    Creation &amp;&amp; rhs\n)\n</code></pre>","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-operator","text":"<pre><code>Creation &amp; operator=(\n    Creation &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation_2","text":"<pre><code>Creation(\n    const Creation &amp; rhs\n) =default\n</code></pre>","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-operator_1","text":"<pre><code>Creation &amp; operator=(\n    const Creation &amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-isinitialized","text":"<pre><code>bool isInitialized() const\n</code></pre> <p>returns true if the object was constructed successfully, otherwise false </p>","title":"function isInitialized"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#variable-m_isinitialized","text":"<pre><code>bool m_isInitialized {false};\n</code></pre>","title":"variable m_isInitialized"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#variable-m_errorvalue","text":"<pre><code>ErrorType m_errorValue;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_errorValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/","text":"<p>This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling.  <code>#include &lt;iceoryx_hoofs/error_handling/error_handling.hpp&gt;</code></p>","title":"iox::ErrorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#public-functions","text":"Name     cxx::GenericRAII setTemporaryErrorHandler(const HandlerFunction &amp; newHandler)   const char * toString(const Error error)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#protected-functions","text":"Name     void reactOnErrorLevel(const ErrorLevel level, const char * errorText)","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friends","text":"Name     void errorHandler(const Error error, const std::function&lt; void()&gt; &amp; errorCallBack, const ErrorLevel level) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright!","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-settemporaryerrorhandler","text":"<pre><code>static cxx::GenericRAII setTemporaryErrorHandler(\n    const HandlerFunction &amp; newHandler\n)\n</code></pre>","title":"function setTemporaryErrorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-tostring","text":"<pre><code>static const char * toString(\n    const Error error\n)\n</code></pre>","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-reactonerrorlevel","text":"<pre><code>static void reactOnErrorLevel(\n    const ErrorLevel level,\n    const char * errorText\n)\n</code></pre>","title":"function reactOnErrorLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friend-errorhandler","text":"<pre><code>friend void errorHandler(\n    const Error error,\n\n    const std::function&lt; void()&gt; &amp; errorCallBack,\n\n    const ErrorLevel level\n);\n</code></pre> <p>Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! </p> <p>2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout &lt;&lt; \"MyCustomCallback\" &lt;&lt; std::endl; }, ErrorLevel::MODERATE );</p> <pre><code>class PrettyClass {\n    float division(float a, float b) {\n        if ( b == 0.0f ) {\n            errorHandler(Error::kPRETTY_CLASS__DIVISION_BY_ZERO);\n        }\n    }\n};\n</code></pre> <pre><code>bool called = false;\nauto temporaryErrorHandler = ErrorHandler::setTemporaryErrorHandler(\n    [&amp;](const Error e, std::function&lt;void()&gt;, const ErrorLevel) {\n        called = true;\n    });\n\nerrorHandler(Error::kTEST__ASSERT_CALLED);\nASSERT_TRUE(called);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend errorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/","text":"<p>implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity  More...</p> <p><code>#include &lt;iceoryx_hoofs/concurrent/lockfree_queue.hpp&gt;</code></p>","title":"iox::concurrent::LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-types","text":"Name     using ElementType element_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-types","text":"Name     using IndexQueue&lt; Capacity &gt; Queue   using typename Queue::value_t BufferIndex","title":"Protected Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-functions","text":"Name      LockFreeQueue()creates and initalizes an empty LockFreeQueue    ~LockFreeQueue() =default    LockFreeQueue(const LockFreeQueue &amp; )    LockFreeQueue(LockFreeQueue &amp;&amp; )   LockFreeQueue &amp; operator=(const LockFreeQueue &amp; )   LockFreeQueue &amp; operator=(LockFreeQueue &amp;&amp; )   constexpr uint64_t capacity() constreturns the capacity of the queue   bool tryPush(ElementType &amp;&amp; value)tries to insert value in FIFO order, moves the value internally   bool tryPush(const ElementType &amp; value)tries to insert value in FIFO order, copies the value internally   iox::cxx::optional&lt; ElementType &gt; push(const ElementType &amp; value)inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow)   iox::cxx::optional&lt; ElementType &gt; push(ElementType &amp;&amp; value)inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow)   iox::cxx::optional&lt; ElementType &gt; pop()tries to remove value in FIFO order   bool empty() constcheck whether the queue is empty   uint64_t size() constget the number of stored elements in the queue","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-functions","text":"Name     template &lt;typename T &gt; void writeBufferAt(const BufferIndex &amp; , T &amp;&amp; )   template &lt;typename T &gt; iox::cxx::optional&lt; ElementType &gt; pushImpl(T &amp;&amp; value)   cxx::optional&lt; ElementType &gt; readBufferAt(const BufferIndex &amp; )","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-attributes","text":"Name     Queue m_freeIndices   Queue m_usedIndices   Buffer&lt; ElementType, Capacity, BufferIndex &gt; m_buffer   std::atomic&lt; uint64_t &gt; m_size","title":"Protected Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#detailed-description","text":"<pre><code>template &lt;typename ElementType ,\nuint64_t Capacity&gt;\nclass iox::concurrent::LockFreeQueue;\n</code></pre> <p>implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-element_t","text":"<pre><code>using iox::concurrent::LockFreeQueue&lt; ElementType, Capacity &gt;::element_t =  ElementType;\n</code></pre>","title":"using element_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-queue","text":"<pre><code>using iox::concurrent::LockFreeQueue&lt; ElementType, Capacity &gt;::Queue =  IndexQueue&lt;Capacity&gt;;\n</code></pre>","title":"using Queue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-bufferindex","text":"<pre><code>using iox::concurrent::LockFreeQueue&lt; ElementType, Capacity &gt;::BufferIndex =  typename Queue::value_t;\n</code></pre>","title":"using BufferIndex"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue","text":"<pre><code>LockFreeQueue()\n</code></pre> <p>creates and initalizes an empty LockFreeQueue</p>","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_1","text":"<pre><code>~LockFreeQueue() =default\n</code></pre>","title":"function ~LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_2","text":"<pre><code>LockFreeQueue(\n    const LockFreeQueue &amp; \n)\n</code></pre>","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_3","text":"<pre><code>LockFreeQueue(\n    LockFreeQueue &amp;&amp; \n)\n</code></pre>","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-operator","text":"<pre><code>LockFreeQueue &amp; operator=(\n    const LockFreeQueue &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-operator_1","text":"<pre><code>LockFreeQueue &amp; operator=(\n    LockFreeQueue &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-capacity","text":"<pre><code>constexpr uint64_t capacity() const\n</code></pre> <p>returns the capacity of the queue </p> <p>Note: threadsafe, lockfree </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-trypush","text":"<pre><code>bool tryPush(\n    ElementType &amp;&amp; value\n)\n</code></pre> <p>tries to insert value in FIFO order, moves the value internally </p> <p>Parameters: </p> <ul> <li>value to be inserted </li> </ul> <p>Return: true if insertion was successful (i.e. queue was not full during push), false otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function tryPush"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-trypush_1","text":"<pre><code>bool tryPush(\n    const ElementType &amp; value\n)\n</code></pre> <p>tries to insert value in FIFO order, copies the value internally </p> <p>Parameters: </p> <ul> <li>value to be inserted </li> </ul> <p>Return: true if insertion was successful (i.e. queue was not full during push), false otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function tryPush"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-push","text":"<pre><code>iox::cxx::optional&lt; ElementType &gt; push(\n    const ElementType &amp; value\n)\n</code></pre> <p>inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) </p> <p>Parameters: </p> <ul> <li>value to be inserted is copied into the queue </li> </ul> <p>Return: removed value if an overflow occured, empty optional otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-push_1","text":"<pre><code>iox::cxx::optional&lt; ElementType &gt; push(\n    ElementType &amp;&amp; value\n)\n</code></pre> <p>inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) </p> <p>Parameters: </p> <ul> <li>value to be inserted is moved into the queue if possible </li> </ul> <p>Return: removed value if an overflow occured, empty optional otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-pop","text":"<pre><code>iox::cxx::optional&lt; ElementType &gt; pop()\n</code></pre> <p>tries to remove value in FIFO order </p> <p>Return: value if removal was successful, empty optional otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-empty","text":"<pre><code>bool empty() const\n</code></pre> <p>check whether the queue is empty </p> <p>Return: true iff the queue is empty </p> <p>Note: </p> <ul> <li>that if the queue is used concurrently it might not be empty anymore after the call (but it was at some point during the call) </li> <li>threadsafe, lockfree </li> </ul>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>get the number of stored elements in the queue </p> <p>Return: number of stored elements in the queue </p> <p>Note: </p> <ul> <li>that this will not be perfectly in sync with the actual number of contained elements during concurrent operation but will always be at most capacity </li> <li>threadsafe, lockfree </li> </ul>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-writebufferat","text":"<pre><code>template &lt;typename T &gt;\nvoid writeBufferAt(\n    const BufferIndex &amp; ,\n    T &amp;&amp; \n)\n</code></pre>","title":"function writeBufferAt"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-pushimpl","text":"<pre><code>template &lt;typename T &gt;\niox::cxx::optional&lt; ElementType &gt; pushImpl(\n    T &amp;&amp; value\n)\n</code></pre>","title":"function pushImpl"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-readbufferat","text":"<pre><code>cxx::optional&lt; ElementType &gt; readBufferAt(\n    const BufferIndex &amp; \n)\n</code></pre>","title":"function readBufferAt"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_freeindices","text":"<pre><code>Queue m_freeIndices;\n</code></pre>","title":"variable m_freeIndices"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_usedindices","text":"<pre><code>Queue m_usedIndices;\n</code></pre>","title":"variable m_usedIndices"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_buffer","text":"<pre><code>Buffer&lt; ElementType, Capacity, BufferIndex &gt; m_buffer;\n</code></pre>","title":"variable m_buffer"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_size","text":"<pre><code>std::atomic&lt; uint64_t &gt; m_size {0u};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/","text":"<p>implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread).  More...</p> <p><code>#include &lt;iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp&gt;</code></p> <p>Inherits from iox::concurrent::LockFreeQueue&lt; ElementType, MaxCapacity &gt;</p>","title":"iox::concurrent::ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-types","text":"Name     using ElementType element_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-functions","text":"Name      ResizeableLockFreeQueue() =default    ~ResizeableLockFreeQueue() =default    ResizeableLockFreeQueue(const ResizeableLockFreeQueue &amp; )    ResizeableLockFreeQueue(ResizeableLockFreeQueue &amp;&amp; )   ResizeableLockFreeQueue &amp; operator=(const ResizeableLockFreeQueue &amp; )   ResizeableLockFreeQueue &amp; operator=(ResizeableLockFreeQueue &amp;&amp; )    ResizeableLockFreeQueue(const uint64_t initialCapacity)   uint64_t capacity() constreturns the current capacity of the queue   iox::cxx::optional&lt; ElementType &gt; push(const ElementType &amp; value)inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow)   iox::cxx::optional&lt; ElementType &gt; push(ElementType &amp;&amp; value)inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow)   template &lt;typename Function ,typename  =typename std::enable_if::value&gt;::type&gt; bool setCapacity(const uint64_t newCapacity, Function &amp;&amp; removeHandler)Set the capacity to some value.   bool setCapacity(const uint64_t newCapacity)Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded.   constexpr uint64_t maxCapacity()returns the maximum capacity of the queue","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-attributes","text":"Name     constexpr uint64_t MAX_CAPACITY","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#additional-inherited-members","text":"<p>Protected Types inherited from iox::concurrent::LockFreeQueue&lt; ElementType, MaxCapacity &gt;</p>     Name     using IndexQueue&lt; Capacity &gt; Queue    <p>Public Functions inherited from iox::concurrent::LockFreeQueue&lt; ElementType, MaxCapacity &gt;</p>     Name      LockFreeQueue()creates and initalizes an empty LockFreeQueue    ~LockFreeQueue() =default    LockFreeQueue(const LockFreeQueue &amp; )    LockFreeQueue(LockFreeQueue &amp;&amp; )   bool tryPush(ElementType &amp;&amp; value)tries to insert value in FIFO order, moves the value internally   bool tryPush(const ElementType &amp; value)tries to insert value in FIFO order, copies the value internally   iox::cxx::optional&lt; ElementType &gt; pop()tries to remove value in FIFO order   bool empty() constcheck whether the queue is empty   uint64_t size() constget the number of stored elements in the queue    <p>Protected Functions inherited from iox::concurrent::LockFreeQueue&lt; ElementType, MaxCapacity &gt;</p>     Name     template &lt;typename T &gt; void writeBufferAt(const BufferIndex &amp; , T &amp;&amp; )   cxx::optional&lt; ElementType &gt; readBufferAt(const BufferIndex &amp; )    <p>Protected Attributes inherited from iox::concurrent::LockFreeQueue&lt; ElementType, MaxCapacity &gt;</p>     Name     Queue m_freeIndices   Queue m_usedIndices   Buffer&lt; ElementType, Capacity, BufferIndex &gt; m_buffer   std::atomic&lt; uint64_t &gt; m_size","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#detailed-description","text":"<pre><code>template &lt;typename ElementType ,\nuint64_t MaxCapacity&gt;\nclass iox::concurrent::ResizeableLockFreeQueue;\n</code></pre> <p>implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#using-element_t","text":"<pre><code>using iox::concurrent::ResizeableLockFreeQueue&lt; ElementType, MaxCapacity &gt;::element_t =  ElementType;\n</code></pre>","title":"using element_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue","text":"<pre><code>ResizeableLockFreeQueue() =default\n</code></pre>","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_1","text":"<pre><code>~ResizeableLockFreeQueue() =default\n</code></pre>","title":"function ~ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_2","text":"<pre><code>ResizeableLockFreeQueue(\n    const ResizeableLockFreeQueue &amp; \n)\n</code></pre>","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_3","text":"<pre><code>ResizeableLockFreeQueue(\n    ResizeableLockFreeQueue &amp;&amp; \n)\n</code></pre>","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-operator","text":"<pre><code>ResizeableLockFreeQueue &amp; operator=(\n    const ResizeableLockFreeQueue &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-operator_1","text":"<pre><code>ResizeableLockFreeQueue &amp; operator=(\n    ResizeableLockFreeQueue &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_4","text":"<pre><code>ResizeableLockFreeQueue(\n    const uint64_t initialCapacity\n)\n</code></pre>","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-capacity","text":"<pre><code>uint64_t capacity() const\n</code></pre> <p>returns the current capacity of the queue </p> <p>Return: the current capacity </p> <p>Note: threadsafe, lockfree </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-push","text":"<pre><code>iox::cxx::optional&lt; ElementType &gt; push(\n    const ElementType &amp; value\n)\n</code></pre> <p>inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) </p> <p>Parameters: </p> <ul> <li>value to be inserted is copied into the queue </li> </ul> <p>Return: removed value if an overflow occured, empty optional otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-push_1","text":"<pre><code>iox::cxx::optional&lt; ElementType &gt; push(\n    ElementType &amp;&amp; value\n)\n</code></pre> <p>inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) </p> <p>Parameters: </p> <ul> <li>value to be inserted is moved into the queue if possible </li> </ul> <p>Return: removed value if an overflow occured, empty optional otherwise </p> <p>Note: threadsafe, lockfree </p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-setcapacity","text":"<pre><code>template &lt;typename Function ,\ntypename  =typename std::enable_if&lt;cxx::is_invocable&lt;Function, ElementType&gt;::value&gt;::type&gt;\nbool setCapacity(\n    const uint64_t newCapacity,\n    Function &amp;&amp; removeHandler\n)\n</code></pre> <p>Set the capacity to some value. </p> <p>Parameters: </p> <ul> <li>newCapacity capacity to be set </li> <li>removeHandler is a function taking an element which specifies what to do with removed elements should the need for removal arise. </li> </ul> <p>Return: true if the capacity was successfully set, false otherwise </p> <p>Note: setCapacity is lockfree, but if an application crashes during setCapacity it currently may prevent other applications from setting the capacity (they will not block though). This is not a problem if for example there is only one application calling setCapacity or setCapacity is only called from vital applications (which if they crash will lead to system shutdown) and there is only one (non-vital, i.e. allowed to crash) application reading the data via pop. The reader application may also call setCapacity, since if it crashes there is no one reading the data and the capacity can be considered meaningless. </p>","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-setcapacity_1","text":"<pre><code>bool setCapacity(\n    const uint64_t newCapacity\n)\n</code></pre> <p>Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded. </p> <p>Parameters: </p> <ul> <li>newCapacity new capacity to be set, if it is larger than MaxCapacity the call fails </li> </ul> <p>Return: true setting if the new capacity was successful, false otherwise (newCapacity &gt; MaxCapacity) </p> <p>Note: threadsafe, lockfree but multiple concurrent calls may have no effect </p>","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-maxcapacity","text":"<pre><code>static constexpr uint64_t maxCapacity()\n</code></pre> <p>returns the maximum capacity of the queue </p> <p>Return: the maximum capacity </p>","title":"function maxCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#variable-max_capacity","text":"<pre><code>static constexpr uint64_t MAX_CAPACITY = MaxCapacity;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable MAX_CAPACITY"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/","text":"<p>More...</p>","title":"iox::cxx::ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-types","text":"Name     template &lt;typename T &gt; using ReturnValue(T::*)(Args...) const ConstMethodPointer","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-functions","text":"Name      ConstMethodCallback() =default    ConstMethodCallback(const ConstMethodCallback &amp; rhs) =default   ConstMethodCallback &amp; operator=(const ConstMethodCallback &amp; rhs) =default    ~ConstMethodCallback() =default   template &lt;typename ClassType &gt;  ConstMethodCallback(const ClassType &amp; objectRef, ConstMethodPointer&lt; ClassType &gt; const methodPtr)Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class.    ConstMethodCallback(ConstMethodCallback &amp;&amp; rhs)Move constructor.   ConstMethodCallback &amp; operator=(ConstMethodCallback &amp;&amp; rhs)Move assignment operator.   template &lt;typename... MethodArguments&gt; expected&lt; ReturnValue, MethodCallbackError &gt; operator()(MethodArguments &amp;&amp;... args) constCalls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK.   bool operator==(const ConstMethodCallback &amp; rhs) constComparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer.   bool operator!=(const ConstMethodCallback &amp; rhs) constInequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer.    operator bool() constVerifies if the ConstMethodCallback is valid.   bool isValid() constVerifies if the ConstMethodCallback is valid.   template &lt;typename ClassType &gt; void setCallback(const ClassType &amp; objectRef, ConstMethodPointer&lt; ClassType &gt; methodPtr)Sets a new callback.   template &lt;typename ClassType &gt; const ClassType * getObjectPointer() constReturns object pointer.   template &lt;typename ClassType &gt; auto getMethodPointer() constReturns cond method pointer.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#detailed-description","text":"<pre><code>template &lt;typename ReturnValue ,\ntypename... Args&gt;\nclass iox::cxx::ConstMethodCallback;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#using-constmethodpointer","text":"<pre><code>template &lt;typename T &gt;\nusing iox::cxx::ConstMethodCallback&lt; ReturnValue, Args &gt;::ConstMethodPointer =  ReturnValue (T::*)(Args...) const;\n</code></pre>","title":"using ConstMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback","text":"<pre><code>ConstMethodCallback() =default\n</code></pre>","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_1","text":"<pre><code>ConstMethodCallback(\n    const ConstMethodCallback &amp; rhs\n) =default\n</code></pre>","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator","text":"<pre><code>ConstMethodCallback &amp; operator=(\n    const ConstMethodCallback &amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_2","text":"<pre><code>~ConstMethodCallback() =default\n</code></pre>","title":"function ~ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_3","text":"<pre><code>template &lt;typename ClassType &gt;\nConstMethodCallback(\n    const ClassType &amp; objectRef,\n    ConstMethodPointer&lt; ClassType &gt; const methodPtr\n)\n</code></pre> <p>Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class. </p> <p>Parameters: </p> <ul> <li>objectRef const object reference </li> <li>methodPtr pointer to a const method </li> </ul>","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_4","text":"<pre><code>ConstMethodCallback(\n    ConstMethodCallback &amp;&amp; rhs\n)\n</code></pre> <p>Move constructor. </p> <p>Parameters: </p> <ul> <li>rhs move origin </li> </ul>","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_1","text":"<pre><code>ConstMethodCallback &amp; operator=(\n    ConstMethodCallback &amp;&amp; rhs\n)\n</code></pre> <p>Move assignment operator. </p> <p>Parameters: </p> <ul> <li>rhs move origin </li> </ul> <p>Return: reference to this </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_2","text":"<pre><code>template &lt;typename... MethodArguments&gt;\nexpected&lt; ReturnValue, MethodCallbackError &gt; operator()(\n    MethodArguments &amp;&amp;... args\n) const\n</code></pre> <p>Calls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. </p> <p>Parameters: </p> <ul> <li>args... arguments which will be perfectly forwarded to the method </li> </ul> <p>Return: If ConstMethodCallback is valid the return value of the method, otherwise an error. </p>","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_3","text":"<pre><code>bool operator==(\n    const ConstMethodCallback &amp; rhs\n) const\n</code></pre> <p>Comparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer. </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_4","text":"<pre><code>bool operator!=(\n    const ConstMethodCallback &amp; rhs\n) const\n</code></pre> <p>Inequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer. </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>Verifies if the ConstMethodCallback is valid. </p> <p>Return: true if objectRef != nullptr otherwise false </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-isvalid","text":"<pre><code>bool isValid() const\n</code></pre> <p>Verifies if the ConstMethodCallback is valid. </p> <p>Return: true if objectRef != nullptr otherwise false </p>","title":"function isValid"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-setcallback","text":"<pre><code>template &lt;typename ClassType &gt;\nvoid setCallback(\n    const ClassType &amp; objectRef,\n    ConstMethodPointer&lt; ClassType &gt; methodPtr\n)\n</code></pre> <p>Sets a new callback. </p> <p>Parameters: </p> <ul> <li>objectRef const reference to the object </li> <li>methodPtr pointer to the method </li> </ul>","title":"function setCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-getobjectpointer","text":"<pre><code>template &lt;typename ClassType &gt;\nconst ClassType * getObjectPointer() const\n</code></pre> <p>Returns object pointer. </p>","title":"function getObjectPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-getmethodpointer","text":"<pre><code>template &lt;typename ClassType &gt;\nauto getMethodPointer() const\n</code></pre> <p>Returns cond method pointer. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/","text":"<p>This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/deadline_timer.hpp&gt;</code></p>","title":"iox::cxx::DeadlineTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#public-functions","text":"Name      DeadlineTimer(const iox::units::Duration timeToWait)Constructor.   bool hasExpired() constChecks if the timer has expired compared to its absolute end time.   void reset()reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time.   void reset(const iox::units::Duration timeToWait)reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time.   iox::units::Duration remainingTime() constcalculates the remaining time before the timer goes off","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#detailed-description","text":"<pre><code>class iox::cxx::DeadlineTimer;\n</code></pre> <p>This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. </p> <pre><code>iox::cxx::DeadlineTimer deadlineTimer(1000_ms);\n\n// to check if the timer is active\nif( deadlineTimer.hasExpired()){\n...\n}\n// to reset the timer and start again with the same duration\ndeadlineTimer.reset();\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-deadlinetimer","text":"<pre><code>explicit DeadlineTimer(\n    const iox::units::Duration timeToWait\n)\n</code></pre> <p>Constructor. </p> <p>Parameters: </p> <ul> <li>timeToWait duration until the timer expires </li> </ul>","title":"function DeadlineTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-hasexpired","text":"<pre><code>bool hasExpired() const\n</code></pre> <p>Checks if the timer has expired compared to its absolute end time. </p> <p>Return: false if the timer is still active and true if it is expired </p>","title":"function hasExpired"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-reset","text":"<pre><code>void reset()\n</code></pre> <p>reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time. </p>","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-reset_1","text":"<pre><code>void reset(\n    const iox::units::Duration timeToWait\n)\n</code></pre> <p>reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time. </p> <p>Parameters: </p> <ul> <li>timeToWait duration until the timer expires. This value overwrites the earlier value which was set during the timer creation. </li> </ul>","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-remainingtime","text":"<pre><code>iox::units::Duration remainingTime() const\n</code></pre> <p>calculates the remaining time before the timer goes off </p> <p>Return: the time duration before the timer expires </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function remainingTime"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/","text":"<p>The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/generic_raii.hpp&gt;</code></p>","title":"iox::cxx::GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#public-functions","text":"Name      GenericRAII(const std::function&lt; void()&gt; &amp; cleanupFunction)constructor which creates GenericRAII that calls only the cleanupFunction on destruction    GenericRAII(const function_ref&lt; void()&gt; &amp; initFunction, const std::function&lt; void()&gt; &amp; cleanupFunction)constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor    ~GenericRAII()calls m_cleanupFunction callable if it was set in the constructor    GenericRAII(const GenericRAII &amp; )   GenericRAII &amp; operator=(const GenericRAII &amp; )    GenericRAII(GenericRAII &amp;&amp; rhs)move constructor which moves a generic raii object without calling the cleanupFunction   GenericRAII &amp; operator=(GenericRAII &amp;&amp; rhs)move assignment which moves a generic raii object without calling the cleanupFunction","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#detailed-description","text":"<pre><code>class iox::cxx::GenericRAII;\n</code></pre> <p>The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. </p> <pre><code>// This example leads to a console output of:\n// hello world\n// I am doing stuff\n// goodbye\nvoid someFunc() {\n    auto raii{[](){ std::cout &lt;&lt; \"hello world\\n\"; },\n                [](){ std::cout &lt;&lt; \"goodbye\\n\"; }};\n    std::cout &lt;&lt; \"I am doing stuff\\n\";\n    // raii goes out of scope here and the cleanupFunction is called in the\n    // destructor\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii","text":"<pre><code>explicit GenericRAII(\n    const std::function&lt; void()&gt; &amp; cleanupFunction\n)\n</code></pre> <p>constructor which creates GenericRAII that calls only the cleanupFunction on destruction </p> <p>Parameters: </p> <ul> <li>cleanupFunction callable which will be called in the destructor </li> </ul>","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_1","text":"<pre><code>GenericRAII(\n    const function_ref&lt; void()&gt; &amp; initFunction,\n    const std::function&lt; void()&gt; &amp; cleanupFunction\n)\n</code></pre> <p>constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor </p> <p>Parameters: </p> <ul> <li>initFunction callable which will be called in the constructor </li> <li>cleanupFunction callable which will be called in the destructor </li> </ul>","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_2","text":"<pre><code>~GenericRAII()\n</code></pre> <p>calls m_cleanupFunction callable if it was set in the constructor </p>","title":"function ~GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_3","text":"<pre><code>GenericRAII(\n    const GenericRAII &amp; \n)\n</code></pre>","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-operator","text":"<pre><code>GenericRAII &amp; operator=(\n    const GenericRAII &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_4","text":"<pre><code>GenericRAII(\n    GenericRAII &amp;&amp; rhs\n)\n</code></pre> <p>move constructor which moves a generic raii object without calling the cleanupFunction </p>","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-operator_1","text":"<pre><code>GenericRAII &amp; operator=(\n    GenericRAII &amp;&amp; rhs\n)\n</code></pre> <p>move assignment which moves a generic raii object without calling the cleanupFunction </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/","text":"<p>More...</p>","title":"iox::cxx::MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-types","text":"Name     template &lt;typename T &gt; using ReturnValue(T::*)(Args...) MethodPointer","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-functions","text":"Name      MethodCallback() =default    MethodCallback(const MethodCallback &amp; rhs) =default   MethodCallback &amp; operator=(const MethodCallback &amp; rhs) =default    ~MethodCallback() =default   template &lt;typename ClassType &gt;  MethodCallback(ClassType &amp; objectRef, MethodPointer&lt; ClassType &gt; methodPtr)Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object.    MethodCallback(MethodCallback &amp;&amp; rhs)Move constructor.   MethodCallback &amp; operator=(MethodCallback &amp;&amp; rhs)Move assignment operator.   template &lt;typename... MethodArguments&gt; expected&lt; ReturnValue, MethodCallbackError &gt; operator()(MethodArguments &amp;&amp;... args)Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK.   bool operator==(const MethodCallback &amp; rhs) constComparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer.   bool operator!=(const MethodCallback &amp; rhs) constInequality operator. Two MethodCallbacks are not equal if they have different object or method pointer.    operator bool() constVerifies if the MethodCallback is valid.   bool isValid() constVerifies if the MethodCallback is valid.   template &lt;typename ClassType &gt; void setCallback(ClassType &amp; objectRef, MethodPointer&lt; ClassType &gt; methodPtr)Sets a new callback.   template &lt;typename ClassType &gt; ClassType * getObjectPointer() constReturns objectRef.   template &lt;typename ClassType &gt; auto getMethodPointer() constReturns cond method pointer.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#detailed-description","text":"<pre><code>template &lt;typename ReturnValue ,\ntypename... Args&gt;\nclass iox::cxx::MethodCallback;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#using-methodpointer","text":"<pre><code>template &lt;typename T &gt;\nusing iox::cxx::MethodCallback&lt; ReturnValue, Args &gt;::MethodPointer =  ReturnValue (T::*)(Args...);\n</code></pre>","title":"using MethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback","text":"<pre><code>MethodCallback() =default\n</code></pre>","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_1","text":"<pre><code>MethodCallback(\n    const MethodCallback &amp; rhs\n) =default\n</code></pre>","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator","text":"<pre><code>MethodCallback &amp; operator=(\n    const MethodCallback &amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_2","text":"<pre><code>~MethodCallback() =default\n</code></pre>","title":"function ~MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_3","text":"<pre><code>template &lt;typename ClassType &gt;\nMethodCallback(\n    ClassType &amp; objectRef,\n    MethodPointer&lt; ClassType &gt; methodPtr\n)\n</code></pre> <p>Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object. </p> <p>Parameters: </p> <ul> <li>objectRef object reference </li> <li>methodPtr pointer to a method </li> </ul>","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_4","text":"<pre><code>MethodCallback(\n    MethodCallback &amp;&amp; rhs\n)\n</code></pre> <p>Move constructor. </p> <p>Parameters: </p> <ul> <li>rhs move origin </li> </ul>","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_1","text":"<pre><code>MethodCallback &amp; operator=(\n    MethodCallback &amp;&amp; rhs\n)\n</code></pre> <p>Move assignment operator. </p> <p>Parameters: </p> <ul> <li>rhs move origin </li> </ul> <p>Return: reference to this </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_2","text":"<pre><code>template &lt;typename... MethodArguments&gt;\nexpected&lt; ReturnValue, MethodCallbackError &gt; operator()(\n    MethodArguments &amp;&amp;... args\n)\n</code></pre> <p>Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. </p> <p>Parameters: </p> <ul> <li>args... arguments which will be perfectly forwarded to the method </li> </ul> <p>Return: If MethodCallback is valid the return value of the method, otherwise an error. </p>","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_3","text":"<pre><code>bool operator==(\n    const MethodCallback &amp; rhs\n) const\n</code></pre> <p>Comparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer. </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_4","text":"<pre><code>bool operator!=(\n    const MethodCallback &amp; rhs\n) const\n</code></pre> <p>Inequality operator. Two MethodCallbacks are not equal if they have different object or method pointer. </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>Verifies if the MethodCallback is valid. </p> <p>Return: true if objectRef != nullptr otherwise false </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-isvalid","text":"<pre><code>bool isValid() const\n</code></pre> <p>Verifies if the MethodCallback is valid. </p> <p>Return: true if objectRef != nullptr otherwise false </p>","title":"function isValid"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-setcallback","text":"<pre><code>template &lt;typename ClassType &gt;\nvoid setCallback(\n    ClassType &amp; objectRef,\n    MethodPointer&lt; ClassType &gt; methodPtr\n)\n</code></pre> <p>Sets a new callback. </p> <p>Parameters: </p> <ul> <li>objectRef const reference to the object </li> <li>methodPtr pointer to the method </li> </ul>","title":"function setCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-getobjectpointer","text":"<pre><code>template &lt;typename ClassType &gt;\nClassType * getObjectPointer() const\n</code></pre> <p>Returns objectRef. </p>","title":"function getObjectPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-getmethodpointer","text":"<pre><code>template &lt;typename ClassType &gt;\nauto getMethodPointer() const\n</code></pre> <p>Returns cond method pointer. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/","text":"","title":"classiox 1 1cxx 1 1NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#ioxcxxnewtype","text":"<p>Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/newtype.hpp&gt;</code></p> <p>Inherits from Policies&lt; NewType&lt; T, Policies... &gt; &gt;</p>","title":"iox::cxx::NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-types","text":"Name     using NewType&lt; T, Policies... &gt; ThisType the type of *this   using T value_type the type of the underlying value","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-functions","text":"Name      NewType()default constructor    NewType(const T &amp; rhs)construct with value copy    NewType(const NewType &amp; rhs)copy constructor    NewType(NewType &amp;&amp; rhs)move constructor   NewType &amp; operator=(const NewType &amp; rhs)copy assignment   NewType &amp; operator=(NewType &amp;&amp; rhs)move assignment   NewType &amp; operator=(const T &amp; rhs)copy by value assignment   NewType &amp; operator=(T &amp;&amp; rhs)copy by value assignment    operator T() constconversion operator","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#protected-functions","text":"Name      NewType(newtype::internal::ProtectedConstructor_t , const T &amp; rhs)","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntemplate&lt; typename &gt; class... Policies&gt;\nclass iox::cxx::NewType;\n</code></pre> <p>Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. </p> <pre><code>class Index : public NewType&lt;int,\n                                newtype::ConstructByValueCopy,\n                                newtype::Comparable,\n                                newtype::Sortable,\n                                newtype::AssignByValueCopy&gt;\n{\n    public:\n    // VERY IMPORTANT: we have to put the constructors and operator= in scope\n    //                 otherwise the code will not compile\n        using ThisType::ThisType;   // this makes all constructors of NewType available for Index\n        using ThisType::operator=;  // put the assignment operators in scope\n\n        // implement ctors and assignment operators when they are implemented by the base class\n        // this is necessary to prevent warnings from some compilers\n        Index() noexcept = default;\n        Index(const Index&amp;) noexcept = default;\n        Index(Index&amp;&amp;) noexcept = default;\n        Index&amp; operator=(const Index&amp;) noexcept = default;\n        Index&amp; operator=(Index&amp;&amp;) noexcept = default;\n};\n\nIndex a(123), c(456);   // allowed since we are using the policy ConstructByValueCopy\n// Index b;             // not allowed since we are not using the policy DefaultConstructable\nif ( a &lt; c ) {}         // allowed since we are Sortable\na = 567;                // allowed since we are assignable\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#using-thistype","text":"<pre><code>using iox::cxx::NewType&lt; T, Policies &gt;::ThisType =  NewType&lt;T, Policies...&gt;;\n</code></pre> <p>the type of *this </p>","title":"using ThisType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#using-value_type","text":"<pre><code>using iox::cxx::NewType&lt; T, Policies &gt;::value_type =  T;\n</code></pre> <p>the type of the underlying value </p>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype","text":"<pre><code>NewType()\n</code></pre> <p>default constructor </p>","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_1","text":"<pre><code>explicit NewType(\n    const T &amp; rhs\n)\n</code></pre> <p>construct with value copy </p>","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_2","text":"<pre><code>NewType(\n    const NewType &amp; rhs\n)\n</code></pre> <p>copy constructor </p>","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_3","text":"<pre><code>NewType(\n    NewType &amp;&amp; rhs\n)\n</code></pre> <p>move constructor </p>","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator","text":"<pre><code>NewType &amp; operator=(\n    const NewType &amp; rhs\n)\n</code></pre> <p>copy assignment </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_1","text":"<pre><code>NewType &amp; operator=(\n    NewType &amp;&amp; rhs\n)\n</code></pre> <p>move assignment </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_2","text":"<pre><code>NewType &amp; operator=(\n    const T &amp; rhs\n)\n</code></pre> <p>copy by value assignment </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_3","text":"<pre><code>NewType &amp; operator=(\n    T &amp;&amp; rhs\n)\n</code></pre> <p>copy by value assignment </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator-t","text":"<pre><code>explicit operator T() const\n</code></pre> <p>conversion operator </p>","title":"function operator T"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_4","text":"<pre><code>NewType(\n    newtype::internal::ProtectedConstructor_t ,\n    const T &amp; rhs\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/","text":"<p>Reserves space on stack for placement new instatiation.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/poor_mans_heap.hpp&gt;</code></p>","title":"iox::cxx::PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#public-functions","text":"Name      PoorMansHeap() =default    ~PoorMansHeap()   template &lt;typename Type ,typename... CTorArgs&gt;  PoorMansHeap(PoorMansHeapType&lt; Type &gt; , CTorArgs &amp;&amp;... ctorArgs)    PoorMansHeap(PoorMansHeap &amp;&amp; other)   PoorMansHeap &amp; operator=(PoorMansHeap &amp;&amp; rhs)    PoorMansHeap(const PoorMansHeap &amp; )   PoorMansHeap &amp; operator=(const PoorMansHeap &amp; )   template &lt;typename Type ,typename... CTorArgs&gt; void newInstance(CTorArgs &amp;&amp;... ctorArgs)   void deleteInstance()Calls the destructor if there is a valid instance, otherwise nothing happens.   bool hasInstance() const   Interface * operator-&gt;() const   Interface &amp; operator*() const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#detailed-description","text":"<pre><code>template &lt;typename Interface ,\nsize_t TypeSize,\nsize_t TypeAlignment =8&gt;\nclass iox::cxx::PoorMansHeap;\n</code></pre> <p>Reserves space on stack for placement new instatiation. </p> <p>Parameters: </p> <ul> <li>Interface base type of all classes which should be stored in here </li> <li>TypeSize maximum size of a child of Interface </li> <li>TypeAlignment alignment which is required for the types</li> </ul> <pre><code>#include \"iceoryx_hoofs/cxx/poor_mans_heap.hpp\"\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n\n#include &lt;iostream&gt;\n\nclass Base\n{\n  public:\n    virtual ~Base() = default;\n    virtual void doStuff() = 0;\n};\n\nclass Foo : public Base\n{\n  public:\n    Foo(int stuff)\n        : m_stuff(stuff)\n    {\n    }\n\n    void doStuff() override\n    {\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \": \" &lt;&lt; m_stuff &lt;&lt; std::endl;\n    }\n\n  private:\n    int m_stuff;\n};\n\nclass Bar : public Base\n{\n  public:\n    void doStuff() override\n    {\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    constexpr auto MaxSize = cxx::maxSize&lt;Foo, Bar&gt;();\n    constexpr auto MaxAlignment = cxx::maxAlignment&lt;Foo, Bar&gt;();\n\n    using FooBar = cxx::PoorMansHeap&lt;Base, MaxSize, MaxAlignment&gt;;\n\n    FooBar fooBar1{cxx::PoorMansHeapType&lt;Foo&gt;(), 42};\n    fooBar1-&gt;doStuff();\n\n    fooBar1.newInstance&lt;Bar&gt;();\n    fooBar1-&gt;doStuff();\n\n    fooBar1.newInstance&lt;Foo&gt;(13);\n    fooBar1-&gt;doStuff();\n\n    FooBar fooBar2;\n    if (!fooBar2.hasInstance())\n    {\n        std::cout &lt;&lt; \"There is no instance!\" &lt;&lt; std::endl;\n    }\n\n    fooBar2.newInstance&lt;Bar&gt;();\n    fooBar2-&gt;doStuff();\n\n    fooBar2.deleteInstance();\n    if (!fooBar2.hasInstance())\n    {\n        std::cout &lt;&lt; \"There is again no instance!\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap","text":"<pre><code>PoorMansHeap() =default\n</code></pre>","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_1","text":"<pre><code>~PoorMansHeap()\n</code></pre>","title":"function ~PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_2","text":"<pre><code>template &lt;typename Type ,\ntypename... CTorArgs&gt;\nPoorMansHeap(\n    PoorMansHeapType&lt; Type &gt; ,\n    CTorArgs &amp;&amp;... ctorArgs\n)\n</code></pre> <p>Parameters: </p> <ul> <li>Type the type to instantiate, wrapped in PoorMansHeapType</li> <li>ctorArgs ctor arguments for the type to instantiate </li> </ul> <p>Constructor for immediate construction of an instance </p>","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_3","text":"<pre><code>PoorMansHeap(\n    PoorMansHeap &amp;&amp; other\n)\n</code></pre>","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator","text":"<pre><code>PoorMansHeap &amp; operator=(\n    PoorMansHeap &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_4","text":"<pre><code>PoorMansHeap(\n    const PoorMansHeap &amp; \n)\n</code></pre>","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator_1","text":"<pre><code>PoorMansHeap &amp; operator=(\n    const PoorMansHeap &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-newinstance","text":"<pre><code>template &lt;typename Type ,\ntypename... CTorArgs&gt;\nvoid newInstance(\n    CTorArgs &amp;&amp;... ctorArgs\n)\n</code></pre> <p>Parameters: </p> <ul> <li>Type the type to instantiate, wrapped in PoorMansHeapType</li> <li>ctorArgs ctor arguments for the type to instantiate </li> </ul> <p>Create a new instance of the Type </p>","title":"function newInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-deleteinstance","text":"<pre><code>void deleteInstance()\n</code></pre> <p>Calls the destructor if there is a valid instance, otherwise nothing happens. </p>","title":"function deleteInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-hasinstance","text":"<pre><code>bool hasInstance() const\n</code></pre> <p>Return: true if there is a valid instance </p> <p>Checks is there is a valid instance </p>","title":"function hasInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator-","text":"<pre><code>Interface * operator-&gt;() const\n</code></pre> <p>Return: pointer to the underlying instance or nullptr if there is no valid instance </p> <p>Returns a pointer to the underlying instance </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator_2","text":"<pre><code>Interface &amp; operator*() const\n</code></pre> <p>Return: reference to the underlying instance </p> <p>Returns a reference to the underlying instance. If there is no valid instance, the behaviour is undefined </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/","text":"<p>This is a proxy which must be used for the non default PoorMansHeap ctor.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/poor_mans_heap.hpp&gt;</code></p>","title":"iox::cxx::PoorMansHeapType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/#detailed-description","text":"<pre><code>template &lt;typename Type &gt;\nclass iox::cxx::PoorMansHeapType;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/#this-is-a-proxy-which-must-be-used-for-the-non-default-poormansheap-ctor","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"This is a proxy which must be used for the non default PoorMansHeap ctor."},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/","text":"","title":"classiox 1 1cxx 1 1Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#ioxcxxserialization","text":"<p>Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/serialization.hpp&gt;</code></p>","title":"iox::cxx::Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-types","text":"Name     enum Error { DESERIALIZATION_FAILED}This is an error which can be used for <code>cxx::expected</code> on a custom deserialization when <code>extract</code> fails.","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-functions","text":"Name      Serialization(const std::string &amp; value)Creates a serialization object from a given raw serialization.   std::string toString() conststring conversion operator, returns the raw serialized string    operator std::string() conststring conversion operator, returns the raw serialized string   template &lt;typename T ,typename... Targs&gt; bool extract(T &amp; t, Targs &amp;... args) constExtracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax.   template &lt;typename T &gt; bool getNth(const unsigned int index, T &amp; t) constExtracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax.   template &lt;typename... Targs&gt; Serialization create(const Targs &amp;... args)Create Serialization if every arguments is convertable to string via cxx::convert::toString, this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string())","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#detailed-description","text":"<pre><code>class iox::cxx::Serialization;\n</code></pre> <p>Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. </p> <pre><code>auto serial = cxx::Serialization::create(\"fuu\", 123, 12.12f, 'c');\nstd::cout &lt;&lt; serial.toString() &lt;&lt; std::endl;\n\nstd::string v1;\nint v2;\nfloat v3;\nchar v4;\n\nif ( serial.extract(v1, v2, v3, v4) ) {} // succeeds since every value is convertable\n\nif ( serial.getNth(0, v2) ) {} // fails since \"fuu\" is not an integer\n\n// if you'd like to write a serializable class they need to have a CTor\n// with a cxx::Serialization argument and an operator cxx::Serialization\nclass Fuu {\n    public:\n        Fuu(const cxx::Serialization &amp; s) {\n            if ( !s.Extract(v1, v2, v3) ) {} // error handling\n        }\n        operator cxx::Serialization() const {\n            return cxx::Serialization::Create(v1, v2, v3);\n        }\n    private:\n        int v1 = 123;\n        char v2 = 'c';\n        std::string v3 = \"hello world\";\n\n};\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#enum-error","text":"Enumerator Value Description     DESERIALIZATION_FAILED  indicates a failed deserialization    <p>This is an error which can be used for <code>cxx::expected</code> on a custom deserialization when <code>extract</code> fails. </p>","title":"enum Error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-serialization","text":"<pre><code>explicit Serialization(\n    const std::string &amp; value\n)\n</code></pre> <p>Creates a serialization object from a given raw serialization. </p> <p>Parameters: </p> <ul> <li>value string of serialized data </li> </ul>","title":"function Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-tostring","text":"<pre><code>std::string toString() const\n</code></pre> <p>string conversion operator, returns the raw serialized string </p> <p>Return: serialized string </p>","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-operator-stdstring","text":"<pre><code>operator std::string() const\n</code></pre> <p>string conversion operator, returns the raw serialized string </p> <p>Return: serialized string </p>","title":"function operator std::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-extract","text":"<pre><code>template &lt;typename T ,\ntypename... Targs&gt;\nbool extract(\n    T &amp; t,\n    Targs &amp;... args\n) const\n</code></pre> <p>Extracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax. </p> <p>Parameters: </p> <ul> <li>t reference where the first value in the serialization will be stored in </li> <li>args reference where the remainding values in the serialization will be stored in </li> </ul> <p>Return: true if extraction of all values was successfull, otherwise false </p>","title":"function extract"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-getnth","text":"<pre><code>template &lt;typename T &gt;\nbool getNth(\n    const unsigned int index,\n    T &amp; t\n) const\n</code></pre> <p>Extracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax. </p> <p>Parameters: </p> <ul> <li>index index to the value which should be extracted </li> <li>t variable where the value should be stored </li> </ul> <p>Return: true if extraction was successful, otherwise false </p>","title":"function getNth"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-create","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic Serialization create(\n    const Targs &amp;... args\n)\n</code></pre> <p>Create Serialization if every arguments is convertable to string via cxx::convert::toString, this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string()) </p> <p>Parameters: </p> <ul> <li>args list of string convertable data </li> </ul> <p>Return: Serialization object which contains the serialized data </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function create"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/","text":"<p>wrapper of multiple fifo's  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/variant_queue.hpp&gt;</code></p>","title":"iox::cxx::VariantQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-types","text":"Name     using variant&lt; concurrent::FiFo&lt; ValueType, Capacity &gt;, concurrent::SoFi&lt; ValueType, Capacity &gt;, concurrent::ResizeableLockFreeQueue&lt; ValueType, Capacity &gt;, concurrent::ResizeableLockFreeQueue&lt; ValueType, Capacity &gt; &gt; fifo_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-functions","text":"Name      VariantQueue(const VariantQueueTypes type)Constructor of a VariantQueue.   optional&lt; ValueType &gt; push(const ValueType &amp; value)pushs an element into the fifo   optional&lt; ValueType &gt; pop()pops an element from the fifo   bool empty() constreturns true if empty otherwise true   uint64_t size()get the current size of the queue. Caution, another thread can have changed the size just after reading it   bool setCapacity(const uint64_t newCapacity)set the capacity of the queue   uint64_t capacity() constget the capacity of the queue.   fifo_t &amp; getUnderlyingFiFo()returns reference to the underlying fifo","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#detailed-description","text":"<pre><code>template &lt;typename ValueType ,\nuint64_t Capacity&gt;\nclass iox::cxx::VariantQueue;\n</code></pre> <p>wrapper of multiple fifo's </p> <p>Parameters: </p> <ul> <li>ValueType type which should be stored </li> <li>Capacity capacity of the underlying fifo </li> </ul> <pre><code>cxx::VariantQueue&lt;int, 5&gt; nonOverflowingQueue(cxx::VariantQueueTypes::FiFo_SingleProducerSingleConsumer);\ncxx::VariantQueue&lt;int, 5&gt; overflowingQueue(cxx::VariantQueueTypes::SoFi_SingleProducerSingleConsumer);\n\n// overflow case\nauto status = nonOverflowingQueue.push(123);\nif ( !status ) {\n    std::cout &lt;&lt; \"queue is full\" &lt;&lt; std::endl;\n}\n\nauto overriddenElement = overflowingQueue.push(123);\nif ( overriddenElement-&gt;has_value() ) {\n    std::cout &lt;&lt; \"element \" &lt;&lt; overriddenElement-&gt;value() &lt;&lt; \" was overridden\\n\";\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#using-fifo_t","text":"<pre><code>using iox::cxx::VariantQueue&lt; ValueType, Capacity &gt;::fifo_t =  variant&lt;concurrent::FiFo&lt;ValueType, Capacity&gt;, concurrent::SoFi&lt;ValueType, Capacity&gt;, concurrent::ResizeableLockFreeQueue&lt;ValueType, Capacity&gt;, concurrent::ResizeableLockFreeQueue&lt;ValueType, Capacity&gt; &gt;;\n</code></pre>","title":"using fifo_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-variantqueue","text":"<pre><code>VariantQueue(\n    const VariantQueueTypes type\n)\n</code></pre> <p>Constructor of a VariantQueue. </p> <p>Parameters: </p> <ul> <li>type type of the underlying queue </li> </ul>","title":"function VariantQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-push","text":"<pre><code>optional&lt; ValueType &gt; push(\n    const ValueType &amp; value\n)\n</code></pre> <p>pushs an element into the fifo </p> <p>Parameters: </p> <ul> <li>value value which should be added in the fifo </li> </ul> <p>Return: if the underlying queue has an overflow the optional will contain the value which was overridden (SOFI) or which was dropped (FIFO) otherwise the optional contains nullopt_t</p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-pop","text":"<pre><code>optional&lt; ValueType &gt; pop()\n</code></pre> <p>pops an element from the fifo </p> <p>Return: if the fifo did contain an element it is returned inside the optional otherwise the optional contains nullopt_t</p>","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-empty","text":"<pre><code>bool empty() const\n</code></pre> <p>returns true if empty otherwise true </p>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-size","text":"<pre><code>uint64_t size()\n</code></pre> <p>get the current size of the queue. Caution, another thread can have changed the size just after reading it </p> <p>Return: queue size </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-setcapacity","text":"<pre><code>bool setCapacity(\n    const uint64_t newCapacity\n)\n</code></pre> <p>set the capacity of the queue </p> <p>Parameters: </p> <ul> <li>newCapacity valid values are 0 &lt; newCapacity &lt; MAX_SUBSCRIBER_QUEUE_CAPACITY </li> </ul> <p>Return: true if setting the new capacity succeeded, false otherwise </p> <p>Note: depending on the internal queue used, concurrent pushes and pops are possible (for FiFo_MultiProducerSingleConsumer and SoFi_MultiProducerSingleConsumer) </p> <p>Precondition: it is important that no pop or push calls occur during this call </p>","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-capacity","text":"<pre><code>uint64_t capacity() const\n</code></pre> <p>get the capacity of the queue. </p> <p>Return: queue size </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-getunderlyingfifo","text":"<pre><code>fifo_t &amp; getUnderlyingFiFo()\n</code></pre> <p>returns reference to the underlying fifo </p> <pre><code>VariantQueueTypes&lt;int, 10&gt; myFifo(VariantQueueTypes::FiFo_SingleProducerSingleConsumer);\n\n// access the underlying fifo directly and call empty on it\nmyFifo.getUnderlyingFiFo().template\nget_at_index&lt;VariantQueueTypes::FiFo_SingleProducerSingleConsumer&gt;()-&gt;empty();\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getUnderlyingFiFo"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/","text":"<p>Collection of static methods for conversion from and to string.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/convert.hpp&gt;</code></p>","title":"iox::cxx::convert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-types","text":"Name     enum NumberType","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-functions","text":"Name     template &lt;typename Source &gt; std::enable_if&lt;!std::is_convertible&lt; Source, std::string &gt;::value, std::string &gt;::type toString(const Source &amp; t)Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined)   template &lt;typename Source &gt; std::enable_if&lt; std::is_convertible&lt; Source, std::string &gt;::value, std::string &gt;::type toString(const Source &amp; t)Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined)   template &lt;typename Destination &gt; bool fromString(const char * v, Destination &amp; dest)Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined.   bool stringIsNumber(const char * v, const NumberType type)checks if a given string v is a number","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-attributes","text":"Name     constexpr int32_t STRTOULL_BASE","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#detailed-description","text":"<pre><code>class iox::cxx::convert;\n</code></pre> <p>Collection of static methods for conversion from and to string. </p> <pre><code>std::string number      = cxx::convert::toString(123);\nstd::string someClass   = cxx::convert::toString(someToStringConvertableObject);\n\nint i;\nunsigned int a;\nif ( cxx::convert::fromString(\"123\", i) ) {}  // will succeed\nif ( cxx::convert::fromString(\"-123\", a) ) {} // will fail since -123 is not unsigned\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#enum-numbertype","text":"Enumerator Value Description     INTEGER     UNSIGNED_INTEGER     FLOAT","title":"enum NumberType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-tostring","text":"<pre><code>template &lt;typename Source &gt;\nstatic std::enable_if&lt;!std::is_convertible&lt; Source, std::string &gt;::value, std::string &gt;::type toString(\n    const Source &amp; t\n)\n</code></pre> <p>Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) </p> <p>Parameters: </p> <ul> <li>Source type of the value which should be converted to a string </li> <li>t value which should be converted to a string </li> </ul> <p>Return: string representation of t </p>","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-tostring_1","text":"<pre><code>template &lt;typename Source &gt;\nstatic std::enable_if&lt; std::is_convertible&lt; Source, std::string &gt;::value, std::string &gt;::type toString(\n    const Source &amp; t\n)\n</code></pre> <p>Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) </p> <p>Parameters: </p> <ul> <li>Source type of the value which should be converted to a string </li> <li>t value which should be converted to a string </li> </ul> <p>Return: string representation of t </p>","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-fromstring","text":"<pre><code>template &lt;typename Destination &gt;\nstatic bool fromString(\n    const char * v,\n    Destination &amp; dest\n)\n</code></pre> <p>Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined. </p> <p>Parameters: </p> <ul> <li>v string which contains the value of dest </li> <li>dest destination to which the value should be written </li> </ul> <p>Return: false = if the conversion fails otherwise true </p>","title":"function fromString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-stringisnumber","text":"<pre><code>static bool stringIsNumber(\n    const char * v,\n    const NumberType type\n)\n</code></pre> <p>checks if a given string v is a number </p> <p>Parameters: </p> <ul> <li>v string which contains the number </li> <li>type is the expected contained type in v </li> </ul> <p>Return: true if the given string is a number, otherwise false </p>","title":"function stringIsNumber"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#variable-strtoull_base","text":"<pre><code>static constexpr int32_t STRTOULL_BASE = 10;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable STRTOULL_BASE"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/","text":"<p>expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/expected.hpp&gt;</code></p> <p>Inherited by iox::cxx::expected&lt; void, ErrorType &gt;</p>","title":"iox::cxx::expected&lt; ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#public-functions","text":"Name      expected()default ctor is deleted since you have to clearly state if the expected contains a success value or an error value    expected(const expected &amp; ) =defaultthe copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected    expected(expected &amp;&amp; rhs)the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected    ~expected() =defaultcalls the destructor of the success value or error value - depending on what is stored in the expected   expected &amp; operator=(const expected &amp; )calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected   expected &amp; operator=(expected &amp;&amp; rhs)calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected    expected(const success&lt; void &gt; &amp; successValue)constructs an expected which is signaling success    expected(const error&lt; ErrorType &gt; &amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by errorValue    expected(error&lt; ErrorType &gt; &amp;&amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by value    operator bool() constreturns true if the expected contains an error otherwise false   bool has_error() constreturns true if the expected contains an error otherwise false   ErrorType &amp; get_error()returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior   const ErrorType &amp; get_error() constreturns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior   ErrorType &amp;&amp; get_error()returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior   const expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable) constif the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable)if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   const expected &amp; and_then(const cxx::function_ref&lt; void()&gt; &amp; callable) constif the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable   expected &amp; and_then(const cxx::function_ref&lt; void()&gt; &amp; callable)if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable   expected create_value()creates an expected which is signaling success   template &lt;typename... Targs&gt; expected create_error(Targs &amp;&amp;... args)creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#detailed-description","text":"<pre><code>template &lt;typename ErrorType &gt;\nclass iox::cxx::expected&lt; ErrorType &gt;;\n</code></pre> <p>expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. </p> <p>Parameters: </p> <ul> <li>ErrorType type of the error which can be stored in the expected</li> </ul> <pre><code>cxx::expected&lt;int, float&gt; callMe() {\n    bool l_errorOccured;\n    // ... do stuff\n    if ( l_errorOccured ) {\n        return cxx::error&lt;float&gt;(55.1f);\n    } else if ( !l_errorOccured ) {\n        return cxx::success&lt;int&gt;(123);\n    }\n}\n\ncxx::expected&lt;float&gt; errorOnlyMethod() {\n    return callMe().or_else([]{\n        std::cerr &lt;&lt; \"Error Occured\\n\";\n        /// perform some action\n    }).and_then([](cxx::expected&lt;int, float&gt; &amp; result){\n        std::cout &lt;&lt; \"Success, got \" &lt;&lt; result.value() &lt;&lt; std::endl;\n        /// perform some action\n    });\n}\n\ncxx::expected&lt;std::vector&lt;int&gt;, int&gt; allHailHypnotoad(success&lt;std::vector&lt;int&gt;&gt;({6,6,6}));\nallHailHypnotoad-&gt;push_back(7);\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected","text":"<pre><code>expected()\n</code></pre> <p>default ctor is deleted since you have to clearly state if the expected contains a success value or an error value </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_1","text":"<pre><code>expected(\n    const expected &amp; \n) =default\n</code></pre> <p>the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_2","text":"<pre><code>expected(\n    expected &amp;&amp; rhs\n)\n</code></pre> <p>the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_3","text":"<pre><code>~expected() =default\n</code></pre> <p>calls the destructor of the success value or error value - depending on what is stored in the expected </p>","title":"function ~expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator","text":"<pre><code>expected &amp; operator=(\n    const expected &amp; \n)\n</code></pre> <p>calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator_1","text":"<pre><code>expected &amp; operator=(\n    expected &amp;&amp; rhs\n)\n</code></pre> <p>calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_4","text":"<pre><code>expected(\n    const success&lt; void &gt; &amp; successValue\n)\n</code></pre> <p>constructs an expected which is signaling success </p> <p>Parameters: </p> <ul> <li>successValue value which will be stored in the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_5","text":"<pre><code>expected(\n    const error&lt; ErrorType &gt; &amp; errorValue\n)\n</code></pre> <p>constructs an expected which is signaling an error and stores the error value provided by errorValue </p> <p>Parameters: </p> <ul> <li>errorValue error value which will be stored in the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_6","text":"<pre><code>expected(\n    error&lt; ErrorType &gt; &amp;&amp; errorValue\n)\n</code></pre> <p>constructs an expected which is signaling an error and stores the error value provided by value </p> <p>Parameters: </p> <ul> <li>errorValue error value which will be moved into the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>returns true if the expected contains an error otherwise false </p> <p>Return: bool which contains true if the expected contains an error </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-has_error","text":"<pre><code>bool has_error() const\n</code></pre> <p>returns true if the expected contains an error otherwise false </p> <p>Return: bool which contains true if the expected contains an error </p>","title":"function has_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error","text":"<pre><code>ErrorType &amp; get_error()\n</code></pre> <p>returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error_1","text":"<pre><code>const ErrorType &amp; get_error() const\n</code></pre> <p>returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: const reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error_2","text":"<pre><code>ErrorType &amp;&amp; get_error()\n</code></pre> <p>returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: rvalue reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-or_else","text":"<pre><code>const expected &amp; or_else(\n    const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable\n) const\n</code></pre> <p>if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains an error </li> </ul> <p>Return: const reference to the expected itself </p> <pre><code>someExpected.or_else([](float&amp; error){\n    std::cout &lt;&lt; \"error occured : \" &lt;&lt; error &lt;&lt; std::endl;\n})\n</code></pre>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-or_else_1","text":"<pre><code>expected &amp; or_else(\n    const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable\n)\n</code></pre> <p>if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains an error </li> </ul> <p>Return: const reference to the expected itself </p> <pre><code>someExpected.or_else([](float&amp; error){\n    std::cout &lt;&lt; \"error occured : \" &lt;&lt; error &lt;&lt; std::endl;\n})\n</code></pre>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-and_then","text":"<pre><code>const expected &amp; and_then(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n) const\n</code></pre> <p>if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains a success value </li> </ul> <p>Return: const reference to the expected itself </p> <pre><code>someExpected.and_then([]{\n    std::cout &lt;&lt; \"we are successful!\" &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-and_then_1","text":"<pre><code>expected &amp; and_then(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n)\n</code></pre> <p>if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains a success value </li> </ul> <p>Return: const reference to the expected itself </p> <pre><code>someExpected.and_then([]{\n    std::cout &lt;&lt; \"we are successful!\" &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-create_value","text":"<pre><code>static expected create_value()\n</code></pre> <p>creates an expected which is signaling success </p> <p>Return: expected signalling success </p>","title":"function create_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-create_error","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic expected create_error(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType </p> <p>Parameters: </p> <ul> <li>args... arguments which will be forwarded to the ErrorType constructor </li> </ul> <p>Return: expected signalling error </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function create_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/","text":"<p>specialization of the expected class which can contain an error as well as a success value  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/expected.hpp&gt;</code></p>","title":"iox::cxx::expected&lt; ValueType, ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#public-functions","text":"Name      expected()default ctor is deleted since you have to clearly state if the expected contains a success value or an error value    expected(const expected &amp; ) =defaultthe copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected    expected(expected &amp;&amp; rhs)the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected    ~expected() =defaultcalls the destructor of the success value or error value - depending on what is stored in the expected   expected &amp; operator=(const expected &amp; )calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected   expected &amp; operator=(expected &amp;&amp; rhs)calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected    expected(const success&lt; ValueType &gt; &amp; successValue)constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value    expected(success&lt; ValueType &gt; &amp;&amp; successValue)constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value    expected(const error&lt; ErrorType &gt; &amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by errorValue    expected(error&lt; ErrorType &gt; &amp;&amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by errorValue    operator bool() constreturns true if the expected contains an error otherwise false   bool has_error() constreturns true if the expected contains an error otherwise false   ErrorType &amp; get_error()returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior   const ErrorType &amp; get_error() constreturns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior   ErrorType &amp;&amp; get_error()returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior   ValueType &amp; value()returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior   const ValueType &amp; value() constreturns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior   ValueType &amp;&amp; value()returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior   ValueType value_or(const ValueType &amp; value) constreturns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value   ValueType value_or(const ValueType &amp; value)returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value   ValueType &amp; operator*()dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined.   const ValueType &amp; operator*() constdereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined.   ValueType * operator-&gt;()arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined.   const ValueType * operator-&gt;() constarrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined.   template &lt;typename T &gt;  operator expected&lt; T &gt;()conversion operator to an error only expected which can be useful if you would like to return only the success of a function   template &lt;typename T &gt;  operator expected&lt; T &gt;() constconversion operator to an error only expected which can be useful if you would like to return only the success of a function   const expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable) constif the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable)if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   const expected &amp; and_then(const cxx::function_ref&lt; void(ValueType &amp;)&gt; &amp; callable) constif the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable   expected &amp; and_then(const cxx::function_ref&lt; void(ValueType &amp;)&gt; &amp; callable)if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable   template &lt;typename Optional  =ValueType,typename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt; const expected &amp; and_then(const cxx::function_ref&lt; void(typename Optional::type &amp;)&gt; &amp; callable) constif the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable   template &lt;typename Optional  =ValueType,typename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt; expected &amp; and_then(const cxx::function_ref&lt; void(typename Optional::type &amp;)&gt; &amp; callable)if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable   template &lt;typename Optional  =ValueType,typename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt; const expected &amp; if_empty(const cxx::function_ref&lt; void()&gt; &amp; callable) constif the expected contains a success value and its type is an empty optional, calls the provided callable   template &lt;typename Optional  =ValueType,typename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt; expected &amp; if_empty(const cxx::function_ref&lt; void()&gt; &amp; callable)if the expected contains a success value and its type is an empty optional, calls the provided callable   optional&lt; ValueType &gt; to_optional() const   template &lt;typename... Targs&gt; expected create_value(Targs &amp;&amp;... args)creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType   template &lt;typename... Targs&gt; expected create_error(Targs &amp;&amp;... args)creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#detailed-description","text":"<pre><code>template &lt;typename ValueType ,\ntypename ErrorType &gt;\nclass iox::cxx::expected&lt; ValueType, ErrorType &gt;;\n</code></pre> <p>specialization of the expected class which can contain an error as well as a success value </p> <p>Parameters: </p> <ul> <li>ValueType type of the value which can be stored in the expected </li> <li>ErrorType type of the error which can be stored in the expected </li> </ul>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected","text":"<pre><code>expected()\n</code></pre> <p>default ctor is deleted since you have to clearly state if the expected contains a success value or an error value </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_1","text":"<pre><code>expected(\n    const expected &amp; \n) =default\n</code></pre> <p>the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_2","text":"<pre><code>expected(\n    expected &amp;&amp; rhs\n)\n</code></pre> <p>the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_3","text":"<pre><code>~expected() =default\n</code></pre> <p>calls the destructor of the success value or error value - depending on what is stored in the expected </p>","title":"function ~expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator","text":"<pre><code>expected &amp; operator=(\n    const expected &amp; \n)\n</code></pre> <p>calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_1","text":"<pre><code>expected &amp; operator=(\n    expected &amp;&amp; rhs\n)\n</code></pre> <p>calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_4","text":"<pre><code>expected(\n    const success&lt; ValueType &gt; &amp; successValue\n)\n</code></pre> <p>constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value </p> <p>Parameters: </p> <ul> <li>successValue value which will be stored in the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_5","text":"<pre><code>expected(\n    success&lt; ValueType &gt; &amp;&amp; successValue\n)\n</code></pre> <p>constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value </p> <p>Parameters: </p> <ul> <li>successValue value which will be moved into the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_6","text":"<pre><code>expected(\n    const error&lt; ErrorType &gt; &amp; errorValue\n)\n</code></pre> <p>constructs an expected which is signaling an error and stores the error value provided by errorValue </p> <p>Parameters: </p> <ul> <li>errorValue error value which will be stored in the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_7","text":"<pre><code>expected(\n    error&lt; ErrorType &gt; &amp;&amp; errorValue\n)\n</code></pre> <p>constructs an expected which is signaling an error and stores the error value provided by errorValue </p> <p>Parameters: </p> <ul> <li>errorValue error value which will be moved into the expected </li> </ul>","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>returns true if the expected contains an error otherwise false </p> <p>Return: bool which contains true if the expected contains an error </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-has_error","text":"<pre><code>bool has_error() const\n</code></pre> <p>returns true if the expected contains an error otherwise false </p> <p>Return: bool which contains true if the expected contains an error </p>","title":"function has_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error","text":"<pre><code>ErrorType &amp; get_error()\n</code></pre> <p>returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error_1","text":"<pre><code>const ErrorType &amp; get_error() const\n</code></pre> <p>returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: const reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error_2","text":"<pre><code>ErrorType &amp;&amp; get_error()\n</code></pre> <p>returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior </p> <p>Return: rvalue reference to the internally contained error </p>","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value","text":"<pre><code>ValueType &amp; value()\n</code></pre> <p>returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior </p> <p>Return: reference to the internally contained value </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_1","text":"<pre><code>const ValueType &amp; value() const\n</code></pre> <p>returns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior </p> <p>Return: const reference to the internally contained value </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_2","text":"<pre><code>ValueType &amp;&amp; value()\n</code></pre> <p>returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior </p> <p>Return: rvalue reference to the internally contained value </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_or","text":"<pre><code>ValueType value_or(\n    const ValueType &amp; value\n) const\n</code></pre> <p>returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value </p> <p>Return: copy of the internally contained value or copy of value </p>","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_or_1","text":"<pre><code>ValueType value_or(\n    const ValueType &amp; value\n)\n</code></pre> <p>returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value </p> <p>Return: copy of the internally contained value or copy of value </p>","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_2","text":"<pre><code>ValueType &amp; operator*()\n</code></pre> <p>dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. </p> <p>Return: reference to the contained value </p> <pre><code>cxx::expected&lt;int, float&gt; frodo(success&lt;int&gt;(45));\n*frodo += 12;\nstd::cout &lt;&lt; *frodo &lt;&lt; std::endl; // prints 57\n</code></pre>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_3","text":"<pre><code>const ValueType &amp; operator*() const\n</code></pre> <p>dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. </p> <p>Return: const reference to the contained value </p> <pre><code>cxx::expected&lt;int, float&gt; frodo(success&lt;int&gt;(45));\n*frodo += 12;\nstd::cout &lt;&lt; *frodo &lt;&lt; std::endl; // prints 57\n</code></pre>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-","text":"<pre><code>ValueType * operator-&gt;()\n</code></pre> <p>arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. </p> <p>Return: pointer of type ValueType to the contained value </p> <pre><code>cxx::expected&lt;std::vector&lt;int&gt;, int&gt; holyPiotr(success&lt;std::vector&lt;int&gt;&gt;({1,2,3}));\nholyPiotr-&gt;push_back(4);\n</code></pre>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-_1","text":"<pre><code>const ValueType * operator-&gt;() const\n</code></pre> <p>arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. </p> <p>Return: pointer of type const ValueType to the contained value </p> <pre><code>cxx::expected&lt;std::vector&lt;int&gt;, int&gt; holyPiotr(success&lt;std::vector&lt;int&gt;&gt;({1,2,3}));\nholyPiotr-&gt;push_back(4);\n</code></pre>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-expected-t","text":"<pre><code>template &lt;typename T &gt;\noperator expected&lt; T &gt;()\n</code></pre> <p>conversion operator to an error only expected which can be useful if you would like to return only the success of a function </p> <p>Return: converts an expected which can contain a value and an error to an expected which contains only an error </p> <pre><code>cxx::expected&lt;int, int&gt; someErrorProneFunction(){}\n\ncxx::expected&lt;int&gt; isItSuccessful() {\n    return someErrorProneFunction();\n}\n</code></pre>","title":"function operator expected&lt; T &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-expected-t_1","text":"<pre><code>template &lt;typename T &gt;\noperator expected&lt; T &gt;() const\n</code></pre> <p>conversion operator to an error only expected which can be useful if you would like to return only the success of a function </p> <p>Return: converts an expected which can contain a value and an error to an expected which contains only an error </p> <pre><code>cxx::expected&lt;int, int&gt; someErrorProneFunction(){}\n\ncxx::expected&lt;int&gt; isItSuccessful() {\n    return someErrorProneFunction();\n}\n</code></pre>","title":"function operator expected&lt; T &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-or_else","text":"<pre><code>const expected &amp; or_else(\n    const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable\n) const\n</code></pre> <p>if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains an error </li> </ul> <p>Return: const reference to the expected itself </p> <pre><code>someExpected.or_else([](float&amp; result){\n    std::cout &lt;&lt; \"error occured : \" &lt;&lt; error &lt;&lt; std::endl;\n})\n</code></pre>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-or_else_1","text":"<pre><code>expected &amp; or_else(\n    const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable\n)\n</code></pre> <p>if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains an error </li> </ul> <p>Return: reference to the expected itself </p> <pre><code>someExpected.or_else([](float&amp; error){\n    std::cout &lt;&lt; \"error occured : \" &lt;&lt; error &lt;&lt; std::endl;\n})\n</code></pre>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then","text":"<pre><code>const expected &amp; and_then(\n    const cxx::function_ref&lt; void(ValueType &amp;)&gt; &amp; callable\n) const\n</code></pre> <p>if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains a success value </li> </ul> <p>Return: const reference to the expected </p> <pre><code>someExpected.and_then([](int&amp; result){\n    std::cout &lt;&lt; \"we have a result : \" &lt;&lt; result &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_1","text":"<pre><code>expected &amp; and_then(\n    const cxx::function_ref&lt; void(ValueType &amp;)&gt; &amp; callable\n)\n</code></pre> <p>if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable </p> <p>Parameters: </p> <ul> <li>callable callable which will be called if the expected contains a success value </li> </ul> <p>Return: reference to the expected </p> <pre><code>someExpected.and_then([](int&amp; result){\n    std::cout &lt;&lt; \"we have a result : \" &lt;&lt; result &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_2","text":"<pre><code>template &lt;typename Optional  =ValueType,\ntypename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt;\nconst expected &amp; and_then(\n    const cxx::function_ref&lt; void(typename Optional::type &amp;)&gt; &amp; callable\n) const\n</code></pre> <p>if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable </p> <p>Parameters: </p> <ul> <li>callable the callable to be called with the contents of the optional </li> </ul> <p>Return: reference to the expected </p> <pre><code>anExpectedOptional.and_then([](int&amp; value){\n    std::cout &lt;&lt; \"the optional contains the value: \" &lt;&lt; result &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_3","text":"<pre><code>template &lt;typename Optional  =ValueType,\ntypename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt;\nexpected &amp; and_then(\n    const cxx::function_ref&lt; void(typename Optional::type &amp;)&gt; &amp; callable\n)\n</code></pre> <p>if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable </p> <p>Parameters: </p> <ul> <li>callable the callable to be called with the contents of the optional </li> </ul> <p>Return: reference to the expected </p> <pre><code>anExpectedOptional.and_then([](int&amp; value){\n    std::cout &lt;&lt; \"the optional contains the value: \" &lt;&lt; result &lt;&lt; std::endl;\n})\n</code></pre>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-if_empty","text":"<pre><code>template &lt;typename Optional  =ValueType,\ntypename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt;\nconst expected &amp; if_empty(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n) const\n</code></pre> <p>if the expected contains a success value and its type is an empty optional, calls the provided callable </p> <p>Parameters: </p> <ul> <li>callable the callable to be called if the contained optional is empty </li> </ul> <p>Return: reference to the expected </p> <pre><code>anExpectedOptional.and_then([](SomeType&amp; value){\n        std::cout &lt;&lt; \"we got something in the optional: \" &lt;&lt; value &lt;&lt; std::endl;\n    })\n    .if_empty([](){\n        std::cout &lt;&lt; \"the optional was empty, but do something anyway!\" &lt;&lt; result &lt;&lt; std::endl;\n    })\n</code></pre>","title":"function if_empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-if_empty_1","text":"<pre><code>template &lt;typename Optional  =ValueType,\ntypename std::enable_if&lt; internal::IsOptional&lt; Optional &gt;::value, int &gt;::type  =0&gt;\nexpected &amp; if_empty(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n)\n</code></pre> <p>if the expected contains a success value and its type is an empty optional, calls the provided callable </p> <p>Parameters: </p> <ul> <li>callable the callable to be called if the contained optional is empty </li> </ul> <p>Return: reference to the expected </p> <pre><code>anExpectedOptional.and_then([](SomeType&amp; value){\n        std::cout &lt;&lt; \"we got something in the optional: \" &lt;&lt; value &lt;&lt; std::endl;\n    })\n    .if_empty([](){\n        std::cout &lt;&lt; \"the optional was empty, but do something anyway!\" &lt;&lt; result &lt;&lt; std::endl;\n    })\n</code></pre>","title":"function if_empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-to_optional","text":"<pre><code>optional&lt; ValueType &gt; to_optional() const\n</code></pre>","title":"function to_optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-create_value","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic expected create_value(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType </p> <p>Parameters: </p> <ul> <li>args... arguments which will be forwarded to the ValueType constructor </li> </ul> <p>Return: expected signalling success </p>","title":"function create_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-create_error","text":"<pre><code>template &lt;typename... Targs&gt;\nstatic expected create_error(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType </p> <p>Parameters: </p> <ul> <li>args... arguments which will be forwarded to the ErrorType constructor </li> </ul> <p>Return: expected signalling error </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function create_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/","text":"<p>More...</p> <p>Inherits from iox::cxx::expected&lt; ErrorType &gt;</p>","title":"iox::cxx::expected&lt; void, ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/#additional-inherited-members","text":"<p>Public Functions inherited from iox::cxx::expected&lt; ErrorType &gt;</p>     Name      expected()default ctor is deleted since you have to clearly state if the expected contains a success value or an error value    expected(const expected &amp; ) =defaultthe copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected    expected(expected &amp;&amp; rhs)the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected    ~expected() =defaultcalls the destructor of the success value or error value - depending on what is stored in the expected   expected &amp; operator=(const expected &amp; )calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected   expected &amp; operator=(expected &amp;&amp; rhs)calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected    expected(const success&lt; void &gt; &amp; successValue)constructs an expected which is signaling success    expected(const error&lt; ErrorType &gt; &amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by errorValue    expected(error&lt; ErrorType &gt; &amp;&amp; errorValue)constructs an expected which is signaling an error and stores the error value provided by value    operator bool() constreturns true if the expected contains an error otherwise false   bool has_error() constreturns true if the expected contains an error otherwise false   ErrorType &amp; get_error()returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior   const ErrorType &amp; get_error() constreturns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior   ErrorType &amp;&amp; get_error()returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior   const expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable) constif the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   expected &amp; or_else(const cxx::function_ref&lt; void(ErrorType &amp;)&gt; &amp; callable)if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable   const expected &amp; and_then(const cxx::function_ref&lt; void()&gt; &amp; callable) constif the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable   expected &amp; and_then(const cxx::function_ref&lt; void()&gt; &amp; callable)if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable   expected create_value()creates an expected which is signaling success   template &lt;typename... Targs&gt; expected create_error(Targs &amp;&amp;... args)creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/#detailed-description","text":"<pre><code>template &lt;typename ErrorType &gt;\nclass iox::cxx::expected&lt; void, ErrorType &gt;;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/","text":"<p>C++11 compatible uni-directional forward list implementation.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/forward_list.hpp&gt;</code></p>","title":"iox::cxx::forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-types","text":"Name     using IteratorBase&lt; false &gt; iterator   using IteratorBase&lt; true &gt; const_iterator   using T value_type   using decltype(Capacity) size_type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-functions","text":"Name      forward_list()constructor for an empty list (of T-types elements)    ~forward_list()destructs the list and also calls the destructor of all contained elements    forward_list(const forward_list &amp; rhs)copy constructor list including elements    forward_list(forward_list &amp;&amp; rhs)move constructor list including elements   forward_list &amp; operator=(const forward_list &amp; rhs)copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.)   forward_list &amp; operator=(forward_list &amp;&amp; rhs)move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.)   iterator before_begin()retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator-&gt;)   const_iterator before_begin() constretrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after   const_iterator cbefore_begin() constconst_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after   iterator begin()default list operation to retrieve an interator to first list element   const_iterator begin() constdefault list operation to retrieve an const_iterator to first list element   const_iterator cbegin() constdefault list operation to retrieve an const_iterator to first list element   iterator end()default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   const_iterator end() constdefault list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   const_iterator cend() constdefault list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   bool empty() constlist meta information on filling   bool full() constlist meta information on filling   size_type size() constlist meta information on filling   size_type capacity() constlist meta information, maximum number of elements the list can contain   size_type max_size() constlist meta information, maximum number of elements the list can contain   T &amp; front()Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing.   const T &amp; front() constReturns a reference to the first element in the container. calling front() on an empty list will terminate() the processing.   bool push_front(const T &amp; data)add element to the beginning of the list   bool push_front(T &amp;&amp; data)add element to the beginning of the list via move   bool pop_front()remove the first element from the begining of the list element destructor will be invoked   void clear()remove all elements from the list, list will be empty element destructors will be invoked   iterator erase_after(const_iterator beforeToBeErasedIter)remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element   size_type remove(const T &amp; data)remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined.   template &lt;typename UnaryPredicate &gt; size_type remove_if(UnaryPredicate pred)remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined.   template &lt;typename... ConstructorArgs&gt; T &amp; emplace_front(ConstructorArgs &amp;&amp;... args)construct element inplace at begining of list   template &lt;typename... ConstructorArgs&gt; iterator emplace_after(const_iterator afterToBeEmplacedIter, ConstructorArgs &amp;&amp;... args)construct element inplace after the pointed-to element   iterator insert_after(const_iterator citer, const T &amp; data)insert element after iterator position   iterator insert_after(const_iterator citer, T &amp;&amp; data)add element after the pointed-to element via move","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#detailed-description","text":"<pre><code>template &lt;typename T ,\nuint64_t Capacity&gt;\nclass iox::cxx::forward_list;\n</code></pre> <p>C++11 compatible uni-directional forward list implementation. </p> <p>Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side.</p> <p>overview of cxx::forward_list deviations to std::forward_list(C++11)</p> <ul> <li>list declaration with mandatory max list size argument</li> <li>member functions don't throw exception but will trigger different failure handling</li> <li>push_front returns a bool (instead of void) informing on successful insertion (true)</li> <li>pop_front returns a bool (instead of void) informing on successful removal (true), otherwise empty (false)</li> <li>emplace_front returns a reference to the inserted element (instead of void), this is C++17-conform</li> <li>remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform</li> </ul>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#yet-missing-implementations","text":"<ul> <li>allocator, difference_type based operations</li> <li>assign, resize, swap, merge, splice_after, reverse, unique, sort</li> <li>list operator==, operator!=, operator&lt;, operator&lt;=, operator&gt;, operator&gt;= Ttype user data to be managed within list </li> </ul> <p>Capacitynumber of maximum list elements a client can push to the list. minimum value is '1' </p>","title":"(yet) missing implementations"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-iterator","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::iterator =  IteratorBase&lt;false&gt;;\n</code></pre>","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-const_iterator","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::const_iterator =  IteratorBase&lt;true&gt;;\n</code></pre>","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-value_type","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::value_type =  T;\n</code></pre>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-size_type","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::size_type =  decltype(Capacity);\n</code></pre>","title":"using size_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list","text":"<pre><code>forward_list()\n</code></pre> <p>constructor for an empty list (of T-types elements) </p>","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_1","text":"<pre><code>~forward_list()\n</code></pre> <p>destructs the list and also calls the destructor of all contained elements </p>","title":"function ~forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_2","text":"<pre><code>forward_list(\n    const forward_list &amp; rhs\n)\n</code></pre> <p>copy constructor list including elements </p> <p>Parameters: </p> <ul> <li>rhs is the list to copy from (same capacity) </li> </ul>","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_3","text":"<pre><code>forward_list(\n    forward_list &amp;&amp; rhs\n)\n</code></pre> <p>move constructor list including elements </p> <p>Parameters: </p> <ul> <li>rhs is the list to move-construct elements from (same capacity) </li> </ul>","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-operator","text":"<pre><code>forward_list &amp; operator=(\n    const forward_list &amp; rhs\n)\n</code></pre> <p>copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) </p> <p>Parameters: </p> <ul> <li>rhs is the list to copy from (same capacity) </li> </ul> <p>Return: reference to created list </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-operator_1","text":"<pre><code>forward_list &amp; operator=(\n    forward_list &amp;&amp; rhs\n)\n</code></pre> <p>move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) </p> <p>Parameters: </p> <ul> <li>rhs is the list to move from ('source', same capacity) </li> </ul> <p>Return: reference to created list </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-before_begin","text":"<pre><code>iterator before_begin()\n</code></pre> <p>retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to fictional element before first data element </p>","title":"function before_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-before_begin_1","text":"<pre><code>const_iterator before_begin() const\n</code></pre> <p>retrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after </p> <p>Return: iterator to fictional element before first data element </p>","title":"function before_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cbefore_begin","text":"<pre><code>const_iterator cbefore_begin() const\n</code></pre> <p>const_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after </p> <p>Return: iterator to fictional element before first data element </p>","title":"function cbefore_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-begin","text":"<pre><code>iterator begin()\n</code></pre> <p>default list operation to retrieve an interator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-begin_1","text":"<pre><code>const_iterator begin() const\n</code></pre> <p>default list operation to retrieve an const_iterator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cbegin","text":"<pre><code>const_iterator cbegin() const\n</code></pre> <p>default list operation to retrieve an const_iterator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function cbegin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-end","text":"<pre><code>iterator end()\n</code></pre> <p>default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-end_1","text":"<pre><code>const_iterator end() const\n</code></pre> <p>default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cend","text":"<pre><code>const_iterator cend() const\n</code></pre> <p>default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function cend"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-empty","text":"<pre><code>bool empty() const\n</code></pre> <p>list meta information on filling </p> <p>Return: no elements in list (true), otherwise (false) </p>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-full","text":"<pre><code>bool full() const\n</code></pre> <p>list meta information on filling </p> <p>Return: whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false) </p>","title":"function full"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-size","text":"<pre><code>size_type size() const\n</code></pre> <p>list meta information on filling </p> <p>Return: current number of elements in list @min returns min 0 @max returns max capacity </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-capacity","text":"<pre><code>size_type capacity() const\n</code></pre> <p>list meta information, maximum number of elements the list can contain </p> <p>Return: list has been initialized with the following number of elements. </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-max_size","text":"<pre><code>size_type max_size() const\n</code></pre> <p>list meta information, maximum number of elements the list can contain </p> <p>Return: list has been initialized with the following number of elements, same as capacity()</p>","title":"function max_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-front","text":"<pre><code>T &amp; front()\n</code></pre> <p>Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. </p> <p>Return: reference to the first element </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-front_1","text":"<pre><code>const T &amp; front() const\n</code></pre> <p>Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. </p> <p>Return: const reference to the first element </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-push_front","text":"<pre><code>bool push_front(\n    const T &amp; data\n)\n</code></pre> <p>add element to the beginning of the list </p> <p>Parameters: </p> <ul> <li>data reference to data element </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-push_front_1","text":"<pre><code>bool push_front(\n    T &amp;&amp; data\n)\n</code></pre> <p>add element to the beginning of the list via move </p> <p>Parameters: </p> <ul> <li>data universal reference perfectly forwarded to client class </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-pop_front","text":"<pre><code>bool pop_front()\n</code></pre> <p>remove the first element from the begining of the list element destructor will be invoked </p> <p>Return: successful removal (true), otherwise no element could be taken from list (e.g. empty -&gt; false) </p>","title":"function pop_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-clear","text":"<pre><code>void clear()\n</code></pre> <p>remove all elements from the list, list will be empty element destructors will be invoked </p>","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-erase_after","text":"<pre><code>iterator erase_after(\n    const_iterator beforeToBeErasedIter\n)\n</code></pre> <p>remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element </p> <p>Parameters: </p> <ul> <li>beforeToBeErasedIter iterator linking the element before the to-be-removed element </li> </ul> <p>Return: an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list </p>","title":"function erase_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-remove","text":"<pre><code>size_type remove(\n    const T &amp; data\n)\n</code></pre> <p>remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. </p> <p>Parameters: </p> <ul> <li>data value to compare to </li> </ul> <p>Return: the number of elements removed, return is C++20-conform </p>","title":"function remove"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-remove_if","text":"<pre><code>template &lt;typename UnaryPredicate &gt;\nsize_type remove_if(\n    UnaryPredicate pred\n)\n</code></pre> <p>remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. </p> <p>Parameters: </p> <ul> <li>pred unary predicate which returns true if the element should be removed </li> </ul> <p>Return: the number of elements removed, return is C++20-conform </p>","title":"function remove_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-emplace_front","text":"<pre><code>template &lt;typename... ConstructorArgs&gt;\nT &amp; emplace_front(\n    ConstructorArgs &amp;&amp;... args\n)\n</code></pre> <p>construct element inplace at begining of list </p> <p>Parameters: </p> <ul> <li>args T-typed construction parameters (initializer list) </li> </ul> <p>Return: referene to generated element, return is C++17-conform </p>","title":"function emplace_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-emplace_after","text":"<pre><code>template &lt;typename... ConstructorArgs&gt;\niterator emplace_after(\n    const_iterator afterToBeEmplacedIter,\n    ConstructorArgs &amp;&amp;... args\n)\n</code></pre> <p>construct element inplace after the pointed-to element </p> <p>Parameters: </p> <ul> <li>args T-typed construction parameters (initializer list) </li> <li>afterToBeEmplacedIter position in list to (construct)insert after </li> </ul> <p>Return: iterator to the newly added element </p>","title":"function emplace_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-insert_after","text":"<pre><code>iterator insert_after(\n    const_iterator citer,\n    const T &amp; data\n)\n</code></pre> <p>insert element after iterator position </p> <p>Parameters: </p> <ul> <li>citer iterator with the position to insert after </li> <li>data reference to element to add </li> </ul> <p>Return: iterator to the newly added element </p>","title":"function insert_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-insert_after_1","text":"<pre><code>iterator insert_after(\n    const_iterator citer,\n    T &amp;&amp; data\n)\n</code></pre> <p>add element after the pointed-to element via move </p> <p>Parameters: </p> <ul> <li>citer iterator with the position to insert after </li> <li>data universal reference perfectly forwarded to client class </li> </ul> <p>Return: iterator to the newly added element </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function insert_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/","text":"<p>nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate()  More...</p>","title":"iox::cxx::forward_list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-types","text":"Name     using std::forward_iterator_tag iterator_category   using typename std::conditional&lt; IsConstIterator, const T, T &gt;::type value_type   using void difference_type   using typename std::conditional&lt; IsConstIterator, const T *, T * &gt;::type pointer   using typename std::conditional&lt; IsConstIterator, const T &amp;, T &amp; &gt;::type reference","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-functions","text":"Name      IteratorBase(const IteratorBase&lt; false &gt; &amp; iter)construct a const_iterator from an iterator   IteratorBase &amp; operator=(const IteratorBase&lt; false &gt; &amp; rhs)assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented   IteratorBase &amp; operator++()prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end   template &lt;bool IsConstIteratorOther&gt; bool operator==(const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs) constcomparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked   template &lt;bool IsConstIteratorOther&gt; bool operator!=(const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs) constcomparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked   reference operator*() constdereferencing element content via iterator-position element   pointer operator-&gt;() constdereferencing element content via iterator-position element","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friends","text":"Name     class IteratorBase&lt; true &gt;   class forward_list&lt; T, Capacity &gt;","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#detailed-description","text":"<pre><code>template &lt;bool IsConstIterator =true&gt;\nclass iox::cxx::forward_list::IteratorBase;\n</code></pre> <p>nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-iterator_category","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::iterator_category =  std::forward_iterator_tag;\n</code></pre>","title":"using iterator_category"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-value_type","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::value_type =  typename std::conditional&lt;IsConstIterator, const T, T&gt;::type;\n</code></pre>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-difference_type","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::difference_type =  void;\n</code></pre>","title":"using difference_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-pointer","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::pointer =  typename std::conditional&lt;IsConstIterator, const T*, T*&gt;::type;\n</code></pre>","title":"using pointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-reference","text":"<pre><code>using iox::cxx::forward_list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::reference =  typename std::conditional&lt;IsConstIterator, const T&amp;, T&amp;&gt;::type;\n</code></pre>","title":"using reference"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-iteratorbase","text":"<pre><code>IteratorBase(\n    const IteratorBase&lt; false &gt; &amp; iter\n)\n</code></pre> <p>construct a const_iterator from an iterator </p> <p>Parameters: </p> <ul> <li>iter is the iterator which will deliver list and index info for the const_iterator </li> </ul>","title":"function IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator","text":"<pre><code>IteratorBase &amp; operator=(\n    const IteratorBase&lt; false &gt; &amp; rhs\n)\n</code></pre> <p>assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented </p> <p>Parameters: </p> <ul> <li>rhs is the iterator which will deliver list and index info for the const_iterator </li> </ul> <p>Return: reference to this iterator object </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_1","text":"<pre><code>IteratorBase &amp; operator++()\n</code></pre> <p>prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end </p> <p>Return: reference to this iterator object </p>","title":"function operator++"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_2","text":"<pre><code>template &lt;bool IsConstIteratorOther&gt;\nbool operator==(\n    const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs\n) const\n</code></pre> <p>comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked </p> <p>Parameters: </p> <ul> <li>rhs is the 2nd iterator to compare to </li> </ul> <p>Return: list position for two iterators is the same (true) or different (false) </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_3","text":"<pre><code>template &lt;bool IsConstIteratorOther&gt;\nbool operator!=(\n    const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs\n) const\n</code></pre> <p>comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked </p> <p>Parameters: </p> <ul> <li>rhs is the 2nd iterator to compare to </li> </ul> <p>Return: list position for two iterators is the same (true) or different (false) </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_4","text":"<pre><code>reference operator*() const\n</code></pre> <p>dereferencing element content via iterator-position element </p> <p>Return: reference to list element data </p>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator-","text":"<pre><code>pointer operator-&gt;() const\n</code></pre> <p>dereferencing element content via iterator-position element </p> <p>Return: pointer to const list data element </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friend-iteratorbase-true","text":"<pre><code>friend class IteratorBase&lt; true &gt;(\n    IteratorBase&lt; true &gt; \n);\n</code></pre>","title":"friend IteratorBase&lt; true &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friend-forward_list-t-capacity","text":"<pre><code>friend class forward_list&lt; T, Capacity &gt;(\n    forward_list&lt; T, Capacity &gt; \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend forward_list&lt; T, Capacity &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref/","text":"<p>More...</p>","title":"iox::cxx::function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref/#detailed-description","text":"<pre><code>template &lt;typename SignatureType &gt;\nclass iox::cxx::function_ref;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/","text":"<p>cxx::function_ref is a non-owning reference to a callable.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/function_ref.hpp&gt;</code></p>","title":"iox::cxx::function_ref&lt; ReturnType(ArgTypes...)&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#public-functions","text":"Name      function_ref()Creates an empty function_ref in an invalid state.    ~function_ref() =default    function_ref(const function_ref &amp; ) =default   function_ref &amp; operator=(const function_ref &amp; ) =default   template &lt;typename CallableType ,typename  =std::enable_if_t&lt;!is_function_pointer::value                                          &amp;&amp; !has_same_decayed_type::value                                          &amp;&amp; is_invocable::value&gt;&gt;  function_ref(CallableType &amp;&amp; callable)Creates a function_ref with a callable whose lifetime has to be longer than function_ref.    function_ref(ReturnType(*)(ArgTypes...) function)Creates a function_ref from a function pointer.    function_ref(function_ref &amp;&amp; rhs)   function_ref &amp; operator=(function_ref &amp;&amp; rhs)   ReturnType operator()(ArgTypes... args) constCalls the provided callable.    operator bool() constChecks whether a valid target is contained.   void swap(function_ref &amp; rhs)Swaps the contents of two function_ref's.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#detailed-description","text":"<pre><code>template &lt;class ReturnType ,\nclass... ArgTypes&gt;\nclass iox::cxx::function_ref&lt; ReturnType(ArgTypes...)&gt;;\n</code></pre> <p>cxx::function_ref is a non-owning reference to a callable. </p> <p>Attention: Invoking an empty function_ref can lead to a program termination!</p> <pre><code>   It has these features:\n    * No heap usage\n    * No exceptions\n    * Stateful lambda support\n    * C++11/14 support\n</code></pre> <pre><code>// Usage as function parameter\nvoid fuu(cxx::function_ref&lt;void()&gt; callback)\n{\n    callback();\n}\n// Call the lambda\nfuu([]{ doSomething(); });\n\n// Usage with l-values\n// Pitfall: Ensure that lifetime of callable suits the point in time of calling callback()\nauto callable = [&amp;]{ doSomething(); };\ncxx::function_ref&lt;void()&gt; callback(callable);\n// Call the callback\ncallback();\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref","text":"<pre><code>function_ref()\n</code></pre> <p>Creates an empty function_ref in an invalid state. </p> <p>Note: Handle with care, program will terminate when calling an invalid function_ref</p>","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_1","text":"<pre><code>~function_ref() =default\n</code></pre>","title":"function ~function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_2","text":"<pre><code>function_ref(\n    const function_ref &amp; \n) =default\n</code></pre>","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator","text":"<pre><code>function_ref &amp; operator=(\n    const function_ref &amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_3","text":"<pre><code>template &lt;typename CallableType ,\ntypename  =std::enable_if_t&lt;!is_function_pointer&lt;CallableType&gt;::value                                          &amp;&amp; !has_same_decayed_type&lt;CallableType, function_ref&gt;::value                                          &amp;&amp; is_invocable&lt;CallableType, ArgTypes...&gt;::value&gt;&gt;\nfunction_ref(\n    CallableType &amp;&amp; callable\n)\n</code></pre> <p>Creates a function_ref with a callable whose lifetime has to be longer than function_ref. </p> <p>Parameters: </p> <ul> <li>callable that is not a function_ref</li> </ul>","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_4","text":"<pre><code>function_ref(\n    ReturnType(*)(ArgTypes...) function\n)\n</code></pre> <p>Creates a function_ref from a function pointer. </p> <p>Parameters: </p> <ul> <li>function function pointer to function we want to reference</li> </ul> <p>Note: This overload is needed, as the general implementation will not work properly for function pointers. This ctor is not needed anymore once we can use user-defined-deduction guides (C++17) </p>","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_5","text":"<pre><code>function_ref(\n    function_ref &amp;&amp; rhs\n)\n</code></pre>","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator_1","text":"<pre><code>function_ref &amp; operator=(\n    function_ref &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator_2","text":"<pre><code>ReturnType operator()(\n    ArgTypes... args\n) const\n</code></pre> <p>Calls the provided callable. </p> <p>Parameters: </p> <ul> <li>Arguments are forwarded to the underlying function pointer </li> </ul> <p>Return: Returns the data type of the underlying function pointer </p> <p>Attention: Invoking an empty function_ref can lead to a program termination! </p>","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>Checks whether a valid target is contained. </p> <p>Return: True if valid target is contained, otherwise false </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-swap","text":"<pre><code>void swap(\n    function_ref &amp; rhs\n)\n</code></pre> <p>Swaps the contents of two function_ref's. </p> <p>Parameters: </p> <ul> <li>Reference to another function_ref</li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function swap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/","text":"<p>C++11 compatible bi-directional list implementation.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/list.hpp&gt;</code></p>","title":"iox::cxx::list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-types","text":"Name     using IteratorBase&lt; false &gt; iterator   using IteratorBase&lt; true &gt; const_iterator   using T value_type   using decltype(Capacity) size_type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-functions","text":"Name      list()constructor for an empty list (of T-types elements)    ~list()destructs the list and also calls the destructor of all contained elements    list(const list &amp; rhs)copy constructor list including elements    list(list &amp;&amp; rhs)move constructor list including elements   list &amp; operator=(const list &amp; rhs)copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.)   list &amp; operator=(list &amp;&amp; rhs)move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.)   iterator begin()default list operation to retrieve an interator to first list element   const_iterator begin() constdefault list operation to retrieve an const_iterator to first list element   const_iterator cbegin() constdefault list operation to retrieve an const_iterator to first list element   iterator end()default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   const_iterator end() constdefault list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   const_iterator cend() constdefault list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;)   bool empty() constlist meta information on filling   bool full() constlist meta information on filling   size_type size() constlist meta information on filling   size_type capacity() constlist meta information, maximum number of elements the list can contain   size_type max_size() constlist meta information, maximum number of elements the list can contain   T &amp; front()Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing.   const T &amp; front() constReturns a reference to the first element in the container. calling front() on an empty list will terminate() the processing.   T &amp; back()Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing.   const T &amp; back() constReturns a reference to the last element in the container. calling back() on an empty list will terminate() the processing.   bool push_front(const T &amp; data)add element to the beginning of the list   bool push_front(T &amp;&amp; data)add element to the beginning of the list via move   bool push_back(const T &amp; data)add element to the end of the list   bool push_back(T &amp;&amp; data)add element to the end of the list via move   bool pop_front()remove the first element from the begining of the list element destructor will be invoked   bool pop_back()remove the last element from the end of the list element destructor will be invoked   void clear()remove all elements from the list, list will be empty element destructors will be invoked   iterator erase(const_iterator iter)remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element   size_type remove(const T &amp; data)remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined.   template &lt;typename UnaryPredicate &gt; size_type remove_if(UnaryPredicate pred)remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined.   template &lt;typename... ConstructorArgs&gt; T &amp; emplace_front(ConstructorArgs &amp;&amp;... args)construct element inplace at begining of list   template &lt;typename... ConstructorArgs&gt; T &amp; emplace_back(ConstructorArgs &amp;&amp;... args)construct element inplace at end of list   template &lt;typename... ConstructorArgs&gt; iterator emplace(const_iterator iter, ConstructorArgs &amp;&amp;... args)construct element inplace at iterator position   iterator insert(const_iterator citer, const T &amp; data)insert element before iterator position   iterator insert(const_iterator citer, T &amp;&amp; data)add element before the pointed-to element via move","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#detailed-description","text":"<pre><code>template &lt;typename T ,\nuint64_t Capacity&gt;\nclass iox::cxx::list;\n</code></pre> <p>C++11 compatible bi-directional list implementation. </p> <p>Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side.</p> <p>overview of cxx::forward_list deviations to std::forward_list(C++11)</p> <ul> <li>list declaration with mandatory max list size argument</li> <li>member functions don't throw exception but will trigger different failure handling</li> <li>push_front/~_back returns a bool (instead of void) informing on successful insertion (true)</li> <li>pop_front/~_back returns a bool (instead of void) informing on successful removal (true), otherwise empty (false)</li> <li>emplace_front/~_back returns a reference to the inserted element (instead of void), this is C++17-conform</li> <li>remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform</li> </ul>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#yet-missing-implementations","text":"<ul> <li>allocator, difference_type / range operations</li> <li>assign, resize, swap, merge, splice_after, reverse, rbegin/crbegin, rend/crend, unique, sort</li> <li>list operator==, operator!=, operator&lt;, operator&lt;=, operator&gt;, operator&gt;= Ttype user data to be managed within list </li> </ul> <p>Capacitynumber of maximum list elements a client can push to the list. minimum value is '1' </p>","title":"(yet) missing implementations"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-iterator","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::iterator =  IteratorBase&lt;false&gt;;\n</code></pre>","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-const_iterator","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::const_iterator =  IteratorBase&lt;true&gt;;\n</code></pre>","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-value_type","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::value_type =  T;\n</code></pre>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-size_type","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::size_type =  decltype(Capacity);\n</code></pre>","title":"using size_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list","text":"<pre><code>list()\n</code></pre> <p>constructor for an empty list (of T-types elements) </p>","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_1","text":"<pre><code>~list()\n</code></pre> <p>destructs the list and also calls the destructor of all contained elements </p>","title":"function ~list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_2","text":"<pre><code>list(\n    const list &amp; rhs\n)\n</code></pre> <p>copy constructor list including elements </p> <p>Parameters: </p> <ul> <li>rhs is the list to copy from (same capacity) </li> </ul>","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_3","text":"<pre><code>list(\n    list &amp;&amp; rhs\n)\n</code></pre> <p>move constructor list including elements </p> <p>Parameters: </p> <ul> <li>rhs is the list to move-construct elements from (same capacity) </li> </ul>","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-operator","text":"<pre><code>list &amp; operator=(\n    const list &amp; rhs\n)\n</code></pre> <p>copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) </p> <p>Parameters: </p> <ul> <li>rhs is the list to copy from (same capacity) </li> </ul> <p>Return: reference to created list </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-operator_1","text":"<pre><code>list &amp; operator=(\n    list &amp;&amp; rhs\n)\n</code></pre> <p>move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) </p> <p>Parameters: </p> <ul> <li>rhs is the list to move from ('source', same capacity) </li> </ul> <p>Return: reference to created list </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-begin","text":"<pre><code>iterator begin()\n</code></pre> <p>default list operation to retrieve an interator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-begin_1","text":"<pre><code>const_iterator begin() const\n</code></pre> <p>default list operation to retrieve an const_iterator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-cbegin","text":"<pre><code>const_iterator cbegin() const\n</code></pre> <p>default list operation to retrieve an const_iterator to first list element </p> <p>Return: iterator to first list element, returns iterator to end() when list is empty </p>","title":"function cbegin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-end","text":"<pre><code>iterator end()\n</code></pre> <p>default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-end_1","text":"<pre><code>const_iterator end() const\n</code></pre> <p>default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-cend","text":"<pre><code>const_iterator cend() const\n</code></pre> <p>default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator-&gt;) </p> <p>Return: iterator to end element, does not contain data. </p>","title":"function cend"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-empty","text":"<pre><code>bool empty() const\n</code></pre> <p>list meta information on filling </p> <p>Return: no elements in list (true), otherwise (false) </p>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-full","text":"<pre><code>bool full() const\n</code></pre> <p>list meta information on filling </p> <p>Return: whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false) </p>","title":"function full"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-size","text":"<pre><code>size_type size() const\n</code></pre> <p>list meta information on filling </p> <p>Return: current number of elements in list @min returns min 0 @max returns max capacity </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-capacity","text":"<pre><code>size_type capacity() const\n</code></pre> <p>list meta information, maximum number of elements the list can contain </p> <p>Return: list has been initialized with the following number of elements. </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-max_size","text":"<pre><code>size_type max_size() const\n</code></pre> <p>list meta information, maximum number of elements the list can contain </p> <p>Return: list has been initialized with the following number of elements, same as capacity()</p>","title":"function max_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-front","text":"<pre><code>T &amp; front()\n</code></pre> <p>Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. </p> <p>Return: reference to the first element </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-front_1","text":"<pre><code>const T &amp; front() const\n</code></pre> <p>Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. </p> <p>Return: const reference to the first element </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-back","text":"<pre><code>T &amp; back()\n</code></pre> <p>Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. </p> <p>Return: reference to the last element </p>","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-back_1","text":"<pre><code>const T &amp; back() const\n</code></pre> <p>Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. </p> <p>Return: const reference to the last element </p>","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_front","text":"<pre><code>bool push_front(\n    const T &amp; data\n)\n</code></pre> <p>add element to the beginning of the list </p> <p>Parameters: </p> <ul> <li>data reference to data element </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_front_1","text":"<pre><code>bool push_front(\n    T &amp;&amp; data\n)\n</code></pre> <p>add element to the beginning of the list via move </p> <p>Parameters: </p> <ul> <li>data universal reference perfectly forwarded to client class </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_back","text":"<pre><code>bool push_back(\n    const T &amp; data\n)\n</code></pre> <p>add element to the end of the list </p> <p>Parameters: </p> <ul> <li>data reference to data element </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_back_1","text":"<pre><code>bool push_back(\n    T &amp;&amp; data\n)\n</code></pre> <p>add element to the end of the list via move </p> <p>Parameters: </p> <ul> <li>data universal reference perfectly forwarded to client class </li> </ul> <p>Return: successful insertion (true), otherwise no element could be added to list (e.g. full -&gt; false) </p>","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-pop_front","text":"<pre><code>bool pop_front()\n</code></pre> <p>remove the first element from the begining of the list element destructor will be invoked </p> <p>Return: successful removal (true), otherwise no element could be taken from list (e.g. empty -&gt; false) </p>","title":"function pop_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-pop_back","text":"<pre><code>bool pop_back()\n</code></pre> <p>remove the last element from the end of the list element destructor will be invoked </p> <p>Return: successful removal (true), otherwise no element could be taken from list (e.g. empty -&gt; false) </p>","title":"function pop_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-clear","text":"<pre><code>void clear()\n</code></pre> <p>remove all elements from the list, list will be empty element destructors will be invoked </p>","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-erase","text":"<pre><code>iterator erase(\n    const_iterator iter\n)\n</code></pre> <p>remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element </p> <p>Parameters: </p> <ul> <li>iter iterator linking the to-be-removed element </li> </ul> <p>Return: an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list </p>","title":"function erase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-remove","text":"<pre><code>size_type remove(\n    const T &amp; data\n)\n</code></pre> <p>remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. </p> <p>Parameters: </p> <ul> <li>data value to compare to </li> </ul> <p>Return: the number of elements removed, return is C++20-conform </p>","title":"function remove"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-remove_if","text":"<pre><code>template &lt;typename UnaryPredicate &gt;\nsize_type remove_if(\n    UnaryPredicate pred\n)\n</code></pre> <p>remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. </p> <p>Parameters: </p> <ul> <li>pred unary predicate which returns true if the element should be removed </li> </ul> <p>Return: the number of elements removed, return is C++20-conform </p>","title":"function remove_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace_front","text":"<pre><code>template &lt;typename... ConstructorArgs&gt;\nT &amp; emplace_front(\n    ConstructorArgs &amp;&amp;... args\n)\n</code></pre> <p>construct element inplace at begining of list </p> <p>Parameters: </p> <ul> <li>args T-typed construction parameters (initializer list) </li> </ul> <p>Return: referene to generated element, return is C++17-conform </p>","title":"function emplace_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace_back","text":"<pre><code>template &lt;typename... ConstructorArgs&gt;\nT &amp; emplace_back(\n    ConstructorArgs &amp;&amp;... args\n)\n</code></pre> <p>construct element inplace at end of list </p> <p>Parameters: </p> <ul> <li>args T-typed construction parameters (initializer list) </li> </ul> <p>Return: referene to generated element, return is C++17-conform </p>","title":"function emplace_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace","text":"<pre><code>template &lt;typename... ConstructorArgs&gt;\niterator emplace(\n    const_iterator iter,\n    ConstructorArgs &amp;&amp;... args\n)\n</code></pre> <p>construct element inplace at iterator position </p> <p>Parameters: </p> <ul> <li>args T-typed construction parameters (initializer list) </li> <li>iter position in list to (construct)insert after </li> </ul> <p>Return: iterator to the newly added element </p>","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-insert","text":"<pre><code>iterator insert(\n    const_iterator citer,\n    const T &amp; data\n)\n</code></pre> <p>insert element before iterator position </p> <p>Parameters: </p> <ul> <li>citer iterator with the position to insert after </li> <li>data reference to element to add </li> </ul> <p>Return: iterator to the newly added element </p>","title":"function insert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-insert_1","text":"<pre><code>iterator insert(\n    const_iterator citer,\n    T &amp;&amp; data\n)\n</code></pre> <p>add element before the pointed-to element via move </p> <p>Parameters: </p> <ul> <li>citer iterator with the position to insert after </li> <li>data universal reference perfectly forwarded to client class </li> </ul> <p>Return: iterator to the newly added element </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function insert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/","text":"<p>nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate()  More...</p>","title":"iox::cxx::list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-types","text":"Name     using std::bidirectional_iterator_tag iterator_category   using typename std::conditional&lt; IsConstIterator, const T, T &gt;::type value_type   using void difference_type   using typename std::conditional&lt; IsConstIterator, const T *, T * &gt;::type pointer   using typename std::conditional&lt; IsConstIterator, const T &amp;, T &amp; &gt;::type reference","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-functions","text":"Name      IteratorBase(const IteratorBase&lt; false &gt; &amp; iter)construct a const_iterator from an iterator   IteratorBase &amp; operator=(const IteratorBase&lt; false &gt; &amp; rhs)assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented   IteratorBase &amp; operator++()prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end   IteratorBase &amp; operator--()prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin())   template &lt;bool IsConstIteratorOther&gt; bool operator==(const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs) constcomparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked   template &lt;bool IsConstIteratorOther&gt; bool operator!=(const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs) constcomparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked   reference operator*() constdereferencing element content via iterator-position element   pointer operator-&gt;() constdereferencing element content via iterator-position element","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friends","text":"Name     class IteratorBase&lt; true &gt;   class list&lt; T, Capacity &gt;","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#detailed-description","text":"<pre><code>template &lt;bool IsConstIterator =true&gt;\nclass iox::cxx::list::IteratorBase;\n</code></pre> <p>nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-iterator_category","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::iterator_category =  std::bidirectional_iterator_tag;\n</code></pre>","title":"using iterator_category"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-value_type","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::value_type =  typename std::conditional&lt;IsConstIterator, const T, T&gt;::type;\n</code></pre>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-difference_type","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::difference_type =  void;\n</code></pre>","title":"using difference_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-pointer","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::pointer =  typename std::conditional&lt;IsConstIterator, const T*, T*&gt;::type;\n</code></pre>","title":"using pointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-reference","text":"<pre><code>using iox::cxx::list&lt; T, Capacity &gt;::IteratorBase&lt; IsConstIterator &gt;::reference =  typename std::conditional&lt;IsConstIterator, const T&amp;, T&amp;&gt;::type;\n</code></pre>","title":"using reference"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-iteratorbase","text":"<pre><code>IteratorBase(\n    const IteratorBase&lt; false &gt; &amp; iter\n)\n</code></pre> <p>construct a const_iterator from an iterator </p> <p>Parameters: </p> <ul> <li>iter is the iterator which will deliver list and index info for the const_iterator </li> </ul>","title":"function IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator","text":"<pre><code>IteratorBase &amp; operator=(\n    const IteratorBase&lt; false &gt; &amp; rhs\n)\n</code></pre> <p>assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented </p> <p>Parameters: </p> <ul> <li>rhs is the iterator which will deliver list and index info for the const_iterator </li> </ul> <p>Return: reference to this iterator object </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_1","text":"<pre><code>IteratorBase &amp; operator++()\n</code></pre> <p>prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end </p> <p>Return: reference to this iterator object </p>","title":"function operator++"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator-","text":"<pre><code>IteratorBase &amp; operator--()\n</code></pre> <p>prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin()) </p> <p>Return: reference to this iterator object </p>","title":"function operator--"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_2","text":"<pre><code>template &lt;bool IsConstIteratorOther&gt;\nbool operator==(\n    const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs\n) const\n</code></pre> <p>comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked </p> <p>Parameters: </p> <ul> <li>rhs is the 2nd iterator to compare to </li> </ul> <p>Return: list position for two iterators is the same (true) or different (false) </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_3","text":"<pre><code>template &lt;bool IsConstIteratorOther&gt;\nbool operator!=(\n    const IteratorBase&lt; IsConstIteratorOther &gt; &amp; rhs\n) const\n</code></pre> <p>comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -&gt; there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked </p> <p>Parameters: </p> <ul> <li>rhs is the 2nd iterator to compare to </li> </ul> <p>Return: list position for two iterators is the same (true) or different (false) </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_4","text":"<pre><code>reference operator*() const\n</code></pre> <p>dereferencing element content via iterator-position element </p> <p>Return: reference to list element data </p>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator-_1","text":"<pre><code>pointer operator-&gt;() const\n</code></pre> <p>dereferencing element content via iterator-position element </p> <p>Return: pointer to const list data element </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friend-iteratorbase-true","text":"<pre><code>friend class IteratorBase&lt; true &gt;(\n    IteratorBase&lt; true &gt; \n);\n</code></pre>","title":"friend IteratorBase&lt; true &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friend-list-t-capacity","text":"<pre><code>friend class list&lt; T, Capacity &gt;(\n    list&lt; T, Capacity &gt; \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend list&lt; T, Capacity &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/","text":"<p>Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/optional.hpp&gt;</code></p>","title":"iox::cxx::optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-types","text":"Name     using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-functions","text":"Name      optional()Creates an optional which has no value. If you access such an optional via .value() or the arrow operator the behavior is undefined.    optional(const nullopt_t &amp; )Creates an optional which has no value. If you access such an optional via .value() or the arrow operator the behavior is defined in the cxx::Expects handling.    optional(T &amp;&amp; value)Creates an optional by forwarding value to the constructor of T. This optional has a value.    optional(const T &amp; value)Creates an optional by using the copy constructor of T.   template &lt;typename... Targs&gt;  optional(in_place_t , Targs &amp;&amp;... args)Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable.    ~optional()The destructor will call the destructor of T if a value is set.    optional(const optional &amp; rhs)Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value.    optional(optional &amp;&amp; rhs)Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value.   optional &amp; operator=(const optional &amp; rhs)Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor.   optional &amp; operator=(optional &amp;&amp; rhs)Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor.   constexpr bool operator==(const optional&lt; T &gt; &amp; rhs) constIf the optionals have values it compares these values by using their comparison operator.   constexpr bool operator==(const nullopt_t &amp; ) constComparison with nullopt_t for easier unset optional comparison.   constexpr bool operator!=(const optional&lt; T &gt; &amp; rhs) constIf the optionals have values it compares these values by using their comparison operator.   constexpr bool operator!=(const nullopt_t &amp; ) constComparision with nullopt_t for easier unset optional comparison.   template &lt;typename U  =T&gt; std::enable_if&lt;!std::is_same&lt; U, optional&lt; T &gt; &amp; &gt;::value, optional &gt;::type &amp; operator=(U &amp;&amp; value)Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called.   const T * operator-&gt;() constReturns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it.   const T &amp; operator*() constReturns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it.   T * operator-&gt;()Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it.   T &amp; operator*()Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it.   constexpr operator bool() constWill return true if the optional contains a value, otherwise false.   constexpr bool has_value() constWill return true if the optional contains a value, otherwise false.   template &lt;typename... Targs&gt; T &amp; emplace(Targs &amp;&amp;... args)A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called.   void reset()Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value.   T &amp; value()Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it.   const T &amp; value() constReturns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it.   T &amp;&amp; value()Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it.   const T &amp;&amp; value() constReturns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it.   template &lt;typename U &gt; constexpr T value_or(U &amp;&amp; default_value) constIf the optional contains a value a copy of that value is returned, otherwise the default_value is returned.   optional &amp; and_then(const cxx::function_ref&lt; void(T &amp;)&gt; &amp; callable)calls the provided callable with the optional value as arguments if the optional contains a value   const optional &amp; and_then(const cxx::function_ref&lt; void(const T &amp;)&gt; &amp; callable) constcalls the provided callable with the optional value as arguments if the optional contains a value   optional &amp; or_else(const cxx::function_ref&lt; void()&gt; &amp; callable)calls the provided callable if the optional does not contain a value   const optional &amp; or_else(const cxx::function_ref&lt; void()&gt; &amp; callable) constcalls the provided callable if the optional does not contain a value","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::cxx::optional;\n</code></pre> <p>Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. </p> <pre><code>#include \"iceoryx_hoofs/cxx/optional.hpp\"\n\ncxx::optional&lt;void*&gt; SomeFactory() {\n    void *memory = malloc(1234);\n    if ( memory == nullptr )\n        return cxx::nullopt_t();\n    else\n        return cxx::make_optional&lt;void*&gt;(memory);\n}\n\nint main() {\n    auto var = SomeFactory();\n    // never forget the has_value call before working with an optional\n    if ( var.has_value() ) {\n        // do stuff with var\n    }\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#using-type","text":"<pre><code>using iox::cxx::optional&lt; T &gt;::type =  T;\n</code></pre>","title":"using type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional","text":"<pre><code>optional()\n</code></pre> <p>Creates an optional which has no value. If you access such an optional via .value() or the arrow operator the behavior is undefined. </p>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_1","text":"<pre><code>optional(\n    const nullopt_t &amp; \n)\n</code></pre> <p>Creates an optional which has no value. If you access such an optional via .value() or the arrow operator the behavior is defined in the cxx::Expects handling. </p>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_2","text":"<pre><code>optional(\n    T &amp;&amp; value\n)\n</code></pre> <p>Creates an optional by forwarding value to the constructor of T. This optional has a value. </p> <p>Parameters: </p> <ul> <li>value rvalue of type T which will be moved into the optional </li> </ul>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_3","text":"<pre><code>optional(\n    const T &amp; value\n)\n</code></pre> <p>Creates an optional by using the copy constructor of T. </p> <p>Parameters: </p> <ul> <li>value lvalue of type T which will be copy constructed into the optional </li> </ul>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_4","text":"<pre><code>template &lt;typename... Targs&gt;\noptional(\n    in_place_t ,\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable. </p> <p>Parameters: </p> <ul> <li>in_place_t compile time variable to distinguish between constructors with certain behavior </li> </ul> <p>Template Parameters: </p> <ul> <li>Targs is the template parameter pack for the perfectly forwarded arguments </li> </ul>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_5","text":"<pre><code>~optional()\n</code></pre> <p>The destructor will call the destructor of T if a value is set. </p>","title":"function ~optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_6","text":"<pre><code>optional(\n    const optional &amp; rhs\n)\n</code></pre> <p>Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value. </p> <p>Parameters: </p> <ul> <li>rhs source of the copy </li> </ul>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_7","text":"<pre><code>optional(\n    optional &amp;&amp; rhs\n)\n</code></pre> <p>Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value. </p> <p>Parameters: </p> <ul> <li>rhs source of the move </li> </ul>","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator","text":"<pre><code>optional &amp; operator=(\n    const optional &amp; rhs\n)\n</code></pre> <p>Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor. </p> <p>Parameters: </p> <ul> <li>rhs source of the copy </li> </ul> <p>Return: reference to the current optional </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_1","text":"<pre><code>optional &amp; operator=(\n    optional &amp;&amp; rhs\n)\n</code></pre> <p>Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor. </p> <p>Parameters: </p> <ul> <li>rhs source of the move </li> </ul> <p>Return: reference to the current optional </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_2","text":"<pre><code>constexpr bool operator==(\n    const optional&lt; T &gt; &amp; rhs\n) const\n</code></pre> <p>If the optionals have values it compares these values by using their comparison operator. </p> <p>Parameters: </p> <ul> <li>rhs value to which this optional should be compared to </li> </ul> <p>Return: true if the contained values are equal, otherwise false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_3","text":"<pre><code>constexpr bool operator==(\n    const nullopt_t &amp; \n) const\n</code></pre> <p>Comparison with nullopt_t for easier unset optional comparison. </p> <p>Return: true if the optional is unset, otherwise false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_4","text":"<pre><code>constexpr bool operator!=(\n    const optional&lt; T &gt; &amp; rhs\n) const\n</code></pre> <p>If the optionals have values it compares these values by using their comparison operator. </p> <p>Parameters: </p> <ul> <li>rhs value to which this optional should be compared to </li> </ul> <p>Return: true if the contained values are not equal, otherwise false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_5","text":"<pre><code>constexpr bool operator!=(\n    const nullopt_t &amp; \n) const\n</code></pre> <p>Comparision with nullopt_t for easier unset optional comparison. </p> <p>Return: true if the optional is set, otherwise false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_6","text":"<pre><code>template &lt;typename U  =T&gt;\nstd::enable_if&lt;!std::is_same&lt; U, optional&lt; T &gt; &amp; &gt;::value, optional &gt;::type &amp; operator=(\n    U &amp;&amp; value\n)\n</code></pre> <p>Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called. </p> <p>Parameters: </p> <ul> <li>value value to assign to the underlying optional value </li> </ul> <p>Return: reference to the current optional </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-","text":"<pre><code>const T * operator-&gt;() const\n</code></pre> <p>Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: pointer of type const T to the underlying type </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_7","text":"<pre><code>const T &amp; operator*() const\n</code></pre> <p>Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: reference of type const T to the underlying type </p>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-_1","text":"<pre><code>T * operator-&gt;()\n</code></pre> <p>Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: pointer of type T to the underlying type </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_8","text":"<pre><code>T &amp; operator*()\n</code></pre> <p>Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: reference of type T to the underlying type </p>","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-bool","text":"<pre><code>explicit constexpr operator bool() const\n</code></pre> <p>Will return true if the optional contains a value, otherwise false. </p> <p>Return: true if optional contains a value, otherwise false </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-has_value","text":"<pre><code>constexpr bool has_value() const\n</code></pre> <p>Will return true if the optional contains a value, otherwise false. </p> <p>Return: true if optional contains a value, otherwise false </p>","title":"function has_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-emplace","text":"<pre><code>template &lt;typename... Targs&gt;\nT &amp; emplace(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called. </p> <p>Parameters: </p> <ul> <li>perfectly forwards args to the constructor of T to perform a placement new </li> </ul> <p>Return: reference to the underlying type </p>","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-reset","text":"<pre><code>void reset()\n</code></pre> <p>Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value. </p>","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value","text":"<pre><code>T &amp; value()\n</code></pre> <p>Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: reference to the underlying type </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_1","text":"<pre><code>const T &amp; value() const\n</code></pre> <p>Returns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: const reference to the underlying type </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_2","text":"<pre><code>T &amp;&amp; value()\n</code></pre> <p>Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: rvalue reference to the underlying type </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_3","text":"<pre><code>const T &amp;&amp; value() const\n</code></pre> <p>Returns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. </p> <p>Return: const rvalue reference to the underlying type </p>","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_or","text":"<pre><code>template &lt;typename U &gt;\nconstexpr T value_or(\n    U &amp;&amp; default_value\n) const\n</code></pre> <p>If the optional contains a value a copy of that value is returned, otherwise the default_value is returned. </p> <p>Return: copy of the underlying type if the optional has a value otherwise a copy of default_value </p>","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-and_then","text":"<pre><code>optional &amp; and_then(\n    const cxx::function_ref&lt; void(T &amp;)&gt; &amp; callable\n)\n</code></pre> <p>calls the provided callable with the optional value as arguments if the optional contains a value </p> <p>Parameters: </p> <ul> <li>callable which has T as argument </li> </ul> <p>Return: reference to this </p>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-and_then_1","text":"<pre><code>const optional &amp; and_then(\n    const cxx::function_ref&lt; void(const T &amp;)&gt; &amp; callable\n) const\n</code></pre> <p>calls the provided callable with the optional value as arguments if the optional contains a value </p> <p>Parameters: </p> <ul> <li>callable which has T as argument </li> </ul> <p>Return: reference to this </p>","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-or_else","text":"<pre><code>optional &amp; or_else(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n)\n</code></pre> <p>calls the provided callable if the optional does not contain a value </p> <p>Parameters: </p> <ul> <li>callable </li> </ul> <p>Return: reference to this </p>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-or_else_1","text":"<pre><code>const optional &amp; or_else(\n    const cxx::function_ref&lt; void()&gt; &amp; callable\n) const\n</code></pre> <p>calls the provided callable if the optional does not contain a value </p> <p>Parameters: </p> <ul> <li>callable </li> </ul> <p>Return: reference to this </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/","text":"<p>stack implementation with a simple push pop interface  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/stack.hpp&gt;</code></p>","title":"iox::cxx::stack"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#public-functions","text":"Name     cxx::optional&lt; T &gt; pop()returns the last pushed element when the stack contains elements otherwise a cxx::nullopt   template &lt;typename... Targs&gt; bool push(Targs &amp;&amp;... args)pushed an element into the stack by forwarding all arguments to the constructor of T   uint64_t size() constreturns the stack size   constexpr uint64_t capacity()returns the stack capacity","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#detailed-description","text":"<pre><code>template &lt;typename T ,\nuint64_t Capacity&gt;\nclass iox::cxx::stack;\n</code></pre> <p>stack implementation with a simple push pop interface </p> <p>Template Parameters: </p> <ul> <li>T type which the stack contains </li> <li>Capacity the capacity of the stack </li> </ul>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-pop","text":"<pre><code>cxx::optional&lt; T &gt; pop()\n</code></pre> <p>returns the last pushed element when the stack contains elements otherwise a cxx::nullopt </p>","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-push","text":"<pre><code>template &lt;typename... Targs&gt;\nbool push(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>pushed an element into the stack by forwarding all arguments to the constructor of T </p> <p>Parameters: </p> <ul> <li>args arguments which will be perfectly forwarded to the constructor of T </li> </ul> <p>Return: true if the push was successful, otherwise false </p>","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>returns the stack size </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-capacity","text":"<pre><code>static constexpr uint64_t capacity()\n</code></pre> <p>returns the stack capacity </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/","text":"<p>string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/string.hpp&gt;</code></p>","title":"iox::cxx::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#public-functions","text":"Name     constexpr string() =defaultcreates an empty string with size 0    string(const string &amp; other)copy constructor    string(string &amp;&amp; other)move constructor   string &amp; operator=(const string &amp; rhs)copy assignment   string &amp; operator=(string &amp;&amp; rhs)move assignment   template &lt;uint64_t N&gt;  string(const string&lt; N &gt; &amp; other)creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity   template &lt;uint64_t N&gt;  string(string&lt; N &gt; &amp;&amp; other)moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity   template &lt;uint64_t N&gt; string &amp; operator=(const string&lt; N &gt; &amp; rhs)assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity   template &lt;uint64_t N&gt; string &amp; operator=(string&lt; N &gt; &amp;&amp; rhs)moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity   template &lt;uint64_t N&gt;  string(const char(&amp;) other[N])conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity    string(TruncateToCapacity_t , const char *const other)conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity    string(TruncateToCapacity_t , const std::string &amp; other)conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity    string(TruncateToCapacity_t , const char *const other, const uint64_t count)constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated.   template &lt;uint64_t N&gt; string &amp; operator=(const char(&amp;) rhs[N])assigns a char array to string with compile time check if the array size is less than or equal to the string capacity   template &lt;uint64_t N&gt; string &amp; assign(const string&lt; N &gt; &amp; str)fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity   template &lt;uint64_t N&gt; string &amp; assign(const char(&amp;) str[N])assigns a char array to string with compile time check if the array size is less than or equal to the string capacity   bool unsafe_assign(const char *const str)assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity.   bool unsafe_assign(const std::string &amp; str)assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity.   template &lt;uint64_t N&gt; int64_t compare(const string&lt; N &gt; &amp; other) constcompares two strings   template &lt;uint64_t N&gt; bool operator==(const string&lt; N &gt; &amp; rhs) constchecks if self is equal to rhs   template &lt;uint64_t N&gt; bool operator!=(const string&lt; N &gt; &amp; rhs) constchecks if self is not equal to rhs   template &lt;uint64_t N&gt; bool operator&lt;(const string&lt; N &gt; &amp; rhs) constchecks if self is less than rhs, in lexicographical order   template &lt;uint64_t N&gt; bool operator&lt;=(const string&lt; N &gt; &amp; rhs) constchecks if self is less than or equal to rhs, in lexicographical order   template &lt;uint64_t N&gt; bool operator&gt;(const string&lt; N &gt; &amp; rhs) constchecks if self is greater than rhs, in lexicographical order   template &lt;uint64_t N&gt; bool operator&gt;=(const string&lt; N &gt; &amp; rhs) constchecks if self is greater than or equal to rhs, in lexicographical order   bool operator==(const char *const rhs) constThe equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string.   bool operator!=(const char *const rhs) constThe inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string.   const char * c_str() constreturns a pointer to the char array of self   constexpr uint64_t size() constreturns the number of characters stored in the string   constexpr bool empty() constreturns if the string is empty or not    operator std::string() constconverts the string to a std::string   template &lt;typename T &gt; string &amp; operator+=(const T &amp; )since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case   template &lt;typename T &gt; std::enable_if&lt; internal::IsCharArray&lt; T &gt;::value    template &lt;typename T &gt; std::enable_if&lt; internal::IsCharArray&lt; T &gt;::value    iox::cxx::optional&lt; string&lt; Capacity &gt; &gt; substr(const uint64_t pos, const uint64_t count) constcreates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size(); iox::cxx::nullopt is returned if pos is greater than the size of the original string;   iox::cxx::optional&lt; string&lt; Capacity &gt; &gt; substr(const uint64_t pos =0U) constcreates a substring containing the characters from pos until size(); iox::cxx::nullopt is returned if pos is greater than the size of the original string   template &lt;typename T &gt; std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value    template &lt;typename T &gt; std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value    template &lt;typename T &gt; std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value    constexpr uint64_t capacity()returns the maximum number of characters that can be stored in the string","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friends","text":"Name     class string   std::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#detailed-description","text":"<pre><code>template &lt;uint64_t Capacity&gt;\nclass iox::cxx::string;\n</code></pre> <p>string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string","text":"<pre><code>constexpr string() =default\n</code></pre> <p>creates an empty string with size 0 </p>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_1","text":"<pre><code>string(\n    const string &amp; other\n)\n</code></pre> <p>copy constructor </p> <p>Parameters: </p> <ul> <li>other is the copy origin </li> </ul>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_2","text":"<pre><code>string(\n    string &amp;&amp; other\n)\n</code></pre> <p>move constructor </p> <p>Parameters: </p> <ul> <li>other is the move origin </li> </ul>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator","text":"<pre><code>string &amp; operator=(\n    const string &amp; rhs\n)\n</code></pre> <p>copy assignment </p> <p>Parameters: </p> <ul> <li>rhs is the copy origin</li> </ul> <p>Return: reference to self </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_1","text":"<pre><code>string &amp; operator=(\n    string &amp;&amp; rhs\n)\n</code></pre> <p>move assignment </p> <p>Parameters: </p> <ul> <li>rhs is the move origin</li> </ul> <p>Return: reference to self </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_3","text":"<pre><code>template &lt;uint64_t N&gt;\nstring(\n    const string&lt; N &gt; &amp; other\n)\n</code></pre> <p>creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity </p> <p>Parameters: </p> <ul> <li>other is the copy origin </li> </ul>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_4","text":"<pre><code>template &lt;uint64_t N&gt;\nstring(\n    string&lt; N &gt; &amp;&amp; other\n)\n</code></pre> <p>moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity </p> <p>Parameters: </p> <ul> <li>other is the move origin </li> </ul>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_2","text":"<pre><code>template &lt;uint64_t N&gt;\nstring &amp; operator=(\n    const string&lt; N &gt; &amp; rhs\n)\n</code></pre> <p>assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity </p> <p>Parameters: </p> <ul> <li>rhs is the copy origin</li> </ul> <p>Return: reference to self </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_3","text":"<pre><code>template &lt;uint64_t N&gt;\nstring &amp; operator=(\n    string&lt; N &gt; &amp;&amp; rhs\n)\n</code></pre> <p>moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity </p> <p>Parameters: </p> <ul> <li>rhs is the move origin</li> </ul> <p>Return: reference to self </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_5","text":"<pre><code>template &lt;uint64_t N&gt;\nstring(\n    const char(&amp;) other[N]\n)\n</code></pre> <p>conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity </p> <p>Parameters: </p> <ul> <li>other is the char array</li> </ul> <p>Template Parameters: </p> <ul> <li>N is the implicit template parameter for the char array size </li> </ul> <p>Note: if the array is not zero-terminated, the last value will be overwritten with 0</p> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    string&lt;4&gt; fuu(\"abcd\");\n}\n</code></pre>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_6","text":"<pre><code>string(\n    TruncateToCapacity_t ,\n    const char *const other\n)\n</code></pre> <p>conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity </p> <p>Parameters: </p> <ul> <li>TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior </li> <li>other is the cstring to convert </li> </ul> <p>Attention: truncates characters if the size is greater than the string capacity</p> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    string&lt;4&gt; fuu(TruncateToCapacity, \"abcd\");\n}\n</code></pre>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_7","text":"<pre><code>string(\n    TruncateToCapacity_t ,\n    const std::string &amp; other\n)\n</code></pre> <p>conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity </p> <p>Parameters: </p> <ul> <li>TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior </li> <li>other is the std::string to convert </li> </ul> <p>Attention: truncates characters if the std::string size is greater than the string capacity</p> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    std::string bar = \"bar\";\n    string&lt;4&gt; fuu(TruncateToCapacity, bar);\n}\n</code></pre>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_8","text":"<pre><code>string(\n    TruncateToCapacity_t ,\n    const char *const other,\n    const uint64_t count\n)\n</code></pre> <p>constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated. </p> <p>Parameters: </p> <ul> <li>TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior </li> <li>other is the cstring to convert </li> <li>count is the number of characters for constructing the string</li> </ul> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    string&lt;4&gt; fuu(TruncateToCapacity, \"abcd\", 2);\n}\n</code></pre>","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_4","text":"<pre><code>template &lt;uint64_t N&gt;\nstring &amp; operator=(\n    const char(&amp;) rhs[N]\n)\n</code></pre> <p>assigns a char array to string with compile time check if the array size is less than or equal to the string capacity </p> <p>Parameters: </p> <ul> <li>rhs is the char array</li> </ul> <p>Template Parameters: </p> <ul> <li>[in] N is the implicit template parameter for the char array size </li> </ul> <p>Return: reference to self</p> <p>Note: if the array is not zero-terminated, the last value will be overwritten with 0</p> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    string&lt;4&gt; fuu = \"abcd\";\n}\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-assign","text":"<pre><code>template &lt;uint64_t N&gt;\nstring &amp; assign(\n    const string&lt; N &gt; &amp; str\n)\n</code></pre> <p>fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity </p> <p>Parameters: </p> <ul> <li>str is the fixed string object to assign</li> </ul> <p>Return: reference to self </p>","title":"function assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-assign_1","text":"<pre><code>template &lt;uint64_t N&gt;\nstring &amp; assign(\n    const char(&amp;) str[N]\n)\n</code></pre> <p>assigns a char array to string with compile time check if the array size is less than or equal to the string capacity </p> <p>Parameters: </p> <ul> <li>str is the char array</li> </ul> <p>Template Parameters: </p> <ul> <li>[in] N is the implicit template parameter for the char array size </li> </ul> <p>Return: reference to self</p> <p>Note: if the array is not zero-terminated, the last value will be overwritten with 0</p> <pre><code>#include \"iceoryx_hoofs/cxx/string.hpp\"\nusing namespace iox::cxx;\n\nint main()\n{\n    string&lt;4&gt; fuu;\n    char bar[] = \"abcd\";\n    fuu.assign(bar);\n}\n</code></pre>","title":"function assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_assign","text":"<pre><code>bool unsafe_assign(\n    const char *const str\n)\n</code></pre> <p>assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity. </p> <p>Parameters: </p> <ul> <li>str is the cstring to assign</li> </ul> <p>Return: true if the assignment succeeds, otherwise false </p>","title":"function unsafe_assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_assign_1","text":"<pre><code>bool unsafe_assign(\n    const std::string &amp; str\n)\n</code></pre> <p>assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity. </p> <p>Parameters: </p> <ul> <li>str is the std::string to assign</li> </ul> <p>Return: true if the assignment succeeds, otherwise false </p>","title":"function unsafe_assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-compare","text":"<pre><code>template &lt;uint64_t N&gt;\nint64_t compare(\n    const string&lt; N &gt; &amp; other\n) const\n</code></pre> <p>compares two strings </p> <p>Parameters: </p> <ul> <li>other is the string to compare with self</li> </ul> <p>Return: an integer &lt; 0 if the first character that does not match has a lower value in self than in other, 0 if the contents of both strings are equal, an integer &gt; 0 if the first character that does not match has a greater value in self than in other </p>","title":"function compare"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_5","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator==(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is equal to rhs </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if both strings are equal, otherwise false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_6","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator!=(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is not equal to rhs </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if both strings are not equal, otherwise false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_7","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator&lt;(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is less than rhs, in lexicographical order </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if self is less than rhs, otherwise false </p>","title":"function operator&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_8","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator&lt;=(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is less than or equal to rhs, in lexicographical order </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if self is less than or equal to rhs, otherwise false </p>","title":"function operator&lt;="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_9","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator&gt;(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is greater than rhs, in lexicographical order </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if self is greater than rhs, otherwise false </p>","title":"function operator&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_10","text":"<pre><code>template &lt;uint64_t N&gt;\nbool operator&gt;=(\n    const string&lt; N &gt; &amp; rhs\n) const\n</code></pre> <p>checks if self is greater than or equal to rhs, in lexicographical order </p> <p>Parameters: </p> <ul> <li>rhs is the string to compare with self</li> </ul> <p>Return: true if self is greater than or equal to rhs, otherwise false </p>","title":"function operator&gt;="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_11","text":"<pre><code>bool operator==(\n    const char *const rhs\n) const\n</code></pre> <p>The equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. </p> <p>Parameters: </p> <ul> <li>rhs is the char pointer to the array to compare</li> </ul> <p>Return: false</p> <p>Todo: consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template  bool operator==(const char (&amp;rhs)[N]) const noexcept","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_12","text":"<pre><code>bool operator!=(\n    const char *const rhs\n) const\n</code></pre> <p>The inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. </p> <p>Parameters: </p> <ul> <li>rhs is the char pointer to the array to compare</li> </ul> <p>Return: false</p> <p>Todo: consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template  bool operator!=(const char (&amp;rhs)[N]) const noexcept","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-c_str","text":"<pre><code>const char * c_str() const\n</code></pre> <p>returns a pointer to the char array of self </p> <p>Return: a pointer to the char array of self </p>","title":"function c_str"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-size","text":"<pre><code>constexpr uint64_t size() const\n</code></pre> <p>returns the number of characters stored in the string </p> <p>Return: the number of characters stored in the string </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-empty","text":"<pre><code>constexpr bool empty() const\n</code></pre> <p>returns if the string is empty or not </p> <p>Return: true if size() == 0 otherwise false </p>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator-stdstring","text":"<pre><code>operator std::string() const\n</code></pre> <p>converts the string to a std::string </p> <p>Return: a std::string with data equivalent to those stored in the string </p>","title":"function operator std::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_13","text":"<pre><code>template &lt;typename T &gt;\nstring &amp; operator+=(\n    const T &amp; \n)\n</code></pre> <p>since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case </p>","title":"function operator+="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-append","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt; internal::IsCharArray&lt; T &gt;::value||internal::IsCxxString&lt; T &gt;::value, string &amp; &gt;::type append(\n    TruncateToCapacity_t ,\n    const T &amp; t\n)\n</code></pre> <p>appends a fixed string or string literal to the end of this. If this' capacity is too small for appending the whole string (literal) the remainder of the characters are truncated. </p> <p>Parameters: </p> <ul> <li>TruncateToCapacity_t is a compile time variable which is used to make the user aware of the possible truncation </li> <li>t is the fixed string/string literal to append</li> </ul> <p>Return: reference to self</p> <pre><code>string&lt;5&gt; fuu(\"cde\");\nfuu.append(TruncateToCapacity, \"fgahc\");\n</code></pre>","title":"function append"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_append","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt; internal::IsCharArray&lt; T &gt;::value||internal::IsCxxString&lt; T &gt;::value, bool &gt;::type unsafe_append(\n    const T &amp; t\n)\n</code></pre> <p>appends a fixed string or string literal to the end of this. The appending fails if the sum of both sizes is greater than this' capacity. </p> <p>Parameters: </p> <ul> <li>fixed string/string literal to append</li> </ul> <p>Return: true if the appending succeeds, otherwise false </p>","title":"function unsafe_append"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-substr","text":"<pre><code>iox::cxx::optional&lt; string&lt; Capacity &gt; &gt; substr(\n    const uint64_t pos,\n    const uint64_t count\n) const\n</code></pre> <p>creates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size(); iox::cxx::nullopt is returned if pos is greater than the size of the original string; </p> <p>Parameters: </p> <ul> <li>pos is the position of the first character used for the substring </li> <li>count is the requested length of the substring</li> </ul> <p>Return: an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string </p>","title":"function substr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-substr_1","text":"<pre><code>iox::cxx::optional&lt; string&lt; Capacity &gt; &gt; substr(\n    const uint64_t pos =0U\n) const\n</code></pre> <p>creates a substring containing the characters from pos until size(); iox::cxx::nullopt is returned if pos is greater than the size of the original string </p> <p>Parameters: </p> <ul> <li>pos is the position of the first character used for the substring</li> </ul> <p>Return: an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string </p>","title":"function substr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt; std::is_same&lt; T, std::string &gt;::value||internal::IsCharArray&lt; T &gt;::value||internal::IsCxxString&lt; T &gt;::value, iox::cxx::optional&lt; uint64_t &gt; &gt;::type find(\n    const T &amp; t,\n    const uint64_t pos =0U\n) const\n</code></pre> <p>finds the first occurence of the given character sequence; returns the position of the first character of the found substring, returns iox::cxx::nullopt if no substring is found or if pos is greater than this' size </p> <p>Parameters: </p> <ul> <li>t is the character sequence to search for; must be a cxx::string, string literal or std::string </li> <li>pos is the position at which to start the search</li> </ul> <p>Return: an optional containing the position of the first character of the found substring, iox::cxx::nullopt if no substring is found </p>","title":"function find"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find_first_of","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt; std::is_same&lt; T, std::string &gt;::value||internal::IsCharArray&lt; T &gt;::value||internal::IsCxxString&lt; T &gt;::value, iox::cxx::optional&lt; uint64_t &gt; &gt;::type find_first_of(\n    const T &amp; t,\n    const uint64_t pos =0U\n) const\n</code></pre> <p>finds the first occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found or if pos is greater than this' size </p> <p>Parameters: </p> <ul> <li>t is the character sequence to search for; must be a cxx::string, string literal or std::string </li> <li>pos is the position at which to start the search</li> </ul> <p>Return: an optional containing the position of the first character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found </p>","title":"function find_first_of"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find_last_of","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt; std::is_same&lt; T, std::string &gt;::value||internal::IsCharArray&lt; T &gt;::value||internal::IsCxxString&lt; T &gt;::value, iox::cxx::optional&lt; uint64_t &gt; &gt;::type find_last_of(\n    const T &amp; t,\n    const uint64_t pos =Capacity\n) const\n</code></pre> <p>finds the last occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found </p> <p>Parameters: </p> <ul> <li>t is the character sequence to search for; must be a cxx::string, string literal or std::string </li> <li>pos is the position at which to finish the search</li> </ul> <p>Return: an optional containing the position of the last character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found </p>","title":"function find_last_of"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-capacity","text":"<pre><code>static constexpr uint64_t capacity()\n</code></pre> <p>returns the maximum number of characters that can be stored in the string </p> <p>Return: the maximum number of characters that can be stored in the string </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friend-string","text":"<pre><code>friend class string(\n    string \n);\n</code></pre>","title":"friend string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friend-concatenate","text":"<pre><code>friend std::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value||internal::IsCxxString&lt; T1 &gt;::value) &amp;&amp;(internal::IsCharArray&lt; T2 &gt;::value||internal::IsCxxString&lt; T2 &gt;::value), string&lt; internal::GetCapa&lt; T1 &gt;::capa+internal::GetCapa&lt; T2 &gt;::capa &gt; &gt;::type concatenate(\n    const T1 &amp; t1,\n\n    const T2 &amp; t2\n);\n</code></pre> <p>concatenates two fixed strings/string literals </p> <p>Parameters: </p> <ul> <li>fixed strings/string literals to concatenate</li> </ul> <p>Return: a new fixed string with capacity equal to the sum of the capacities of the concatenated strings</p> <pre><code>string&lt;5&gt; fuu(\"cdefg\");\nauto bar = iox::cxx::concatenate(fuu, \"ahc\");\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend concatenate"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/","text":"<p>The unique_ptr class is a heap-less unique ptr implementation, unlike the STL.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/unique_ptr.hpp&gt;</code></p>","title":"iox::cxx::unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#public-functions","text":"Name      unique_ptr()    unique_ptr(function_ref&lt; void(T *)&gt; &amp;&amp; deleter)unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset.    unique_ptr(T const ptr, function_ref&lt; void(T )&gt; &amp;&amp; deleter)unique_ptr Creates a unique pointer that takes ownership of an object.    unique_ptr(const unique_ptr &amp; other)   unique_ptr &amp; operator=(const unique_ptr &amp; )    unique_ptr(unique_ptr &amp;&amp; rhs)   unique_ptr &amp; operator=(unique_ptr &amp;&amp; rhs)    ~unique_ptr()   unique_ptr&lt; T &gt; &amp; operator=(std::nullptr_t )   T * operator-&gt;()operator -&gt; Transparent access to the managed object.   const T * operator-&gt;() constoperator -&gt; Transparent access to the managed object.    operator bool() constoperator bool Returns true if it points to something.   T * get()get Retrieve the underlying raw pointer.   const T * get() constget Retrieve the underlying raw pointer.   T * release()release Release ownership of the underlying pointer.   void reset(T *const ptr =nullptr)reset Reset the unique pointer to take ownership of the given pointer.   void swap(unique_ptr &amp; other)swap Swaps object ownership with another unique_ptr (incl. deleters)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::cxx::unique_ptr;\n</code></pre> <p>The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. </p> <p>To avoid using the heap, deleters are not managed by the pointer itself, and instead must be provided as function references ('cxx:function_ref'). The functions must exist at least as long as the pointers that use them.</p> <p>Also unlike the STL implementation, the deleters are not encoded in the unique_ptr type, allowing unique_ptr instances with different deleters to be stored in the same containers. </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr","text":"<pre><code>unique_ptr()\n</code></pre>","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_1","text":"<pre><code>unique_ptr(\n    function_ref&lt; void(T *)&gt; &amp;&amp; deleter\n)\n</code></pre> <p>unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset. </p>","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_2","text":"<pre><code>unique_ptr(\n    T *const ptr,\n    function_ref&lt; void(T *)&gt; &amp;&amp; deleter\n)\n</code></pre> <p>unique_ptr Creates a unique pointer that takes ownership of an object. </p> <p>Parameters: </p> <ul> <li>ptr The raw pointer to the object to be managed. </li> <li>deleter The deleter function for cleaning up the managed object. As cxx:function_ref used for the deleter is non-owning the user needs to care about the lifetime of the callable! </li> </ul> <p>A deleter must always be provided as no default can be provided given that no heap is used. The unique_ptr must know how to delete the managed object when the pointer goes out of scope. </p>","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_3","text":"<pre><code>unique_ptr(\n    const unique_ptr &amp; other\n)\n</code></pre>","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator","text":"<pre><code>unique_ptr &amp; operator=(\n    const unique_ptr &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_4","text":"<pre><code>unique_ptr(\n    unique_ptr &amp;&amp; rhs\n)\n</code></pre>","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator_1","text":"<pre><code>unique_ptr &amp; operator=(\n    unique_ptr &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_5","text":"<pre><code>~unique_ptr()\n</code></pre> <p>Automatically deletes the managed object on destruction. </p>","title":"function ~unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator_2","text":"<pre><code>unique_ptr&lt; T &gt; &amp; operator=(\n    std::nullptr_t \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-","text":"<pre><code>T * operator-&gt;()\n</code></pre> <p>operator -&gt; Transparent access to the managed object. </p> <p>Return: </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-_1","text":"<pre><code>const T * operator-&gt;() const\n</code></pre> <p>operator -&gt; Transparent access to the managed object. </p> <p>Return: </p>","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>operator bool Returns true if it points to something. </p>","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-get","text":"<pre><code>T * get()\n</code></pre> <p>get Retrieve the underlying raw pointer. </p> <p>Return: Pointer to managed object or nullptr if none owned. </p> <p>The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted. </p>","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-get_1","text":"<pre><code>const T * get() const\n</code></pre> <p>get Retrieve the underlying raw pointer. </p> <p>Return: Pointer to managed object or nullptr if none owned. </p> <p>The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted. </p>","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-release","text":"<pre><code>T * release()\n</code></pre> <p>release Release ownership of the underlying pointer. </p> <p>Return: Pointer to the managed object or nullptr if none owned. </p>","title":"function release"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-reset","text":"<pre><code>void reset(\n    T *const ptr =nullptr\n)\n</code></pre> <p>reset Reset the unique pointer to take ownership of the given pointer. </p> <p>Parameters: </p> <ul> <li>ptr Pointer to object to take ownership on. </li> </ul> <p>Any previously owned objects will be deleted. If no pointer given then points to nullptr. </p>","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-swap","text":"<pre><code>void swap(\n    unique_ptr &amp; other\n)\n</code></pre> <p>swap Swaps object ownership with another unique_ptr (incl. deleters) </p> <p>Parameters: </p> <ul> <li>other The unique_ptr with which to swap owned objects. </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function swap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/","text":"<p>Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/variant.hpp&gt;</code></p>","title":"iox::cxx::variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#public-functions","text":"Name     constexpr variant() =defaultthe default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when .index() is called   template &lt;uint64_t N,typename... CTorArguments&gt; constexpr variant(const in_place_index&lt; N &gt; &amp; index, CTorArguments &amp;&amp;... args)creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error.   template &lt;typename T ,typename... CTorArguments&gt; constexpr variant(const in_place_type&lt; T &gt; &amp; type, CTorArguments &amp;&amp;... args)creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error.   template &lt;typename T ,typename  =std::enable_if_t&lt;!std::is_same, variant&gt;::value&gt;,typename std::enable_if_t&lt;!internal::is_in_place_index&lt; std::decay_t&lt; T &gt;&gt;::value, bool &gt;  =false,typename std::enable_if_t&lt;!internal::is_in_place_type&lt; std::decay_t&lt; T &gt;&gt;::value, bool &gt;  =false&gt; constexpr variant(T &amp;&amp; arg)creates a variant from a user supplied value   constexpr variant(const variant &amp; rhs)if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied   constexpr variant &amp; operator=(const variant &amp; rhs)if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied   constexpr variant(variant &amp;&amp; rhs)if the variant contains an element the elements move constructor is called otherwise an empty variant is moved   constexpr variant &amp; operator=(variant &amp;&amp; rhs)if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved    ~variant()if the variant contains an element the elements destructor is called otherwise nothing happens   template &lt;typename T &gt; std::enable_if&lt;!std::is_same&lt; T, variant&lt; Types... &gt; &amp; &gt;::value, variant&lt; Types... &gt; &gt;::type &amp; operator=(T &amp;&amp; rhs)if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T.   template &lt;uint64_t TypeIndex,typename... CTorArguments&gt; bool emplace_at_index(CTorArguments &amp;&amp;... args)calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant)   template &lt;typename T ,typename... CTorArguments&gt; bool emplace(CTorArguments &amp;&amp;... args)calls the constructor of the type T and perfectly forwards the arguments to the constructor of T.   template &lt;uint64_t TypeIndex&gt; internal::get_type_at_index&lt; 0, TypeIndex, Types... &gt;::type * get_at_index()returns a pointer to the type stored at index TypeIndex. (not stl compliant)   template &lt;uint64_t TypeIndex&gt; const internal::get_type_at_index&lt; 0, TypeIndex, Types... &gt;::type * get_at_index() constreturns a pointer to the type stored at index TypeIndex. (not stl compliant)   template &lt;typename T &gt; const T * get() constreturns a pointer to the type T stored in the variant. (not stl compliant)   template &lt;typename T &gt; T * get()returns a pointer to the type T stored in the variant. (not stl compliant)   template &lt;typename T &gt; T * get_if(T * defaultValue)returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue   template &lt;typename T &gt; const T * get_if(const T * defaultValue) constreturns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue   constexpr uint64_t index() constreturns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#detailed-description","text":"<pre><code>template &lt;typename... Types&gt;\nclass iox::cxx::variant;\n</code></pre> <p>Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. </p> <p>Parameters: </p> <ul> <li>Types... variadic list of types which the variant should be able to store</li> </ul> <pre><code>#include \"iceoryx_hoofs/cxx/variant.hpp\"\n#include &lt;iostream&gt;\n\ncxx::variant&lt;int, float, double&gt; someVariant;\n\n// ... do stuff\n\nif ( someVariant.index() == INVALID_VARIANT_INDEX )\n{\n    someVariant.emplace&lt;float&gt;(123.456f);\n}\nelse if ( someVariant.index() == 1)\n{\n    auto blubb = someVariant.template get_at_index&lt;1&gt;();\n    std::cout &lt;&lt; *blubb &lt;&lt; std::endl;\n\n    auto sameAsBlubb = someVariant.get&lt;float&gt;();\n    std::cout &lt;&lt; *sameAsBlubb &lt;&lt; std::endl;\n}\n\n// .. do stuff\n\nint defaultValue = 123;\nint * fuu = someVariant.get_if&lt;int&gt;(&amp;defaultValue);\nstd::cout &lt;&lt; *fuu &lt;&lt; std::endl;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant","text":"<pre><code>constexpr variant() =default\n</code></pre> <p>the default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when .index() is called </p>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_1","text":"<pre><code>template &lt;uint64_t N,\ntypename... CTorArguments&gt;\nconstexpr variant(\n    const in_place_index&lt; N &gt; &amp; index,\n    CTorArguments &amp;&amp;... args\n)\n</code></pre> <p>creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error. </p> <p>Template Parameters: </p>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_2","text":"<pre><code>template &lt;typename T ,\ntypename... CTorArguments&gt;\nconstexpr variant(\n    const in_place_type&lt; T &gt; &amp; type,\n    CTorArguments &amp;&amp;... args\n)\n</code></pre> <p>creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error. </p> <p>Template Parameters: </p>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_3","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;T&gt;, variant&gt;::value&gt;,\ntypename std::enable_if_t&lt;!internal::is_in_place_index&lt; std::decay_t&lt; T &gt;&gt;::value, bool &gt;  =false,\ntypename std::enable_if_t&lt;!internal::is_in_place_type&lt; std::decay_t&lt; T &gt;&gt;::value, bool &gt;  =false&gt;\nconstexpr variant(\n    T &amp;&amp; arg\n)\n</code></pre> <p>creates a variant from a user supplied value </p> <p>Template Parameters: </p>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_4","text":"<pre><code>constexpr variant(\n    const variant &amp; rhs\n)\n</code></pre> <p>if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied </p> <p>Parameters: </p> <ul> <li>rhs source of the copy </li> </ul>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator","text":"<pre><code>constexpr variant &amp; operator=(\n    const variant &amp; rhs\n)\n</code></pre> <p>if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied </p> <p>Parameters: </p> <ul> <li>rhs source of the copy assignment </li> </ul> <p>Return: reference to the variant itself </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_5","text":"<pre><code>constexpr variant(\n    variant &amp;&amp; rhs\n)\n</code></pre> <p>if the variant contains an element the elements move constructor is called otherwise an empty variant is moved </p> <p>Parameters: </p> <ul> <li>rhs source of the move </li> </ul>","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator_1","text":"<pre><code>constexpr variant &amp; operator=(\n    variant &amp;&amp; rhs\n)\n</code></pre> <p>if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved </p> <p>Parameters: </p> <ul> <li>rhs source of the move assignment </li> </ul> <p>Return: reference to the variant itself </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_6","text":"<pre><code>~variant()\n</code></pre> <p>if the variant contains an element the elements destructor is called otherwise nothing happens </p>","title":"function ~variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator_2","text":"<pre><code>template &lt;typename T &gt;\nstd::enable_if&lt;!std::is_same&lt; T, variant&lt; Types... &gt; &amp; &gt;::value, variant&lt; Types... &gt; &gt;::type &amp; operator=(\n    T &amp;&amp; rhs\n)\n</code></pre> <p>if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T. </p> <p>Template Parameters: </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-emplace_at_index","text":"<pre><code>template &lt;uint64_t TypeIndex,\ntypename... CTorArguments&gt;\nbool emplace_at_index(\n    CTorArguments &amp;&amp;... args\n)\n</code></pre> <p>calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant) </p> <p>Parameters: </p> <ul> <li>args arguments which will be forwarded to the constructor to the type at TypeIndex </li> </ul> <p>Template Parameters: </p> <ul> <li>TypeIndex index of the type which will be created </li> <li>CTorArguments variadic types of the c'tor arguments </li> </ul> <p>Return: if the variant already contains a different type it returns false, if the construction was successful it returns true </p>","title":"function emplace_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-emplace","text":"<pre><code>template &lt;typename T ,\ntypename... CTorArguments&gt;\nbool emplace(\n    CTorArguments &amp;&amp;... args\n)\n</code></pre> <p>calls the constructor of the type T and perfectly forwards the arguments to the constructor of T. </p> <p>Template Parameters: </p>","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_at_index","text":"<pre><code>template &lt;uint64_t TypeIndex&gt;\ninternal::get_type_at_index&lt; 0, TypeIndex, Types... &gt;::type * get_at_index()\n</code></pre> <p>returns a pointer to the type stored at index TypeIndex. (not stl compliant) </p> <p>Template Parameters: </p>","title":"function get_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_at_index_1","text":"<pre><code>template &lt;uint64_t TypeIndex&gt;\nconst internal::get_type_at_index&lt; 0, TypeIndex, Types... &gt;::type * get_at_index() const\n</code></pre> <p>returns a pointer to the type stored at index TypeIndex. (not stl compliant) </p> <p>Template Parameters: </p>","title":"function get_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get","text":"<pre><code>template &lt;typename T &gt;\nconst T * get() const\n</code></pre> <p>returns a pointer to the type T stored in the variant. (not stl compliant) </p> <p>Template Parameters: </p>","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_1","text":"<pre><code>template &lt;typename T &gt;\nT * get()\n</code></pre> <p>returns a pointer to the type T stored in the variant. (not stl compliant) </p> <p>Template Parameters: </p>","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_if","text":"<pre><code>template &lt;typename T &gt;\nT * get_if(\n    T * defaultValue\n)\n</code></pre> <p>returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue </p> <p>Return: pointer to the stored value if it is of type T, otherwise defaultValue </p>","title":"function get_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_if_1","text":"<pre><code>template &lt;typename T &gt;\nconst T * get_if(\n    const T * defaultValue\n) const\n</code></pre> <p>returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue </p> <p>Template Parameters: </p>","title":"function get_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-index","text":"<pre><code>constexpr uint64_t index() const\n</code></pre> <p>returns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX </p> <p>Return: index of the stored type </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/","text":"<p>C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/vector.hpp&gt;</code></p>","title":"iox::cxx::vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-types","text":"Name     using T value_type   using T * iterator   using const T * const_iterator","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-functions","text":"Name      vector() =defaultcreates an empty vector    vector(const uint64_t count, const T &amp; value)creates a vector with count copies of elements with value value    vector(const uint64_t count)creates a vector with count copies of elements constructed with the default constructor of T    vector(const vector &amp; rhs)copy constructor to copy a vector of the same capacity    vector(vector &amp;&amp; rhs)move constructor to move a vector of the same capacity    ~vector()destructs the vector and also calls the destructor of all contained elements   vector &amp; operator=(const vector &amp; rhs)copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed   vector &amp; operator=(vector &amp;&amp; rhs)move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed   iterator begin()returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector)   const_iterator begin() constreturns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector)   iterator end()returns an iterator to the element which comes after the last element (the first element which is outside of the vector)   const_iterator end() constreturns a const iterator to the element which comes after the last element (the first element which is outside of the vector)   T * data()return the pointer to the underlying array   const T * data() constreturn the const pointer to the underlying array   T &amp; at(const uint64_t index)returns a reference to the element stored at index. the behavior   const T &amp; at(const uint64_t index) constreturns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist.   T &amp; operator[](const uint64_t index)returns a reference to the element stored at index. the behavior   const T &amp; operator[](const uint64_t index) constreturns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist.   T &amp; front()returns a reference to the first element; terminates if the vector is empty   const T &amp; front() constreturns a const reference to the first element; terminates if the vector is empty   T &amp; back()returns a reference to the last element; terminates if the vector is empty   const T &amp; back() constreturns a const reference to the last element; terminates if the vector is empty   uint64_t capacity() constreturns the capacity of the vector which was given via the template argument   uint64_t size() constreturns the number of elements which are currently stored in the vector   bool empty() constreturns true if the vector is emtpy, otherwise false   void clear()calls the destructor of all contained elements and removes them   template &lt;typename... Targs&gt; bool resize(const uint64_t count, const Targs &amp;... args)resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged.   template &lt;typename... Targs&gt; bool emplace(const uint64_t position, Targs &amp;&amp;... args)forwards all arguments to the constructor of the contained element and performs a placement new at the provided position   template &lt;typename... Targs&gt; bool emplace_back(Targs &amp;&amp;... args)forwards all arguments to the constructor of the contained element and performs a placement new at the end   bool push_back(const T &amp; value)appends the given element at the end of the vector   bool push_back(T &amp;&amp; value)appends the given element at the end of the vector   bool pop_back()removes the last element of the vector; calling pop_back on an empty container does nothing   iterator erase(iterator position)removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#detailed-description","text":"<pre><code>template &lt;typename T ,\nuint64_t Capacity&gt;\nclass iox::cxx::vector;\n</code></pre> <p>C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. </p> <p>Attention: Out of bounds access or accessing an empty vector can lead to a program termination! </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-value_type","text":"<pre><code>using iox::cxx::vector&lt; T, Capacity &gt;::value_type =  T;\n</code></pre>","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-iterator","text":"<pre><code>using iox::cxx::vector&lt; T, Capacity &gt;::iterator =  T*;\n</code></pre>","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-const_iterator","text":"<pre><code>using iox::cxx::vector&lt; T, Capacity &gt;::const_iterator =  const T*;\n</code></pre>","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector","text":"<pre><code>vector() =default\n</code></pre> <p>creates an empty vector </p>","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_1","text":"<pre><code>vector(\n    const uint64_t count,\n    const T &amp; value\n)\n</code></pre> <p>creates a vector with count copies of elements with value value </p> <p>Parameters: </p> <ul> <li>count is the number copies which are inserted into the vector </li> <li>value is the value which is inserted into the vector </li> </ul>","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_2","text":"<pre><code>vector(\n    const uint64_t count\n)\n</code></pre> <p>creates a vector with count copies of elements constructed with the default constructor of T </p> <p>Parameters: </p> <ul> <li>count is the number copies which are inserted into the vector </li> </ul>","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_3","text":"<pre><code>vector(\n    const vector &amp; rhs\n)\n</code></pre> <p>copy constructor to copy a vector of the same capacity </p>","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_4","text":"<pre><code>vector(\n    vector &amp;&amp; rhs\n)\n</code></pre> <p>move constructor to move a vector of the same capacity </p>","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_5","text":"<pre><code>~vector()\n</code></pre> <p>destructs the vector and also calls the destructor of all contained elements </p>","title":"function ~vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator","text":"<pre><code>vector &amp; operator=(\n    const vector &amp; rhs\n)\n</code></pre> <p>copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_1","text":"<pre><code>vector &amp; operator=(\n    vector &amp;&amp; rhs\n)\n</code></pre> <p>move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-begin","text":"<pre><code>iterator begin()\n</code></pre> <p>returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-begin_1","text":"<pre><code>const_iterator begin() const\n</code></pre> <p>returns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) </p>","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-end","text":"<pre><code>iterator end()\n</code></pre> <p>returns an iterator to the element which comes after the last element (the first element which is outside of the vector) </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-end_1","text":"<pre><code>const_iterator end() const\n</code></pre> <p>returns a const iterator to the element which comes after the last element (the first element which is outside of the vector) </p>","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-data","text":"<pre><code>T * data()\n</code></pre> <p>return the pointer to the underlying array </p> <p>Return: pointer to underlying array </p>","title":"function data"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-data_1","text":"<pre><code>const T * data() const\n</code></pre> <p>return the const pointer to the underlying array </p> <p>Return: const pointer to underlying array </p>","title":"function data"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-at","text":"<pre><code>T &amp; at(\n    const uint64_t index\n)\n</code></pre> <p>returns a reference to the element stored at index. the behavior </p> <p>Attention: Out of bounds access can lead to a program termination! </p>","title":"function at"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-at_1","text":"<pre><code>const T &amp; at(\n    const uint64_t index\n) const\n</code></pre> <p>returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. </p> <p>Attention: Out of bounds access can lead to a program termination! </p>","title":"function at"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_2","text":"<pre><code>T &amp; operator[](\n    const uint64_t index\n)\n</code></pre> <p>returns a reference to the element stored at index. the behavior </p> <p>Attention: Out of bounds access can lead to a program termination! </p>","title":"function operator[]"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_3","text":"<pre><code>const T &amp; operator[](\n    const uint64_t index\n) const\n</code></pre> <p>returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. </p> <p>Attention: Out of bounds access can lead to a program termination! </p>","title":"function operator[]"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-front","text":"<pre><code>T &amp; front()\n</code></pre> <p>returns a reference to the first element; terminates if the vector is empty </p> <p>Return: reference to the first element </p> <p>Attention: Accessing an empty vector can lead to a program termination! </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-front_1","text":"<pre><code>const T &amp; front() const\n</code></pre> <p>returns a const reference to the first element; terminates if the vector is empty </p> <p>Return: const reference to the first element </p> <p>Attention: Accessing an empty vector can lead to a program termination! </p>","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-back","text":"<pre><code>T &amp; back()\n</code></pre> <p>returns a reference to the last element; terminates if the vector is empty </p> <p>Return: reference to the last element </p> <p>Attention: Accessing an empty vector can lead to a program termination! </p>","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-back_1","text":"<pre><code>const T &amp; back() const\n</code></pre> <p>returns a const reference to the last element; terminates if the vector is empty </p> <p>Return: const reference to the last element </p> <p>Attention: Accessing an empty vector can lead to a program termination! </p>","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-capacity","text":"<pre><code>uint64_t capacity() const\n</code></pre> <p>returns the capacity of the vector which was given via the template argument </p>","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>returns the number of elements which are currently stored in the vector </p>","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-empty","text":"<pre><code>bool empty() const\n</code></pre> <p>returns true if the vector is emtpy, otherwise false </p>","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-clear","text":"<pre><code>void clear()\n</code></pre> <p>calls the destructor of all contained elements and removes them </p>","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-resize","text":"<pre><code>template &lt;typename... Targs&gt;\nbool resize(\n    const uint64_t count,\n    const Targs &amp;... args\n)\n</code></pre> <p>resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged. </p> <p>Parameters: </p> <ul> <li>count new size of the vector </li> <li>args arguments which are used by the constructor of newly created elements </li> </ul> <p>Return: true if the resize was successful, false if count is greater than the capacity. </p> <p>Note: perfect forwarded arguments are explicitly not wanted here. think of what happens if resize creates two new elements via move construction. The first one has a valid source but the second gets an already moved parameter. </p>","title":"function resize"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-emplace","text":"<pre><code>template &lt;typename... Targs&gt;\nbool emplace(\n    const uint64_t position,\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>forwards all arguments to the constructor of the contained element and performs a placement new at the provided position </p> <p>Parameters: </p> <ul> <li>position the position where the element should be created </li> </ul>","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-emplace_back","text":"<pre><code>template &lt;typename... Targs&gt;\nbool emplace_back(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>forwards all arguments to the constructor of the contained element and performs a placement new at the end </p>","title":"function emplace_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-push_back","text":"<pre><code>bool push_back(\n    const T &amp; value\n)\n</code></pre> <p>appends the given element at the end of the vector </p> <p>Return: true if successful, false if vector already full </p>","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-push_back_1","text":"<pre><code>bool push_back(\n    T &amp;&amp; value\n)\n</code></pre> <p>appends the given element at the end of the vector </p> <p>Return: true if successful, false if vector already full </p>","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-pop_back","text":"<pre><code>bool pop_back()\n</code></pre> <p>removes the last element of the vector; calling pop_back on an empty container does nothing </p> <p>Return: true if the last element was removed. If the vector is empty it returns false. </p>","title":"function pop_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-erase","text":"<pre><code>iterator erase(\n    iterator position\n)\n</code></pre> <p>removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function erase"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/","text":"","title":"iox::log::LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#public-functions","text":"Name     LogManager &amp; GetLogManager()   Logger &amp; CreateLogContext(const std::string &amp; ctxId, const std::string &amp; ctxDescription, const LogLevel appDefLogLevel)    ~LogManager() =default    LogManager(const LogManager &amp; )    LogManager(LogManager &amp;&amp; )   LogManager &amp; operator=(const LogManager &amp; )   LogManager &amp; operator=(LogManager &amp;&amp; )   LogLevel DefaultLogLevel() const   void SetDefaultLogLevel(const LogLevel logLevel, const LogLevelOutput logLevelOutput =LogLevelOutput::kDisplayLogLevel)   LogMode DefaultLogMode() const   void SetDefaultLogMode(const LogMode logMode)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#protected-functions","text":"Name      LogManager() =default","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-getlogmanager","text":"<pre><code>static LogManager &amp; GetLogManager()\n</code></pre>","title":"function GetLogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-createlogcontext","text":"<pre><code>static Logger &amp; CreateLogContext(\n    const std::string &amp; ctxId,\n    const std::string &amp; ctxDescription,\n    const LogLevel appDefLogLevel\n)\n</code></pre>","title":"function CreateLogContext"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager","text":"<pre><code>~LogManager() =default\n</code></pre>","title":"function ~LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_1","text":"<pre><code>LogManager(\n    const LogManager &amp; \n)\n</code></pre>","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_2","text":"<pre><code>LogManager(\n    LogManager &amp;&amp; \n)\n</code></pre>","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-operator","text":"<pre><code>LogManager &amp; operator=(\n    const LogManager &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-operator_1","text":"<pre><code>LogManager &amp; operator=(\n    LogManager &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-defaultloglevel","text":"<pre><code>LogLevel DefaultLogLevel() const\n</code></pre>","title":"function DefaultLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-setdefaultloglevel","text":"<pre><code>void SetDefaultLogLevel(\n    const LogLevel logLevel,\n    const LogLevelOutput logLevelOutput =LogLevelOutput::kDisplayLogLevel\n)\n</code></pre>","title":"function SetDefaultLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-defaultlogmode","text":"<pre><code>LogMode DefaultLogMode() const\n</code></pre>","title":"function DefaultLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-setdefaultlogmode","text":"<pre><code>void SetDefaultLogMode(\n    const LogMode logMode\n)\n</code></pre>","title":"function SetDefaultLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_3","text":"<pre><code>LogManager() =default\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/","text":"","title":"iox::log::LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#public-functions","text":"Name      LogStream(Logger &amp; logger, LogLevel logLevel =LogLevel::kWarn)   virtual ~LogStream()   void Flush()   LogStream &amp; operator&lt;&lt;(const char * cstr)   LogStream &amp; operator&lt;&lt;(const std::string &amp; str)   template &lt;typename T ,typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt; LogStream &amp; operator&lt;&lt;(const T val)   template &lt;typename T ,typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt; LogStream &amp; operator&lt;&lt;(const T val)   template &lt;typename T ,typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt; LogStream &amp; operator&lt;&lt;(const T val)   LogStream &amp; operator&lt;&lt;(const LogRawBuffer &amp; value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-logstream","text":"<pre><code>LogStream(\n    Logger &amp; logger,\n    LogLevel logLevel =LogLevel::kWarn\n)\n</code></pre>","title":"function LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-logstream_1","text":"<pre><code>virtual ~LogStream()\n</code></pre>","title":"function ~LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-flush","text":"<pre><code>void Flush()\n</code></pre>","title":"function Flush"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator","text":"<pre><code>LogStream &amp; operator&lt;&lt;(\n    const char * cstr\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_1","text":"<pre><code>LogStream &amp; operator&lt;&lt;(\n    const std::string &amp; str\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_2","text":"<pre><code>template &lt;typename T ,\ntypename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt;\ninline LogStream &amp; operator&lt;&lt;(\n    const T val\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_3","text":"<pre><code>template &lt;typename T ,\ntypename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt;\ninline LogStream &amp; operator&lt;&lt;(\n    const T val\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_4","text":"<pre><code>template &lt;typename T ,\ntypename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;::type  =0&gt;\ninline LogStream &amp; operator&lt;&lt;(\n    const T val\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_5","text":"<pre><code>LogStream &amp; operator&lt;&lt;(\n    const LogRawBuffer &amp; value\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/","text":"<p>More...</p> <p><code>#include &lt;iceoryx_hoofs/log/logger.hpp&gt;</code></p>","title":"iox::log::Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#public-functions","text":"Name      Logger(Logger &amp;&amp; other)   Logger &amp; operator=(Logger &amp;&amp; rhs)    Logger(const Logger &amp; other)   Logger &amp; operator=(const Logger &amp; rhs)   LogLevel GetLogLevel() constGetter method for the current LogLevel.   void SetLogLevel(const LogLevel logLevel)Sets the LogLevel for the Logger.   cxx::GenericRAII SetLogLevelForScope(const LogLevel logLevel)Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one.   void SetLogMode(const LogMode logMode)   bool IsEnabled(const LogLevel logLevel) const   LogStream LogFatal()   LogStream LogError()   LogStream LogWarn()   LogStream LogInfo()   LogStream LogDebug()   LogStream LogVerbose()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#protected-functions","text":"Name      Logger(const std::string &amp; ctxId, const std::string &amp; ctxDescription, const LogLevel appLogLevel)   virtual void Log(const LogEntry &amp; entry) const","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friends","text":"Name     class LogManager   class LogStream","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#detailed-description","text":"<pre><code>class iox::log::Logger;\n</code></pre> <p>Todo: for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/</p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger","text":"<pre><code>Logger(\n    Logger &amp;&amp; other\n)\n</code></pre>","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-operator","text":"<pre><code>Logger &amp; operator=(\n    Logger &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger_1","text":"<pre><code>Logger(\n    const Logger &amp; other\n)\n</code></pre>","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-operator_1","text":"<pre><code>Logger &amp; operator=(\n    const Logger &amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-getloglevel","text":"<pre><code>LogLevel GetLogLevel() const\n</code></pre> <p>Getter method for the current LogLevel. </p> <p>Return: the current LogLevel </p>","title":"function GetLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setloglevel","text":"<pre><code>void SetLogLevel(\n    const LogLevel logLevel\n)\n</code></pre> <p>Sets the LogLevel for the Logger. </p> <p>Parameters: </p> <ul> <li>logLevel to be set </li> </ul>","title":"function SetLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setloglevelforscope","text":"<pre><code>cxx::GenericRAII SetLogLevelForScope(\n    const LogLevel logLevel\n)\n</code></pre> <p>Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one. </p> <p>Parameters: </p> <ul> <li>logLevel to be set temporarily </li> </ul> <p>Return: a scope guard which resets the LogLevel to the value at the time when this method was called </p>","title":"function SetLogLevelForScope"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setlogmode","text":"<pre><code>void SetLogMode(\n    const LogMode logMode\n)\n</code></pre>","title":"function SetLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-isenabled","text":"<pre><code>bool IsEnabled(\n    const LogLevel logLevel\n) const\n</code></pre>","title":"function IsEnabled"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logfatal","text":"<pre><code>LogStream LogFatal()\n</code></pre>","title":"function LogFatal"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logerror","text":"<pre><code>LogStream LogError()\n</code></pre>","title":"function LogError"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logwarn","text":"<pre><code>LogStream LogWarn()\n</code></pre>","title":"function LogWarn"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-loginfo","text":"<pre><code>LogStream LogInfo()\n</code></pre>","title":"function LogInfo"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logdebug","text":"<pre><code>LogStream LogDebug()\n</code></pre>","title":"function LogDebug"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logverbose","text":"<pre><code>LogStream LogVerbose()\n</code></pre>","title":"function LogVerbose"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger_2","text":"<pre><code>Logger(\n    const std::string &amp; ctxId,\n    const std::string &amp; ctxDescription,\n    const LogLevel appLogLevel\n)\n</code></pre>","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-log","text":"<pre><code>virtual void Log(\n    const LogEntry &amp; entry\n) const\n</code></pre>","title":"function Log"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friend-logmanager","text":"<pre><code>friend class LogManager(\n    LogManager \n);\n</code></pre>","title":"friend LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friend-logstream","text":"<pre><code>friend class LogStream(\n    LogStream \n);\n</code></pre> <p>Todo: LogStream needs to call Log(); do we want to make Log() public? </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/","text":"<p>Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page)  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/file_lock.hpp&gt;</code></p> <p>Inherits from DesignPattern::Creation&lt; FileLock, FileLockError &gt;</p>","title":"iox::posix::FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-types","text":"Name     using cxx::string&lt; FILENAME_LENGTH &gt; FileName_t   using cxx::string&lt; platform::IOX_MAX_PATH_LENGTH &gt; PathName_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-functions","text":"Name      FileLock(const FileLock &amp; )   FileLock &amp; operator=(const FileLock &amp; )    FileLock(FileLock &amp;&amp; rhs)   FileLock &amp; operator=(FileLock &amp;&amp; rhs)    ~FileLock()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-attributes","text":"Name     constexpr int32_t ERROR_CODE   constexpr int32_t INVALID_FD   constexpr const char LOCK_FILE_SUFFIX   constexpr uint64_t FILENAME_LENGTH","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friends","text":"Name     class DesignPattern::Creation&lt; FileLock, FileLockError &gt;","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#additional-inherited-members","text":"<p>Public Types inherited from DesignPattern::Creation&lt; FileLock, FileLockError &gt;</p>     Name     using Creation&lt; DerivedClass, ErrorType &gt; CreationPattern_t   using iox::cxx::expected&lt; DerivedClass, ErrorType &gt; result_t   using ErrorType errorType_t    <p>Public Functions inherited from DesignPattern::Creation&lt; FileLock, FileLockError &gt;</p>     Name     template &lt;typename... Targs&gt; result_t create(Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction   result_t verify(DerivedClass &amp;&amp; newObject)verifies if a class was created successfully   template &lt;typename... Targs&gt; iox::cxx::expected&lt; ErrorType &gt; placementCreate(void *const memory, Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction    Creation() =default    Creation(Creation &amp;&amp; rhs)    Creation(const Creation &amp; rhs) =default   bool isInitialized() constreturns true if the object was constructed successfully, otherwise false    <p>Protected Attributes inherited from DesignPattern::Creation&lt; FileLock, FileLockError &gt;</p>     Name     bool m_isInitialized   ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#detailed-description","text":"<pre><code>class iox::posix::FileLock;\n</code></pre> <p>Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) </p> <pre><code>iox::posix::FileLock::create(nameOfmyLock)\n    .and_then([] { std::cout &lt;&lt; \"We aquired the lock!\" &lt;&lt; std::endl; })\n    .or_else([](auto&amp; error) {\n        if (error == FileLockError::LOCKED_BY_OTHER_PROCESS)\n        {\n            std::cout &lt;&lt; \"Some other process is running and holds the lock!\" &lt;&lt; std::endl;\n        }\n    });\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#using-filename_t","text":"<pre><code>using iox::posix::FileLock::FileName_t =  cxx::string&lt;FILENAME_LENGTH&gt;;\n</code></pre>","title":"using FileName_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#using-pathname_t","text":"<pre><code>using iox::posix::FileLock::PathName_t =  cxx::string&lt;platform::IOX_MAX_PATH_LENGTH&gt;;\n</code></pre>","title":"using PathName_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock","text":"<pre><code>FileLock(\n    const FileLock &amp; \n)\n</code></pre>","title":"function FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-operator","text":"<pre><code>FileLock &amp; operator=(\n    const FileLock &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock_1","text":"<pre><code>FileLock(\n    FileLock &amp;&amp; rhs\n)\n</code></pre>","title":"function FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-operator_1","text":"<pre><code>FileLock &amp; operator=(\n    FileLock &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock_2","text":"<pre><code>~FileLock()\n</code></pre>","title":"function ~FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-error_code","text":"<pre><code>static constexpr int32_t ERROR_CODE = -1;\n</code></pre>","title":"variable ERROR_CODE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-invalid_fd","text":"<pre><code>static constexpr int32_t INVALID_FD = -1;\n</code></pre>","title":"variable INVALID_FD"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-lock_file_suffix","text":"<pre><code>static constexpr const char LOCK_FILE_SUFFIX = \".lock\";\n</code></pre>","title":"variable LOCK_FILE_SUFFIX"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-filename_length","text":"<pre><code>static constexpr uint64_t FILENAME_LENGTH = platform::IOX_MAX_FILENAME_LENGTH\n                                                - sizeof(platform::IOX_LOCK_FILE_PATH_PREFIX) / sizeof(char)\n                                                - sizeof(LOCK_FILE_SUFFIX) / sizeof(char);\n</code></pre>","title":"variable FILENAME_LENGTH"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friend-designpatterncreation-filelock-filelockerror","text":"<pre><code>friend class DesignPattern::Creation&lt; FileLock, FileLockError &gt;(\n    DesignPattern::Creation&lt; FileLock, FileLockError &gt; \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend DesignPattern::Creation&lt; FileLock, FileLockError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/","text":"<p>Inherits from DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;</p>","title":"iox::posix::NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-types","text":"Name     using cxx::string&lt; MAX_MESSAGE_SIZE &gt; Message_t   using concurrent::LockFreeQueue&lt; Message_t, MAX_NUMBER_OF_MESSAGES &gt; MessageQueue_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-functions","text":"Name      NamedPipe(const NamedPipe &amp; )   NamedPipe &amp; operator=(const NamedPipe &amp; )    NamedPipe()For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe.    NamedPipe(NamedPipe &amp;&amp; rhs)   NamedPipe &amp; operator=(NamedPipe &amp;&amp; rhs)    ~NamedPipe()   cxx::expected&lt; IpcChannelError &gt; destroy()destroys an initialized named pipe.   cxx::expected&lt; bool, IpcChannelError &gt; isOutdated()for compatibility with IpcChannelError   cxx::expected&lt; IpcChannelError &gt; trySend(const std::string &amp; message) consttries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned   cxx::expected&lt; IpcChannelError &gt; send(const std::string &amp; message) constsends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered   cxx::expected&lt; IpcChannelError &gt; timedSend(const std::string &amp; message, const units::Duration &amp; timeout) constsends a message via the named pipe.   cxx::expected&lt; std::string, IpcChannelError &gt; tryReceive() consttries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned   cxx::expected&lt; std::string, IpcChannelError &gt; receive() constreceives a message via the named pipe. if the pipe is empty this call is blocking until a message was received   cxx::expected&lt; std::string, IpcChannelError &gt; timedReceive(const units::Duration &amp; timeout) constreceives a message via the named pipe.   cxx::expected&lt; bool, IpcChannelError &gt; unlinkIfExists(const IpcChannelName_t &amp; name)removes a named pipe artifact from the system","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-attributes","text":"Name     constexpr uint64_t MAX_MESSAGE_SIZE   constexpr uint64_t MAX_NUMBER_OF_MESSAGES   constexpr uint64_t NULL_TERMINATOR_SIZE   constexpr units::Duration CYCLE_TIME   constexpr const char NAMED_PIPE_PREFIX","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friends","text":"Name     class DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#additional-inherited-members","text":"<p>Public Types inherited from DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;</p>     Name     using Creation&lt; DerivedClass, ErrorType &gt; CreationPattern_t   using iox::cxx::expected&lt; DerivedClass, ErrorType &gt; result_t   using ErrorType errorType_t    <p>Public Functions inherited from DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;</p>     Name     template &lt;typename... Targs&gt; result_t create(Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction   result_t verify(DerivedClass &amp;&amp; newObject)verifies if a class was created successfully   template &lt;typename... Targs&gt; iox::cxx::expected&lt; ErrorType &gt; placementCreate(void *const memory, Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction    Creation() =default    Creation(Creation &amp;&amp; rhs)    Creation(const Creation &amp; rhs) =default   bool isInitialized() constreturns true if the object was constructed successfully, otherwise false    <p>Protected Attributes inherited from DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;</p>     Name     bool m_isInitialized   ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#using-message_t","text":"<pre><code>using iox::posix::NamedPipe::Message_t =  cxx::string&lt;MAX_MESSAGE_SIZE&gt;;\n</code></pre>","title":"using Message_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#using-messagequeue_t","text":"<pre><code>using iox::posix::NamedPipe::MessageQueue_t =  concurrent::LockFreeQueue&lt;Message_t, MAX_NUMBER_OF_MESSAGES&gt;;\n</code></pre>","title":"using MessageQueue_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe","text":"<pre><code>NamedPipe(\n    const NamedPipe &amp; \n)\n</code></pre>","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-operator","text":"<pre><code>NamedPipe &amp; operator=(\n    const NamedPipe &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_1","text":"<pre><code>NamedPipe()\n</code></pre> <p>For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe. </p>","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_2","text":"<pre><code>NamedPipe(\n    NamedPipe &amp;&amp; rhs\n)\n</code></pre>","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-operator_1","text":"<pre><code>NamedPipe &amp; operator=(\n    NamedPipe &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_3","text":"<pre><code>~NamedPipe()\n</code></pre>","title":"function ~NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-destroy","text":"<pre><code>cxx::expected&lt; IpcChannelError &gt; destroy()\n</code></pre> <p>destroys an initialized named pipe. </p> <p>Return: is always successful </p>","title":"function destroy"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-isoutdated","text":"<pre><code>cxx::expected&lt; bool, IpcChannelError &gt; isOutdated()\n</code></pre> <p>for compatibility with IpcChannelError </p> <p>Return: always false </p>","title":"function isOutdated"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-trysend","text":"<pre><code>cxx::expected&lt; IpcChannelError &gt; trySend(\n    const std::string &amp; message\n) const\n</code></pre> <p>tries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned </p> <p>Return: on failure an error which describes the failure </p>","title":"function trySend"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-send","text":"<pre><code>cxx::expected&lt; IpcChannelError &gt; send(\n    const std::string &amp; message\n) const\n</code></pre> <p>sends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered </p> <p>Parameters: </p> <ul> <li>message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE </li> </ul> <p>Return: success when message was sent otherwise an error which describes the failure </p>","title":"function send"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-timedsend","text":"<pre><code>cxx::expected&lt; IpcChannelError &gt; timedSend(\n    const std::string &amp; message,\n    const units::Duration &amp; timeout\n) const\n</code></pre> <p>sends a message via the named pipe. </p> <p>Parameters: </p> <ul> <li>message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE </li> <li>timeout the timeout on how long this method should retry to send the message </li> </ul> <p>Return: success when message was sent otherwise an error which describes the failure </p>","title":"function timedSend"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-tryreceive","text":"<pre><code>cxx::expected&lt; std::string, IpcChannelError &gt; tryReceive() const\n</code></pre> <p>tries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned </p> <p>Return: on success a string containing the message, otherwise an error which describes the failure </p>","title":"function tryReceive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-receive","text":"<pre><code>cxx::expected&lt; std::string, IpcChannelError &gt; receive() const\n</code></pre> <p>receives a message via the named pipe. if the pipe is empty this call is blocking until a message was received </p> <p>Return: on success a string containing the message, otherwise an error which describes the failure </p>","title":"function receive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-timedreceive","text":"<pre><code>cxx::expected&lt; std::string, IpcChannelError &gt; timedReceive(\n    const units::Duration &amp; timeout\n) const\n</code></pre> <p>receives a message via the named pipe. </p> <p>Parameters: </p> <ul> <li>timeout the timeout on how long this method should retry to receive a message </li> </ul> <p>Return: on success a string containing the message, otherwise an error which describes the failure </p>","title":"function timedReceive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-unlinkifexists","text":"<pre><code>static cxx::expected&lt; bool, IpcChannelError &gt; unlinkIfExists(\n    const IpcChannelName_t &amp; name\n)\n</code></pre> <p>removes a named pipe artifact from the system </p> <p>Return: true if the artifact was removed, false when no artifact was found and IpcChannelError::INTERNAL_LOGIC_ERROR when shm_unlink failed </p>","title":"function unlinkIfExists"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-max_message_size","text":"<pre><code>static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U;\n</code></pre>","title":"variable MAX_MESSAGE_SIZE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-max_number_of_messages","text":"<pre><code>static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U;\n</code></pre>","title":"variable MAX_NUMBER_OF_MESSAGES"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-null_terminator_size","text":"<pre><code>static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U;\n</code></pre>","title":"variable NULL_TERMINATOR_SIZE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-cycle_time","text":"<pre><code>static constexpr units::Duration CYCLE_TIME = units::Duration::fromMilliseconds(10);\n</code></pre>","title":"variable CYCLE_TIME"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-named_pipe_prefix","text":"<pre><code>static constexpr const char NAMED_PIPE_PREFIX = \"iox_np_\";\n</code></pre>","title":"variable NAMED_PIPE_PREFIX"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friend-designpatterncreation-namedpipe-ipcchannelerror","text":"<pre><code>friend class DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;(\n    DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt; \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/","text":"","title":"iox::posix::NamedPipe::NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-functions","text":"Name      NamedPipeData(bool &amp; isInitialized, IpcChannelError &amp; error, const uint64_t maxMsgNumber)    NamedPipeData(const NamedPipeData &amp; )    NamedPipeData(NamedPipeData &amp;&amp; rhs)    ~NamedPipeData()   NamedPipeData &amp; operator=(const NamedPipeData &amp; )   NamedPipeData &amp; operator=(NamedPipeData &amp;&amp; rhs)   Semaphore &amp; sendSemaphore()   Semaphore &amp; receiveSemaphore()   bool waitForInitialization() const   bool hasValidState() const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-attributes","text":"Name     MessageQueue_t messages","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata","text":"<pre><code>NamedPipeData(\n    bool &amp; isInitialized,\n    IpcChannelError &amp; error,\n    const uint64_t maxMsgNumber\n)\n</code></pre>","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_1","text":"<pre><code>NamedPipeData(\n    const NamedPipeData &amp; \n)\n</code></pre>","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_2","text":"<pre><code>NamedPipeData(\n    NamedPipeData &amp;&amp; rhs\n)\n</code></pre>","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_3","text":"<pre><code>~NamedPipeData()\n</code></pre>","title":"function ~NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-operator","text":"<pre><code>NamedPipeData &amp; operator=(\n    const NamedPipeData &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-operator_1","text":"<pre><code>NamedPipeData &amp; operator=(\n    NamedPipeData &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-sendsemaphore","text":"<pre><code>Semaphore &amp; sendSemaphore()\n</code></pre>","title":"function sendSemaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-receivesemaphore","text":"<pre><code>Semaphore &amp; receiveSemaphore()\n</code></pre>","title":"function receiveSemaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-waitforinitialization","text":"<pre><code>bool waitForInitialization() const\n</code></pre>","title":"function waitForInitialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-hasvalidstate","text":"<pre><code>bool hasValidState() const\n</code></pre>","title":"function hasValidState"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#variable-messages","text":"<pre><code>MessageQueue_t messages;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable messages"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/","text":"<p>More...</p>","title":"iox::posix::PosixCallBuilder"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-types","text":"Name     using ReturnType(*)(FunctionArguments...) FunctionType_t input function type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-functions","text":"Name     PosixCallVerificator&lt; ReturnType &gt; operator()(FunctionArguments... arguments)Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#detailed-description","text":"<pre><code>template &lt;typename ReturnType ,\ntypename... FunctionArguments&gt;\nclass iox::posix::PosixCallBuilder;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#using-functiontype_t","text":"<pre><code>using iox::posix::PosixCallBuilder&lt; ReturnType, FunctionArguments &gt;::FunctionType_t =  ReturnType (*)(FunctionArguments...);\n</code></pre> <p>input function type </p>","title":"using FunctionType_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#function-operator","text":"<pre><code>PosixCallVerificator&lt; ReturnType &gt; operator()(\n    FunctionArguments... arguments\n)\n</code></pre> <p>Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times. </p> <p>Parameters: </p> <ul> <li>arguments arguments which will be provided to the posix function </li> </ul> <p>Return: the PosixCallVerificator to verify the return value </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/","text":"<p>class which is created by the verificator to evaluate the result of a posix call  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/posix_call.hpp&gt;</code></p>","title":"iox::posix::PosixCallEvaluator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#public-functions","text":"Name     template &lt;typename... IgnoredErrnos&gt; PosixCallEvaluator&lt; ReturnType &gt; ignoreErrnos(const IgnoredErrnos... ignoredErrnos) constignore specified errnos from the evaluation   template &lt;typename... SilentErrnos&gt; PosixCallEvaluator&lt; ReturnType &gt; suppressErrorMessagesForErrnos(const SilentErrnos... silentErrnos) constsilence specified errnos from printing error messages in the evaluation   cxx::expected&lt; PosixCallResult&lt; ReturnType &gt;, PosixCallResult&lt; ReturnType &gt; &gt; evaluate() constevaluate the result of a posix call","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friends","text":"Name     class PosixCallVerificator","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#detailed-description","text":"<pre><code>template &lt;typename ReturnType &gt;\nclass iox::posix::PosixCallEvaluator;\n</code></pre> <p>class which is created by the verificator to evaluate the result of a posix call </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-ignoreerrnos","text":"<pre><code>template &lt;typename... IgnoredErrnos&gt;\nPosixCallEvaluator&lt; ReturnType &gt; ignoreErrnos(\n    const IgnoredErrnos... ignoredErrnos\n) const\n</code></pre> <p>ignore specified errnos from the evaluation </p> <p>Parameters: </p> <ul> <li>ignoredErrnos the int32_t values of the errnos which should be ignored </li> </ul> <p>Template Parameters: </p> <ul> <li>IgnoredErrnos a list of int32_t variables </li> </ul> <p>Return: a PosixCallEvaluator for further setup of the evaluation </p>","title":"function ignoreErrnos"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-suppresserrormessagesforerrnos","text":"<pre><code>template &lt;typename... SilentErrnos&gt;\nPosixCallEvaluator&lt; ReturnType &gt; suppressErrorMessagesForErrnos(\n    const SilentErrnos... silentErrnos\n) const\n</code></pre> <p>silence specified errnos from printing error messages in the evaluation </p> <p>Parameters: </p> <ul> <li>silentErrnos the int32_t values of the errnos which should be silent and not cause an error log </li> </ul> <p>Template Parameters: </p> <ul> <li>SilentErrnos a list of int32_t variables </li> </ul> <p>Return: a PosixCallEvaluator for further setup of the evaluation </p>","title":"function suppressErrorMessagesForErrnos"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-evaluate","text":"<pre><code>cxx::expected&lt; PosixCallResult&lt; ReturnType &gt;, PosixCallResult&lt; ReturnType &gt; &gt; evaluate() const\n</code></pre> <p>evaluate the result of a posix call </p> <p>Return: returns an expected which contains in both cases a PosixCallResult with the return value (.value) and the errno value (.errnum) of the function call","title":"function evaluate"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friend-posixcallverificator","text":"<pre><code>friend class PosixCallVerificator(\n    PosixCallVerificator \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend PosixCallVerificator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/","text":"<p>class which verifies the return value of a posix function call  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/posix_call.hpp&gt;</code></p>","title":"iox::posix::PosixCallVerificator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#public-functions","text":"Name     template &lt;typename... SuccessReturnValues&gt; PosixCallEvaluator&lt; ReturnType &gt; successReturnValue(const SuccessReturnValues... successReturnValues)the posix function call defines success through a single value   template &lt;typename... FailureReturnValues&gt; PosixCallEvaluator&lt; ReturnType &gt; failureReturnValue(const FailureReturnValues... failureReturnValues)the posix function call defines failure through a single value   PosixCallEvaluator&lt; ReturnType &gt; returnValueMatchesErrno()the posix function call defines failure through return of the errno value instead of setting the errno","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friends","text":"Name     class PosixCallBuilder","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#detailed-description","text":"<pre><code>template &lt;typename ReturnType &gt;\nclass iox::posix::PosixCallVerificator;\n</code></pre> <p>class which verifies the return value of a posix function call </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-successreturnvalue","text":"<pre><code>template &lt;typename... SuccessReturnValues&gt;\nPosixCallEvaluator&lt; ReturnType &gt; successReturnValue(\n    const SuccessReturnValues... successReturnValues\n)\n</code></pre> <p>the posix function call defines success through a single value </p> <p>Parameters: </p> <ul> <li>successReturnValues a list of values which define success </li> </ul> <p>Return: the PosixCallEvaluator which evaluates the errno values </p>","title":"function successReturnValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-failurereturnvalue","text":"<pre><code>template &lt;typename... FailureReturnValues&gt;\nPosixCallEvaluator&lt; ReturnType &gt; failureReturnValue(\n    const FailureReturnValues... failureReturnValues\n)\n</code></pre> <p>the posix function call defines failure through a single value </p> <p>Parameters: </p> <ul> <li>failureReturnValues a list of values which define failure </li> </ul> <p>Return: the PosixCallEvaluator which evaluates the errno values </p>","title":"function failureReturnValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-returnvaluematcheserrno","text":"<pre><code>PosixCallEvaluator&lt; ReturnType &gt; returnValueMatchesErrno()\n</code></pre> <p>the posix function call defines failure through return of the errno value instead of setting the errno </p> <p>Return: the PosixCallEvaluator which evaluates the errno values </p>","title":"function returnValueMatchesErrno"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friend-posixcallbuilder","text":"<pre><code>friend class PosixCallBuilder(\n    PosixCallBuilder \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend PosixCallBuilder"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/","text":"","title":"iox::posix::PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-types","text":"Name     using cxx::string&lt; 100 &gt; string_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-functions","text":"Name      PosixGroup(const gid_t f_id)    PosixGroup(const string_t &amp; f_name)   bool operator==(const PosixGroup &amp; other) const   string_t getName() const   gid_t getID() const   bool doesExist() const   PosixGroup getGroupOfCurrentProcess()   cxx::optional&lt; uid_t &gt; getGroupID(const string_t &amp; f_name)   cxx::optional&lt; string_t &gt; getGroupName(gid_t f_id)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#using-string_t","text":"<pre><code>using iox::posix::PosixGroup::string_t =  cxx::string&lt;100&gt;;\n</code></pre>","title":"using string_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-posixgroup","text":"<pre><code>explicit PosixGroup(\n    const gid_t f_id\n)\n</code></pre>","title":"function PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-posixgroup_1","text":"<pre><code>explicit PosixGroup(\n    const string_t &amp; f_name\n)\n</code></pre>","title":"function PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-operator","text":"<pre><code>bool operator==(\n    const PosixGroup &amp; other\n) const\n</code></pre>","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getname","text":"<pre><code>string_t getName() const\n</code></pre>","title":"function getName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getid","text":"<pre><code>gid_t getID() const\n</code></pre>","title":"function getID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-doesexist","text":"<pre><code>bool doesExist() const\n</code></pre>","title":"function doesExist"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupofcurrentprocess","text":"<pre><code>static PosixGroup getGroupOfCurrentProcess()\n</code></pre>","title":"function getGroupOfCurrentProcess"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupid","text":"<pre><code>static cxx::optional&lt; uid_t &gt; getGroupID(\n    const string_t &amp; f_name\n)\n</code></pre>","title":"function getGroupID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupname","text":"<pre><code>static cxx::optional&lt; string_t &gt; getGroupName(\n    gid_t f_id\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getGroupName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/","text":"","title":"iox::posix::PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-types","text":"Name     using cxx::vector&lt; PosixGroup, MaxNumberOfGroups &gt; groupVector_t   using cxx::string&lt; 100 &gt; string_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-functions","text":"Name      PosixUser(const uid_t f_id)    PosixUser(const string_t &amp; f_name)   groupVector_t getGroups() const   string_t getName() const   uid_t getID() const   bool doesExist() const   PosixUser getUserOfCurrentProcess()   cxx::optional&lt; uid_t &gt; getUserID(const string_t &amp; f_name)   cxx::optional&lt; string_t &gt; getUserName(uid_t f_id)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#using-groupvector_t","text":"<pre><code>using iox::posix::PosixUser::groupVector_t =  cxx::vector&lt;PosixGroup, MaxNumberOfGroups&gt;;\n</code></pre>","title":"using groupVector_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#using-string_t","text":"<pre><code>using iox::posix::PosixUser::string_t =  cxx::string&lt;100&gt;;\n</code></pre>","title":"using string_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-posixuser","text":"<pre><code>explicit PosixUser(\n    const uid_t f_id\n)\n</code></pre>","title":"function PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-posixuser_1","text":"<pre><code>explicit PosixUser(\n    const string_t &amp; f_name\n)\n</code></pre>","title":"function PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getgroups","text":"<pre><code>groupVector_t getGroups() const\n</code></pre>","title":"function getGroups"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getname","text":"<pre><code>string_t getName() const\n</code></pre>","title":"function getName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getid","text":"<pre><code>uid_t getID() const\n</code></pre>","title":"function getID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-doesexist","text":"<pre><code>bool doesExist() const\n</code></pre>","title":"function doesExist"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getuserofcurrentprocess","text":"<pre><code>static PosixUser getUserOfCurrentProcess()\n</code></pre>","title":"function getUserOfCurrentProcess"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getuserid","text":"<pre><code>static cxx::optional&lt; uid_t &gt; getUserID(\n    const string_t &amp; f_name\n)\n</code></pre>","title":"function getUserID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getusername","text":"<pre><code>static cxx::optional&lt; string_t &gt; getUserName(\n    uid_t f_id\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getUserName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/","text":"<p>Posix semaphore C++ Wrapping class.  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/semaphore.hpp&gt;</code></p> <p>Inherits from DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;</p>","title":"iox::posix::Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#public-functions","text":"Name      Semaphore()Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods.    Semaphore(Semaphore &amp;&amp; rhs)Move constructor.   Semaphore &amp; operator=(Semaphore &amp;&amp; rhs)Move assignment operator.    Semaphore(const Semaphore &amp; )We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying.   Semaphore &amp; operator=(const Semaphore &amp; )We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying.    ~Semaphore()Destructor.   cxx::expected&lt; int, SemaphoreError &gt; getValue() constcalls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval.   cxx::expected&lt; SemaphoreError &gt; post()calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore.   cxx::expected&lt; SemaphoreWaitState, SemaphoreError &gt; timedWait(const units::Duration abs_timeout)see wait()   cxx::expected&lt; bool, SemaphoreError &gt; tryWait()see wait()   cxx::expected&lt; SemaphoreError &gt; wait()calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friends","text":"Name     class DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#additional-inherited-members","text":"<p>Public Types inherited from DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;</p>     Name     using Creation&lt; DerivedClass, ErrorType &gt; CreationPattern_t   using iox::cxx::expected&lt; DerivedClass, ErrorType &gt; result_t   using ErrorType errorType_t    <p>Public Functions inherited from DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;</p>     Name     template &lt;typename... Targs&gt; result_t create(Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction   result_t verify(DerivedClass &amp;&amp; newObject)verifies if a class was created successfully   template &lt;typename... Targs&gt; iox::cxx::expected&lt; ErrorType &gt; placementCreate(void *const memory, Targs &amp;&amp;... args)factory method which guarantees that either a working object is produced or an error value describing the error during construction    Creation() =default    Creation(Creation &amp;&amp; rhs)    Creation(const Creation &amp; rhs) =default   bool isInitialized() constreturns true if the object was constructed successfully, otherwise false    <p>Protected Attributes inherited from DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;</p>     Name     bool m_isInitialized   ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#detailed-description","text":"<pre><code>class iox::posix::Semaphore;\n</code></pre> <p>Posix semaphore C++ Wrapping class. </p> <pre><code>auto semaphore = posix::Semaphore::CreateUnnamed(false, 5);\nint value;\nif ( semaphore.getValue(value) ) // no error has occurred\n{\n    std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore","text":"<pre><code>Semaphore()\n</code></pre> <p>Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods. </p>","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_1","text":"<pre><code>Semaphore(\n    Semaphore &amp;&amp; rhs\n)\n</code></pre> <p>Move constructor. </p>","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-operator","text":"<pre><code>Semaphore &amp; operator=(\n    Semaphore &amp;&amp; rhs\n)\n</code></pre> <p>Move assignment operator. </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_2","text":"<pre><code>Semaphore(\n    const Semaphore &amp; \n)\n</code></pre> <p>We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. </p>","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-operator_1","text":"<pre><code>Semaphore &amp; operator=(\n    const Semaphore &amp; \n)\n</code></pre> <p>We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_3","text":"<pre><code>~Semaphore()\n</code></pre> <p>Destructor. </p>","title":"function ~Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-getvalue","text":"<pre><code>cxx::expected&lt; int, SemaphoreError &gt; getValue() const\n</code></pre> <p>calls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval. </p> <p>Parameters: </p> <ul> <li>value reference in which the value of the semaphore is written to</li> </ul> <p>Return: expected which contains either the value of the semaphore or the cause why the value could not be retrieved </p> <p>If one or more processes or threads are blocked waiting to lock the semaphore with sem_wait(3), POSIX.1 permits two possibilities for the value returned in sval: either 0 is returned; or a negative number whose absolute value is the count of the number of processes and threads currently blocked in sem_wait(3). Linux adopts the former behavior.</p>","title":"function getValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-post","text":"<pre><code>cxx::expected&lt; SemaphoreError &gt; post()\n</code></pre> <p>calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. </p> <p>Return: if post fails the expected contains the error which occurred </p>","title":"function post"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-timedwait","text":"<pre><code>cxx::expected&lt; SemaphoreWaitState, SemaphoreError &gt; timedWait(\n    const units::Duration abs_timeout\n)\n</code></pre> <p>see wait()</p> <p>Parameters: </p> <ul> <li>abs_timeout timeout of the wait </li> </ul> <p>Return: when successful the SemaphoreWaitState states if a timeout happened or not otherwise the SemaphoreError contains the error </p>","title":"function timedWait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-trywait","text":"<pre><code>cxx::expected&lt; bool, SemaphoreError &gt; tryWait()\n</code></pre> <p>see wait()</p> <p>Return: if the semaphore was decremented the expected contains the value true otherwise false. if an error occurred it is stored inside the expected </p>","title":"function tryWait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-wait","text":"<pre><code>cxx::expected&lt; SemaphoreError &gt; wait()\n</code></pre> <p>calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call. </p> <p>Return: if an error during the call occurs the error value is set </p> <p>iox_sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking.</p> <p>iox_sem_timedwait() is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decrement cannot be immediately performed.</p> <p>If the timeout has already expired by the time of the call, and the semaphore could not be locked immediately, then iox_sem_timedwait() fails with a timeout error (errno set to ETIMEDOUT).</p> <p>If the operation can be performed immediately, then iox_sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout. Furthermore, the validity of abs_timeout is not checked in this case.</p>","title":"function wait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friend-designpatterncreation-semaphore-semaphoreerror","text":"<pre><code>friend class DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;(\n    DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt; \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/","text":"","title":"classiox 1 1posix 1 1SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#ioxposixsignalguard","text":"<p>The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call.  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/signal_handler.hpp&gt;</code></p>","title":"iox::posix::SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#public-functions","text":"Name      SignalGuard(SignalGuard &amp;&amp; rhs)    SignalGuard(const SignalGuard &amp; )    ~SignalGuard()   SignalGuard &amp; operator=(const SignalGuard &amp; rhs)   SignalGuard &amp; operator=(SignalGuard &amp;&amp; rhs)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friends","text":"Name     SignalGuard registerSignalHandler(const Signal, const SignalHandlerCallback_t) Register a callback for a specific posix signal (SIG***).","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#detailed-description","text":"<pre><code>class iox::posix::SignalGuard;\n</code></pre> <p>The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. </p> <p>Attention: NEVER USE THIS CLASS AS A MEMBER VARIABLE! A class which should be used only in method/function scopes. </p> <pre><code>{\n  auto signalGuard = registerSignalHandler(Signal::BUS, printErrorMessage);\n  my_c_call_which_can_cause_SIGBUS();\n}\n// here we are out of scope and the signal action for Signal::BUS is restored\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard","text":"<pre><code>SignalGuard(\n    SignalGuard &amp;&amp; rhs\n)\n</code></pre>","title":"function SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard_1","text":"<pre><code>SignalGuard(\n    const SignalGuard &amp; \n)\n</code></pre>","title":"function SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard_2","text":"<pre><code>~SignalGuard()\n</code></pre>","title":"function ~SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-operator","text":"<pre><code>SignalGuard &amp; operator=(\n    const SignalGuard &amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-operator_1","text":"<pre><code>SignalGuard &amp; operator=(\n    SignalGuard &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friend-registersignalhandler","text":"<pre><code>friend SignalGuard registerSignalHandler(\n    const Signal,\n\n    const SignalHandlerCallback_t\n);\n</code></pre> <p>Register a callback for a specific posix signal (SIG***). </p> <p>Parameters: </p> <ul> <li>Signal the signal to which the callback should be attached </li> <li>callback the callback which should be called when the signal is raised. </li> </ul> <p>Return: SignalGuard, when it goes out of scope the previous signal action is restored. </p> <p>Attention: if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend registerSignalHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/","text":"<p>The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred.  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/signal_watcher.hpp&gt;</code></p>","title":"iox::posix::SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#public-functions","text":"Name      SignalWatcher(const SignalWatcher &amp; )    SignalWatcher(SignalWatcher &amp;&amp; )    ~SignalWatcher() =default   SignalWatcher &amp; operator=(const SignalWatcher &amp; )   SignalWatcher &amp; operator=(SignalWatcher &amp;&amp; )   void waitForSignal() constBlocks until either SIGTERM or SIGINT has occurred.   bool wasSignalTriggered() constReturns true when SIGTERM or SIGINT has occurred, otherwise false.   SignalWatcher &amp; getInstance()Returns the singleton instance of the SignalWatcher.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#protected-functions","text":"Name      SignalWatcher()","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friends","text":"Name     void internalSignalHandler(int )","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#detailed-description","text":"<pre><code>class iox::posix::SignalWatcher;\n</code></pre> <p>The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. </p> <pre><code>// can be used to loop until SIGINT or SIGTERM has occurred\n#include &lt;iceoryx_hoofs/posix/signal_watcher.hpp&gt;\nvoid loopUntilTerminationRequested()\n{\n    while(!iox::posix::hasTerminationRequested())\n    {\n        // your algorithm\n    }\n}\n\n// another possibility is to block until SIGINT or SIGTERM has occurred\nvoid blockUntilCtrlC() {\n    // your objects which spawn threads\n    iox::posix::waitForTerminationRequest();\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher","text":"<pre><code>SignalWatcher(\n    const SignalWatcher &amp; \n)\n</code></pre>","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_1","text":"<pre><code>SignalWatcher(\n    SignalWatcher &amp;&amp; \n)\n</code></pre>","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_2","text":"<pre><code>~SignalWatcher() =default\n</code></pre>","title":"function ~SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-operator","text":"<pre><code>SignalWatcher &amp; operator=(\n    const SignalWatcher &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-operator_1","text":"<pre><code>SignalWatcher &amp; operator=(\n    SignalWatcher &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-waitforsignal","text":"<pre><code>void waitForSignal() const\n</code></pre> <p>Blocks until either SIGTERM or SIGINT has occurred. </p>","title":"function waitForSignal"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-wassignaltriggered","text":"<pre><code>bool wasSignalTriggered() const\n</code></pre> <p>Returns true when SIGTERM or SIGINT has occurred, otherwise false. </p>","title":"function wasSignalTriggered"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-getinstance","text":"<pre><code>static SignalWatcher &amp; getInstance()\n</code></pre> <p>Returns the singleton instance of the SignalWatcher. </p>","title":"function getInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_3","text":"<pre><code>SignalWatcher()\n</code></pre>","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friend-internalsignalhandler","text":"<pre><code>friend void internalSignalHandler(\n    int \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend internalSignalHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/","text":"<p>Interface for timers on POSIX operating systems.  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/timer.hpp&gt;</code></p>","title":"iox::posix::Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-types","text":"Name     enum RunMode   enum CatchUpPolicy { SKIP_TO_NEXT_BEAT, IMMEDIATE, TERMINATE}defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-functions","text":"Name      Timer(const units::Duration timeToWait)Creates a timer without an operating system callback.    Timer(const units::Duration timeToWait, const std::function&lt; void()&gt; &amp; callback)Creates a timer with an operating system callback.    Timer(const Timer &amp; other)Move or semantics are forbidden as address of object is not allowed to change.    Timer(Timer &amp;&amp; other)Move or semantics are forbidden as address of object is not allowed to change.   Timer &amp; operator=(const Timer &amp; other)Move or semantics are forbidden as address of object is not allowed to change.   Timer &amp; operator=(Timer &amp;&amp; other)Move or semantics are forbidden as address of object is not allowed to change.   virtual ~Timer() =defaultD'tor.   cxx::expected&lt; TimerError &gt; start(const RunMode runMode, const CatchUpPolicy catchUpPolicy)Starts the timer.   cxx::expected&lt; TimerError &gt; stop()Disarms the timer.   cxx::expected&lt; TimerError &gt; restart(const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy)Disarms the timer, assigns a new timeToWait value and arms the timer.   cxx::expected&lt; units::Duration, TimerError &gt; timeUntilExpiration()   cxx::expected&lt; uint64_t, TimerError &gt; getOverruns()In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval.   bool hasError() constReturns true if the construction of the object was successful.   TimerError getError() constReturns the error that occured on constructing the object.   cxx::expected&lt; units::Duration, TimerError &gt; now()creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#detailed-description","text":"<pre><code>class iox::posix::Timer;\n</code></pre> <p>Interface for timers on POSIX operating systems. </p> <p>Note: Can't be copied or moved as operating system has a pointer to this object. It needs to be ensured that this object lives longer than timeToWait, otherwise the operating system will unregister the timer </p> <pre><code>posix::Timer TiborTheTimer{100_ms, [&amp;]() { fooBar++; }};\n\n// Start a periodic timer\nTiborTheTimer.start(true);\n// [.. wait ..]\n// Timer fires after 100_ms and calls the lambda which increments fooBar\n\nTiborTheTimer.stop();\n</code></pre> <p>This class will be DEPRECATED in the near future. In its current form there may still be potential races when start/stop/restart are called concurrently (this includes the callback, which is executed in a separate thread). The implementation also has too much overhead in the callback execution (due to execution logic and potentially multiple callback threads).</p> <p>It will be replaced with simpler versions for individual use cases, such as a CountdownTimer which can be used for watchdog/keepalive purposes. </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#enum-runmode","text":"Enumerator Value Description     ONCE     PERIODIC","title":"enum RunMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#enum-catchuppolicy","text":"Enumerator Value Description     SKIP_TO_NEXT_BEAT     IMMEDIATE     TERMINATE      <p>defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME </p>","title":"enum CatchUpPolicy"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer","text":"<pre><code>Timer(\n    const units::Duration timeToWait\n)\n</code></pre> <p>Creates a timer without an operating system callback. </p> <p>Parameters: </p> <ul> <li>timeToWait - How long should be waited? </li> </ul> <p>Note: Does not set up an operating system timer, but uses CLOCK_REALTIME instead </p> <p>Todo: refactor this cTor and its functionality to a class called StopWatch </p> <p>Creates a light-weight timer object that can be used with</p> <ul> <li>hasExpiredComparedToCreationTime()</li> <li>resetCreationTime()</li> </ul>","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_1","text":"<pre><code>Timer(\n    const units::Duration timeToWait,\n    const std::function&lt; void()&gt; &amp; callback\n)\n</code></pre> <p>Creates a timer with an operating system callback. </p> <p>Parameters: </p> <ul> <li>timeToWait - How long should be waited? </li> <li>callback - Function called after timeToWait (User needs to ensure lifetime of function till stop() call) </li> </ul> <p>Note: Operating systems needs a valid reference to this object, hence DesignPattern::Creation can't be used </p> <p>Initially the timer is stopped.</p>","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_2","text":"<pre><code>Timer(\n    const Timer &amp; other\n)\n</code></pre> <p>Move or semantics are forbidden as address of object is not allowed to change. </p>","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_3","text":"<pre><code>Timer(\n    Timer &amp;&amp; other\n)\n</code></pre> <p>Move or semantics are forbidden as address of object is not allowed to change. </p>","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-operator","text":"<pre><code>Timer &amp; operator=(\n    const Timer &amp; other\n)\n</code></pre> <p>Move or semantics are forbidden as address of object is not allowed to change. </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-operator_1","text":"<pre><code>Timer &amp; operator=(\n    Timer &amp;&amp; other\n)\n</code></pre> <p>Move or semantics are forbidden as address of object is not allowed to change. </p>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_4","text":"<pre><code>virtual ~Timer() =default\n</code></pre> <p>D'tor. </p>","title":"function ~Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-start","text":"<pre><code>cxx::expected&lt; TimerError &gt; start(\n    const RunMode runMode,\n    const CatchUpPolicy catchUpPolicy\n)\n</code></pre> <p>Starts the timer. </p> <p>Parameters: </p> <ul> <li>runMode for continuous callbacks PERIODIC otherwise ONCE </li> <li>CatchUpPolicy define behavior when callbackRuntime &gt; timeToWait </li> </ul> <p>Note: Shall only be called when callback is given </p> <p>The callback is called by the operating system after the time has expired.</p>","title":"function start"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-stop","text":"<pre><code>cxx::expected&lt; TimerError &gt; stop()\n</code></pre> <p>Disarms the timer. </p> <p>Note: Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all </p>","title":"function stop"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-restart","text":"<pre><code>cxx::expected&lt; TimerError &gt; restart(\n    const units::Duration timeToWait,\n    const RunMode runMode,\n    const CatchUpPolicy catchUpPolicy\n)\n</code></pre> <p>Disarms the timer, assigns a new timeToWait value and arms the timer. </p> <p>Parameters: </p> <ul> <li>timeToWait duration till the callback should be called </li> <li>runMode for continuous callbacks PERIODIC otherwise ONCE </li> <li>CatchUpPolicy define behavior when callbackRuntime &gt; timeToWait </li> </ul> <p>Note: Shall only be called when callback is given </p>","title":"function restart"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timeuntilexpiration","text":"<pre><code>cxx::expected&lt; units::Duration, TimerError &gt; timeUntilExpiration()\n</code></pre> <p>Note: Shall only be called when callback is given </p>","title":"function timeUntilExpiration"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-getoverruns","text":"<pre><code>cxx::expected&lt; uint64_t, TimerError &gt; getOverruns()\n</code></pre> <p>In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. </p> <p>Note: Shall only be called when callback is given </p>","title":"function getOverruns"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-haserror","text":"<pre><code>bool hasError() const\n</code></pre> <p>Returns true if the construction of the object was successful. </p>","title":"function hasError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-geterror","text":"<pre><code>TimerError getError() const\n</code></pre> <p>Returns the error that occured on constructing the object. </p>","title":"function getError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-now","text":"<pre><code>static cxx::expected&lt; units::Duration, TimerError &gt; now()\n</code></pre> <p>creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...) </p> <p>Return: if the clock_gettime call failed TimerError is returned otherwise Duration </p> <p>Todo: maybe move this to a clock implementation? </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function now"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/","text":"<p>This class will be DEPRECATED in the near future. ## Public Functions</p>     Name     void callbackHelper(sigval data)Wrapper that can be registered with the operating system.    OsTimer(const units::Duration timeToWait, const std::function&lt; void()&gt; &amp; callback)    OsTimer(const OsTimer &amp; )    OsTimer(OsTimer &amp;&amp; )   OsTimer &amp; operator=(const OsTimer &amp; )   OsTimer &amp; operator=(OsTimer &amp;&amp; )   virtual ~OsTimer()D'tor.   cxx::expected&lt; TimerError &gt; start(const RunMode runMode, const CatchUpPolicy catchUpPolicy)Starts the timer.   cxx::expected&lt; TimerError &gt; stop()Disarms the timer.   cxx::expected&lt; TimerError &gt; restart(const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy)Disarms the timer, assigns a new timeToWait value and arms the timer.   cxx::expected&lt; units::Duration, TimerError &gt; timeUntilExpiration()   cxx::expected&lt; uint64_t, TimerError &gt; getOverruns()In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval.   bool hasError() constReturns true if the construction of the object was successful.   TimerError getError() constReturns the error that occured on constructing the object.","title":"iox::posix::Timer::OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-callbackhelper","text":"<pre><code>static void callbackHelper(\n    sigval data\n)\n</code></pre> <p>Wrapper that can be registered with the operating system. </p>","title":"function callbackHelper"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer","text":"<pre><code>OsTimer(\n    const units::Duration timeToWait,\n    const std::function&lt; void()&gt; &amp; callback\n)\n</code></pre>","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_1","text":"<pre><code>OsTimer(\n    const OsTimer &amp; \n)\n</code></pre>","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_2","text":"<pre><code>OsTimer(\n    OsTimer &amp;&amp; \n)\n</code></pre>","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-operator","text":"<pre><code>OsTimer &amp; operator=(\n    const OsTimer &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-operator_1","text":"<pre><code>OsTimer &amp; operator=(\n    OsTimer &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_3","text":"<pre><code>virtual ~OsTimer()\n</code></pre> <p>D'tor. </p>","title":"function ~OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-start","text":"<pre><code>cxx::expected&lt; TimerError &gt; start(\n    const RunMode runMode,\n    const CatchUpPolicy catchUpPolicy\n)\n</code></pre> <p>Starts the timer. </p> <p>Parameters: </p> <ul> <li>runMode can be a periodic timer if set to RunMode::PERIODIC or it runs just once when it is set to RunMode::ONCE </li> <li>CatchUpPolicy define behavior when callbackRuntime &gt; timeToWait </li> </ul> <p>Note: Shall only be called when callback is given </p> <p>The callback is called by the operating system after the time has expired.</p>","title":"function start"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-stop","text":"<pre><code>cxx::expected&lt; TimerError &gt; stop()\n</code></pre> <p>Disarms the timer. </p> <p>Note: Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all </p>","title":"function stop"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-restart","text":"<pre><code>cxx::expected&lt; TimerError &gt; restart(\n    const units::Duration timeToWait,\n    const RunMode runMode,\n    const CatchUpPolicy catchUpPolicy\n)\n</code></pre> <p>Disarms the timer, assigns a new timeToWait value and arms the timer. </p> <p>Parameters: </p> <ul> <li>runMode periodic can be a periodic timer if set to RunMode::PERIODIC or once when in RunMode::ONCE </li> <li>CatchUpPolicy define behavior when callbackRuntime &gt; timeToWait </li> </ul> <p>Note: Shall only be called when callback is given </p>","title":"function restart"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-timeuntilexpiration","text":"<pre><code>cxx::expected&lt; units::Duration, TimerError &gt; timeUntilExpiration()\n</code></pre> <p>Note: Shall only be called when callback is given </p>","title":"function timeUntilExpiration"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-getoverruns","text":"<pre><code>cxx::expected&lt; uint64_t, TimerError &gt; getOverruns()\n</code></pre> <p>In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. </p> <p>Note: Shall only be called when callback is given </p>","title":"function getOverruns"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-haserror","text":"<pre><code>bool hasError() const\n</code></pre> <p>Returns true if the construction of the object was successful. </p>","title":"function hasError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-geterror","text":"<pre><code>TimerError getError() const\n</code></pre> <p>Returns the error that occured on constructing the object. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getError"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/","text":"<p>get the best fitting unsigned integer type for a given value at compile time  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/helplets.hpp&gt;</code></p>","title":"iox::cxx::BestFittingType"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#public-types","text":"Name     using typename internal::BestFittingTypeImpl&lt;(Value &gt; std::numeric_limits&lt; uint8_t &gt;::max()),(Value &gt; std::numeric_limits&lt; uint16_t &gt;::max()),(Value &gt; std::numeric_limits&lt; uint32_t &gt;::max())&gt;::Type_t Type_t ignore the warnings because we need the comparisons to find the best fitting type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#detailed-description","text":"<pre><code>template &lt;uint64_t Value&gt;\nstruct iox::cxx::BestFittingType;\n</code></pre> <p>get the best fitting unsigned integer type for a given value at compile time </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#using-type_t","text":"<pre><code>using iox::cxx::BestFittingType&lt; Value &gt;::Type_t =  typename internal::BestFittingTypeImpl&lt;(Value &gt; std::numeric_limits&lt;uint8_t&gt;::max()), (Value &gt; std::numeric_limits&lt;uint16_t&gt;::max()), (Value &gt; std::numeric_limits&lt;uint32_t&gt;::max())&gt;::Type_t;\n</code></pre> <p>ignore the warnings because we need the comparisons to find the best fitting type </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using Type_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/","text":"<p>struct used to define a compile time variable which is used to distinguish between constructors with certain behavior  <code>#include &lt;iceoryx_hoofs/cxx/string.hpp&gt;</code></p>","title":"iox::cxx::TruncateToCapacity_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#public-functions","text":"Name      TruncateToCapacity_t() =default","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#function-truncatetocapacity_t","text":"<pre><code>explicit TruncateToCapacity_t() =default\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function TruncateToCapacity_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/","text":"<p>Conditionally add const to type T if C has the const qualifier.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/type_traits.hpp&gt;</code></p>","title":"iox::cxx::add_const_conditionally"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#public-types","text":"Name     using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename C &gt;\nstruct iox::cxx::add_const_conditionally;\n</code></pre> <p>Conditionally add const to type T if C has the const qualifier. </p> <p>Template Parameters: </p> <ul> <li>T is the type to conditionally add the const qualifier </li> <li>Condition is the type which determines if the const qualifier needs to be added to T </li> </ul>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#using-type","text":"<pre><code>using iox::cxx::add_const_conditionally&lt; T, C &gt;::type =  T;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/","text":"<p>More...</p>","title":"iox::cxx::add_const_conditionally&lt; T, const C &gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#public-types","text":"Name     using const T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename C &gt;\nstruct iox::cxx::add_const_conditionally&lt; T, const C &gt;;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#using-type","text":"<pre><code>using iox::cxx::add_const_conditionally&lt; T, const C &gt;::type =  const T;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/","text":"<p>helper struct to create an expected which is signalling an error more easily  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/expected.hpp&gt;</code></p>","title":"iox::cxx::error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-functions","text":"Name      error(const T &amp; t)constructor which creates a error helper class by copying the value of t    error(T &amp;&amp; t)constructor which creates a error helper class by moving the value of t   template &lt;typename... Targs&gt;  error(Targs &amp;&amp;... args)constructor which creates a error helper class by forwarding arguments to the constructor of T","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-attributes","text":"Name     T value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nstruct iox::cxx::error;\n</code></pre> <p>helper struct to create an expected which is signalling an error more easily </p> <p>Parameters: </p> <ul> <li>T type which the success helper class should contain </li> </ul> <pre><code>cxx::expected&lt;float&gt; callMe() {\n    //...\n    return cxx::error&lt;float&gt;(12.34f);\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error","text":"<pre><code>error(\n    const T &amp; t\n)\n</code></pre> <p>constructor which creates a error helper class by copying the value of t </p> <p>Parameters: </p> <ul> <li>t value which should be later stored in an expected </li> </ul>","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error_1","text":"<pre><code>error(\n    T &amp;&amp; t\n)\n</code></pre> <p>constructor which creates a error helper class by moving the value of t </p> <p>Parameters: </p> <ul> <li>t value which should be later moved into an expected </li> </ul>","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error_2","text":"<pre><code>template &lt;typename... Targs&gt;\nerror(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>constructor which creates a error helper class by forwarding arguments to the constructor of T </p> <p>Parameters: </p> <ul> <li>args... arguments which will be perfectly forwarded to the constructor </li> </ul>","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#variable-value","text":"<pre><code>T value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/","text":"","title":"iox::cxx::forward_list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#public-attributes","text":"Name     size_type nextIdx   bool invalidElement","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#variable-nextidx","text":"<pre><code>size_type nextIdx;\n</code></pre>","title":"variable nextIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#variable-invalidelement","text":"<pre><code>bool invalidElement;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable invalidElement"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/","text":"<p>More...</p>","title":"iox::cxx::greater_or_equal"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#public-functions","text":"Name      greater_or_equal(T t)   constexpr operator T() const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#detailed-description","text":"<pre><code>template &lt;typename T ,\nT Minimum&gt;\nstruct iox::cxx::greater_or_equal;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#function-greater_or_equal","text":"<pre><code>inline greater_or_equal(\n    T t\n)\n</code></pre>","title":"function greater_or_equal"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#function-operator-t","text":"<pre><code>inline constexpr operator T() const\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/","text":"<p>helper struct to perform an emplacement at a predefined index in the constructor of a variant  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/variant.hpp&gt;</code></p>","title":"iox::cxx::in_place_index"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#public-attributes","text":"Name     constexpr uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#detailed-description","text":"<pre><code>template &lt;uint64_t N&gt;\nstruct iox::cxx::in_place_index;\n</code></pre> <p>helper struct to perform an emplacement at a predefined index in the constructor of a variant </p> <p>Template Parameters: </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#variable-value","text":"<pre><code>static constexpr uint64_t value = N;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__t/","text":"<p>helper struct which is used to call the in-place-construction constructor  <code>#include &lt;iceoryx_hoofs/cxx/optional.hpp&gt;</code></p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::cxx::in_place_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/","text":"<p>helper struct to perform an emplacement of a predefined type in in the constructor of a variant  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/variant.hpp&gt;</code></p>","title":"iox::cxx::in_place_type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#public-types","text":"Name     using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nstruct iox::cxx::in_place_type;\n</code></pre> <p>helper struct to perform an emplacement of a predefined type in in the constructor of a variant </p> <p>Template Parameters: </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#using-type","text":"<pre><code>using iox::cxx::in_place_type&lt; T &gt;::type =  T;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/","text":"<p>Check whether T is a function pointer with arbitrary signature.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/type_traits.hpp&gt;</code></p> <p>Inherits from std::false_type</p>","title":"iox::cxx::is_function_pointer"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nstruct iox::cxx::is_function_pointer;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/#check-whether-t-is-a-function-pointer-with-arbitrary-signature","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Check whether T is a function pointer with arbitrary signature."},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer_3_01ReturnType_07_5_08_07ArgTypes_8_8_8_08_4/","text":"<p>More...</p> <p>Inherits from std::true_type</p>","title":"iox::cxx::is_function_pointer&lt; ReturnType(*)(ArgTypes...)&gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer_3_01ReturnType_07_5_08_07ArgTypes_8_8_8_08_4/#detailed-description","text":"<pre><code>template &lt;typename ReturnType ,\ntypename... ArgTypes&gt;\nstruct iox::cxx::is_function_pointer&lt; ReturnType(*)(ArgTypes...)&gt;;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/","text":"<p>Verifies whether the passed Callable type is in fact invocable with the given arguments.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/type_traits.hpp&gt;</code></p>","title":"iox::cxx::is_invocable"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-functions","text":"Name     template &lt;typename C ,typename... As&gt; constexpr std::true_type test(typename cxx::invoke_result&lt; C, As... &gt;::type * )   template &lt;typename C ,typename... As&gt; constexpr std::false_type test(... )","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-attributes","text":"Name     constexpr bool value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#detailed-description","text":"<pre><code>template &lt;typename Callable ,\ntypename... ArgTypes&gt;\nstruct iox::cxx::is_invocable;\n</code></pre> <p>Verifies whether the passed Callable type is in fact invocable with the given arguments. </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#function-test","text":"<pre><code>template &lt;typename C ,\ntypename... As&gt;\nstatic inline constexpr std::true_type test(\n    typename cxx::invoke_result&lt; C, As... &gt;::type * \n)\n</code></pre> <p>Note: result_of is deprecated, switch to invoke_result in C++17 </p>","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#function-test_1","text":"<pre><code>template &lt;typename C ,\ntypename... As&gt;\nstatic inline constexpr std::false_type test(\n    ... \n)\n</code></pre>","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#variable-value","text":"<pre><code>static constexpr bool value = decltype([test](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#function-test)&lt;Callable, ArgTypes...&gt;(nullptr))::value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/","text":"<p>Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType.  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/type_traits.hpp&gt;</code></p>","title":"iox::cxx::is_invocable_r"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-functions","text":"Name     template &lt;typename C ,typename... As&gt; constexpr std::true_type test(std::enable_if_t&lt; std::is_convertible&lt; typename cxx::invoke_result&lt; C, As... &gt;::type, ReturnType &gt;::value &gt; * )   template &lt;typename C ,typename... As&gt; constexpr std::false_type test(... )","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-attributes","text":"Name     constexpr bool value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#detailed-description","text":"<pre><code>template &lt;typename ReturnType ,\ntypename Callable ,\ntypename... ArgTypes&gt;\nstruct iox::cxx::is_invocable_r;\n</code></pre> <p>Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. </p> <p>Note: This is an implementation of std::is_invokable_r (C++17). </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#function-test","text":"<pre><code>template &lt;typename C ,\ntypename... As&gt;\nstatic inline constexpr std::true_type test(\n    std::enable_if_t&lt; std::is_convertible&lt; typename cxx::invoke_result&lt; C, As... &gt;::type, ReturnType &gt;::value &gt; * \n)\n</code></pre>","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#function-test_1","text":"<pre><code>template &lt;typename C ,\ntypename... As&gt;\nstatic inline constexpr std::false_type test(\n    ... \n)\n</code></pre>","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#variable-value","text":"<pre><code>static constexpr bool value = decltype(test&lt;Callable, ArgTypes...&gt;(nullptr))::value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/","text":"","title":"iox::cxx::list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#public-attributes","text":"Name     size_type nextIdx   size_type prevIdx","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#variable-nextidx","text":"<pre><code>size_type nextIdx;\n</code></pre>","title":"variable nextIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#variable-previdx","text":"<pre><code>size_type prevIdx;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable prevIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/","text":"<p>More...</p>","title":"iox::cxx::not_null"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#public-functions","text":"Name      not_null(T t)   constexpr operator T() const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename  =typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value, void&gt;::type&gt;\nstruct iox::cxx::not_null;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#function-not_null","text":"<pre><code>inline not_null(\n    T t\n)\n</code></pre>","title":"function not_null"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#function-operator-t","text":"<pre><code>inline constexpr operator T() const\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1nullopt__t/","text":"<p>Helper struct which is used to signal an empty optional. It is equivalent to no value.  <code>#include &lt;iceoryx_hoofs/cxx/optional.hpp&gt;</code></p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::cxx::nullopt_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/","text":"<p>More...</p>","title":"iox::cxx::range"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#public-functions","text":"Name      range(T t)   constexpr operator T() const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#detailed-description","text":"<pre><code>template &lt;typename T ,\nT Minimum,\nT Maximum&gt;\nstruct iox::cxx::range;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#function-range","text":"<pre><code>inline range(\n    T t\n)\n</code></pre>","title":"function range"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#function-operator-t","text":"<pre><code>inline constexpr operator T() const\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/","text":"<p>helper struct to create an expected which is signalling success more easily  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/expected.hpp&gt;</code></p>","title":"iox::cxx::success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-functions","text":"Name      success(const T &amp; t)constructor which creates a success helper class by copying the value of t    success(T &amp;&amp; t)constructor which creates a success helper class by moving the value of t   template &lt;typename... Targs&gt;  success(Targs &amp;&amp;... args)constructor which creates a success helper class by forwarding arguments to the constructor of T","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-attributes","text":"Name     T value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#detailed-description","text":"<pre><code>template &lt;typename T  =void&gt;\nstruct iox::cxx::success;\n</code></pre> <p>helper struct to create an expected which is signalling success more easily </p> <p>Parameters: </p> <ul> <li>T type which the success helper class should contain </li> </ul> <pre><code>cxx::expected&lt;int, float&gt; callMe() {\n    //...\n    return cxx::success&lt;int&gt;(55);\n}\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success","text":"<pre><code>success(\n    const T &amp; t\n)\n</code></pre> <p>constructor which creates a success helper class by copying the value of t </p> <p>Parameters: </p> <ul> <li>t value which should be later stored in an expected </li> </ul>","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success_1","text":"<pre><code>success(\n    T &amp;&amp; t\n)\n</code></pre> <p>constructor which creates a success helper class by moving the value of t </p> <p>Parameters: </p> <ul> <li>t value which should be later moved into an expected </li> </ul>","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success_2","text":"<pre><code>template &lt;typename... Targs&gt;\nsuccess(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>constructor which creates a success helper class by forwarding arguments to the constructor of T </p> <p>Parameters: </p> <ul> <li>args... arguments which will be perfectly forwarded to the constructor </li> </ul>","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#variable-value","text":"<pre><code>T value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success_3_01void_01_4/","text":"<p>helper struct to create an error only expected which is signalling success more easily  More...</p> <p><code>#include &lt;iceoryx_hoofs/cxx/expected.hpp&gt;</code></p>","title":"iox::cxx::success&lt; void &gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success_3_01void_01_4/#detailed-description","text":"<pre><code>struct iox::cxx::success&lt; void &gt;;\n</code></pre> <p>helper struct to create an error only expected which is signalling success more easily </p> <pre><code>cxx::expected&lt;float&gt; callMe() {\n    //...\n    return cxx::success&lt;&gt;();\n}\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin/","text":"<p>Inherited by iox::log::LogBin16, iox::log::LogBin32, iox::log::LogBin64, iox::log::LogBin8</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::log::LogBin"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/","text":"<p>Inherits from iox::log::LogBin</p>","title":"iox::log::LogBin16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-functions","text":"Name     constexpr LogBin16(uint16_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-attributes","text":"Name     uint16_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#function-logbin16","text":"<pre><code>inline constexpr LogBin16(\n    uint16_t value\n)\n</code></pre>","title":"function LogBin16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#variable-value","text":"<pre><code>uint16_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/","text":"<p>Inherits from iox::log::LogBin</p>","title":"iox::log::LogBin32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-functions","text":"Name     constexpr LogBin32(uint32_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-attributes","text":"Name     uint32_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#function-logbin32","text":"<pre><code>inline constexpr LogBin32(\n    uint32_t value\n)\n</code></pre>","title":"function LogBin32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#variable-value","text":"<pre><code>uint32_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/","text":"<p>Inherits from iox::log::LogBin</p>","title":"iox::log::LogBin64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-functions","text":"Name     constexpr LogBin64(uint64_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-attributes","text":"Name     uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#function-logbin64","text":"<pre><code>inline constexpr LogBin64(\n    uint64_t value\n)\n</code></pre>","title":"function LogBin64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#variable-value","text":"<pre><code>uint64_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/","text":"<p>Inherits from iox::log::LogBin</p>","title":"iox::log::LogBin8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-functions","text":"Name     constexpr LogBin8(uint8_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-attributes","text":"Name     uint8_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#function-logbin8","text":"<pre><code>inline constexpr LogBin8(\n    uint8_t value\n)\n</code></pre>","title":"function LogBin8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#variable-value","text":"<pre><code>uint8_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/","text":"","title":"iox::log::LogEntry"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#public-attributes","text":"Name     LogLevel level   std::chrono::milliseconds time   std::string message","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-level","text":"<pre><code>LogLevel level {LogLevel::kVerbose};\n</code></pre>","title":"variable level"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-time","text":"<pre><code>std::chrono::milliseconds time {0};\n</code></pre>","title":"variable time"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-message","text":"<pre><code>std::string message;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable message"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex/","text":"<p>Inherited by iox::log::LogHex16, iox::log::LogHex32, iox::log::LogHex64, iox::log::LogHex8</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::log::LogHex"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/","text":"<p>Inherits from iox::log::LogHex</p>","title":"iox::log::LogHex16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-functions","text":"Name     constexpr LogHex16(uint16_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-attributes","text":"Name     uint16_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#function-loghex16","text":"<pre><code>inline constexpr LogHex16(\n    uint16_t value\n)\n</code></pre>","title":"function LogHex16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#variable-value","text":"<pre><code>uint16_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/","text":"<p>Inherits from iox::log::LogHex</p>","title":"iox::log::LogHex32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-functions","text":"Name     constexpr LogHex32(uint32_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-attributes","text":"Name     uint32_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#function-loghex32","text":"<pre><code>inline constexpr LogHex32(\n    uint32_t value\n)\n</code></pre>","title":"function LogHex32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#variable-value","text":"<pre><code>uint32_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/","text":"<p>Inherits from iox::log::LogHex</p>","title":"iox::log::LogHex64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-functions","text":"Name     constexpr LogHex64(uint64_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-attributes","text":"Name     uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#function-loghex64","text":"<pre><code>inline constexpr LogHex64(\n    uint64_t value\n)\n</code></pre>","title":"function LogHex64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#variable-value","text":"<pre><code>uint64_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/","text":"<p>Inherits from iox::log::LogHex</p>","title":"iox::log::LogHex8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-functions","text":"Name     constexpr LogHex8(uint8_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-attributes","text":"Name     uint8_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#function-loghex8","text":"<pre><code>inline constexpr LogHex8(\n    uint8_t value\n)\n</code></pre>","title":"function LogHex8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#variable-value","text":"<pre><code>uint8_t value;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/","text":"","title":"iox::log::LogRawBuffer"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#public-attributes","text":"Name     const uint8_t * data   uint8_t size","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#variable-data","text":"<pre><code>const uint8_t * data;\n</code></pre>","title":"variable data"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#variable-size","text":"<pre><code>uint8_t size;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable size"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateNamedSemaphore__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::posix::CreateNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::posix::CreateUnnamedSharedMemorySemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::posix::CreateUnnamedSingleProcessSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1OpenNamedSemaphore__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::posix::OpenNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/","text":"<p>result of a posix call  More...</p> <p><code>#include &lt;iceoryx_hoofs/posix_wrapper/posix_call.hpp&gt;</code></p>","title":"iox::posix::PosixCallResult"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-functions","text":"Name      PosixCallResult() =default   cxx::string&lt; POSIX_CALL_ERROR_STRING_SIZE &gt; getHumanReadableErrnum() constreturns the result of std::strerror(errnum) which acquires a human readable error string","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-attributes","text":"Name     T value the return value of the posix function call   int32_t errnum the errno value which was set by the posix function call","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nstruct iox::posix::PosixCallResult;\n</code></pre> <p>result of a posix call </p>","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#function-posixcallresult","text":"<pre><code>PosixCallResult() =default\n</code></pre>","title":"function PosixCallResult"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#function-gethumanreadableerrnum","text":"<pre><code>cxx::string&lt; POSIX_CALL_ERROR_STRING_SIZE &gt; getHumanReadableErrnum() const\n</code></pre> <p>returns the result of std::strerror(errnum) which acquires a human readable error string </p>","title":"function getHumanReadableErrnum"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#variable-value","text":"<pre><code>T value {};\n</code></pre> <p>the return value of the posix function call </p>","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#variable-errnum","text":"<pre><code>int32_t errnum = POSIX_CALL_INVALID_ERRNO;\n</code></pre> <p>the errno value which was set by the posix function call </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable errnum"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/","text":"","title":"iox::posix::PosixRights"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-functions","text":"Name      PosixRights(bool f_read, bool f_write, bool f_execute)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-attributes","text":"Name     bool m_read   bool m_write   bool m_execute","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#function-posixrights","text":"<pre><code>PosixRights(\n    bool f_read,\n    bool f_write,\n    bool f_execute\n)\n</code></pre>","title":"function PosixRights"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_read","text":"<pre><code>bool m_read;\n</code></pre>","title":"variable m_read"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_write","text":"<pre><code>bool m_write;\n</code></pre>","title":"variable m_write"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_execute","text":"<pre><code>bool m_execute;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_execute"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/","text":"","title":"iox::posix::Timer::OsTimerCallbackHandle"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-functions","text":"Name     sigval indexAndDescriptorToSigval(uint8_t index, uint32_t descriptor)   uint8_t sigvalToIndex(sigval intVal)   uint32_t sigvalToDescriptor(sigval intVal)   void incrementDescriptor()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-attributes","text":"Name     constexpr uint32_t MAX_DESCRIPTOR_VALUE   std::mutex m_accessMutex   std::atomic&lt; uint32_t &gt; m_descriptor the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first   std::atomic_flag m_callbackIsAboutToBeExecuted   std::atomic&lt; bool &gt; m_inUse   std::atomic&lt; bool &gt; m_isTimerActive   std::atomic&lt; uint64_t &gt; m_timerInvocationCounter   CatchUpPolicy m_catchUpPolicy   OsTimer * m_timer","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-indexanddescriptortosigval","text":"<pre><code>static sigval indexAndDescriptorToSigval(\n    uint8_t index,\n    uint32_t descriptor\n)\n</code></pre>","title":"function indexAndDescriptorToSigval"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-sigvaltoindex","text":"<pre><code>static uint8_t sigvalToIndex(\n    sigval intVal\n)\n</code></pre>","title":"function sigvalToIndex"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-sigvaltodescriptor","text":"<pre><code>static uint32_t sigvalToDescriptor(\n    sigval intVal\n)\n</code></pre>","title":"function sigvalToDescriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-incrementdescriptor","text":"<pre><code>void incrementDescriptor()\n</code></pre>","title":"function incrementDescriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-max_descriptor_value","text":"<pre><code>static constexpr uint32_t MAX_DESCRIPTOR_VALUE {(1u &lt;&lt; 24u) - 1u};\n</code></pre>","title":"variable MAX_DESCRIPTOR_VALUE"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_accessmutex","text":"<pre><code>std::mutex m_accessMutex;\n</code></pre>","title":"variable m_accessMutex"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_descriptor","text":"<pre><code>std::atomic&lt; uint32_t &gt; m_descriptor {0u};\n</code></pre> <p>the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first </p>","title":"variable m_descriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_callbackisabouttobeexecuted","text":"<pre><code>std::atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT;\n</code></pre>","title":"variable m_callbackIsAboutToBeExecuted"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_inuse","text":"<pre><code>std::atomic&lt; bool &gt; m_inUse {false};\n</code></pre>","title":"variable m_inUse"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_istimeractive","text":"<pre><code>std::atomic&lt; bool &gt; m_isTimerActive {false};\n</code></pre>","title":"variable m_isTimerActive"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_timerinvocationcounter","text":"<pre><code>std::atomic&lt; uint64_t &gt; m_timerInvocationCounter {0u};\n</code></pre>","title":"variable m_timerInvocationCounter"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_catchuppolicy","text":"<pre><code>CatchUpPolicy m_catchUpPolicy {CatchUpPolicy::TERMINATE};\n</code></pre>","title":"variable m_catchUpPolicy"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_timer","text":"<pre><code>OsTimer * m_timer {nullptr};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_timer"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/","text":"","title":"iceoryx_hoofs/cxx/algorithm.hpp"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::algorithm","title":"Namespaces"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_ALGORITHM_HPP\n#define IOX_HOOFS_CXX_ALGORITHM_HPP\n\n#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\nnamespace iox\n{\nnamespace algorithm\n{\ntemplate &lt;typename T&gt;\nconstexpr T max(const T&amp; left) noexcept;\n\ntemplate &lt;typename T&gt;\nconstexpr T max(const T&amp; left, const T&amp; right) noexcept;\n\ntemplate &lt;typename T, typename... Targs&gt;\nconstexpr T max(const T&amp; left, const T&amp; right, const Targs&amp;... args) noexcept;\n\ntemplate &lt;typename T&gt;\nconstexpr T min(const T&amp; left) noexcept;\n\ntemplate &lt;typename T&gt;\nconstexpr T min(const T&amp; left, const T&amp; right) noexcept;\n\ntemplate &lt;typename T, typename... Targs&gt;\nconstexpr T min(const T&amp; left, const T&amp; right, const Targs&amp;... args) noexcept;\n\ntemplate &lt;typename T, typename CompareType&gt;\nconstexpr bool doesContainType() noexcept;\n\ntemplate &lt;typename T, typename CompareType, typename Next, typename... Remainder&gt;\nconstexpr bool doesContainType() noexcept;\n\ntemplate &lt;typename T&gt;\ninline constexpr bool doesContainValue(const T) noexcept;\n\ntemplate &lt;typename T, typename... ValueList&gt;\ninline constexpr bool\ndoesContainValue(const T value, const T firstValueListEntry, const ValueList... remainingValueListEntries) noexcept;\n\ntemplate &lt;typename Container&gt;\nContainer uniqueMergeSortedContainers(const Container&amp; v1, const Container&amp; v2) noexcept;\n} // namespace algorithm\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/algorithm.inl\"\n\n#endif // IOX_HOOFS_CXX_ALGORITHM_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/attributes_8hpp/","text":"","title":"iceoryx_hoofs/cxx/attributes.hpp"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#defines","text":"Name      IOX_DISCARD_RESULT(expr) if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value    IOX_NO_DISCARD IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well.    IOX_FALLTHROUGH IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler.    IOX_MAYBE_UNUSED IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler.","title":"Defines"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_discard_result","text":"<pre><code>#define IOX_DISCARD_RESULT(\n    expr\n)\nstatic_cast&lt;void&gt;(expr)\n</code></pre> <p>if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value </p> <p>Parameters: </p> <ul> <li>expr name of the function where the return value is not used. </li> </ul> <pre><code>uint32_t foo();\nIOX_DISCARD_RESULT(foo()); // suppress compiler warning for unused return value\n</code></pre>","title":"define IOX_DISCARD_RESULT"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_no_discard","text":"<pre><code>#define IOX_NO_DISCARD \n</code></pre> <p>IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well. </p> <p>Note: [[nodiscard]], [[gnu::warn_unused]] supported since clang 3.9 (https://clang.llvm.org/cxx_status.html) activate keywords for gcc&gt;=5 or clang&gt;=4 </p>","title":"define IOX_NO_DISCARD"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_fallthrough","text":"<pre><code>#define IOX_FALLTHROUGH \n</code></pre> <p>IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler. </p> <p>Note: [[fallthrough]] supported since clang 3.9 (https://clang.llvm.org/cxx_status.html) activate keywords for gcc&gt;=7 or clang&gt;=4 </p>","title":"define IOX_FALLTHROUGH"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_maybe_unused","text":"<pre><code>#define IOX_MAYBE_UNUSED \n</code></pre> <p>IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler. </p> <p>Note: activate attribute for gcc or clang </p>","title":"define IOX_MAYBE_UNUSED"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_ATTRIBUTES_HPP\n#define IOX_HOOFS_CXX_ATTRIBUTES_HPP\n\nnamespace iox\n{\nnamespace cxx\n{\n// NOLINTNEXTLINE\n#define IOX_DISCARD_RESULT(expr) static_cast&lt;void&gt;(expr)\n\n//    [[nodiscard]], [[gnu::warn_unused]] supported since gcc 4.8 (https://gcc.gnu.org/projects/cxx-status.html)\n#if defined(_WIN32)\n// On WIN32 we are using C++17 which makes the keyword [[nodiscard]] available\n// NOLINTNEXTLINE\n#define IOX_NO_DISCARD [[nodiscard]]\n#elif defined(__APPLE__) &amp;&amp; defined(__clang__)\n// On APPLE we are using C++17 which makes the keyword [[nodiscard]] available\n// NOLINTNEXTLINE\n#define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]]\n#elif (defined(__clang__) &amp;&amp; __clang_major__ &gt;= 4)\n// NOLINTNEXTLINE\n#define IOX_NO_DISCARD [[gnu::warn_unused]]\n#elif (defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 5)\n// NOLINTNEXTLINE\n#define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]]\n#else\n// on an unknown platform we use for now nothing since we do not know what is supported there\n#define IOX_NO_DISCARD\n#endif\n\n//    [[fallthrough]] supported since gcc 7 (https://gcc.gnu.org/projects/cxx-status.html)\n#if defined(_WIN32)\n// On WIN32 we are using C++17 which makes the keyword [[fallthrough]] available\n// NOLINTNEXTLINE\n#define IOX_FALLTHROUGH [[fallthrough]]\n#elif defined(__APPLE__) &amp;&amp; defined(__clang__)\n// On APPLE we are using C++17 which makes the keyword [[fallthrough]] available\n// NOLINTNEXTLINE\n#define IOX_FALLTHROUGH [[fallthrough]]\n#elif (defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 7) &amp;&amp; !defined(__clang__)\n// clang prints a warning therefore we exclude it here\n// NOLINTNEXTLINE\n#define IOX_FALLTHROUGH [[fallthrough]]\n#else\n// on an unknown platform we use for now nothing since we do not know what is supported there\n#define IOX_FALLTHROUGH\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n// NOLINTNEXTLINE\n#define IOX_MAYBE_UNUSED [[gnu::unused]]\n#elif defined(_WIN32)\n// On WIN32 we are using C++17 which makes the attribute [[maybe_unused]] available\n// NOLINTNEXTLINE\n#define IOX_MAYBE_UNUSED [[maybe_unused]]\n// on an unknown platform we use for now nothing since we do not know what is supported there\n#else\n#define IOX_MAYBE_UNUSED\n#endif\n\n\n} // namespace cxx\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/convert_8hpp/","text":"","title":"iceoryx_hoofs/cxx/convert.hpp"},{"location":"API-reference/hoofs/Files/convert_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/convert_8hpp/#classes","text":"Name     class iox::cxx::convert Collection of static methods for conversion from and to string.","title":"Classes"},{"location":"API-reference/hoofs/Files/convert_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_CONVERT_HPP\n#define IOX_HOOFS_CXX_CONVERT_HPP\n\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/posix_wrapper/posix_call.hpp\"\n\n#include &lt;climits&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nclass convert\n{\n  public:\n    enum class NumberType\n    {\n        INTEGER,\n        UNSIGNED_INTEGER,\n        FLOAT\n    };\n\n    static constexpr int32_t STRTOULL_BASE = 10;\n\n    template &lt;typename Source&gt;\n    static typename std::enable_if&lt;!std::is_convertible&lt;Source, std::string&gt;::value, std::string&gt;::type\n    toString(const Source&amp; t) noexcept;\n\n    template &lt;typename Source&gt;\n    static typename std::enable_if&lt;std::is_convertible&lt;Source, std::string&gt;::value, std::string&gt;::type\n    toString(const Source&amp; t) noexcept;\n\n    template &lt;typename Destination&gt;\n    static bool fromString(const char* v, Destination&amp; dest) noexcept;\n\n    static bool stringIsNumber(const char* v, const NumberType type) noexcept;\n\n  private:\n    static bool stringIsNumberWithErrorMessage(const char* v, const NumberType type) noexcept;\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/convert.inl\"\n\n#endif // IOX_HOOFS_CXX_CONVERT_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/creation_8hpp/","text":"","title":"iceoryx_hoofs/design_pattern/creation.hpp"},{"location":"API-reference/hoofs/Files/creation_8hpp/#namespaces","text":"Name     DesignPattern","title":"Namespaces"},{"location":"API-reference/hoofs/Files/creation_8hpp/#classes","text":"Name     class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from <code>[Creation]()</code> and your class has three more static factory methods - <code>create</code>, <code>placementCreate</code> and <code>verify</code>. <code>create</code> forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables <code>m_isInitialized</code> and <code>m_errorValue</code>. The user always has to set <code>m_isInitialized</code> to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided <code>m_errorValue</code> variable which is then returned to the user.","title":"Classes"},{"location":"API-reference/hoofs/Files/creation_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP\n#define IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n\n#include &lt;utility&gt;\n\nnamespace DesignPattern\n{\ntemplate &lt;typename DerivedClass, typename ErrorType&gt;\nclass Creation\n{\n  public:\n    using CreationPattern_t = Creation&lt;DerivedClass, ErrorType&gt;;\n    using result_t = iox::cxx::expected&lt;DerivedClass, ErrorType&gt;;\n    using errorType_t = ErrorType;\n\n    template &lt;typename... Targs&gt;\n    static result_t create(Targs&amp;&amp;... args) noexcept;\n\n    static result_t verify(DerivedClass&amp;&amp; newObject) noexcept;\n\n    template &lt;typename... Targs&gt;\n    static iox::cxx::expected&lt;ErrorType&gt; placementCreate(void* const memory, Targs&amp;&amp;... args) noexcept;\n\n    Creation() noexcept = default;\n    Creation(Creation&amp;&amp; rhs) noexcept;\n\n    Creation&amp; operator=(Creation&amp;&amp; rhs) noexcept;\n    Creation(const Creation&amp; rhs) noexcept = default;\n    Creation&amp; operator=(const Creation&amp; rhs) noexcept = default;\n\n    bool isInitialized() const noexcept;\n\n  protected:\n    bool m_isInitialized{false};\n    ErrorType m_errorValue;\n};\n\n} // namespace DesignPattern\n\n#include \"iceoryx_hoofs/internal/design_pattern/creation.inl\"\n\n#endif // IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/","text":"","title":"iceoryx_hoofs/cxx/deadline_timer.hpp"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#classes","text":"Name     class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off.","title":"Classes"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_DEADLINETIMER_HPP\n#define IOX_HOOFS_CXX_DEADLINETIMER_HPP\n\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/platform/signal.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nclass DeadlineTimer\n{\n  public:\n    explicit DeadlineTimer(const iox::units::Duration timeToWait) noexcept;\n\n    bool hasExpired() const noexcept;\n\n    void reset() noexcept;\n\n    void reset(const iox::units::Duration timeToWait) noexcept;\n\n    iox::units::Duration remainingTime() const noexcept;\n\n  private:\n    static iox::units::Duration getCurrentMonotonicTime() noexcept;\n\n    iox::units::Duration m_timeToWait;\n    iox::units::Duration m_endTime;\n};\n\n} // namespace cxx\n} // namespace iox\n\n\n#endif // IOX_HOOFS_CXX_DEADLINETIMER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/dir_43372932726f396de09d653db921856f/","text":"","title":"iceoryx_hoofs"},{"location":"API-reference/hoofs/Files/dir_43372932726f396de09d653db921856f/#directories","text":"Name     iceoryx_hoofs/concurrent   iceoryx_hoofs/cxx   iceoryx_hoofs/design_pattern   iceoryx_hoofs/error_handling   iceoryx_hoofs/log   iceoryx_hoofs/posix_wrapper     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Directories"},{"location":"API-reference/hoofs/Files/dir_4554a0dfe1910cf7e5fc30606e89ec3b/","text":"","title":"iceoryx_hoofs/log"},{"location":"API-reference/hoofs/Files/dir_4554a0dfe1910cf7e5fc30606e89ec3b/#files","text":"Name     iceoryx_hoofs/log/logcommon.hpp   iceoryx_hoofs/log/logger.hpp   iceoryx_hoofs/log/logging.hpp   iceoryx_hoofs/log/logging_free_function_building_block.hpp   iceoryx_hoofs/log/logmanager.hpp   iceoryx_hoofs/log/logstream.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/dir_4be3a838476cf176e1cc6d252595800c/","text":"","title":"iceoryx_hoofs/error_handling"},{"location":"API-reference/hoofs/Files/dir_4be3a838476cf176e1cc6d252595800c/#files","text":"Name     iceoryx_hoofs/error_handling/error_handling.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/dir_80df14e6826adad25285ba7061a3cbc3/","text":"","title":"iceoryx_hoofs/posix_wrapper"},{"location":"API-reference/hoofs/Files/dir_80df14e6826adad25285ba7061a3cbc3/#files","text":"Name     iceoryx_hoofs/posix_wrapper/file_lock.hpp   iceoryx_hoofs/posix_wrapper/named_pipe.hpp   iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp   iceoryx_hoofs/posix_wrapper/posix_call.hpp   iceoryx_hoofs/posix_wrapper/semaphore.hpp   iceoryx_hoofs/posix_wrapper/signal_handler.hpp   iceoryx_hoofs/posix_wrapper/signal_watcher.hpp   iceoryx_hoofs/posix_wrapper/thread.hpp   iceoryx_hoofs/posix_wrapper/timer.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/dir_8475303a094ead7ab771a23b7ea9d6dc/","text":"","title":"iceoryx_hoofs/concurrent"},{"location":"API-reference/hoofs/Files/dir_8475303a094ead7ab771a23b7ea9d6dc/#files","text":"Name     iceoryx_hoofs/concurrent/lockfree_queue.hpp   iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/dir_9f0c002bf5da746f923d40dd18d0d6ea/","text":"","title":"iceoryx_hoofs/design_pattern"},{"location":"API-reference/hoofs/Files/dir_9f0c002bf5da746f923d40dd18d0d6ea/#files","text":"Name     iceoryx_hoofs/design_pattern/creation.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/dir_dd6b3e218624307615d59b658265510b/","text":"","title":"iceoryx_hoofs/cxx"},{"location":"API-reference/hoofs/Files/dir_dd6b3e218624307615d59b658265510b/#files","text":"Name     iceoryx_hoofs/cxx/algorithm.hpp   iceoryx_hoofs/cxx/attributes.hpp   iceoryx_hoofs/cxx/convert.hpp   iceoryx_hoofs/cxx/deadline_timer.hpp   iceoryx_hoofs/cxx/expected.hpp   iceoryx_hoofs/cxx/filesystem.hpp   iceoryx_hoofs/cxx/forward_list.hpp   iceoryx_hoofs/cxx/function.hpp   iceoryx_hoofs/cxx/function_ref.hpp   iceoryx_hoofs/cxx/functional_interface.hpp   iceoryx_hoofs/cxx/generic_raii.hpp   iceoryx_hoofs/cxx/helplets.hpp   iceoryx_hoofs/cxx/list.hpp   iceoryx_hoofs/cxx/method_callback.hpp   iceoryx_hoofs/cxx/newtype.hpp   iceoryx_hoofs/cxx/optional.hpp   iceoryx_hoofs/cxx/poor_mans_heap.hpp   iceoryx_hoofs/cxx/requires.hpp   iceoryx_hoofs/cxx/scoped_static.hpp   iceoryx_hoofs/cxx/serialization.hpp   iceoryx_hoofs/cxx/stack.hpp   iceoryx_hoofs/cxx/string.hpp   iceoryx_hoofs/cxx/type_traits.hpp   iceoryx_hoofs/cxx/types.hpp   iceoryx_hoofs/cxx/unique_ptr.hpp   iceoryx_hoofs/cxx/variant.hpp   iceoryx_hoofs/cxx/variant_queue.hpp   iceoryx_hoofs/cxx/vector.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/","text":"","title":"iceoryx_hoofs/error_handling/error_handling.hpp"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context","title":"Namespaces"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#classes","text":"Name     class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling.","title":"Classes"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#defines","text":"Name      ICEORYX_ERRORS(error)    CREATE_ICEORYX_ERROR_ENUM(name)    CREATE_ICEORYX_ERROR_STRING(name)","title":"Defines"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-iceoryx_errors","text":"<pre><code>#define ICEORYX_ERRORS(\n    error\n)\n</code></pre>","title":"define ICEORYX_ERRORS"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-create_iceoryx_error_enum","text":"<pre><code>#define CREATE_ICEORYX_ERROR_ENUM(\n    name\n)\nk##name,\n</code></pre>","title":"define CREATE_ICEORYX_ERROR_ENUM"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-create_iceoryx_error_string","text":"<pre><code>#define CREATE_ICEORYX_ERROR_STRING(\n    name\n)\n#name,\n</code></pre>","title":"define CREATE_ICEORYX_ERROR_STRING"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP\n#define IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP\n\n#include \"iceoryx_hoofs/cxx/generic_raii.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n\nnamespace iox\n{\n// clang-format off\n#define ICEORYX_ERRORS(error) \\\n    error(NO_ERROR)\\\n    error(FILEREADER__FAILED_TO_OPEN_FILE) \\\n    error(POSH__ROUDI_PROCESS_SHUTDOWN_FAILED) \\\n    error(POSH__ROUDI_PROCESS_SEND_VIA_IPC_CHANNEL_FAILED)\\\n    error(POSH__RUNTIME_FACTORY_IS_NOT_SET) \\\n    error(POSH__RUNTIME_IS_CREATED_MULTIPLE_TIMES) \\\n    error(POSH__RUNTIME_PUBLISHER_PORT_NOT_UNIQUE) \\\n    error(POSH__RUNTIME_SERVICE_DESCRIPTION_FORBIDDEN) \\\n    error(POSH__RUNTIME_PUBLISHER_PORT_CREATION_UNKNOWN_ERROR) \\\n    error(POSH__RUNTIME_SUBSCRIBER_PORT_CREATION_UNKNOWN_ERROR) \\\n    error(POSH__RUNTIME_CLIENT_PORT_CREATION_UNKNOWN_ERROR) \\\n    error(POSH__RUNTIME_SERVER_PORT_CREATION_UNKNOWN_ERROR) \\\n    error(POSH__RUNTIME_ROUDI_PUBLISHER_LIST_FULL) \\\n    error(POSH__RUNTIME_ROUDI_SUBSCRIBER_LIST_FULL) \\\n    error(POSH__RUNTIME_ROUDI_OUT_OF_CLIENTS) \\\n    error(POSH__RUNTIME_ROUDI_OUT_OF_SERVERS) \\\n    error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_LIST_FULL) \\\n    error(POSH__RUNTIME_ROUDI_EVENT_VARIABLE_LIST_FULL) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_CREATE_NODE_INVALID_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_CREATE_NODE_WRONG_IPC_MESSAGE_RESPONSE) \\\n    error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_CREATION_UNKNOWN_ERROR) \\\n    error(POSH__RUNTIME_APP_WITH_SAME_RUNTIME_NAME_STILL_RUNNING) \\\n    error(POSH__RUNTIME_NO_WRITABLE_SHM_SEGMENT) \\\n    error(POSH__RUNTIME_NO_NAME_PROVIDED) \\\n    error(POSH__RUNTIME_NAME_EMPTY) \\\n    error(POSH__RUNTIME_LEADING_SLASH_PROVIDED) \\\n    error(POSH__SERVICE_DISCOVERY_UNKNOWN_EVENT_PROVIDED) \\\n    error(POSH__SERVICE_DISCOVERY_UNKNOWN_MESSAGE_PATTERN_PROVIDED) \\\n    error(POSH__PORT_MANAGER_PUBLISHERPORT_NOT_UNIQUE) \\\n    error(POSH__PORT_MANAGER_SERVERPORT_NOT_UNIQUE) \\\n    error(POSH__PORT_MANAGER_COULD_NOT_ADD_SERVICE_TO_REGISTRY) \\\n    error(POSH__PORT_MANAGER_INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN) \\\n    error(POSH__MEMPOOL_POSSIBLE_DOUBLE_FREE) \\\n    error(POSH__RECEIVERPORT_DELIVERYFIFO_OVERFLOW) \\\n    error(POSH__SENDERPORT_SAMPLE_SIZE_CHANGED_FOR_ACTIVE_PORT) \\\n    error(POSH__SENDERPORT_ACTIVATE_FIELD_WITHOUT_DATA) \\\n    error(POSH__SENDERPORT_FIELD_SUBSCRIBE_WITHOUT_DATA) \\\n    error(POSH__SENDERPORT_ACTIVATE_FIELD_WHEN_LATCHED_TOPIC_ACTIVATED) \\\n    error(POSH__SENDERPORT_ALLOCATE_FAILED) \\\n    error(POSH__SENDERPORT_SUBSCRIBER_LIST_OVERFLOW) \\\n    error(POSH__PUBLISHING_EMPTY_SAMPLE) \\\n    error(POSH__SENDING_EMPTY_REQUEST) \\\n    error(POSH__SENDING_EMPTY_RESPONSE) \\\n    error(POSH__SHM_APP_BASEADDRESS_VIOLATES_SPECIFICATION) \\\n    error(POSH__SHM_APP_SEGMENT_BASEADDRESS_VIOLATES_SPECIFICATION) \\\n    error(POSH__SHM_APP_MAPP_ERR) \\\n    error(POSH__SHM_APP_SEGMENT_MAPP_ERR) \\\n    error(POSH__SHM_APP_SEGMENT_COUNT_OVERFLOW) \\\n    error(POSH__INTERFACEPORT_CAPRO_MESSAGE_DISMISSED) \\\n    error(POSH__SERVICE_DISCOVERY_INSTANCE_CONTAINER_OVERFLOW) \\\n    error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_EVENT_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_STATE_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__BASE_CLIENT_OVERRIDING_WITH_EVENT_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__BASE_CLIENT_OVERRIDING_WITH_STATE_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__BASE_SERVER_OVERRIDING_WITH_EVENT_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__BASE_SERVER_OVERRIDING_WITH_STATE_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\\n    error(POPO__CHUNK_QUEUE_POPPER_CHUNK_WITH_INCOMPATIBLE_CHUNK_HEADER_VERSION) \\\n    error(POPO__CHUNK_DISTRIBUTOR_OVERFLOW_OF_QUEUE_CONTAINER) \\\n    error(POPO__CHUNK_DISTRIBUTOR_CLEANUP_DEADLOCK_BECAUSE_BAD_APPLICATION_TERMINATION) \\\n    error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_FREE_FROM_USER) \\\n    error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_SEND_FROM_USER) \\\n    error(POPO__CHUNK_RECEIVER_INVALID_CHUNK_TO_RELEASE_FROM_USER) \\\n    error(POPO__CHUNK_LOCKING_ERROR) \\\n    error(POPO__CHUNK_UNLOCKING_ERROR) \\\n    error(POPO__CAPRO_PROTOCOL_ERROR) \\\n    error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_FREE_FROM_USER) \\\n    error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_SEND_FROM_USER) \\\n    error(POPO__CLIENT_PORT_INVALID_RESPONSE_TO_RELEASE_FROM_USER) \\\n    error(POPO__SERVER_PORT_INVALID_REQUEST_TO_RELEASE_FROM_USER) \\\n    error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_FREE_FROM_USER) \\\n    error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_SEND_FROM_USER) \\\n    error(POPO__SERVER_PORT_NO_CLIENT_RESPONSE_QUEUE_TO_CONNECT) \\\n    error(POPO__CONDITION_VARIABLE_DATA_FAILED_TO_CREATE_SEMAPHORE) \\\n    error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAS_TRIGGERED) \\\n    error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAIT) \\\n    error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_TIMED_WAIT) \\\n    error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_RESET) \\\n    error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_DESTROY) \\\n    error(POPO__CONDITION_NOTIFIER_INDEX_TOO_LARGE) \\\n    error(POPO__CONDITION_NOTIFIER_SEMAPHORE_CORRUPT_IN_NOTIFY) \\\n    error(POPO__NOTIFICATION_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN) \\\n    error(POPO__TRIGGER_INVALID_RESET_CALLBACK) \\\n    error(POPO__TRIGGER_INVALID_HAS_TRIGGERED_CALLBACK) \\\n    error(POPO__TRIGGER_HANDLE_INVALID_RESET_CALLBACK) \\\n    error(POPO__TYPED_UNIQUE_ID_ROUDI_HAS_ALREADY_DEFINED_CUSTOM_UNIQUE_ID) \\\n    error(POPO__TYPED_UNIQUE_ID_OVERFLOW) \\\n    error(POPO__WAITSET_COULD_NOT_DETACH_CONDITION) \\\n    error(MEPOO__MEMPOOL_CONFIG_MUST_BE_ORDERED_BY_INCREASING_SIZE) \\\n    error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_WITHOUT_MEMPOOL) \\\n    error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_IS_TOO_LARGE) \\\n    error(MEPOO__MEMPOOL_GETCHUNK_POOL_IS_RUNNING_OUT_OF_CHUNKS) \\\n    error(MEPOO__MEMPOOL_CHUNKSIZE_MUST_BE_MULTIPLE_OF_CHUNK_MEMORY_ALIGNMENT) \\\n    error(MEPOO__MEMPOOL_ADDMEMPOOL_AFTER_GENERATECHUNKMANAGEMENTPOOL) \\\n    error(MEPOO__TYPED_MEMPOOL_HAS_INCONSISTENT_STATE) \\\n    error(MEPOO__TYPED_MEMPOOL_MANAGEMENT_SEGMENT_IS_BROKEN) \\\n    error(MEPOO__USER_WITH_MORE_THAN_ONE_WRITE_SEGMENT) \\\n    error(MEPOO__SEGMENT_COULD_NOT_APPLY_POSIX_RIGHTS_TO_SHARED_MEMORY) \\\n    error(MEPOO__SEGMENT_UNABLE_TO_CREATE_SHARED_MEMORY_OBJECT) \\\n    error(MEPOO__INTROSPECTION_CONTAINER_FULL) \\\n    error(MEPOO__CANNOT_ALLOCATE_CHUNK) \\\n    error(MEPOO__MAXIMUM_NUMBER_OF_MEMPOOLS_REACHED) \\\n    error(PORT_POOL__PUBLISHERLIST_OVERFLOW) \\\n    error(PORT_POOL__SUBSCRIBERLIST_OVERFLOW) \\\n    error(PORT_POOL__CLIENTLIST_OVERFLOW) \\\n    error(PORT_POOL__SERVERLIST_OVERFLOW) \\\n    error(PORT_POOL__INTERFACELIST_OVERFLOW) \\\n    error(PORT_POOL__APPLICATIONLIST_OVERFLOW) \\\n    error(PORT_POOL__NODELIST_OVERFLOW) \\\n    error(PORT_POOL__CONDITION_VARIABLE_LIST_OVERFLOW) \\\n    error(PORT_POOL__EVENT_VARIABLE_LIST_OVERFLOW) \\\n    error(PORT_MANAGER__PORT_POOL_UNAVAILABLE) \\\n    error(PORT_MANAGER__INTROSPECTION_MEMORY_MANAGER_UNAVAILABLE) \\\n    error(PORT_MANAGER__HANDLE_PUBLISHER_PORTS_INVALID_CAPRO_MESSAGE) \\\n    error(PORT_MANAGER__HANDLE_SUBSCRIBER_PORTS_INVALID_CAPRO_MESSAGE) \\\n    error(PORT_MANAGER__HANDLE_CLIENT_PORTS_INVALID_CAPRO_MESSAGE) \\\n    error(PORT_MANAGER__HANDLE_SERVER_PORTS_INVALID_CAPRO_MESSAGE) \\\n    error(PORT_MANAGER__NO_PUBLISHER_PORT_FOR_INTERNAL_SERVICE) \\\n    error(ROUDI_COMPONENTS__SHARED_MEMORY_UNAVAILABLE) \\\n    error(ROUDI_APP__FAILED_TO_CREATE_SEMAPHORE) \\\n    error(ROUDI_APP__FAILED_TO_UNLOCK_SEMAPHORE_IN_SIG_HANDLER) \\\n    error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_SEGMENT_MANAGER_MEMORY_BLOCK) \\\n    error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_INTROSPECTION_MEMORY_BLOCK) \\\n    error(ROUDI__PRECONDITIONS_FOR_PROCESS_MANAGER_NOT_FULFILLED) \\\n    error(ICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK) \\\n    error(ICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING) \\\n    error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_PORTPOOL_MEMORY_BLOCK) \\\n    error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_MANAGEMENT_MEMORY_BLOCK) \\\n    error(MQ_UNKNOWN_MSG) \\\n    error(MQ_INVALID_MSG) \\\n    error(IPC_INTERFACE__UNABLE_TO_CREATE_APPLICATION_CHANNEL) \\\n    error(IPC_INTERFACE__REG_ROUDI_NOT_AVAILABLE) \\\n    error(IPC_INTERFACE__REG_UNABLE_TO_WRITE_TO_ROUDI_CHANNEL) \\\n    error(IPC_INTERFACE__REG_ACK_INVALIG_NUMBER_OF_PARAMS) \\\n    error(IPC_INTERFACE__REG_ACK_NO_RESPONSE) \\\n    error(IPC_INTERFACE__CHECK_MQ_MAPS_TO_FILE) \\\n    error(IPC_INTERFACE__APP_WITH_SAME_NAME_STILL_RUNNING) \\\n    error(IPC_INTERFACE__COULD_NOT_ACQUIRE_FILE_LOCK) \\\n    error(POSIX_WRAPPER__FAILED_TO_CREATE_SEMAPHORE) \\\n    error(POSIX_TIMER__FIRED_TIMER_BUT_STATE_IS_INVALID) \\\n    error(POSIX_TIMER__TIMERPOOL_OVERFLOW) \\\n    error(POSIX_TIMER__INCONSISTENT_STATE) \\\n    error(POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME) \\\n    error(BINDING_C__UNDEFINED_STATE_IN_IOX_QUEUE_FULL_POLICY) \\\n    error(BINDING_C__UNDEFINED_STATE_IN_IOX_CONSUMER_TOO_SLOW_POLICY) \\\n    error(BINDING_C__PUBLISHER_OPTIONS_NOT_INITIALIZED) \\\n    error(BINDING_C__SUBSCRIBER_OPTIONS_NOT_INITIALIZED) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_EVENT_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_STATE_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_EVENT_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_STATE_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_EVENT_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_STATE_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVICE_DISCOVERY_EVENT_VALUE) \\\n    error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_MESSAGING_PATTERN_VALUE) \\\n    error(EXPECTS_ENSURES_FAILED)\n\n    // EXPECTS_ENSURES_FAILED is used as a temporary solution to make Expects/Ensures testable\n\n// clang-format on\n\n// DO NOT TOUCH START, you can doodle around with the lines above!!!\n#define CREATE_ICEORYX_ERROR_ENUM(name) k##name,\n#define CREATE_ICEORYX_ERROR_STRING(name) #name,\n\nenum class Error : uint32_t\n{\n    ICEORYX_ERRORS(CREATE_ICEORYX_ERROR_ENUM)\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Error value) noexcept;\n\nenum class ErrorLevel : uint32_t\n{\n    FATAL,\n    SEVERE,\n    MODERATE\n};\n\nusing HandlerFunction = std::function&lt;void(const Error error, const std::function&lt;void()&gt;, const ErrorLevel)&gt;;\n\nclass ErrorHandler\n{\n    friend void\n    errorHandler(const Error error, const std::function&lt;void()&gt;&amp; errorCallBack, const ErrorLevel level) noexcept;\n\n  public:\n    static cxx::GenericRAII setTemporaryErrorHandler(const HandlerFunction&amp; newHandler) noexcept;\n\n    static const char* toString(const Error error) noexcept;\n\n  protected:\n    static void reactOnErrorLevel(const ErrorLevel level, const char* errorText) noexcept;\n\n  private:\n    static void defaultHandler(const Error error,\n                               const std::function&lt;void()&gt;&amp; errorCallBack,\n                               const ErrorLevel level = ErrorLevel::FATAL) noexcept;\n\n    static const char* ERROR_NAMES[];\n    static iox::HandlerFunction handler;\n    static std::mutex handler_mutex;\n};\n\nvoid errorHandler(const Error error,\n                  const std::function&lt;void()&gt;&amp; errorCallBack = std::function&lt;void()&gt;(),\n                  const ErrorLevel level = ErrorLevel::FATAL) noexcept;\n} // namespace iox\n\n#endif // IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/expected_8hpp/","text":"","title":"iceoryx_hoofs/cxx/expected.hpp"},{"location":"API-reference/hoofs/Files/expected_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx   iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/expected_8hpp/#classes","text":"Name     struct iox::cxx::success helper struct to create an expected which is signalling success more easily   struct iox::cxx::success&lt; void &gt; helper struct to create an error only expected which is signalling success more easily   struct iox::cxx::error helper struct to create an expected which is signalling an error more easily   class iox::cxx::expected&lt; ErrorType &gt; expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception.   class iox::cxx::expected&lt; ValueType, ErrorType &gt; specialization of the expected class which can contain an error as well as a success value   class iox::cxx::expected&lt; void, ErrorType &gt;","title":"Classes"},{"location":"API-reference/hoofs/Files/expected_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_EXPECTED_HPP\n#define IOX_HOOFS_CXX_EXPECTED_HPP\n\n#include \"iceoryx_hoofs/cxx/attributes.hpp\"\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/variant.hpp\"\n\n#include &lt;utility&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nnamespace internal\n{\ntemplate &lt;typename...&gt;\nstruct IsOptional;\n} // namespace internal\n\ntemplate &lt;typename T = void&gt;\nstruct success\n{\n    success(const T&amp; t) noexcept;\n\n    success(T&amp;&amp; t) noexcept;\n    template &lt;typename... Targs&gt;\n\n    success(Targs&amp;&amp;... args) noexcept;\n\n    T value;\n};\n\ntemplate &lt;&gt;\nstruct success&lt;void&gt;\n{\n};\n\ntemplate &lt;typename T&gt;\nstruct error\n{\n    error(const T&amp; t) noexcept;\n\n    error(T&amp;&amp; t) noexcept;\n\n    template &lt;typename... Targs&gt;\n    error(Targs&amp;&amp;... args) noexcept;\n\n    T value;\n};\n\ntemplate &lt;typename... T&gt;\nclass IOX_NO_DISCARD expected;\n\ntemplate &lt;typename ErrorType&gt;\nclass IOX_NO_DISCARD expected&lt;ErrorType&gt;\n{\n  public:\n    expected() = delete;\n\n    expected(const expected&amp;) noexcept = default;\n\n    expected(expected&amp;&amp; rhs) noexcept;\n\n#if defined(_WIN32)\n    template &lt;typename ValueType&gt;\n    expected(const expected&lt;ValueType, ErrorType&gt;&amp; rhs) noexcept;\n\n    template &lt;typename ValueType&gt;\n    expected(expected&lt;ValueType, ErrorType&gt;&amp;&amp; rhs) noexcept;\n#endif\n    ~expected() noexcept = default;\n\n    expected&amp; operator=(const expected&amp;) noexcept;\n\n    expected&amp; operator=(expected&amp;&amp; rhs) noexcept;\n\n#if defined(_WIN32)\n    template &lt;typename ValueType&gt;\n    expected&amp; operator=(const expected&lt;ValueType, ErrorType&gt;&amp; rhs) noexcept;\n\n    template &lt;typename ValueType&gt;\n    expected&amp; operator=(expected&lt;ValueType, ErrorType&gt;&amp;&amp; rhs) noexcept;\n#endif\n\n    expected(const success&lt;void&gt;&amp; successValue) noexcept;\n\n    expected(const error&lt;ErrorType&gt;&amp; errorValue) noexcept;\n\n    expected(error&lt;ErrorType&gt;&amp;&amp; errorValue) noexcept;\n\n    static expected create_value() noexcept;\n\n    template &lt;typename... Targs&gt;\n    static expected create_error(Targs&amp;&amp;... args) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool has_error() const noexcept;\n\n    ErrorType&amp; get_error() &amp; noexcept;\n\n    const ErrorType&amp; get_error() const&amp; noexcept;\n\n    ErrorType&amp;&amp; get_error() &amp;&amp; noexcept;\n\n    const expected&amp; or_else(const cxx::function_ref&lt;void(ErrorType&amp;)&gt;&amp; callable) const noexcept;\n\n    expected&amp; or_else(const cxx::function_ref&lt;void(ErrorType&amp;)&gt;&amp; callable) noexcept;\n\n    const expected&amp; and_then(const cxx::function_ref&lt;void()&gt;&amp; callable) const noexcept;\n\n    expected&amp; and_then(const cxx::function_ref&lt;void()&gt;&amp; callable) noexcept;\n\n  private:\n    expected(variant&lt;ErrorType&gt;&amp;&amp; store, const bool hasError) noexcept;\n    variant&lt;ErrorType&gt; m_store;\n    bool m_hasError;\n    static constexpr uint64_t ERROR_INDEX = 0U;\n};\n\ntemplate &lt;typename ValueType, typename ErrorType&gt;\nclass IOX_NO_DISCARD expected&lt;ValueType, ErrorType&gt;\n{\n  public:\n    expected() = delete;\n\n    expected(const expected&amp;) noexcept = default;\n\n    expected(expected&amp;&amp; rhs) noexcept;\n\n    ~expected() noexcept = default;\n\n    expected&amp; operator=(const expected&amp;) noexcept;\n\n    expected&amp; operator=(expected&amp;&amp; rhs) noexcept;\n\n    expected(const success&lt;ValueType&gt;&amp; successValue) noexcept;\n\n    expected(success&lt;ValueType&gt;&amp;&amp; successValue) noexcept;\n\n    expected(const error&lt;ErrorType&gt;&amp; errorValue) noexcept;\n\n    expected(error&lt;ErrorType&gt;&amp;&amp; errorValue) noexcept;\n\n    template &lt;typename... Targs&gt;\n    static expected create_value(Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename... Targs&gt;\n    static expected create_error(Targs&amp;&amp;... args) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool has_error() const noexcept;\n\n    ErrorType&amp; get_error() &amp; noexcept;\n\n    const ErrorType&amp; get_error() const&amp; noexcept;\n\n    ErrorType&amp;&amp; get_error() &amp;&amp; noexcept;\n\n    ValueType&amp; value() &amp; noexcept;\n\n    const ValueType&amp; value() const&amp; noexcept;\n\n    ValueType&amp;&amp; value() &amp;&amp; noexcept;\n\n    ValueType value_or(const ValueType&amp; value) const noexcept;\n\n    ValueType value_or(const ValueType&amp; value) noexcept;\n\n\n    ValueType&amp; operator*() noexcept;\n\n    const ValueType&amp; operator*() const noexcept;\n\n    ValueType* operator-&gt;() noexcept;\n\n    const ValueType* operator-&gt;() const noexcept;\n\n    template &lt;typename T&gt;\n    operator expected&lt;T&gt;() noexcept;\n\n    template &lt;typename T&gt;\n    operator expected&lt;T&gt;() const noexcept;\n\n    const expected&amp; or_else(const cxx::function_ref&lt;void(ErrorType&amp;)&gt;&amp; callable) const noexcept;\n\n    expected&amp; or_else(const cxx::function_ref&lt;void(ErrorType&amp;)&gt;&amp; callable) noexcept;\n\n    const expected&amp; and_then(const cxx::function_ref&lt;void(ValueType&amp;)&gt;&amp; callable) const noexcept;\n\n    expected&amp; and_then(const cxx::function_ref&lt;void(ValueType&amp;)&gt;&amp; callable) noexcept;\n\n    template &lt;typename Optional = ValueType,\n              typename std::enable_if&lt;internal::IsOptional&lt;Optional&gt;::value, int&gt;::type = 0&gt;\n    const expected&amp; and_then(const cxx::function_ref&lt;void(typename Optional::type&amp;)&gt;&amp; callable) const noexcept;\n\n    template &lt;typename Optional = ValueType,\n              typename std::enable_if&lt;internal::IsOptional&lt;Optional&gt;::value, int&gt;::type = 0&gt;\n    expected&amp; and_then(const cxx::function_ref&lt;void(typename Optional::type&amp;)&gt;&amp; callable) noexcept;\n\n    template &lt;typename Optional = ValueType,\n              typename std::enable_if&lt;internal::IsOptional&lt;Optional&gt;::value, int&gt;::type = 0&gt;\n    [[deprecated]] const expected&amp; if_empty(const cxx::function_ref&lt;void()&gt;&amp; callable) const noexcept;\n\n    template &lt;typename Optional = ValueType,\n              typename std::enable_if&lt;internal::IsOptional&lt;Optional&gt;::value, int&gt;::type = 0&gt;\n    [[deprecated]] expected&amp; if_empty(const cxx::function_ref&lt;void()&gt;&amp; callable) noexcept;\n\n    optional&lt;ValueType&gt; to_optional() const noexcept;\n\n  private:\n    expected(variant&lt;ValueType, ErrorType&gt;&amp;&amp; f_store, const bool hasError) noexcept;\n    variant&lt;ValueType, ErrorType&gt; m_store;\n    bool m_hasError;\n    static constexpr uint64_t VALUE_INDEX = 0U;\n    static constexpr uint64_t ERROR_INDEX = 1U;\n};\n\ntemplate &lt;typename ErrorType&gt;\nclass IOX_NO_DISCARD expected&lt;void, ErrorType&gt; : public expected&lt;ErrorType&gt;\n{\n  public:\n    using expected&lt;ErrorType&gt;::expected;\n};\n\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/expected.inl\"\n\n#endif // IOX_HOOFS_CXX_EXPECTED_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/file_lock.hpp"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#classes","text":"Name     class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page)","title":"Classes"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/design_pattern/creation.hpp\"\n\nnamespace iox\n{\nnamespace posix\n{\nenum class FileLockError\n{\n    INVALID_FILE_NAME,\n    LOCKED_BY_OTHER_PROCESS,\n    ACCESS_DENIED,\n    QUOTA_EXHAUSTED,\n    INVALID_CHARACTERS_IN_FILE_NAME,\n    SYSTEM_LIMIT,\n    PROCESS_LIMIT,\n    NO_SUCH_DIRECTORY,\n    SPECIAL_FILE,\n    FILE_TOO_LARGE,\n    FILE_IN_USE,\n    OUT_OF_MEMORY,\n    I_O_ERROR,\n    SYS_CALL_NOT_IMPLEMENTED,\n    INTERNAL_LOGIC_ERROR,\n};\n\nclass FileLock : public DesignPattern::Creation&lt;FileLock, FileLockError&gt;\n{\n  public:\n    static constexpr int32_t ERROR_CODE = -1;\n    static constexpr int32_t INVALID_FD = -1;\n    static constexpr const char LOCK_FILE_SUFFIX[] = \".lock\";\n    static constexpr uint64_t FILENAME_LENGTH = platform::IOX_MAX_FILENAME_LENGTH\n                                                - sizeof(platform::IOX_LOCK_FILE_PATH_PREFIX) / sizeof(char)\n                                                - sizeof(LOCK_FILE_SUFFIX) / sizeof(char);\n\n    using FileName_t = cxx::string&lt;FILENAME_LENGTH&gt;;\n    using PathName_t = cxx::string&lt;platform::IOX_MAX_PATH_LENGTH&gt;;\n\n    FileLock(const FileLock&amp;) = delete;\n    FileLock&amp; operator=(const FileLock&amp;) = delete;\n    FileLock(FileLock&amp;&amp; rhs) noexcept;\n    FileLock&amp; operator=(FileLock&amp;&amp; rhs) noexcept;\n\n    ~FileLock() noexcept;\n\n  private:\n    int32_t m_fd{INVALID_FD};\n    FileName_t m_name;\n    PathName_t m_fileLockPath;\n\n    explicit FileLock(const FileName_t&amp; name) noexcept;\n\n    void invalidate() noexcept;\n\n    cxx::expected&lt;FileLockError&gt; initializeFileLock() noexcept;\n    FileLockError convertErrnoToFileLockError(const int32_t errnum) const noexcept;\n    cxx::expected&lt;FileLockError&gt; closeFileDescriptor() noexcept;\n\n    friend class DesignPattern::Creation&lt;FileLock, FileLockError&gt;;\n};\n} // namespace posix\n} // namespace iox\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/","text":"","title":"iceoryx_hoofs/cxx/filesystem.hpp"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_FILESYSTEM_HPP\n#define IOX_HOOFS_CXX_FILESYSTEM_HPP\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nenum class perms : uint64_t\n{\n    none = 0,\n\n    owner_read = 0400,\n    owner_write = 0200,\n    owner_exec = 0100,\n    owner_all = 0700,\n\n    group_read = 040,\n    group_write = 020,\n    group_exec = 010,\n    group_all = 070,\n\n    others_read = 04,\n    others_write = 02,\n    others_exec = 01,\n    others_all = 07,\n\n    all = 0777,\n\n    set_uid = 04000,\n    set_gid = 02000,\n    sticky_bit = 01000,\n\n    mask = 07777,\n\n    unknown = 0xFFFF\n};\n\nperms operator|(const perms&amp; lhs, const perms&amp; rhs) noexcept;\n\nperms operator&amp;(const perms&amp; lhs, const perms&amp; rhs) noexcept;\n\nperms operator^(const perms&amp; lhs, const perms&amp; rhs) noexcept;\n\nperms operator~(const perms&amp; value) noexcept;\n\nperms operator|=(perms&amp; lhs, const perms&amp; rhs) noexcept;\n\nperms operator&amp;=(perms&amp; lhs, const perms&amp; rhs) noexcept;\n\nperms operator^=(perms&amp; lhs, const perms&amp; rhs) noexcept;\n\ntemplate &lt;typename StreamType&gt;\nStreamType&amp; operator&lt;&lt;(StreamType&amp; stream, perms value) noexcept;\n} // namespace cxx\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/","text":"","title":"iceoryx_hoofs/cxx/forward_list.hpp"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#classes","text":"Name     class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation.","title":"Classes"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_FORWARD_LIST_HPP\n#define IOX_HOOFS_CXX_FORWARD_LIST_HPP\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\n#include \"iceoryx_hoofs/platform/platform_correction.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, uint64_t Capacity&gt;\nclass forward_list\n{\n  private:\n    // forward declarations, private\n    struct ListLink;\n    template &lt;bool&gt;\n    class IteratorBase;\n\n  public:\n    using iterator = IteratorBase&lt;false&gt;;\n    using const_iterator = IteratorBase&lt;true&gt;;\n    using value_type = T;\n    using size_type = decltype(Capacity);\n\n    forward_list() noexcept;\n\n    ~forward_list() noexcept;\n\n    forward_list(const forward_list&amp; rhs) noexcept;\n\n    forward_list(forward_list&amp;&amp; rhs) noexcept;\n\n    forward_list&amp; operator=(const forward_list&amp; rhs) noexcept;\n\n    forward_list&amp; operator=(forward_list&amp;&amp; rhs) noexcept;\n\n    iterator before_begin() noexcept;\n\n    const_iterator before_begin() const noexcept;\n\n    const_iterator cbefore_begin() const noexcept;\n\n    iterator begin() noexcept;\n\n    const_iterator begin() const noexcept;\n\n    const_iterator cbegin() const noexcept;\n\n    iterator end() noexcept;\n\n    const_iterator end() const noexcept;\n\n    const_iterator cend() const noexcept;\n\n    bool empty() const noexcept;\n\n    bool full() const noexcept;\n\n    size_type size() const noexcept;\n\n    size_type capacity() const noexcept;\n\n    size_type max_size() const noexcept;\n\n    T&amp; front() noexcept;\n\n    const T&amp; front() const noexcept;\n\n    bool push_front(const T&amp; data) noexcept;\n\n    bool push_front(T&amp;&amp; data) noexcept;\n\n    bool pop_front() noexcept;\n\n    void clear() noexcept;\n\n    iterator erase_after(const_iterator beforeToBeErasedIter) noexcept;\n\n    size_type remove(const T&amp; data) noexcept;\n\n    template &lt;typename UnaryPredicate&gt;\n    size_type remove_if(UnaryPredicate pred) noexcept;\n\n    template &lt;typename... ConstructorArgs&gt;\n    T&amp; emplace_front(ConstructorArgs&amp;&amp;... args) noexcept;\n\n    template &lt;typename... ConstructorArgs&gt;\n    iterator emplace_after(const_iterator afterToBeEmplacedIter, ConstructorArgs&amp;&amp;... args) noexcept;\n\n    iterator insert_after(const_iterator citer, const T&amp; data) noexcept;\n\n    iterator insert_after(const_iterator citer, T&amp;&amp; data) noexcept;\n\n  private:\n    template &lt;bool IsConstIterator = true&gt;\n    class IteratorBase\n    {\n      public:\n        // provide the following public types for a std::iterator compatible iterator_category interface\n        using iterator_category = std::forward_iterator_tag;\n        using value_type = typename std::conditional&lt;IsConstIterator, const T, T&gt;::type;\n        using difference_type = void;\n        using pointer = typename std::conditional&lt;IsConstIterator, const T*, T*&gt;::type;\n        using reference = typename std::conditional&lt;IsConstIterator, const T&amp;, T&amp;&gt;::type;\n\n\n        IteratorBase(const IteratorBase&lt;false&gt;&amp; iter) noexcept;\n\n        IteratorBase&amp; operator=(const IteratorBase&lt;false&gt;&amp; rhs) noexcept;\n\n        IteratorBase&amp; operator++() noexcept;\n\n        template &lt;bool IsConstIteratorOther&gt;\n        bool operator==(const IteratorBase&lt;IsConstIteratorOther&gt;&amp; rhs) const noexcept;\n\n        template &lt;bool IsConstIteratorOther&gt;\n        bool operator!=(const IteratorBase&lt;IsConstIteratorOther&gt;&amp; rhs) const noexcept;\n\n        reference operator*() const noexcept;\n\n        pointer operator-&gt;() const noexcept;\n\n\n      private:\n        using parentListPointer = typename std::\n            conditional&lt;IsConstIterator, const forward_list&lt;T, Capacity&gt;*, forward_list&lt;T, Capacity&gt;*&gt;::type;\n\n        explicit IteratorBase(parentListPointer parent, size_type idx) noexcept;\n\n        // Make IteratorBase&lt;true&gt; a friend class of IteratorBase&lt;false&gt; so the copy constructor can access the\n        // private member variables.\n        friend class IteratorBase&lt;true&gt;;\n        friend class forward_list&lt;T, Capacity&gt;;\n        parentListPointer m_list;\n        size_type m_iterListNodeIdx;\n    };\n\n    struct NodeLink\n    {\n        size_type nextIdx;\n        bool invalidElement;\n    };\n\n    void init() noexcept;\n    T* getDataPtrFromIdx(const size_type idx) noexcept;\n    const T* getDataPtrFromIdx(const size_type idx) const noexcept;\n\n    bool isValidElementIdx(const size_type idx) const noexcept;\n    bool isInvalidIterator(const const_iterator&amp; iter) const noexcept;\n    bool isInvalidIterOrDifferentLists(const const_iterator&amp; iter) const noexcept;\n    bool isInvalidElement(const size_type idx) const noexcept;\n    void setInvalidElement(const size_type idx, const bool value) noexcept;\n    size_type&amp; getNextIdx(const size_type idx) noexcept;\n    const size_type&amp; getNextIdx(const size_type idx) const noexcept;\n    size_type&amp; getNextIdx(const const_iterator&amp; iter) noexcept;\n    const size_type&amp; getNextIdx(const const_iterator&amp; iter) const noexcept;\n    void setNextIdx(const size_type idx, const size_type nextIdx) noexcept;\n    static void errorMessage(const char* source, const char* msg) noexcept;\n\n    //***************************************\n    //    members\n    //***************************************\n\n    // two extra slots in the list to handle the 'before_begin' and 'end' element\n    // the necessity for 'before_begin' elements stems from the way a forward_list removes elements at an arbitrary\n    // position. Removing the front-most list element (aka begin()) requires an element pointing towards this position,\n    // hence 'before_begin'. The before_begin index is the head of the list.\n    static constexpr size_type BEFORE_BEGIN_INDEX{Capacity};\n    static constexpr size_type END_INDEX{size_type(Capacity) + 1U};\n    static constexpr size_type NODE_LINK_COUNT{size_type(Capacity) + 2U};\n\n    // available storage-indices are moved between a 'freeList' (m_freeListHeadIdx) and 'usedList' where elements\n    // are inserted by the user (starting from BEFORE_BEGIN_INDEX)\n    size_type m_freeListHeadIdx{0U};\n\n    NodeLink m_links[NODE_LINK_COUNT];\n    using element_t = uint8_t[sizeof(T)];\n    alignas(T) element_t m_data[Capacity];\n\n    size_type m_size{0U};\n}; // forward_list\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/forward_list.inl\"\n\n#endif // IOX_HOOFS_CXX_FORWARD_LIST_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/function_8hpp/","text":"","title":"iceoryx_hoofs/cxx/function.hpp"},{"location":"API-reference/hoofs/Files/function_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/function_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_FUNCTION_HPP\n#define IOX_HOOFS_FUNCTION_HPP\n\n#include \"iceoryx_hoofs/internal/cxx/static_storage.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/storable_function.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename Signature, uint64_t Capacity = 128U&gt;\nusing function = storable_function&lt;static_storage&lt;Capacity&gt;, Signature&gt;;\n\n\n} // namespace cxx\n} // namespace iox\n\n#endif // IOX_HOOFS_FUNCTION_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/","text":"","title":"iceoryx_hoofs/cxx/function_ref.hpp"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#classes","text":"Name     class iox::cxx::function_ref&lt; ReturnType(ArgTypes...)&gt; cxx::function_ref is a non-owning reference to a callable.","title":"Classes"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_FUNCTION_REF_HPP\n#define IOX_HOOFS_CXX_FUNCTION_REF_HPP\n\n#include \"iceoryx_hoofs/cxx/requires.hpp\"\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n\n#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename SignatureType&gt;\nclass function_ref;\n\n\ntemplate &lt;class ReturnType, class... ArgTypes&gt;\nclass function_ref&lt;ReturnType(ArgTypes...)&gt;\n{\n    using SignatureType = ReturnType(ArgTypes...);\n\n    template &lt;typename T1, typename T2&gt;\n    using has_same_decayed_type = typename std::integral_constant&lt;\n        bool,\n        bool(std::is_same&lt;typename std::decay&lt;T1&gt;::type, typename std::decay&lt;T2&gt;::type&gt;::value)&gt;;\n\n  public:\n    function_ref() noexcept;\n\n    ~function_ref() noexcept = default;\n\n    function_ref(const function_ref&amp;) noexcept = default;\n\n    function_ref&amp; operator=(const function_ref&amp;) noexcept = default;\n\n    template &lt;typename CallableType,\n              typename = std::enable_if_t&lt;!is_function_pointer&lt;CallableType&gt;::value\n                                          &amp;&amp; !has_same_decayed_type&lt;CallableType, function_ref&gt;::value\n                                          &amp;&amp; is_invocable&lt;CallableType, ArgTypes...&gt;::value&gt;&gt;\n    function_ref(CallableType&amp;&amp; callable) noexcept;\n\n    function_ref(ReturnType (*function)(ArgTypes...)) noexcept;\n\n    function_ref(function_ref&amp;&amp; rhs) noexcept;\n\n    function_ref&amp; operator=(function_ref&amp;&amp; rhs) noexcept;\n\n    ReturnType operator()(ArgTypes... args) const noexcept;\n\n    explicit operator bool() const noexcept;\n\n    void swap(function_ref&amp; rhs) noexcept;\n\n  private:\n    void* m_pointerToCallable{nullptr};\n    ReturnType (*m_functionPointer)(void*, ArgTypes...){nullptr};\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/function_ref.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/","text":"","title":"iceoryx_hoofs/cxx/functional_interface.hpp"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx   iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP\n#define IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP\n\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nnamespace internal\n{\ntemplate &lt;typename Derived, class = void&gt;\nstruct HasValueMethod : std::false_type\n{\n};\n\ntemplate &lt;typename Derived&gt;\nstruct HasValueMethod&lt;Derived, cxx::void_t&lt;decltype(std::declval&lt;Derived&gt;().value())&gt;&gt; : std::true_type\n{\n};\n\ntemplate &lt;typename Derived, class = void&gt;\nstruct HasGetErrorMethod : std::false_type\n{\n};\n\ntemplate &lt;typename Derived&gt;\nstruct HasGetErrorMethod&lt;Derived, cxx::void_t&lt;decltype(std::declval&lt;Derived&gt;().get_error())&gt;&gt; : std::true_type\n{\n};\n\ntemplate &lt;typename Derived&gt;\nstruct Expect\n{\n    void expect(const char* const msg) const noexcept;\n};\n\ntemplate &lt;typename Derived, typename ValueType&gt;\nstruct ExpectWithValue\n{\n    //         the method prints the provided message and induces a fatal error\n    ValueType&amp; expect(const char* const msg) &amp; noexcept;\n\n    //         the method prints the provided message and induces a fatal error\n    const ValueType&amp; expect(const char* const msg) const&amp; noexcept;\n\n    //         the method prints the provided message and induces a fatal error\n    ValueType&amp;&amp; expect(const char* const msg) &amp;&amp; noexcept;\n\n    //         the method prints the provided message and induces a fatal error\n    const ValueType&amp;&amp; expect(const char* const msg) const&amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived, typename ValueType&gt;\nstruct ValueOr\n{\n    template &lt;typename U&gt;\n    ValueType value_or(U&amp;&amp; alternative) const&amp; noexcept;\n\n    template &lt;typename U&gt;\n    ValueType value_or(U&amp;&amp; alternative) &amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived, typename ValueType&gt;\nstruct AndThenWithValue\n{\n    using and_then_callback_t = cxx::function_ref&lt;void(ValueType&amp;)&gt;;\n    using const_and_then_callback_t = cxx::function_ref&lt;void(const ValueType&amp;)&gt;;\n\n    Derived&amp; and_then(const and_then_callback_t&amp; callable) &amp; noexcept;\n\n    const Derived&amp; and_then(const const_and_then_callback_t&amp; callable) const&amp; noexcept;\n\n    Derived&amp;&amp; and_then(const and_then_callback_t&amp; callable) &amp;&amp; noexcept;\n\n    const Derived&amp;&amp; and_then(const const_and_then_callback_t&amp; callable) const&amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived&gt;\nstruct AndThen\n{\n    using and_then_callback_t = cxx::function_ref&lt;void()&gt;;\n\n    Derived&amp; and_then(const and_then_callback_t&amp; callable) &amp; noexcept;\n\n    const Derived&amp; and_then(const and_then_callback_t&amp; callable) const&amp; noexcept;\n\n    Derived&amp;&amp; and_then(const and_then_callback_t&amp; callable) &amp;&amp; noexcept;\n\n    const Derived&amp;&amp; and_then(const and_then_callback_t&amp; callable) const&amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived, typename ErrorType&gt;\nstruct OrElseWithValue\n{\n    using or_else_callback_t = cxx::function_ref&lt;void(ErrorType&amp;)&gt;;\n    using const_or_else_callback_t = cxx::function_ref&lt;void(const ErrorType&amp;)&gt;;\n\n    Derived&amp; or_else(const or_else_callback_t&amp; callable) &amp; noexcept;\n\n    const Derived&amp; or_else(const const_or_else_callback_t&amp; callable) const&amp; noexcept;\n\n    Derived&amp;&amp; or_else(const or_else_callback_t&amp; callable) &amp;&amp; noexcept;\n\n    const Derived&amp;&amp; or_else(const const_or_else_callback_t&amp; callable) const&amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived&gt;\nstruct OrElse\n{\n    using or_else_callback_t = cxx::function_ref&lt;void()&gt;;\n\n    Derived&amp; or_else(const or_else_callback_t&amp; callable) &amp; noexcept;\n\n    const Derived&amp; or_else(const or_else_callback_t&amp; callable) const&amp; noexcept;\n\n    Derived&amp;&amp; or_else(const or_else_callback_t&amp; callable) &amp;&amp; noexcept;\n\n    const Derived&amp;&amp; or_else(const or_else_callback_t&amp; callable) const&amp;&amp; noexcept;\n};\n\ntemplate &lt;typename Derived, typename ValueType, typename ErrorType&gt;\nstruct FunctionalInterfaceImpl : public ExpectWithValue&lt;Derived, ValueType&gt;,\n                                 public ValueOr&lt;Derived, ValueType&gt;,\n                                 public AndThenWithValue&lt;Derived, ValueType&gt;,\n                                 public OrElseWithValue&lt;Derived, ErrorType&gt;\n{\n};\n\ntemplate &lt;typename Derived&gt;\nstruct FunctionalInterfaceImpl&lt;Derived, void, void&gt;\n    : public Expect&lt;Derived&gt;, public AndThen&lt;Derived&gt;, public OrElse&lt;Derived&gt;\n{\n};\n\ntemplate &lt;typename Derived, typename ValueType&gt;\nstruct FunctionalInterfaceImpl&lt;Derived, ValueType, void&gt; : public ExpectWithValue&lt;Derived, ValueType&gt;,\n                                                           public ValueOr&lt;Derived, ValueType&gt;,\n                                                           public AndThenWithValue&lt;Derived, ValueType&gt;,\n                                                           public OrElse&lt;Derived&gt;\n{\n};\n\ntemplate &lt;typename Derived, typename ErrorType&gt;\nstruct FunctionalInterfaceImpl&lt;Derived, void, ErrorType&gt;\n    : public Expect&lt;Derived&gt;, public AndThen&lt;Derived&gt;, public OrElseWithValue&lt;Derived, ErrorType&gt;\n{\n};\n} // namespace internal\n\ntemplate &lt;typename Derived, typename ValueType, typename ErrorType&gt;\nusing FunctionalInterface = internal::FunctionalInterfaceImpl&lt;Derived, ValueType, ErrorType&gt;;\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/functional_interface.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/","text":"","title":"iceoryx_hoofs/cxx/generic_raii.hpp"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#classes","text":"Name     class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources.","title":"Classes"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_GENERIC_RAII_HPP\n#define IOX_HOOFS_CXX_GENERIC_RAII_HPP\n\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n\n#include &lt;functional&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nclass GenericRAII\n{\n  public:\n    explicit GenericRAII(const std::function&lt;void()&gt;&amp; cleanupFunction) noexcept;\n\n    GenericRAII(const function_ref&lt;void()&gt;&amp; initFunction, const std::function&lt;void()&gt;&amp; cleanupFunction) noexcept;\n\n    ~GenericRAII() noexcept;\n\n    GenericRAII(const GenericRAII&amp;) = delete;\n    GenericRAII&amp; operator=(const GenericRAII&amp;) = delete;\n\n    GenericRAII(GenericRAII&amp;&amp; rhs) noexcept;\n\n    GenericRAII&amp; operator=(GenericRAII&amp;&amp; rhs) noexcept;\n\n  private:\n    void destroy() noexcept;\n\n  private:\n    std::function&lt;void()&gt; m_cleanupFunction;\n};\n\n} // namespace cxx\n} // namespace iox\n\n#endif // IOX_HOOFS_CXX_GENERIC_RAII_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/helplets_8hpp/","text":"","title":"iceoryx_hoofs/cxx/helplets.hpp"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx   iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#classes","text":"Name     struct iox::cxx::not_null   struct iox::cxx::greater_or_equal   struct iox::cxx::range   struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time","title":"Classes"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#defines","text":"Name      IOX_BUILDER_PARAMETER(type, name, defaultValue) Macro which generates a setter method useful for a builder pattern.","title":"Defines"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#define-iox_builder_parameter","text":"<pre><code>#define IOX_BUILDER_PARAMETER(\n    type,\n    name,\n    defaultValue\n)\n  public:                                                                                                              \\\n    decltype(auto) name(type const&amp; value)&amp;&amp;                                                                           \\\n    {                                                                                                                  \\\n        m_##name = value;                                                                                              \\\n        return std::move(*this);                                                                                       \\\n    }                                                                                                                  \\\n                                                                                                                       \\\n    decltype(auto) name(type&amp;&amp; value)&amp;&amp;                                                                                \\\n    {                                                                                                                  \\\n        m_##name = std::move(value);                                                                                   \\\n        return std::move(*this);                                                                                       \\\n    }                                                                                                                  \\\n                                                                                                                       \\\n  private:                                                                                                             \\\n    type m_##name{defaultValue};\n</code></pre> <p>Macro which generates a setter method useful for a builder pattern. </p> <p>Parameters: </p> <ul> <li>type the data type of the parameter </li> <li>name the name of the parameter </li> <li>defaultValue the default value of the parameter </li> </ul> <pre><code>class MyBuilder {\n  IOX_BUILDER_PARAMETER(TypeA, NameB, ValueC)\n  // START generates the following code\n  public:\n    decltype(auto) NameB(TypeA const&amp; value) &amp;&amp;\n    {\n        m_NameB = value;\n        return std::move(*this);\n    }\n\n    decltype(auto) NameB(TypeA&amp;&amp; value) &amp;&amp;\n    {\n        m_NameB = std::move(value);\n        return std::move(*this);\n    }\n\n  private:\n    TypeA m_NameB = ValueC;\n  // END\n};\n</code></pre>","title":"define IOX_BUILDER_PARAMETER"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_HELPLETS_HPP\n#define IOX_HOOFS_CXX_HELPLETS_HPP\n\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n\n#include &lt;cassert&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\n#include \"iceoryx_hoofs/platform/platform_correction.hpp\"\n#include \"iceoryx_hoofs/platform/platform_settings.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;uint64_t Capacity&gt;\nclass string;\nstruct TruncateToCapacity_t;\n\nnamespace internal\n{\ntemplate &lt;bool GreaterUint8, bool GreaterUint16, bool GreaterUint32&gt;\nstruct BestFittingTypeImpl\n{\n    using Type_t = uint64_t;\n};\n\ntemplate &lt;&gt;\nstruct BestFittingTypeImpl&lt;false, false, false&gt;\n{\n    using Type_t = uint8_t;\n};\n\ntemplate &lt;&gt;\nstruct BestFittingTypeImpl&lt;true, false, false&gt;\n{\n    using Type_t = uint16_t;\n};\n\ntemplate &lt;&gt;\nstruct BestFittingTypeImpl&lt;true, true, false&gt;\n{\n    using Type_t = uint32_t;\n};\n\nconstexpr char ASCII_A = 'a';\nconstexpr char ASCII_Z = 'z';\nconstexpr char ASCII_CAPITAL_A = 'A';\nconstexpr char ASCII_CAPITAL_Z = 'Z';\nconstexpr char ASCII_0 = '0';\nconstexpr char ASCII_9 = '9';\nconstexpr char ASCII_MINUS = '-';\nconstexpr char ASCII_DOT = '.';\nconstexpr char ASCII_COLON = ':';\nconstexpr char ASCII_UNDERSCORE = '_';\n} // namespace internal\n\ntemplate &lt;typename T, typename = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value, void&gt;::type&gt;\nstruct not_null\n{\n  public:\n    not_null(T t) noexcept\n        : value(t)\n    {\n        Expects(t != nullptr);\n    }\n\n    constexpr operator T() const noexcept\n    {\n        return value;\n    }\n\n  private:\n    T value;\n};\n\ntemplate &lt;typename T, T Minimum&gt;\nstruct greater_or_equal\n{\n  public:\n    greater_or_equal(T t) noexcept\n        : value(t)\n    {\n        Expects(t &gt;= Minimum);\n    }\n\n    constexpr operator T() const noexcept\n    {\n        return value;\n    }\n\n  private:\n    T value;\n};\n\ntemplate &lt;typename T, T Minimum, T Maximum&gt;\nstruct range\n{\n  public:\n    range(T t) noexcept\n        : value(t)\n    {\n        Expects(t &gt;= Minimum &amp;&amp; t &lt;= Maximum);\n    }\n\n    constexpr operator T() const noexcept\n    {\n        return value;\n    }\n\n  private:\n    T value;\n};\n\ntemplate &lt;typename T&gt;\nT align(const T value, const T alignment) noexcept\n{\n    T remainder = value % alignment;\n    return value + ((remainder == 0u) ? 0u : alignment - remainder);\n}\n\nvoid* alignedAlloc(const uint64_t alignment, const uint64_t size) noexcept;\n\nvoid alignedFree(void* const memory) noexcept;\n\ntemplate &lt;size_t s = 0&gt;\nconstexpr size_t maxAlignment() noexcept\n{\n    return s;\n}\n\ntemplate &lt;typename T, typename... Args&gt;\nconstexpr size_t maxAlignment() noexcept\n{\n    return alignof(T) &gt; maxAlignment&lt;Args...&gt;() ? alignof(T) : maxAlignment&lt;Args...&gt;();\n}\n\ntemplate &lt;size_t s = 0&gt;\nconstexpr size_t maxSize() noexcept\n{\n    return s;\n}\n\ntemplate &lt;typename T, typename... Args&gt;\nconstexpr size_t maxSize() noexcept\n{\n    return sizeof(T) &gt; maxSize&lt;Args...&gt;() ? sizeof(T) : maxSize&lt;Args...&gt;();\n}\n\ntemplate &lt;typename T, typename Enumeration&gt;\nconst char* convertEnumToString(T port, const Enumeration source) noexcept\n{\n    return port[static_cast&lt;size_t&gt;(source)];\n}\n\ntemplate &lt;typename enum_type&gt;\nauto enumTypeAsUnderlyingType(enum_type const value) noexcept -&gt; typename std::underlying_type&lt;enum_type&gt;::type\n{\n    return static_cast&lt;typename std::underlying_type&lt;enum_type&gt;::type&gt;(value);\n}\n\ntemplate &lt;typename Container, typename Functor&gt;\nvoid forEach(Container&amp; c, const Functor&amp; f) noexcept\n{\n    for (auto&amp; element : c)\n    {\n        f(element);\n    }\n}\n\ntemplate &lt;uint64_t SizeValue&gt;\nstatic constexpr uint64_t strlen2(char const (&amp;/*notInterested*/)[SizeValue]) noexcept\n{\n    return SizeValue - 1;\n}\n\ntemplate &lt;uint64_t Value&gt;\nstruct BestFittingType\n{\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n    using Type_t = typename internal::BestFittingTypeImpl&lt;(Value &gt; std::numeric_limits&lt;uint8_t&gt;::max()),\n                                                          (Value &gt; std::numeric_limits&lt;uint16_t&gt;::max()),\n                                                          (Value &gt; std::numeric_limits&lt;uint32_t&gt;::max())&gt;::Type_t;\n#pragma GCC diagnostic pop\n};\n\ntemplate &lt;uint64_t Value&gt;\nusing BestFittingType_t = typename BestFittingType&lt;Value&gt;::Type_t;\n\nconstexpr bool isCompiledOn32BitSystem() noexcept\n{\n    return INTPTR_MAX == INT32_MAX;\n}\n\ntemplate &lt;typename T&gt;\nconstexpr bool isPowerOfTwo(const T n) noexcept\n{\n    static_assert(std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, \"Only unsigned integer are allowed!\");\n    return n &amp;&amp; ((n &amp; (n - 1U)) == 0U);\n}\n\ntemplate &lt;uint64_t StringCapacity&gt;\nbool isValidFileName(const string&lt;StringCapacity&gt;&amp; name) noexcept;\n\ntemplate &lt;uint64_t StringCapacity&gt;\nbool isValidFilePath(const string&lt;StringCapacity&gt;&amp; name) noexcept;\n\ntemplate &lt;typename F, typename T&gt;\nconstexpr T from(const F value) noexcept;\n\ntemplate &lt;typename T, typename F&gt;\nconstexpr T into(const F value) noexcept;\n\n#define IOX_BUILDER_PARAMETER(type, name, defaultValue)                                                                \\\n  public:                                                                                                              \\\n    decltype(auto) name(type const&amp; value)&amp;&amp;                                                                           \\\n    {                                                                                                                  \\\n        m_##name = value;                                                                                              \\\n        return std::move(*this);                                                                                       \\\n    }                                                                                                                  \\\n                                                                                                                       \\\n    decltype(auto) name(type&amp;&amp; value)&amp;&amp;                                                                                \\\n    {                                                                                                                  \\\n        m_##name = std::move(value);                                                                                   \\\n        return std::move(*this);                                                                                       \\\n    }                                                                                                                  \\\n                                                                                                                       \\\n  private:                                                                                                             \\\n    type m_##name{defaultValue};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/helplets.inl\"\n\n#endif // IOX_HOOFS_CXX_HELPLETS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/list_8hpp/","text":"","title":"iceoryx_hoofs/cxx/list.hpp"},{"location":"API-reference/hoofs/Files/list_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/list_8hpp/#classes","text":"Name     class iox::cxx::list C++11 compatible bi-directional list implementation.","title":"Classes"},{"location":"API-reference/hoofs/Files/list_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_LIST_HPP\n#define IOX_HOOFS_CXX_LIST_HPP\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\n#include \"iceoryx_hoofs/platform/platform_correction.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, uint64_t Capacity&gt;\nclass list\n{\n  private:\n    // forward declarations, private\n    struct ListLink;\n    template &lt;bool&gt;\n    class IteratorBase;\n\n  public:\n    using iterator = IteratorBase&lt;false&gt;;\n    using const_iterator = IteratorBase&lt;true&gt;;\n    using value_type = T;\n    using size_type = decltype(Capacity);\n\n    list() noexcept;\n\n    ~list() noexcept;\n\n    list(const list&amp; rhs) noexcept;\n\n    list(list&amp;&amp; rhs) noexcept;\n\n    list&amp; operator=(const list&amp; rhs) noexcept;\n\n    list&amp; operator=(list&amp;&amp; rhs) noexcept;\n\n\n    iterator begin() noexcept;\n\n    const_iterator begin() const noexcept;\n\n    const_iterator cbegin() const noexcept;\n\n    iterator end() noexcept;\n\n    const_iterator end() const noexcept;\n\n    const_iterator cend() const noexcept;\n\n    bool empty() const noexcept;\n\n    bool full() const noexcept;\n\n    size_type size() const noexcept;\n\n    size_type capacity() const noexcept;\n\n    size_type max_size() const noexcept;\n\n    T&amp; front() noexcept;\n\n    const T&amp; front() const noexcept;\n\n    T&amp; back() noexcept;\n\n    const T&amp; back() const noexcept;\n\n    bool push_front(const T&amp; data) noexcept;\n\n    bool push_front(T&amp;&amp; data) noexcept;\n\n    bool push_back(const T&amp; data) noexcept;\n\n    bool push_back(T&amp;&amp; data) noexcept;\n\n    bool pop_front() noexcept;\n\n    bool pop_back() noexcept;\n\n    void clear() noexcept;\n\n    iterator erase(const_iterator iter) noexcept;\n\n    size_type remove(const T&amp; data) noexcept;\n\n    template &lt;typename UnaryPredicate&gt;\n    size_type remove_if(UnaryPredicate pred) noexcept;\n\n    template &lt;typename... ConstructorArgs&gt;\n    T&amp; emplace_front(ConstructorArgs&amp;&amp;... args) noexcept;\n\n    template &lt;typename... ConstructorArgs&gt;\n    T&amp; emplace_back(ConstructorArgs&amp;&amp;... args) noexcept;\n\n    template &lt;typename... ConstructorArgs&gt;\n    iterator emplace(const_iterator iter, ConstructorArgs&amp;&amp;... args) noexcept;\n\n    iterator insert(const_iterator citer, const T&amp; data) noexcept;\n\n    iterator insert(const_iterator citer, T&amp;&amp; data) noexcept;\n\n  private:\n    template &lt;bool IsConstIterator = true&gt;\n    class IteratorBase\n    {\n      public:\n        // provide the following public types for a std::iterator compatible iterator_category interface\n        using iterator_category = std::bidirectional_iterator_tag;\n        using value_type = typename std::conditional&lt;IsConstIterator, const T, T&gt;::type;\n        using difference_type = void;\n        using pointer = typename std::conditional&lt;IsConstIterator, const T*, T*&gt;::type;\n        using reference = typename std::conditional&lt;IsConstIterator, const T&amp;, T&amp;&gt;::type;\n\n\n        IteratorBase(const IteratorBase&lt;false&gt;&amp; iter) noexcept;\n\n        IteratorBase&amp; operator=(const IteratorBase&lt;false&gt;&amp; rhs) noexcept;\n\n        IteratorBase&amp; operator++() noexcept;\n\n        IteratorBase&amp; operator--() noexcept;\n\n\n        template &lt;bool IsConstIteratorOther&gt;\n        bool operator==(const IteratorBase&lt;IsConstIteratorOther&gt;&amp; rhs) const noexcept;\n\n        template &lt;bool IsConstIteratorOther&gt;\n        bool operator!=(const IteratorBase&lt;IsConstIteratorOther&gt;&amp; rhs) const noexcept;\n\n        reference operator*() const noexcept;\n\n        pointer operator-&gt;() const noexcept;\n\n\n      private:\n        using parentListPointer =\n            typename std::conditional&lt;IsConstIterator, const list&lt;T, Capacity&gt;*, list&lt;T, Capacity&gt;*&gt;::type;\n\n        explicit IteratorBase(parentListPointer parent, size_type idx) noexcept;\n\n        // Make IteratorBase&lt;true&gt; a friend class of IteratorBase&lt;false&gt; so the copy constructor can access the\n        // private member variables.\n        friend class IteratorBase&lt;true&gt;;\n        friend class list&lt;T, Capacity&gt;;\n        parentListPointer m_list;\n        size_type m_iterListNodeIdx;\n    };\n\n    struct NodeLink\n    {\n        size_type nextIdx;\n        size_type prevIdx;\n    };\n\n    void init() noexcept;\n    T* getDataPtrFromIdx(const size_type idx) noexcept;\n    const T* getDataPtrFromIdx(const size_type idx) const noexcept;\n\n    bool isValidElementIdx(const size_type idx) const noexcept;\n    bool isInvalidIterator(const const_iterator&amp; iter) const noexcept;\n    bool isInvalidIterOrDifferentLists(const const_iterator&amp; iter) const noexcept;\n    size_type&amp; getPrevIdx(const size_type idx) noexcept;\n    size_type&amp; getNextIdx(const size_type idx) noexcept;\n    size_type&amp; getPrevIdx(const const_iterator&amp; iter) noexcept;\n    size_type&amp; getNextIdx(const const_iterator&amp; iter) noexcept;\n    const size_type&amp; getPrevIdx(const size_type idx) const noexcept;\n    const size_type&amp; getNextIdx(const size_type idx) const noexcept;\n    const size_type&amp; getPrevIdx(const const_iterator&amp; iter) const noexcept;\n    const size_type&amp; getNextIdx(const const_iterator&amp; iter) const noexcept;\n    void setPrevIdx(const size_type idx, const size_type prevIdx) noexcept;\n    void setNextIdx(const size_type idx, const size_type nextIdx) noexcept;\n\n    static void errorMessage(const char* source, const char* msg) noexcept;\n\n    //***************************************\n    //    members\n    //***************************************\n\n    static constexpr size_type BEGIN_END_LINK_INDEX{size_type(Capacity)};\n    static constexpr size_type NODE_LINK_COUNT{size_type(Capacity) + 1U};\n    static constexpr size_type INVALID_INDEX{NODE_LINK_COUNT};\n\n    // unused/free elements are stored in an internal list (freeList), this freeList is accessed via the\n    // member variable m_freeListHeadIdx; user insert- and erase- operations move elements between the freeList and\n    // active list\n    size_type m_freeListHeadIdx{0U};\n\n    // m_links array is one element bigger than request element count. In this additional element links are stored\n    // to the beginning and end of the list. This additional element (index position 'capacity' aka\n    // BEGIN_END_LINK_INDEX) 'previous' will point to the last valid element (end()) and 'next' will point to the\n    // first used list element (begin())\n    NodeLink m_links[NODE_LINK_COUNT];\n    using element_t = uint8_t[sizeof(T)];\n    alignas(T) element_t m_data[Capacity];\n\n    size_type m_size{0U};\n}; // list\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/list.inl\"\n\n#endif // IOX_HOOFS_CXX_LIST_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/","text":"","title":"iceoryx_hoofs/concurrent/lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::concurrent","title":"Namespaces"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#classes","text":"Name     class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity","title":"Classes"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP\n#define IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/buffer.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/index_queue.hpp\"\n\n#include &lt;atomic&gt;\n\n\nnamespace iox\n{\nnamespace concurrent\n{\ntemplate &lt;typename ElementType, uint64_t Capacity&gt;\nclass LockFreeQueue\n{\n  public:\n    using element_t = ElementType;\n\n    LockFreeQueue() noexcept;\n\n    ~LockFreeQueue() noexcept = default;\n\n    // remark: a thread-safe and lockfree implementation of copy seems impossible\n    // but unsafe copying (i.e. where synchronization is up to the user) would be possible\n    // can be implemented when it is needed\n    LockFreeQueue(const LockFreeQueue&amp;) = delete;\n    LockFreeQueue(LockFreeQueue&amp;&amp;) = delete;\n    LockFreeQueue&amp; operator=(const LockFreeQueue&amp;) = delete;\n    LockFreeQueue&amp; operator=(LockFreeQueue&amp;&amp;) = delete;\n\n    constexpr uint64_t capacity() const noexcept;\n\n    bool tryPush(ElementType&amp;&amp; value) noexcept;\n\n    bool tryPush(const ElementType&amp; value) noexcept;\n\n    iox::cxx::optional&lt;ElementType&gt; push(const ElementType&amp; value) noexcept;\n\n    iox::cxx::optional&lt;ElementType&gt; push(ElementType&amp;&amp; value) noexcept;\n\n    iox::cxx::optional&lt;ElementType&gt; pop() noexcept;\n\n    bool empty() const noexcept;\n\n    uint64_t size() const noexcept;\n\n  protected:\n    using Queue = IndexQueue&lt;Capacity&gt;;\n    using BufferIndex = typename Queue::value_t;\n\n    // remark: actually m_freeIndices do not have to be in a queue, it could be another\n    // multi-push multi-pop capable lockfree container (e.g. a stack or a list)\n    Queue m_freeIndices;\n\n    // required to be a queue for LockFreeQueue to exhibit FIFO behaviour\n    Queue m_usedIndices;\n\n    Buffer&lt;ElementType, Capacity, BufferIndex&gt; m_buffer;\n\n    std::atomic&lt;uint64_t&gt; m_size{0u};\n\n    // template is needed to distinguish between lvalue and rvalue T references\n    // (universal reference type deduction)\n    template &lt;typename T&gt;\n    void writeBufferAt(const BufferIndex&amp;, T&amp;&amp;) noexcept;\n\n    // needed to avoid code duplication (via universal reference type deduction)\n    template &lt;typename T&gt;\n    iox::cxx::optional&lt;ElementType&gt; pushImpl(T&amp;&amp; value) noexcept;\n\n    cxx::optional&lt;ElementType&gt; readBufferAt(const BufferIndex&amp;) noexcept;\n};\n} // namespace concurrent\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/lockfree_queue.inl\"\n\n#endif // IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/","text":"","title":"iceoryx_hoofs/log/logcommon.hpp"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#classes","text":"Name     struct iox::log::LogEntry","title":"Classes"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGCOMMON_HPP\n#define IOX_HOOFS_LOG_LOGCOMMON_HPP\n\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace log\n{\nenum class LogLevel : uint8_t\n{\n    kOff = 0,\n    kFatal,\n    kError,\n    kWarn,\n    kInfo,\n    kDebug,\n    kVerbose\n};\n\nenum class LogMode : uint8_t\n{\n    kRemote = 0x01,\n    kFile = 0x02,\n    kConsole = 0x04\n};\n\nconstexpr const char* LogLevelColor[] = {\n    \"\",                 // nothing\n    \"\\033[0;1;97;41m\",  // bold bright white on red\n    \"\\033[0;1;31;103m\", // bold red on light yellow\n    \"\\033[0;1;93m\",     // bold bright yellow\n    \"\\033[0;1;92m\",     // bold bright green\n    \"\\033[0;1;96m\",     // bold bright cyan\n    \"\\033[0;1;36m\",     // bold cyan\n};\n\nconstexpr const char* LogLevelText[] = {\n    \"[  Off  ]\", // nothing\n    \"[ Fatal ]\", // bold bright white on red\n    \"[ Error ]\", // bold red on light yellow\n    \"[Warning]\", // bold bright yellow\n    \"[ Info  ]\", // bold bright green\n    \"[ Debug ]\", // bold bright cyan\n    \"[Verbose]\", // bold cyan\n};\n\nLogMode operator|(LogMode lhs, LogMode rhs) noexcept;\nLogMode&amp; operator|=(LogMode&amp; lhs, LogMode rhs) noexcept;\nLogMode operator&amp;(LogMode lhs, LogMode rhs) noexcept;\nLogMode&amp; operator&amp;=(LogMode&amp; lhs, LogMode rhs) noexcept;\n\nstruct LogEntry\n{\n    LogLevel level{LogLevel::kVerbose};\n    std::chrono::milliseconds time{0};\n    std::string message;\n};\n\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGCOMMON_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logger_8hpp/","text":"","title":"iceoryx_hoofs/log/logger.hpp"},{"location":"API-reference/hoofs/Files/logger_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logger_8hpp/#classes","text":"Name     class iox::log::Logger","title":"Classes"},{"location":"API-reference/hoofs/Files/logger_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGGER_HPP\n#define IOX_HOOFS_LOG_LOGGER_HPP\n\n#include \"iceoryx_hoofs/cxx/generic_raii.hpp\"\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace log\n{\n\nclass Logger\n{\n    friend class LogManager;\n    friend class LogStream;\n\n  public:\n    Logger(Logger&amp;&amp; other) noexcept;\n    Logger&amp; operator=(Logger&amp;&amp; rhs) noexcept;\n\n    Logger(const Logger&amp; other) = delete;\n    Logger&amp; operator=(const Logger&amp; rhs) = delete;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogLevel GetLogLevel() const noexcept;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    void SetLogLevel(const LogLevel logLevel) noexcept;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    cxx::GenericRAII SetLogLevelForScope(const LogLevel logLevel) noexcept;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    void SetLogMode(const LogMode logMode) noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    bool IsEnabled(const LogLevel logLevel) const noexcept;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogFatal() noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogError() noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogWarn() noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogInfo() noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogDebug() noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogStream LogVerbose() noexcept;\n\n  protected:\n    Logger(const std::string&amp; ctxId, const std::string&amp; ctxDescription, const LogLevel appLogLevel) noexcept;\n\n    // virtual because of Logger_Mock\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    virtual void Log(const LogEntry&amp; entry) const noexcept;\n\n  private:\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    static void Print(const LogEntry&amp; entry) noexcept;\n\n    std::atomic&lt;LogLevel&gt; m_logLevel{LogLevel::kVerbose};\n    std::atomic&lt;LogLevel&gt; m_logLevelPredecessor{LogLevel::kVerbose};\n    std::atomic&lt;LogMode&gt; m_logMode{LogMode::kConsole};\n};\n\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGGER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logging_8hpp/","text":"","title":"iceoryx_hoofs/log/logging.hpp"},{"location":"API-reference/hoofs/Files/logging_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logging_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGGING_HPP\n#define IOX_HOOFS_LOG_LOGGING_HPP\n\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n#include \"iceoryx_hoofs/log/logger.hpp\"\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace log\n{\nLogger&amp; createLogger(const std::string&amp; ctxId,\n                     const std::string&amp; ctxDescription,\n                     const LogLevel appDefLogLevel = LogLevel::kWarn) noexcept;\n\ninline constexpr LogHex8 HexFormat(uint8_t value) noexcept\n{\n    return LogHex8(value);\n}\ninline constexpr LogHex8 HexFormat(int8_t value) noexcept\n{\n    return LogHex8(static_cast&lt;uint8_t&gt;(value));\n}\ninline constexpr LogHex16 HexFormat(uint16_t value) noexcept\n{\n    return LogHex16(value);\n}\ninline constexpr LogHex16 HexFormat(int16_t value) noexcept\n{\n    return LogHex16(static_cast&lt;uint16_t&gt;(value));\n}\ninline constexpr LogHex32 HexFormat(uint32_t value) noexcept\n{\n    return LogHex32(value);\n}\ninline constexpr LogHex32 HexFormat(int32_t value) noexcept\n{\n    return LogHex32(static_cast&lt;uint32_t&gt;(value));\n}\ninline constexpr LogHex64 HexFormat(uint64_t value) noexcept\n{\n    return LogHex64(value);\n}\ninline constexpr LogHex64 HexFormat(int64_t value) noexcept\n{\n    return LogHex64(static_cast&lt;uint64_t&gt;(value));\n}\n\ninline constexpr LogBin8 BinFormat(uint8_t value) noexcept\n{\n    return LogBin8(value);\n}\ninline constexpr LogBin8 BinFormat(int8_t value) noexcept\n{\n    return LogBin8(static_cast&lt;uint8_t&gt;(value));\n}\ninline constexpr LogBin16 BinFormat(uint16_t value) noexcept\n{\n    return LogBin16(value);\n}\ninline constexpr LogBin16 BinFormat(int16_t value) noexcept\n{\n    return LogBin16(static_cast&lt;uint16_t&gt;(value));\n}\ninline constexpr LogBin32 BinFormat(uint32_t value) noexcept\n{\n    return LogBin32(value);\n}\ninline constexpr LogBin32 BinFormat(int32_t value) noexcept\n{\n    return LogBin32(static_cast&lt;uint32_t&gt;(value));\n}\ninline constexpr LogBin64 BinFormat(uint64_t value) noexcept\n{\n    return LogBin64(value);\n}\ninline constexpr LogBin64 BinFormat(int64_t value) noexcept\n{\n    return LogBin64(static_cast&lt;uint64_t&gt;(value));\n}\n\ntemplate &lt;typename T, typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value, std::nullptr_t&gt;::type = nullptr&gt;\ninline constexpr LogRawBuffer RawBuffer(const T&amp; value) noexcept\n{\n    // LogRawBuffer is used with the streaming operator which converts the data into a string,\n    // therefore we shouldn't get lifetime issues\n    return LogRawBuffer{reinterpret_cast&lt;const uint8_t*&gt;(&amp;value), sizeof(T)};\n}\n\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGGING_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/","text":"","title":"iceoryx_hoofs/log/logging_free_function_building_block.hpp"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log   iox::log::ffbb","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP\n#define IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP\n\n\n#include \"iceoryx_hoofs/log/logger.hpp\"\n#include \"iceoryx_hoofs/log/logging.hpp\"\n#include \"iceoryx_hoofs/log/logmanager.hpp\"\n\nnamespace iox\n{\nnamespace log\n{\nnamespace ffbb\n{\ntemplate &lt;typename T&gt;\nstatic Logger&amp; ComponentLogger() noexcept\n{\n    static auto&amp; logger = createLogger(T::Ctx, T::Description, LogManager::GetLogManager().DefaultLogLevel());\n    return logger;\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogFatal() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogFatal();\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogError() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogError();\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogWarn() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogWarn();\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogInfo() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogInfo();\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogDebug() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogDebug();\n}\n\ntemplate &lt;typename T&gt;\ninline LogStream LogVerbose() noexcept\n{\n    return ComponentLogger&lt;T&gt;().LogVerbose();\n}\n} // namespace ffbb\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/","text":"","title":"iceoryx_hoofs/log/logmanager.hpp"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#classes","text":"Name     class iox::log::LogManager","title":"Classes"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGMANAGER_HPP\n#define IOX_HOOFS_LOG_LOGMANAGER_HPP\n\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n#include \"iceoryx_hoofs/log/logger.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace log\n{\nenum class LogLevelOutput : uint8_t\n{\n    kDisplayLogLevel = 0,\n    kHideLogLevel\n};\n\nclass LogManager\n{\n  public:\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    static LogManager&amp; GetLogManager() noexcept;\n    static Logger&amp;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    CreateLogContext(const std::string&amp; ctxId,\n                     const std::string&amp; ctxDescription,\n                     const LogLevel appDefLogLevel) noexcept;\n\n    ~LogManager() noexcept = default;\n\n    LogManager(const LogManager&amp;) = delete;\n    LogManager(LogManager&amp;&amp;) = delete;\n    LogManager&amp; operator=(const LogManager&amp;) = delete;\n    LogManager&amp; operator=(LogManager&amp;&amp;) = delete;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogLevel DefaultLogLevel() const noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    void SetDefaultLogLevel(const LogLevel logLevel,\n                            const LogLevelOutput logLevelOutput = LogLevelOutput::kDisplayLogLevel) noexcept;\n\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    LogMode DefaultLogMode() const noexcept;\n    // NOLINTNEXTLINE(readability-identifier-naming)\n    void SetDefaultLogMode(const LogMode logMode) noexcept;\n\n  protected:\n    LogManager() noexcept = default;\n\n  private:\n    std::atomic&lt;LogLevel&gt; m_defaultLogLevel{LogLevel::kVerbose};\n    std::atomic&lt;LogMode&gt; m_defaultLogMode{LogMode::kConsole};\n\n    std::map&lt;std::string, Logger&gt; m_loggers;\n};\n\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGMANAGER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/logstream_8hpp/","text":"","title":"iceoryx_hoofs/log/logstream.hpp"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#classes","text":"Name     struct iox::log::LogHex   struct iox::log::LogHex8   struct iox::log::LogHex16   struct iox::log::LogHex32   struct iox::log::LogHex64   struct iox::log::LogBin   struct iox::log::LogBin8   struct iox::log::LogBin16   struct iox::log::LogBin32   struct iox::log::LogBin64   struct iox::log::LogRawBuffer   class iox::log::LogStream","title":"Classes"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_LOG_LOGSTREAM_HPP\n#define IOX_HOOFS_LOG_LOGSTREAM_HPP\n\n#include \"iceoryx_hoofs/cxx/convert.hpp\"\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace log\n{\n// helper struct for SFINAE of LogStream&amp; operator&lt;&lt;\nstruct LogHex\n{\n};\n\nstruct LogHex8 : private LogHex\n{\n    uint8_t value;\n    constexpr LogHex8(uint8_t value) noexcept\n        : value(value)\n    {\n    }\n};\n\nstruct LogHex16 : private LogHex\n{\n    uint16_t value;\n    constexpr LogHex16(uint16_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogHex32 : private LogHex\n{\n    uint32_t value;\n    constexpr LogHex32(uint32_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogHex64 : private LogHex\n{\n    uint64_t value;\n    constexpr LogHex64(uint64_t value) noexcept\n        : value(value)\n    {\n    }\n};\n\n// helper struct for SFINAE of LogStream&amp; operator&lt;&lt;\nstruct LogBin\n{\n};\n\nstruct LogBin8 : private LogBin\n{\n    uint8_t value;\n    constexpr LogBin8(uint8_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogBin16 : private LogBin\n{\n    uint16_t value;\n    constexpr LogBin16(uint16_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogBin32 : private LogBin\n{\n    uint32_t value;\n    constexpr LogBin32(uint32_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogBin64 : private LogBin\n{\n    uint64_t value;\n    constexpr LogBin64(uint64_t value) noexcept\n        : value(value)\n    {\n    }\n};\nstruct LogRawBuffer\n{\n    const uint8_t* data;\n    uint8_t size;\n};\n\nclass Logger;\n\nclass LogStream\n{\n  public:\n    LogStream(Logger&amp; logger, LogLevel logLevel = LogLevel::kWarn) noexcept;\n\n    virtual ~LogStream() noexcept;\n\n    void Flush() noexcept;\n\n    LogStream&amp; operator&lt;&lt;(const char* cstr) noexcept;\n\n    LogStream&amp; operator&lt;&lt;(const std::string&amp; str) noexcept;\n\n    template &lt;typename T, typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, int&gt;::type = 0&gt;\n    LogStream&amp; operator&lt;&lt;(const T val) noexcept\n    {\n        m_logEntry.message.append(cxx::convert::toString(val));\n        m_flushed = false;\n        return *this;\n    }\n\n    template &lt;typename T, typename std::enable_if&lt;std::is_base_of&lt;LogHex, T&gt;::value, int&gt;::type = 0&gt;\n    LogStream&amp; operator&lt;&lt;(const T val) noexcept\n    {\n        std::stringstream ss;\n        // the '+val' is there to not interpret the uint8_t as char and print the character instead of the hex value\n        ss &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; +val.value;\n        m_logEntry.message.append(ss.str());\n        m_flushed = false;\n        return *this;\n    }\n\n    template &lt;typename T, typename std::enable_if&lt;std::is_base_of&lt;LogBin, T&gt;::value, int&gt;::type = 0&gt;\n    LogStream&amp; operator&lt;&lt;(const T val) noexcept\n    {\n        m_logEntry.message.append(\"0b\");\n        m_logEntry.message.append(std::bitset&lt;std::numeric_limits&lt;decltype(val.value)&gt;::digits&gt;(val.value).to_string());\n        m_flushed = false;\n        return *this;\n    }\n\n    LogStream&amp; operator&lt;&lt;(const LogRawBuffer&amp; value) noexcept;\n\n  private:\n    Logger&amp; m_logger;\n    bool m_flushed{false};\n    LogEntry m_logEntry;\n};\n\nLogStream&amp; operator&lt;&lt;(LogStream&amp; out, LogLevel value) noexcept;\n\n} // namespace log\n} // namespace iox\n\n#endif // IOX_HOOFS_LOG_LOGSTREAM_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/","text":"","title":"iceoryx_hoofs/cxx/method_callback.hpp"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx   iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#classes","text":"Name     class iox::cxx::ConstMethodCallback   class iox::cxx::MethodCallback","title":"Classes"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_METHOD_CALLBACK_HPP\n#define IOX_HOOFS_CXX_METHOD_CALLBACK_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\nnamespace internal\n{\nclass GenericClass\n{\n};\n} // namespace internal\n\nenum class MethodCallbackError\n{\n    UNINITIALIZED_CALLBACK\n};\n\ntemplate &lt;typename ReturnValue, typename... Args&gt;\nclass ConstMethodCallback\n{\n  public:\n    template &lt;typename T&gt;\n    using ConstMethodPointer = ReturnValue (T::*)(Args...) const;\n\n    ConstMethodCallback() noexcept = default;\n    ConstMethodCallback(const ConstMethodCallback&amp; rhs) noexcept = default;\n    ConstMethodCallback&amp; operator=(const ConstMethodCallback&amp; rhs) noexcept = default;\n    ~ConstMethodCallback() noexcept = default;\n\n    template &lt;typename ClassType&gt;\n    ConstMethodCallback(const ClassType&amp; objectRef, ConstMethodPointer&lt;ClassType&gt; const methodPtr) noexcept;\n\n    ConstMethodCallback(ConstMethodCallback&amp;&amp; rhs) noexcept;\n\n    ConstMethodCallback&amp; operator=(ConstMethodCallback&amp;&amp; rhs) noexcept;\n\n    template &lt;typename... MethodArguments&gt;\n    expected&lt;ReturnValue, MethodCallbackError&gt; operator()(MethodArguments&amp;&amp;... args) const noexcept;\n\n    bool operator==(const ConstMethodCallback&amp; rhs) const noexcept;\n\n    bool operator!=(const ConstMethodCallback&amp; rhs) const noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool isValid() const noexcept;\n\n    template &lt;typename ClassType&gt;\n    void setCallback(const ClassType&amp; objectRef, ConstMethodPointer&lt;ClassType&gt; methodPtr) noexcept;\n\n    template &lt;typename ClassType&gt;\n    const ClassType* getObjectPointer() const noexcept;\n\n    template &lt;typename ClassType&gt;\n    auto getMethodPointer() const noexcept -&gt; ConstMethodPointer&lt;ClassType&gt;;\n\n  private:\n    const void* m_objectPtr{nullptr};\n    ConstMethodPointer&lt;internal::GenericClass&gt; m_methodPtr{nullptr};\n    cxx::function_ref&lt;ReturnValue(const void*, ConstMethodPointer&lt;internal::GenericClass&gt;, Args...)&gt; m_callback;\n};\n\ntemplate &lt;typename ReturnValue, typename... Args&gt;\nclass MethodCallback\n{\n  public:\n    template &lt;typename T&gt;\n    using MethodPointer = ReturnValue (T::*)(Args...);\n\n    MethodCallback() noexcept = default;\n    MethodCallback(const MethodCallback&amp; rhs) noexcept = default;\n    MethodCallback&amp; operator=(const MethodCallback&amp; rhs) noexcept = default;\n    ~MethodCallback() noexcept = default;\n\n    template &lt;typename ClassType&gt;\n    MethodCallback(ClassType&amp; objectRef, MethodPointer&lt;ClassType&gt; methodPtr) noexcept;\n\n    MethodCallback(MethodCallback&amp;&amp; rhs) noexcept;\n\n    MethodCallback&amp; operator=(MethodCallback&amp;&amp; rhs) noexcept;\n\n    template &lt;typename... MethodArguments&gt;\n    expected&lt;ReturnValue, MethodCallbackError&gt; operator()(MethodArguments&amp;&amp;... args) noexcept;\n\n    bool operator==(const MethodCallback&amp; rhs) const noexcept;\n\n    bool operator!=(const MethodCallback&amp; rhs) const noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool isValid() const noexcept;\n\n    template &lt;typename ClassType&gt;\n    void setCallback(ClassType&amp; objectRef, MethodPointer&lt;ClassType&gt; methodPtr) noexcept;\n\n    template &lt;typename ClassType&gt;\n    ClassType* getObjectPointer() const noexcept;\n\n    template &lt;typename ClassType&gt;\n    auto getMethodPointer() const noexcept -&gt; MethodPointer&lt;ClassType&gt;;\n\n  private:\n    void* m_objectPtr{nullptr};\n    MethodPointer&lt;internal::GenericClass&gt; m_methodPtr{nullptr};\n    cxx::function_ref&lt;ReturnValue(void*, MethodPointer&lt;internal::GenericClass&gt;, Args...)&gt; m_callback;\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/method_callback.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/named_pipe.hpp"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#classes","text":"Name     class iox::posix::NamedPipe","title":"Classes"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP\n\n#include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/design_pattern/creation.hpp\"\n#include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\"\n#include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace posix\n{\nclass NamedPipe : public DesignPattern::Creation&lt;NamedPipe, IpcChannelError&gt;\n{\n  public:\n    // no system restrictions at all, except available memory. MAX_MESSAGE_SIZE and MAX_NUMBER_OF_MESSAGES can be\n    // increased as long as there is enough memory available\n    static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U;\n    static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U;\n\n    static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U;\n    static constexpr units::Duration CYCLE_TIME = units::Duration::fromMilliseconds(10);\n    static constexpr const char NAMED_PIPE_PREFIX[] = \"iox_np_\";\n\n    using Message_t = cxx::string&lt;MAX_MESSAGE_SIZE&gt;;\n    using MessageQueue_t = concurrent::LockFreeQueue&lt;Message_t, MAX_NUMBER_OF_MESSAGES&gt;;\n\n    NamedPipe(const NamedPipe&amp;) = delete;\n    NamedPipe&amp; operator=(const NamedPipe&amp;) = delete;\n\n    NamedPipe() noexcept;\n\n    NamedPipe(NamedPipe&amp;&amp; rhs) noexcept;\n    NamedPipe&amp; operator=(NamedPipe&amp;&amp; rhs) noexcept;\n    ~NamedPipe() noexcept;\n\n    cxx::expected&lt;IpcChannelError&gt; destroy() noexcept;\n\n    static cxx::expected&lt;bool, IpcChannelError&gt; unlinkIfExists(const IpcChannelName_t&amp; name) noexcept;\n\n    cxx::expected&lt;bool, IpcChannelError&gt; isOutdated() noexcept;\n\n    cxx::expected&lt;IpcChannelError&gt; trySend(const std::string&amp; message) const noexcept;\n\n    cxx::expected&lt;IpcChannelError&gt; send(const std::string&amp; message) const noexcept;\n\n    cxx::expected&lt;IpcChannelError&gt; timedSend(const std::string&amp; message, const units::Duration&amp; timeout) const noexcept;\n\n    cxx::expected&lt;std::string, IpcChannelError&gt; tryReceive() const noexcept;\n\n    cxx::expected&lt;std::string, IpcChannelError&gt; receive() const noexcept;\n\n    cxx::expected&lt;std::string, IpcChannelError&gt; timedReceive(const units::Duration&amp; timeout) const noexcept;\n\n  private:\n    friend class DesignPattern::Creation&lt;NamedPipe, IpcChannelError&gt;;\n\n    NamedPipe(const IpcChannelName_t&amp; name,\n              const IpcChannelSide channelSide,\n              const size_t maxMsgSize = MAX_MESSAGE_SIZE,\n              const uint64_t maxMsgNumber = MAX_NUMBER_OF_MESSAGES) noexcept;\n\n    template &lt;typename Prefix&gt;\n    static IpcChannelName_t convertName(const Prefix&amp; p, const IpcChannelName_t&amp; name) noexcept;\n\n  private:\n    cxx::optional&lt;SharedMemoryObject&gt; m_sharedMemory;\n\n    class NamedPipeData\n    {\n      public:\n        NamedPipeData(bool&amp; isInitialized, IpcChannelError&amp; error, const uint64_t maxMsgNumber) noexcept;\n        NamedPipeData(const NamedPipeData&amp;) = delete;\n        NamedPipeData(NamedPipeData&amp;&amp; rhs) = delete;\n        ~NamedPipeData() noexcept;\n\n        NamedPipeData&amp; operator=(const NamedPipeData&amp;) = delete;\n        NamedPipeData&amp; operator=(NamedPipeData&amp;&amp; rhs) = delete;\n\n        Semaphore&amp; sendSemaphore() noexcept;\n        Semaphore&amp; receiveSemaphore() noexcept;\n\n        bool waitForInitialization() const noexcept;\n        bool hasValidState() const noexcept;\n\n        MessageQueue_t messages;\n\n      private:\n        static constexpr uint64_t SEND_SEMAPHORE = 0U;\n        static constexpr uint64_t RECEIVE_SEMAPHORE = 1U;\n\n        static constexpr uint64_t INVALID_DATA = 0xBAADF00DAFFEDEAD;\n        static constexpr uint64_t VALID_DATA = 0xBAD0FF1CEBEEFBEE;\n        static constexpr units::Duration WAIT_FOR_INIT_TIMEOUT = units::Duration::fromSeconds(1);\n        static constexpr units::Duration WAIT_FOR_INIT_SLEEP_TIME = units::Duration::fromMilliseconds(1);\n\n        std::atomic&lt;uint64_t&gt; initializationGuard{INVALID_DATA};\n        using semaphoreMemory_t = uint8_t[sizeof(Semaphore)];\n        alignas(Semaphore) semaphoreMemory_t semaphores[2U];\n    };\n\n\n    NamedPipeData* m_data = nullptr;\n};\n} // namespace posix\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/newtype_8hpp/","text":"","title":"iceoryx_hoofs/cxx/newtype.hpp"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#classes","text":"Name     class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods.","title":"Classes"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_NEWTYPE_HPP\n#define IOX_HOOFS_CXX_NEWTYPE_HPP\n\n#include \"iceoryx_hoofs/cxx/algorithm.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/assignment.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/comparable.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/constructor.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/convertable.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/internal.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/protected_constructor.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/newtype/sortable.hpp\"\n\n#include &lt;type_traits&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, template &lt;typename&gt; class... Policies&gt;\nclass NewType : public Policies&lt;NewType&lt;T, Policies...&gt;&gt;...\n{\n  protected:\n    NewType(newtype::internal::ProtectedConstructor_t, const T&amp; rhs) noexcept;\n\n  public:\n    using ThisType = NewType&lt;T, Policies...&gt;;\n    using value_type = T;\n\n    NewType() noexcept;\n\n    explicit NewType(const T&amp; rhs) noexcept;\n\n    NewType(const NewType&amp; rhs) noexcept;\n\n    NewType(NewType&amp;&amp; rhs) noexcept;\n\n    NewType&amp; operator=(const NewType&amp; rhs) noexcept;\n\n    NewType&amp; operator=(NewType&amp;&amp; rhs) noexcept;\n\n    NewType&amp; operator=(const T&amp; rhs) noexcept;\n\n    NewType&amp; operator=(T&amp;&amp; rhs) noexcept;\n\n    explicit operator T() const noexcept;\n\n    template &lt;typename Type&gt;\n    friend typename Type::value_type newtype::internal::newTypeAccessor(const Type&amp;) noexcept;\n\n  private:\n    T m_value;\n};\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/newtype.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/optional_8hpp/","text":"","title":"iceoryx_hoofs/cxx/optional.hpp"},{"location":"API-reference/hoofs/Files/optional_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/optional_8hpp/#classes","text":"Name     struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value.   struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor   class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail.","title":"Classes"},{"location":"API-reference/hoofs/Files/optional_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_OPTIONAL_HPP\n#define IOX_HOOFS_CXX_OPTIONAL_HPP\n\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/requires.hpp\"\n#include \"iceoryx_hoofs/cxx/types.hpp\"\n\n#include &lt;new&gt; // needed for placement new in the construct_value member function\n#include &lt;utility&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nstruct nullopt_t\n{\n};\nconstexpr nullopt_t nullopt = nullopt_t();\n\nstruct in_place_t\n{\n};\nconstexpr in_place_t in_place{};\n\ntemplate &lt;typename T&gt;\nclass optional\n{\n  public:\n    using type = T;\n\n    optional() noexcept;\n\n    optional(const nullopt_t&amp;) noexcept;\n\n    optional(T&amp;&amp; value) noexcept;\n\n    optional(const T&amp; value) noexcept;\n\n    template &lt;typename... Targs&gt;\n    optional(in_place_t, Targs&amp;&amp;... args) noexcept;\n\n    ~optional() noexcept;\n\n    optional(const optional&amp; rhs) noexcept;\n\n    optional(optional&amp;&amp; rhs) noexcept;\n\n    optional&amp; operator=(const optional&amp; rhs) noexcept;\n\n    optional&amp; operator=(optional&amp;&amp; rhs) noexcept;\n\n    constexpr bool operator==(const optional&lt;T&gt;&amp; rhs) const noexcept;\n\n    constexpr bool operator==(const nullopt_t&amp;) const noexcept;\n\n    constexpr bool operator!=(const optional&lt;T&gt;&amp; rhs) const noexcept;\n\n    constexpr bool operator!=(const nullopt_t&amp;) const noexcept;\n\n    template &lt;typename U = T&gt;\n    typename std::enable_if&lt;!std::is_same&lt;U, optional&lt;T&gt;&amp;&gt;::value, optional&gt;::type&amp; operator=(U&amp;&amp; value) noexcept;\n\n    const T* operator-&gt;() const noexcept;\n\n    const T&amp; operator*() const noexcept;\n\n    T* operator-&gt;() noexcept;\n\n    T&amp; operator*() noexcept;\n\n    constexpr explicit operator bool() const noexcept;\n\n    constexpr bool has_value() const noexcept;\n\n    template &lt;typename... Targs&gt;\n    T&amp; emplace(Targs&amp;&amp;... args) noexcept;\n\n    void reset() noexcept;\n\n    T&amp; value() &amp; noexcept;\n\n    const T&amp; value() const&amp; noexcept;\n\n    T&amp;&amp; value() &amp;&amp; noexcept;\n\n    const T&amp;&amp; value() const&amp;&amp; noexcept;\n\n    template &lt;typename U&gt;\n    constexpr T value_or(U&amp;&amp; default_value) const noexcept;\n\n    optional&amp; and_then(const cxx::function_ref&lt;void(T&amp;)&gt;&amp; callable) noexcept;\n\n    const optional&amp; and_then(const cxx::function_ref&lt;void(const T&amp;)&gt;&amp; callable) const noexcept;\n\n    optional&amp; or_else(const cxx::function_ref&lt;void()&gt;&amp; callable) noexcept;\n\n    const optional&amp; or_else(const cxx::function_ref&lt;void()&gt;&amp; callable) const noexcept;\n\n  private:\n    alignas(T) byte_t m_data[sizeof(T)];\n    bool m_hasValue{false};\n\n  private:\n    template &lt;typename... Targs&gt;\n    void construct_value(Targs&amp;&amp;... args) noexcept;\n    void destruct_value() noexcept;\n};\n\ntemplate &lt;typename OptionalBaseType, typename... Targs&gt;\noptional&lt;OptionalBaseType&gt; make_optional(Targs&amp;&amp;... args) noexcept;\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/optional.inl\"\n\n#endif // IOX_HOOFS_CXX_OPTIONAL_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/","text":"","title":"iceoryx_hoofs/cxx/poor_mans_heap.hpp"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#classes","text":"Name     class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor.   class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation.","title":"Classes"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP\n#define IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;utility&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename Type&gt;\nclass PoorMansHeapType\n{\n};\n\ntemplate &lt;typename Interface, size_t TypeSize, size_t TypeAlignment = 8&gt;\nclass PoorMansHeap\n{\n  public:\n    PoorMansHeap() = default;\n    ~PoorMansHeap() noexcept;\n\n    template &lt;typename Type, typename... CTorArgs&gt;\n    PoorMansHeap(PoorMansHeapType&lt;Type&gt;, CTorArgs&amp;&amp;... ctorArgs) noexcept;\n\n    PoorMansHeap(PoorMansHeap&amp;&amp; other) = delete;\n    PoorMansHeap&amp; operator=(PoorMansHeap&amp;&amp; rhs) = delete;\n\n    PoorMansHeap(const PoorMansHeap&amp;) = delete;\n    PoorMansHeap&amp; operator=(const PoorMansHeap&amp;) = delete;\n\n    template &lt;typename Type, typename... CTorArgs&gt;\n    void newInstance(CTorArgs&amp;&amp;... ctorArgs) noexcept;\n\n    void deleteInstance() noexcept;\n\n    bool hasInstance() const noexcept;\n\n    Interface* operator-&gt;() const noexcept;\n\n    Interface&amp; operator*() const noexcept;\n\n  private:\n    Interface* m_instance{nullptr};\n    alignas(TypeAlignment) uint8_t m_heap[TypeSize];\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/poor_mans_heap.inl\"\n\n#endif // IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#classes","text":"Name     struct iox::posix::PosixRights   class iox::posix::PosixGroup   class iox::posix::PosixUser","title":"Classes"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/platform/types.hpp\"\n\n#include &lt;string&gt;\n\nnamespace iox\n{\nnamespace posix\n{\nstatic constexpr int MaxNumberOfGroups = 888;\n\nstruct PosixRights\n{\n    PosixRights(bool f_read, bool f_write, bool f_execute) noexcept;\n    bool m_read;\n    bool m_write;\n    bool m_execute;\n};\n\nclass PosixGroup\n{\n  public:\n    using string_t = cxx::string&lt;100&gt;;\n    explicit PosixGroup(const gid_t f_id) noexcept;\n    explicit PosixGroup(const string_t&amp; f_name) noexcept;\n\n    bool operator==(const PosixGroup&amp; other) const noexcept;\n\n    string_t getName() const noexcept;\n    gid_t getID() const noexcept;\n\n    bool doesExist() const noexcept;\n\n    static PosixGroup getGroupOfCurrentProcess() noexcept;\n\n    static cxx::optional&lt;uid_t&gt; getGroupID(const string_t&amp; f_name) noexcept;\n    static cxx::optional&lt;string_t&gt; getGroupName(gid_t f_id) noexcept;\n\n  private:\n    gid_t m_id;\n    bool m_doesExist{false};\n};\n\nclass PosixUser\n{\n  public:\n    using groupVector_t = cxx::vector&lt;PosixGroup, MaxNumberOfGroups&gt;;\n    using string_t = cxx::string&lt;100&gt;;\n\n    explicit PosixUser(const uid_t f_id) noexcept;\n    explicit PosixUser(const string_t&amp; f_name) noexcept;\n\n    groupVector_t getGroups() const noexcept;\n    string_t getName() const noexcept;\n    uid_t getID() const noexcept;\n\n    bool doesExist() const noexcept;\n\n    static PosixUser getUserOfCurrentProcess() noexcept;\n\n    static cxx::optional&lt;uid_t&gt; getUserID(const string_t&amp; f_name) noexcept;\n    static cxx::optional&lt;string_t&gt; getUserName(uid_t f_id) noexcept;\n\n  private:\n    uid_t m_id;\n    bool m_doesExist{false};\n};\n\n} // namespace posix\n} // namespace iox\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/posix_call.hpp"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix   iox::posix::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#classes","text":"Name     struct iox::posix::PosixCallResult result of a posix call   class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call   class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call   class iox::posix::PosixCallBuilder","title":"Classes"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#defines","text":"Name      posixCall(f) Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way.","title":"Defines"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#define-posixcall","text":"<pre><code>#define posixCall(\n    f\n)\ninternal::createPosixCallBuilder(f, #f, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n</code></pre> <p>Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way. </p> <pre><code>iox::posix::posixCall(sem_timedwait)(handle, timeout)\n     .successReturnValue(0)\n     .ignoreErrnos(ETIMEDOUT) // can be a comma separated list of errnos\n     .evaluate()\n     .and_then([](auto &amp; result){\n         std::cout &lt;&lt; result.value &lt;&lt; std::endl; // return value of sem_timedwait\n         std::cout &lt;&lt; result.errno &lt;&lt; std::endl; // errno which was set by sem_timedwait\n         std::cout &lt;&lt; result.getHumanReadableErrnum() &lt;&lt; std::endl; // get string returned by strerror(errno)\n     })\n     .or_else([](auto &amp; result){\n         std::cout &lt;&lt; result.value &lt;&lt; std::endl; // return value of sem_timedwait\n         std::cout &lt;&lt; result.errno &lt;&lt; std::endl; // errno which was set by sem_timedwait\n         std::cout &lt;&lt; result.getHumanReadableErrnum() &lt;&lt; std::endl; // get string returned by strerror(errno)\n     })\n\n// when your posix call signals failure with one specific return value use\n// .failureReturnValue(_) instead of .successReturnValue(_)\n// when your posix call signals failure by returning the errno value instead of setting the errno use\n// .returnValueMatchesErrno() instead of .successReturnValue(_)\n</code></pre>","title":"define posixCall"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP\n\n#include \"iceoryx_hoofs/cxx/algorithm.hpp\"\n#include \"iceoryx_hoofs/cxx/attributes.hpp\"\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\nnamespace iox\n{\nnamespace posix\n{\nstatic constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U;\nstatic constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U;\nstatic constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1;\n\ntemplate &lt;typename ReturnType, typename... FunctionArguments&gt;\nclass PosixCallBuilder;\n\ntemplate &lt;typename T&gt;\nstruct PosixCallResult\n{\n    PosixCallResult() noexcept = default;\n\n    cxx::string&lt;POSIX_CALL_ERROR_STRING_SIZE&gt; getHumanReadableErrnum() const noexcept;\n\n    T value{};\n\n    int32_t errnum = POSIX_CALL_INVALID_ERRNO;\n};\n\nnamespace internal\n{\ntemplate &lt;typename ReturnType, typename... FunctionArguments&gt;\nPosixCallBuilder&lt;ReturnType, FunctionArguments...&gt; createPosixCallBuilder(ReturnType (*posixCall)(FunctionArguments...),\n                                                                          const char* posixFunctionName,\n                                                                          const char* file,\n                                                                          const int32_t line,\n                                                                          const char* callingFunction) noexcept;\n\ntemplate &lt;typename ReturnType&gt;\nstruct PosixCallDetails\n{\n    PosixCallDetails(const char* posixFunctionName, const char* file, int line, const char* callingFunction) noexcept;\n    const char* posixFunctionName = nullptr;\n    const char* file = nullptr;\n    const char* callingFunction = nullptr;\n    int32_t line = 0;\n    bool hasSuccess = true;\n    bool hasIgnoredErrno = false;\n    bool hasSilentErrno = false;\n\n    PosixCallResult&lt;ReturnType&gt; result;\n};\n} // namespace internal\n\n#define posixCall(f) internal::createPosixCallBuilder(f, #f, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n\ntemplate &lt;typename ReturnType&gt;\nclass IOX_NO_DISCARD PosixCallEvaluator\n{\n  public:\n    template &lt;typename... IgnoredErrnos&gt;\n    PosixCallEvaluator&lt;ReturnType&gt; ignoreErrnos(const IgnoredErrnos... ignoredErrnos) const&amp;&amp; noexcept;\n\n    template &lt;typename... SilentErrnos&gt;\n    PosixCallEvaluator&lt;ReturnType&gt; suppressErrorMessagesForErrnos(const SilentErrnos... silentErrnos) const&amp;&amp; noexcept;\n\n    cxx::expected&lt;PosixCallResult&lt;ReturnType&gt;, PosixCallResult&lt;ReturnType&gt;&gt; evaluate() const&amp;&amp; noexcept;\n\n  private:\n    template &lt;typename&gt;\n    friend class PosixCallVerificator;\n\n    explicit PosixCallEvaluator(internal::PosixCallDetails&lt;ReturnType&gt;&amp; details) noexcept;\n\n  private:\n    internal::PosixCallDetails&lt;ReturnType&gt;&amp; m_details;\n};\n\ntemplate &lt;typename ReturnType&gt;\nclass IOX_NO_DISCARD PosixCallVerificator\n{\n  public:\n    template &lt;typename... SuccessReturnValues&gt;\n    PosixCallEvaluator&lt;ReturnType&gt; successReturnValue(const SuccessReturnValues... successReturnValues) &amp;&amp; noexcept;\n\n    template &lt;typename... FailureReturnValues&gt;\n    PosixCallEvaluator&lt;ReturnType&gt; failureReturnValue(const FailureReturnValues... failureReturnValues) &amp;&amp; noexcept;\n\n    PosixCallEvaluator&lt;ReturnType&gt; returnValueMatchesErrno() &amp;&amp; noexcept;\n\n  private:\n    template &lt;typename, typename...&gt;\n    friend class PosixCallBuilder;\n\n    explicit PosixCallVerificator(internal::PosixCallDetails&lt;ReturnType&gt;&amp; details) noexcept;\n\n  private:\n    internal::PosixCallDetails&lt;ReturnType&gt;&amp; m_details;\n};\n\ntemplate &lt;typename ReturnType, typename... FunctionArguments&gt;\nclass IOX_NO_DISCARD PosixCallBuilder\n{\n  public:\n    using FunctionType_t = ReturnType (*)(FunctionArguments...);\n\n    PosixCallVerificator&lt;ReturnType&gt; operator()(FunctionArguments... arguments) &amp;&amp; noexcept;\n\n  private:\n    template &lt;typename ReturnTypeFriend, typename... FunctionArgumentsFriend&gt;\n    friend PosixCallBuilder&lt;ReturnTypeFriend, FunctionArgumentsFriend...&gt;\n    internal::createPosixCallBuilder(ReturnTypeFriend (*posixCall)(FunctionArgumentsFriend...),\n                                     const char* posixFunctionName,\n                                     const char* file,\n                                     const int32_t line,\n                                     const char* callingFunction) noexcept;\n\n    PosixCallBuilder(FunctionType_t posixCall,\n                     const char* posixFunctionName,\n                     const char* file,\n                     const int32_t line,\n                     const char* callingFunction) noexcept;\n\n  private:\n    FunctionType_t m_posixCall = nullptr;\n    internal::PosixCallDetails&lt;ReturnType&gt; m_details;\n};\n} // namespace posix\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/posix_wrapper/posix_call.inl\"\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/requires_8hpp/","text":"","title":"iceoryx_hoofs/cxx/requires.hpp"},{"location":"API-reference/hoofs/Files/requires_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx   iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/requires_8hpp/#defines","text":"Name      Expects(condition)    Ensures(condition)","title":"Defines"},{"location":"API-reference/hoofs/Files/requires_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/requires_8hpp/#define-expects","text":"<pre><code>#define Expects(\n    condition\n)\ninternal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition)\n</code></pre>","title":"define Expects"},{"location":"API-reference/hoofs/Files/requires_8hpp/#define-ensures","text":"<pre><code>#define Ensures(\n    condition\n)\ninternal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition)\n</code></pre>","title":"define Ensures"},{"location":"API-reference/hoofs/Files/requires_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_REQUIRES_HPP\n#define IOX_HOOFS_CXX_REQUIRES_HPP\n\n#include \"iceoryx_hoofs/platform/platform_correction.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\nnamespace internal\n{\nvoid Require(\n    const bool condition, const char* file, const int line, const char* function, const char* conditionString) noexcept;\n} // namespace internal\n\n// implementing C++ Core Guideline, I.6. Prefer Expects\n// see:\n// https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-expects\n#define Expects(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition)\n\n// implementing C++ Core Guideline, I.8. Prefer Ensures\n// see:\n// https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-ensures\n#define Ensures(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition)\n\n\n} // namespace cxx\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/","text":"","title":"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::concurrent","title":"Namespaces"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#classes","text":"Name     class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread).","title":"Classes"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP\n#define IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP\n\n#include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\"\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n\n#include &lt;atomic&gt;\n\nnamespace iox\n{\nnamespace concurrent\n{\n\n// Remark: We use protected inheritance to make the base class methods inaccessible for the user.\n// We cannot use virtual functions since we need to use this class in shared memory.\n// Some of the methods need to be rewritten specifically for this class, others simply redirect\n// the call to the base class.\n//\n// Since supporting the resize (setCapacity) functionality has an impact on the runtime even\n// if the feature is not used, we provide a queue wihout resize functionality in an additional\n// base class that can be used separately.\ntemplate &lt;typename ElementType, uint64_t MaxCapacity&gt;\nclass ResizeableLockFreeQueue : protected LockFreeQueue&lt;ElementType, MaxCapacity&gt;\n{\n  private:\n    using Base = LockFreeQueue&lt;ElementType, MaxCapacity&gt;;\n\n  public:\n    using element_t = ElementType;\n    static constexpr uint64_t MAX_CAPACITY = MaxCapacity;\n\n    ResizeableLockFreeQueue() noexcept = default;\n    ~ResizeableLockFreeQueue() noexcept = default;\n\n    // deleted for now, can be implemented later if needed\n    // note: concurrent copying or moving in lockfree fashion is nontrivial\n    ResizeableLockFreeQueue(const ResizeableLockFreeQueue&amp;) = delete;\n    ResizeableLockFreeQueue(ResizeableLockFreeQueue&amp;&amp;) = delete;\n    ResizeableLockFreeQueue&amp; operator=(const ResizeableLockFreeQueue&amp;) = delete;\n    ResizeableLockFreeQueue&amp; operator=(ResizeableLockFreeQueue&amp;&amp;) = delete;\n\n    ResizeableLockFreeQueue(const uint64_t initialCapacity) noexcept;\n\n    static constexpr uint64_t maxCapacity() noexcept;\n\n    using Base::empty;\n    using Base::pop;\n    using Base::size;\n    using Base::tryPush;\n\n    uint64_t capacity() const noexcept;\n\n    iox::cxx::optional&lt;ElementType&gt; push(const ElementType&amp; value) noexcept;\n\n    iox::cxx::optional&lt;ElementType&gt; push(ElementType&amp;&amp; value) noexcept;\n\n    // overloads to set the capacity\n    // 1) The most general one allows providing a removeHandler to specify remove behavior.\n    //    This could e.g. be to store them in a container.\n    // 2) The second overload discards removed elements.\n\n\n    template &lt;typename Function,\n              typename = typename std::enable_if&lt;cxx::is_invocable&lt;Function, ElementType&gt;::value&gt;::type&gt;\n    bool setCapacity(const uint64_t newCapacity, Function&amp;&amp; removeHandler) noexcept;\n\n    bool setCapacity(const uint64_t newCapacity) noexcept;\n\n  private:\n    using BufferIndex = typename Base::BufferIndex;\n    std::atomic&lt;uint64_t&gt; m_capacity{MaxCapacity};\n    // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT\n    std::atomic_flag m_resizeInProgress = ATOMIC_FLAG_INIT;\n    iox::cxx::vector&lt;BufferIndex, MaxCapacity&gt; m_unusedIndices;\n\n    uint64_t increaseCapacity(const uint64_t toIncrease) noexcept;\n\n    template &lt;typename Function&gt;\n    uint64_t decreaseCapacity(const uint64_t toDecrease, Function&amp;&amp; removeHandler) noexcept;\n\n    bool tryGetUsedIndex(BufferIndex&amp; index) noexcept;\n\n    template &lt;typename T&gt;\n    iox::cxx::optional&lt;ElementType&gt; pushImpl(T&amp;&amp; value) noexcept;\n};\n\n} // namespace concurrent\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/resizeable_lockfree_queue.inl\"\n\n#endif // IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/","text":"","title":"iceoryx_hoofs/cxx/scoped_static.hpp"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_SCOPED_STATIC_HPP\n#define IOX_HOOFS_CXX_SCOPED_STATIC_HPP\n\n#include \"iceoryx_hoofs/cxx/generic_raii.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, typename... CTorArgs&gt;\nGenericRAII makeScopedStatic(T&amp; memory, CTorArgs&amp;&amp;... ctorArgs) noexcept;\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/scoped_static.inl\"\n\n\n#endif // IOX_HOOFS_CXX_SCOPED_STATIC_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/semaphore.hpp"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#classes","text":"Name     struct iox::posix::CreateUnnamedSingleProcessSemaphore_t   struct iox::posix::CreateUnnamedSharedMemorySemaphore_t   struct iox::posix::CreateNamedSemaphore_t   struct iox::posix::OpenNamedSemaphore_t   class iox::posix::Semaphore Posix semaphore C++ Wrapping class.","title":"Classes"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/design_pattern/creation.hpp\"\n#include \"iceoryx_hoofs/internal/relocatable_pointer/relative_pointer.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/platform/fcntl.hpp\"\n#include \"iceoryx_hoofs/platform/semaphore.hpp\"\n#include \"iceoryx_hoofs/platform/stat.hpp\"\n\n#include &lt;cstring&gt;\n\nnamespace iox\n{\nnamespace posix\n{\nenum class SemaphoreError\n{\n    CREATION_FAILED,\n    NAME_TOO_LONG,\n    UNABLE_TO_OPEN_HANDLE,\n    INVALID_SEMAPHORE_HANDLE,\n    SEMAPHORE_OVERFLOW,\n    INTERRUPTED_BY_SIGNAL_HANDLER,\n    UNDEFINED\n};\n\nenum class SemaphoreWaitState\n{\n    TIMEOUT,\n    NO_TIMEOUT,\n};\n\nstruct CreateUnnamedSingleProcessSemaphore_t\n{\n};\nstruct CreateUnnamedSharedMemorySemaphore_t\n{\n};\nstruct CreateNamedSemaphore_t\n{\n};\nstruct OpenNamedSemaphore_t\n{\n};\nstatic constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore =\n    CreateUnnamedSingleProcessSemaphore_t();\nstatic constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore =\n    CreateUnnamedSharedMemorySemaphore_t();\nstatic constexpr CreateNamedSemaphore_t CreateNamedSemaphore = CreateNamedSemaphore_t();\nstatic constexpr OpenNamedSemaphore_t OpenNamedSemaphore = OpenNamedSemaphore_t();\n\nclass Semaphore : public DesignPattern::Creation&lt;Semaphore, SemaphoreError&gt;\n{\n  public:\n    Semaphore() noexcept;\n\n    Semaphore(Semaphore&amp;&amp; rhs) noexcept;\n\n    Semaphore&amp; operator=(Semaphore&amp;&amp; rhs) noexcept;\n\n    Semaphore(const Semaphore&amp;) = delete;\n\n    Semaphore&amp; operator=(const Semaphore&amp;) = delete;\n\n    ~Semaphore() noexcept;\n\n    cxx::expected&lt;int, SemaphoreError&gt; getValue() const noexcept;\n\n    cxx::expected&lt;SemaphoreError&gt; post() noexcept;\n\n    cxx::expected&lt;SemaphoreWaitState, SemaphoreError&gt; timedWait(const units::Duration abs_timeout) noexcept;\n\n    cxx::expected&lt;bool, SemaphoreError&gt; tryWait() noexcept;\n\n    cxx::expected&lt;SemaphoreError&gt; wait() noexcept;\n\n  private:\n    cxx::string&lt;128&gt; m_name;\n    bool m_isCreated = true;\n    bool m_isNamedSemaphore = true;\n    bool m_isShared = false;\n\n    mutable iox_sem_t m_handle{};\n    mutable iox_sem_t* m_handlePtr = nullptr;\n\n  private:\n    friend class DesignPattern::Creation&lt;Semaphore, SemaphoreError&gt;;\n\n    Semaphore(CreateUnnamedSingleProcessSemaphore_t, const unsigned int value) noexcept;\n\n    Semaphore(CreateUnnamedSharedMemorySemaphore_t, const unsigned int value) noexcept;\n\n    Semaphore(OpenNamedSemaphore_t, const char* name, const int oflag) noexcept;\n\n    Semaphore(CreateNamedSemaphore_t, const char* name, const mode_t mode, const unsigned int value) noexcept;\n\n    bool close() noexcept;\n\n    bool destroy() noexcept;\n\n    static bool init(iox_sem_t* handle, const int pshared, const unsigned int value) noexcept;\n\n    bool open(const int oflag) noexcept;\n\n    iox_sem_t* getHandle() const noexcept;\n\n    bool open(const int oflag, const mode_t mode, const unsigned int value) noexcept;\n\n    static bool unlink(const char* name) noexcept;\n\n    bool isNamedSemaphore() const noexcept;\n\n    void closeHandle() noexcept;\n\n    static SemaphoreError errnoToEnum(const int errnoValue) noexcept;\n};\n} // namespace posix\n} // namespace iox\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/serialization_8hpp/","text":"","title":"iceoryx_hoofs/cxx/serialization.hpp"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#classes","text":"Name     class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01.","title":"Classes"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_SERIALIZATION_HPP\n#define IOX_HOOFS_CXX_SERIALIZATION_HPP\n\n#include \"iceoryx_hoofs/cxx/convert.hpp\"\n\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nclass Serialization\n{\n  public:\n    explicit Serialization(const std::string&amp; value) noexcept;\n\n    std::string toString() const noexcept;\n\n    operator std::string() const noexcept;\n\n    template &lt;typename... Targs&gt;\n    static Serialization create(const Targs&amp;... args) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    bool extract(T&amp; t, Targs&amp;... args) const noexcept;\n\n    template &lt;typename T&gt;\n    bool getNth(const unsigned int index, T&amp; t) const noexcept;\n\n    enum class Error\n    {\n        DESERIALIZATION_FAILED, \n    };\n\n  private:\n    std::string m_value;\n    static constexpr char separator = ':';\n\n  private:\n    static std::string serializer() noexcept;\n\n    static bool removeFirstEntry(std::string&amp; firstEntry, std::string&amp; remainder) noexcept;\n\n    template &lt;typename T&gt;\n    static typename std::enable_if&lt;std::is_convertible&lt;T, Serialization&gt;::value, std::string&gt;::type\n    getString(const T&amp; t) noexcept;\n    template &lt;typename T&gt;\n    static typename std::enable_if&lt;!std::is_convertible&lt;T, Serialization&gt;::value, std::string&gt;::type\n    getString(const T&amp; t) noexcept;\n    template &lt;typename T, typename... Targs&gt;\n    static std::string serializer(const T&amp; t, const Targs&amp;... args) noexcept;\n\n    static bool deserialize(const std::string&amp; serializedString) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    static bool deserialize(const std::string&amp; serializedString, T&amp; t, Targs&amp;... args) noexcept;\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/serialization.inl\"\n\n#endif // IOX_HOOFS_CXX_SERIALIZATION_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/signal_handler.hpp"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#classes","text":"Name     class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call.","title":"Classes"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP\n\n#include \"iceoryx_hoofs/platform/signal.hpp\"\n\nnamespace iox\n{\nnamespace posix\n{\nusing SignalHandlerCallback_t = void (*)(int);\n\nenum class Signal : int\n{\n    BUS = SIGBUS,\n    INT = SIGINT,\n    TERM = SIGTERM,\n    HUP = SIGHUP,\n    ABORT = SIGABRT,\n};\n\nclass SignalGuard\n{\n  public:\n    SignalGuard(SignalGuard&amp;&amp; rhs) noexcept;\n    SignalGuard(const SignalGuard&amp;) = delete;\n    ~SignalGuard() noexcept;\n\n    SignalGuard&amp; operator=(const SignalGuard&amp; rhs) = delete;\n    SignalGuard&amp; operator=(SignalGuard&amp;&amp; rhs) = delete;\n\n    friend SignalGuard registerSignalHandler(const Signal, const SignalHandlerCallback_t) noexcept;\n\n  private:\n    void restorePreviousAction() noexcept;\n    SignalGuard() noexcept = default;\n    SignalGuard(const Signal signal, const struct sigaction&amp; previousAction) noexcept;\n\n  private:\n    Signal m_signal;\n    struct sigaction m_previousAction = {};\n    bool m_doRestorePreviousAction{false};\n};\n\nSignalGuard registerSignalHandler(const Signal signal, const SignalHandlerCallback_t callback) noexcept;\n} // namespace posix\n} // namespace iox\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#classes","text":"Name     class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred.","title":"Classes"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP\n\n#include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\"\n#include \"iceoryx_hoofs/posix_wrapper/signal_handler.hpp\"\n\n#include &lt;atomic&gt;\n\nnamespace iox\n{\nnamespace posix\n{\nclass SignalWatcher\n{\n  public:\n    SignalWatcher(const SignalWatcher&amp;) = delete;\n    SignalWatcher(SignalWatcher&amp;&amp;) = delete;\n    ~SignalWatcher() = default;\n\n    SignalWatcher&amp; operator=(const SignalWatcher&amp;) = delete;\n    SignalWatcher&amp; operator=(SignalWatcher&amp;&amp;) = delete;\n\n    static SignalWatcher&amp; getInstance() noexcept;\n\n    void waitForSignal() const noexcept;\n\n    bool wasSignalTriggered() const noexcept;\n\n  protected:\n    SignalWatcher() noexcept;\n\n  private:\n    friend void internalSignalHandler(int) noexcept;\n    mutable std::atomic&lt;uint64_t&gt; m_numberOfWaiters{0U};\n    mutable Semaphore m_semaphore;\n\n    std::atomic_bool m_hasSignalOccurred{false};\n    SignalGuard m_sigTermGuard;\n    SignalGuard m_sigIntGuard;\n};\n\nvoid waitForTerminationRequest() noexcept;\n\nbool hasTerminationRequested() noexcept;\n} // namespace posix\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/stack_8hpp/","text":"","title":"iceoryx_hoofs/cxx/stack.hpp"},{"location":"API-reference/hoofs/Files/stack_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/stack_8hpp/#classes","text":"Name     class iox::cxx::stack stack implementation with a simple push pop interface","title":"Classes"},{"location":"API-reference/hoofs/Files/stack_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_STACK_HPP\n#define IOX_HOOFS_CXX_STACK_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, uint64_t Capacity&gt;\nclass stack\n{\n  public:\n    cxx::optional&lt;T&gt; pop() noexcept;\n\n    template &lt;typename... Targs&gt;\n    bool push(Targs&amp;&amp;... args) noexcept;\n\n    uint64_t size() const noexcept;\n\n    static constexpr uint64_t capacity() noexcept;\n\n  private:\n    using element_t = uint8_t[sizeof(T)];\n    alignas(T) element_t m_data[Capacity];\n    uint64_t m_size = 0U;\n};\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/stack.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/string_8hpp/","text":"","title":"iceoryx_hoofs/cxx/string.hpp"},{"location":"API-reference/hoofs/Files/string_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/string_8hpp/#classes","text":"Name     struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior   class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap.","title":"Classes"},{"location":"API-reference/hoofs/Files/string_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_STRING_HPP\n#define IOX_HOOFS_CXX_STRING_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/string_internal.hpp\"\n#include \"optional.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T1, typename T2&gt;\ntypename std::enable_if&lt;(internal::IsCharArray&lt;T1&gt;::value || internal::IsCxxString&lt;T1&gt;::value)\n                            &amp;&amp; (internal::IsCharArray&lt;T2&gt;::value || internal::IsCxxString&lt;T2&gt;::value),\n                        string&lt;internal::GetCapa&lt;T1&gt;::capa + internal::GetCapa&lt;T2&gt;::capa&gt;&gt;::type\nconcatenate(const T1&amp; t1, const T2&amp; t2) noexcept;\n\ntemplate &lt;typename T1, typename T2, typename... Targs&gt;\ntypename std::enable_if&lt;(internal::IsCharArray&lt;T1&gt;::value || internal::IsCxxString&lt;T1&gt;::value)\n                            &amp;&amp; (internal::IsCharArray&lt;T2&gt;::value || internal::IsCxxString&lt;T2&gt;::value),\n                        string&lt;internal::SumCapa&lt;T1, T2, Targs...&gt;::value&gt;&gt;::type\nconcatenate(const T1&amp; t1, const T2&amp; t2, const Targs&amp;... targs) noexcept;\n\ntemplate &lt;typename T1, typename T2&gt;\ntypename std::enable_if&lt;(internal::IsCharArray&lt;T1&gt;::value &amp;&amp; internal::IsCxxString&lt;T2&gt;::value)\n                            || (internal::IsCxxString&lt;T1&gt;::value &amp;&amp; internal::IsCharArray&lt;T2&gt;::value)\n                            || (internal::IsCxxString&lt;T1&gt;::value &amp;&amp; internal::IsCxxString&lt;T2&gt;::value),\n                        string&lt;internal::GetCapa&lt;T1&gt;::capa + internal::GetCapa&lt;T2&gt;::capa&gt;&gt;::type\noperator+(const T1&amp; t1, const T2&amp; t2) noexcept;\n\nstruct TruncateToCapacity_t\n{\n    explicit TruncateToCapacity_t() = default;\n};\nconstexpr TruncateToCapacity_t TruncateToCapacity{};\n\ntemplate &lt;uint64_t Capacity&gt;\nclass string\n{\n    static_assert(Capacity &gt; 0U, \"The capacity of the fixed string must be greater than 0!\");\n\n  public:\n    constexpr string() noexcept = default;\n\n    string(const string&amp; other) noexcept;\n\n    string(string&amp;&amp; other) noexcept;\n\n    string&amp; operator=(const string&amp; rhs) noexcept;\n\n    string&amp; operator=(string&amp;&amp; rhs) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string(const string&lt;N&gt;&amp; other) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string(string&lt;N&gt;&amp;&amp; other) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; operator=(const string&lt;N&gt;&amp; rhs) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; operator=(string&lt;N&gt;&amp;&amp; rhs) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string(const char (&amp;other)[N]) noexcept;\n\n    string(TruncateToCapacity_t, const char* const other) noexcept;\n\n    string(TruncateToCapacity_t, const std::string&amp; other) noexcept;\n\n    string(TruncateToCapacity_t, const char* const other, const uint64_t count) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; operator=(const char (&amp;rhs)[N]) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; assign(const string&lt;N&gt;&amp; str) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; assign(const char (&amp;str)[N]) noexcept;\n\n    bool unsafe_assign(const char* const str) noexcept;\n\n    bool unsafe_assign(const std::string&amp; str) noexcept;\n\n    template &lt;uint64_t N&gt;\n    int64_t compare(const string&lt;N&gt;&amp; other) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator==(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator!=(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator&lt;(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator&lt;=(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator&gt;(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    bool operator&gt;=(const string&lt;N&gt;&amp; rhs) const noexcept;\n\n    bool operator==(const char* const rhs) const noexcept;\n\n    bool operator!=(const char* const rhs) const noexcept;\n\n    const char* c_str() const noexcept;\n\n    constexpr uint64_t size() const noexcept;\n\n    static constexpr uint64_t capacity() noexcept;\n\n    constexpr bool empty() const noexcept;\n\n    operator std::string() const noexcept;\n\n    template &lt;typename T&gt;\n    string&amp; operator+=(const T&amp;) noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;internal::IsCharArray&lt;T&gt;::value || internal::IsCxxString&lt;T&gt;::value, string&amp;&gt;::type\n    append(TruncateToCapacity_t, const T&amp; t) noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;internal::IsCharArray&lt;T&gt;::value || internal::IsCxxString&lt;T&gt;::value, bool&gt;::type\n    unsafe_append(const T&amp; t) noexcept;\n\n    iox::cxx::optional&lt;string&lt;Capacity&gt;&gt; substr(const uint64_t pos, const uint64_t count) const noexcept;\n\n    iox::cxx::optional&lt;string&lt;Capacity&gt;&gt; substr(const uint64_t pos = 0U) const noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value || internal::IsCharArray&lt;T&gt;::value\n                                || internal::IsCxxString&lt;T&gt;::value,\n                            iox::cxx::optional&lt;uint64_t&gt;&gt;::type\n    find(const T&amp; t, const uint64_t pos = 0U) const noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value || internal::IsCharArray&lt;T&gt;::value\n                                || internal::IsCxxString&lt;T&gt;::value,\n                            iox::cxx::optional&lt;uint64_t&gt;&gt;::type\n    find_first_of(const T&amp; t, const uint64_t pos = 0U) const noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value || internal::IsCharArray&lt;T&gt;::value\n                                || internal::IsCxxString&lt;T&gt;::value,\n                            iox::cxx::optional&lt;uint64_t&gt;&gt;::type\n    find_last_of(const T&amp; t, const uint64_t pos = Capacity) const noexcept;\n\n    template &lt;uint64_t N&gt;\n    friend class string;\n\n    template &lt;typename T1, typename T2&gt;\n    friend typename std::enable_if&lt;(internal::IsCharArray&lt;T1&gt;::value || internal::IsCxxString&lt;T1&gt;::value)\n                                       &amp;&amp; (internal::IsCharArray&lt;T2&gt;::value || internal::IsCxxString&lt;T2&gt;::value),\n                                   string&lt;internal::GetCapa&lt;T1&gt;::capa + internal::GetCapa&lt;T2&gt;::capa&gt;&gt;::type\n    concatenate(const T1&amp; t1, const T2&amp; t2) noexcept;\n\n  private:\n    template &lt;uint64_t N&gt;\n    string&amp; copy(const string&lt;N&gt;&amp; rhs) noexcept;\n\n    template &lt;uint64_t N&gt;\n    string&amp; move(string&lt;N&gt;&amp;&amp; rhs) noexcept;\n\n    char m_rawstring[Capacity + 1U]{'\\0'};\n    uint64_t m_rawstringSize{0U};\n};\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator==(const std::string&amp; lhs, const string&lt;Capacity&gt;&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator==(const string&lt;Capacity&gt;&amp; lhs, const std::string&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator!=(const std::string&amp; lhs, const string&lt;Capacity&gt;&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator!=(const string&lt;Capacity&gt;&amp; lhs, const std::string&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator==(const char* const lhs, const string&lt;Capacity&gt;&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline bool operator!=(const char* const lhs, const string&lt;Capacity&gt;&amp; rhs) noexcept;\n\ntemplate &lt;uint64_t Capacity&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const string&lt;Capacity&gt;&amp; str) noexcept;\n} // namespace cxx\n} // namespace iox\n#include \"iceoryx_hoofs/internal/cxx/string.inl\"\n\n#endif // IOX_HOOFS_CXX_STRING_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/thread_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/thread.hpp"},{"location":"API-reference/hoofs/Files/thread_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/thread_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/platform/pthread.hpp\"\n\nnamespace iox\n{\nnamespace posix\n{\nconstexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U;\n\nusing ThreadName_t = cxx::string&lt;MAX_THREAD_NAME_LENGTH&gt;;\n\nvoid setThreadName(pthread_t thread, const ThreadName_t&amp; name) noexcept;\nThreadName_t getThreadName(pthread_t thread) noexcept;\n\n} // namespace posix\n} // namespace iox\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/timer_8hpp/","text":"","title":"iceoryx_hoofs/posix_wrapper/timer.hpp"},{"location":"API-reference/hoofs/Files/timer_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::posix   iox::units::duration_literals","title":"Namespaces"},{"location":"API-reference/hoofs/Files/timer_8hpp/#classes","text":"Name     class iox::posix::Timer Interface for timers on POSIX operating systems.","title":"Classes"},{"location":"API-reference/hoofs/Files/timer_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP\n#define IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/design_pattern/creation.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/platform/signal.hpp\"\n#include \"iceoryx_hoofs/platform/time.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;condition_variable&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n#include &lt;functional&gt;\n#include &lt;limits&gt;\n\n\nnamespace iox\n{\nnamespace posix\n{\nenum class TimerError\n{\n    NO_ERROR,\n    TIMER_NOT_INITIALIZED,\n    NO_VALID_CALLBACK,\n    KERNEL_ALLOC_FAILED,\n    INVALID_ARGUMENTS,\n    ALLOC_MEM_FAILED,\n    NO_PERMISSION,\n    INVALID_POINTER,\n    NO_TIMER_TO_DELETE,\n    TIMEOUT_IS_ZERO,\n    INTERNAL_LOGIC_ERROR\n};\n\nusing namespace iox::units::duration_literals;\n\n\n\nclass Timer\n{\n  public:\n    enum class RunMode\n    {\n        ONCE,\n        PERIODIC\n    };\n\n    enum class CatchUpPolicy\n    {\n        SKIP_TO_NEXT_BEAT,\n        IMMEDIATE,\n        TERMINATE\n    };\n\n  private:\n    static constexpr size_t SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR = sizeof(uint32_t);\n    static constexpr size_t SIZE_OF_SIGVAL_INT = sizeof(int);\n    static_assert(SIZE_OF_SIGVAL_INT &gt;= SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR, \"size of sigval_int is to low\");\n\n    static constexpr uint32_t MAX_NUMBER_OF_CALLBACK_HANDLES = 100u;\n    static_assert(MAX_NUMBER_OF_CALLBACK_HANDLES &lt;= std::numeric_limits&lt;uint8_t&gt;::max(),\n                  \"number of callback handles exceeds max index value\");\n    class OsTimer;\n    struct OsTimerCallbackHandle\n    {\n        static constexpr uint32_t MAX_DESCRIPTOR_VALUE{(1u &lt;&lt; 24u) - 1u};\n        static sigval indexAndDescriptorToSigval(uint8_t index, uint32_t descriptor) noexcept;\n        static uint8_t sigvalToIndex(sigval intVal) noexcept;\n        static uint32_t sigvalToDescriptor(sigval intVal) noexcept;\n\n        void incrementDescriptor() noexcept;\n\n        std::mutex m_accessMutex;\n\n        std::atomic&lt;uint32_t&gt; m_descriptor{0u};\n        // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT\n        std::atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT;\n\n        std::atomic&lt;bool&gt; m_inUse{false};\n        std::atomic&lt;bool&gt; m_isTimerActive{false};\n        std::atomic&lt;uint64_t&gt; m_timerInvocationCounter{0u};\n        CatchUpPolicy m_catchUpPolicy{CatchUpPolicy::TERMINATE};\n        OsTimer* m_timer{nullptr};\n    };\n\n    class OsTimer\n    {\n#ifdef __QNX__\n        static constexpr timer_t INVALID_TIMER_ID = 0;\n#else\n        static constexpr timer_t INVALID_TIMER_ID = nullptr;\n#endif\n      public:\n        static void callbackHelper(sigval data) noexcept;\n\n        OsTimer(const units::Duration timeToWait, const std::function&lt;void()&gt;&amp; callback) noexcept;\n\n        OsTimer(const OsTimer&amp;) = delete;\n        OsTimer(OsTimer&amp;&amp;) = delete;\n        OsTimer&amp; operator=(const OsTimer&amp;) = delete;\n        OsTimer&amp; operator=(OsTimer&amp;&amp;) = delete;\n\n        virtual ~OsTimer() noexcept;\n\n        cxx::expected&lt;TimerError&gt; start(const RunMode runMode, const CatchUpPolicy catchUpPolicy) noexcept;\n\n        cxx::expected&lt;TimerError&gt; stop() noexcept;\n\n        cxx::expected&lt;TimerError&gt;\n        restart(const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) noexcept;\n\n        // @brief Returns the time until the timer expires the next time\n        cxx::expected&lt;units::Duration, TimerError&gt; timeUntilExpiration() noexcept;\n\n        cxx::expected&lt;uint64_t, TimerError&gt; getOverruns() noexcept;\n\n        bool hasError() const noexcept;\n\n        TimerError getError() const noexcept;\n\n      private:\n        void executeCallback() noexcept;\n\n      private:\n        units::Duration m_timeToWait;\n\n        std::function&lt;void()&gt; m_callback;\n\n        timer_t m_timerId{INVALID_TIMER_ID};\n\n        uint8_t m_callbackHandleIndex{0u};\n\n        bool m_isInitialized{false};\n\n        TimerError m_errorValue{TimerError::NO_ERROR};\n\n        static OsTimerCallbackHandle s_callbackHandlePool[MAX_NUMBER_OF_CALLBACK_HANDLES];\n    };\n\n  public:\n    Timer(const units::Duration timeToWait) noexcept;\n\n    Timer(const units::Duration timeToWait, const std::function&lt;void()&gt;&amp; callback) noexcept;\n\n    static cxx::expected&lt;units::Duration, TimerError&gt; now() noexcept;\n\n    Timer(const Timer&amp; other) = delete;\n\n    Timer(Timer&amp;&amp; other) = delete;\n\n    Timer&amp; operator=(const Timer&amp; other) = delete;\n\n    Timer&amp; operator=(Timer&amp;&amp; other) = delete;\n\n    virtual ~Timer() noexcept = default;\n\n    cxx::expected&lt;TimerError&gt; start(const RunMode runMode, const CatchUpPolicy catchUpPolicy) noexcept;\n\n    cxx::expected&lt;TimerError&gt; stop() noexcept;\n\n    cxx::expected&lt;TimerError&gt;\n    restart(const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) noexcept;\n\n    // @brief Returns the time until the timer expires the next time\n    cxx::expected&lt;units::Duration, TimerError&gt; timeUntilExpiration() noexcept;\n\n    cxx::expected&lt;uint64_t, TimerError&gt; getOverruns() noexcept;\n\n    bool hasError() const noexcept;\n\n    TimerError getError() const noexcept;\n\n  private:\n    cxx::optional&lt;OsTimer&gt; m_osTimer;\n\n    static cxx::error&lt;TimerError&gt; createErrorFromErrno(const int32_t errnum) noexcept;\n\n    units::Duration m_timeToWait;\n\n    units::Duration m_creationTime;\n\n    TimerError m_errorValue{TimerError::NO_ERROR};\n};\n\n} // namespace posix\n} // namespace iox\n\n#endif // IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/","text":"","title":"iceoryx_hoofs/cxx/type_traits.hpp"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#classes","text":"Name     struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier.   struct iox::cxx::add_const_conditionally&lt; T, const C &gt;   struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments.   struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType.   struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature.   struct iox::cxx::is_function_pointer&lt; ReturnType(*)(ArgTypes...)&gt;","title":"Classes"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_TYPE_TRAITS_HPP\n#define IOX_HOOFS_CXX_TYPE_TRAITS_HPP\n\n#include &lt;type_traits&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, typename C&gt;\nstruct add_const_conditionally\n{\n    using type = T;\n};\ntemplate &lt;typename T, typename C&gt;\nstruct add_const_conditionally&lt;T, const C&gt;\n{\n    using type = const T;\n};\ntemplate &lt;typename T, typename C&gt;\nusing add_const_conditionally_t = typename add_const_conditionally&lt;T, C&gt;::type;\n\ntemplate &lt;typename&gt;\nconstexpr bool always_false_v = false;\n\n// windows defines __cplusplus as 199711L\n#if __cplusplus &lt; 201703L &amp;&amp; !defined(_WIN32)\ntemplate &lt;typename C, typename... Cargs&gt;\nusing invoke_result = std::result_of&lt;C(Cargs...)&gt;;\n#elif __cplusplus &gt;= 201703L || defined(_WIN32)\ntemplate &lt;typename C, typename... Cargs&gt;\nusing invoke_result = std::invoke_result&lt;C, Cargs...&gt;;\n#endif\n\ntemplate &lt;typename Callable, typename... ArgTypes&gt;\nstruct is_invocable\n{\n    // This variant is chosen when Callable(ArgTypes) successfully resolves to a valid type, i.e. is invocable.\n    template &lt;typename C, typename... As&gt;\n    static constexpr std::true_type test(typename cxx::invoke_result&lt;C, As...&gt;::type*) noexcept\n    {\n        return {};\n    }\n\n    // This is chosen if Callable(ArgTypes) does not resolve to a valid type.\n    template &lt;typename C, typename... As&gt;\n    static constexpr std::false_type test(...) noexcept\n    {\n        return {};\n    }\n\n    // Test with nullptr as this can stand in for a pointer to any type.\n    static constexpr bool value = decltype(test&lt;Callable, ArgTypes...&gt;(nullptr))::value;\n};\n\ntemplate &lt;typename ReturnType, typename Callable, typename... ArgTypes&gt;\nstruct is_invocable_r\n{\n    template &lt;typename C, typename... As&gt;\n    static constexpr std::true_type test(\n        std::enable_if_t&lt;std::is_convertible&lt;typename cxx::invoke_result&lt;C, As...&gt;::type, ReturnType&gt;::value&gt;*) noexcept\n    {\n        return {};\n    }\n\n    template &lt;typename C, typename... As&gt;\n    static constexpr std::false_type test(...) noexcept\n    {\n        return {};\n    }\n\n    // Test with nullptr as this can stand in for a pointer to any type.\n    static constexpr bool value = decltype(test&lt;Callable, ArgTypes...&gt;(nullptr))::value;\n};\n\ntemplate &lt;typename T&gt;\nstruct is_function_pointer : std::false_type\n{\n};\ntemplate &lt;typename ReturnType, typename... ArgTypes&gt;\nstruct is_function_pointer&lt;ReturnType (*)(ArgTypes...)&gt; : std::true_type\n{\n};\n\ntemplate &lt;typename...&gt;\nusing void_t = void;\n} // namespace cxx\n} // namespace iox\n\n#endif // IOX_HOOFS_CXX_TYPE_TRAITS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/types_8hpp/","text":"","title":"iceoryx_hoofs/cxx/types.hpp"},{"location":"API-reference/hoofs/Files/types_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/types_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_TYPES_HPP\n#define IOX_HOOFS_CXX_TYPES_HPP\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nusing byte_t = uint8_t;\n}\n} // namespace iox\n\n#endif // IOX_HOOFS_CXX_TYPES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/","text":"","title":"iceoryx_hoofs/cxx/unique_ptr.hpp"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#classes","text":"Name     class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL.","title":"Classes"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_HOOFS_CXX_UNIQUE_PTR_HPP\n#define IOX_HOOFS_CXX_UNIQUE_PTR_HPP\n\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T&gt;\nclass unique_ptr\n{\n  public:\n    unique_ptr() = delete;\n\n    unique_ptr(function_ref&lt;void(T*)&gt;&amp;&amp; deleter) noexcept;\n\n    unique_ptr(T* const ptr, function_ref&lt;void(T*)&gt;&amp;&amp; deleter) noexcept;\n\n    unique_ptr(const unique_ptr&amp; other) = delete;\n    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;\n    unique_ptr(unique_ptr&amp;&amp; rhs) noexcept;\n    unique_ptr&amp; operator=(unique_ptr&amp;&amp; rhs) noexcept;\n\n    ~unique_ptr() noexcept;\n\n\n    unique_ptr&lt;T&gt;&amp; operator=(std::nullptr_t) noexcept;\n\n    T* operator-&gt;() noexcept;\n\n    const T* operator-&gt;() const noexcept;\n\n    explicit operator bool() const noexcept;\n\n    T* get() noexcept;\n\n    const T* get() const noexcept;\n\n    T* release() noexcept;\n\n    void reset(T* const ptr = nullptr) noexcept;\n\n    void swap(unique_ptr&amp; other) noexcept;\n\n  private:\n    T* m_ptr = nullptr;\n    function_ref&lt;void(T* const)&gt; m_deleter;\n};\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/unique_ptr.inl\"\n\n#endif // IOX_HOOFS_CXX_UNIQUE_PTR_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/variant_8hpp/","text":"","title":"iceoryx_hoofs/cxx/variant.hpp"},{"location":"API-reference/hoofs/Files/variant_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/variant_8hpp/#classes","text":"Name     struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant   struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant   class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions.","title":"Classes"},{"location":"API-reference/hoofs/Files/variant_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_VARIANT_HPP\n#define IOX_HOOFS_CXX_VARIANT_HPP\n\n#include \"iceoryx_hoofs/cxx/algorithm.hpp\"\n#include \"iceoryx_hoofs/internal/cxx/variant_internal.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\n#include \"iceoryx_hoofs/platform/platform_correction.hpp\"\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;uint64_t N&gt;\nstruct in_place_index\n{\n    static constexpr uint64_t value = N;\n};\n\ntemplate &lt;typename T&gt;\nstruct in_place_type\n{\n    using type = T;\n};\n\nstatic constexpr uint64_t INVALID_VARIANT_INDEX = std::numeric_limits&lt;uint64_t&gt;::max();\n\ntemplate &lt;typename... Types&gt;\nclass variant\n{\n  private:\n    static constexpr uint64_t TYPE_SIZE = algorithm::max(sizeof(Types)...);\n\n  public:\n    constexpr variant() noexcept = default;\n\n    template &lt;uint64_t N, typename... CTorArguments&gt;\n    constexpr variant(const in_place_index&lt;N&gt;&amp; index, CTorArguments&amp;&amp;... args) noexcept;\n\n    template &lt;typename T, typename... CTorArguments&gt;\n    constexpr variant(const in_place_type&lt;T&gt;&amp; type, CTorArguments&amp;&amp;... args) noexcept;\n\n    template &lt;typename T,\n              typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;T&gt;, variant&gt;::value&gt;,\n              typename std::enable_if_t&lt;!internal::is_in_place_index&lt;std::decay_t&lt;T&gt;&gt;::value, bool&gt; = false,\n              typename std::enable_if_t&lt;!internal::is_in_place_type&lt;std::decay_t&lt;T&gt;&gt;::value, bool&gt; = false&gt;\n    constexpr variant(T&amp;&amp; arg) noexcept;\n\n    constexpr variant(const variant&amp; rhs) noexcept;\n\n    constexpr variant&amp; operator=(const variant&amp; rhs) noexcept;\n\n    constexpr variant(variant&amp;&amp; rhs) noexcept;\n\n    constexpr variant&amp; operator=(variant&amp;&amp; rhs) noexcept;\n\n    ~variant() noexcept;\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;!std::is_same&lt;T, variant&lt;Types...&gt;&amp;&gt;::value, variant&lt;Types...&gt;&gt;::type&amp;\n    operator=(T&amp;&amp; rhs) noexcept;\n\n    template &lt;uint64_t TypeIndex, typename... CTorArguments&gt;\n    bool emplace_at_index(CTorArguments&amp;&amp;... args) noexcept;\n\n    template &lt;typename T, typename... CTorArguments&gt;\n    bool emplace(CTorArguments&amp;&amp;... args) noexcept;\n\n    template &lt;uint64_t TypeIndex&gt;\n    typename internal::get_type_at_index&lt;0, TypeIndex, Types...&gt;::type* get_at_index() noexcept;\n\n    template &lt;uint64_t TypeIndex&gt;\n    const typename internal::get_type_at_index&lt;0, TypeIndex, Types...&gt;::type* get_at_index() const noexcept;\n\n    template &lt;typename T&gt;\n    const T* get() const noexcept;\n\n    template &lt;typename T&gt;\n    T* get() noexcept;\n\n    template &lt;typename T&gt;\n    T* get_if(T* defaultValue) noexcept;\n\n    template &lt;typename T&gt;\n    const T* get_if(const T* defaultValue) const noexcept;\n\n    constexpr uint64_t index() const noexcept;\n\n  private:\n    alignas(algorithm::max(alignof(Types)...)) internal::byte_t m_storage[TYPE_SIZE]{0u};\n    uint64_t m_type_index = INVALID_VARIANT_INDEX;\n\n  private:\n    template &lt;typename T&gt;\n    bool has_bad_variant_element_access() const noexcept;\n    static void error_message(const char* source, const char* msg) noexcept;\n\n    void call_element_destructor() noexcept;\n};\n\ntemplate &lt;typename T, typename... Types&gt;\nconstexpr bool holds_alternative(const variant&lt;Types...&gt;&amp; variant) noexcept;\n\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/variant.inl\"\n\n#endif // IOX_HOOFS_CXX_VARIANT_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/","text":"","title":"iceoryx_hoofs/cxx/variant_queue.hpp"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#classes","text":"Name     class iox::cxx::VariantQueue wrapper of multiple fifo's","title":"Classes"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_VARIANT_QUEUE_HPP\n#define IOX_HOOFS_CXX_VARIANT_QUEUE_HPP\n\n#include \"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp\"\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/variant.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/fifo.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/sofi.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\nenum class VariantQueueTypes : uint64_t\n{\n    FiFo_SingleProducerSingleConsumer = 0,\n    SoFi_SingleProducerSingleConsumer = 1,\n    FiFo_MultiProducerSingleConsumer = 2,\n    SoFi_MultiProducerSingleConsumer = 3\n};\n\n// remark: we need to consider to support the non-resizable queue as well\n//         since it should have performance benefits if resize is not actually needed\n//         for now we just use the most general variant, which allows resizing\n\ntemplate &lt;typename ValueType, uint64_t Capacity&gt;\nclass VariantQueue\n{\n  public:\n    using fifo_t = variant&lt;concurrent::FiFo&lt;ValueType, Capacity&gt;,\n                           concurrent::SoFi&lt;ValueType, Capacity&gt;,\n                           concurrent::ResizeableLockFreeQueue&lt;ValueType, Capacity&gt;,\n                           concurrent::ResizeableLockFreeQueue&lt;ValueType, Capacity&gt;&gt;;\n\n    VariantQueue(const VariantQueueTypes type) noexcept;\n\n    optional&lt;ValueType&gt; push(const ValueType&amp; value) noexcept;\n\n    optional&lt;ValueType&gt; pop() noexcept;\n\n    bool empty() const noexcept;\n\n    uint64_t size() noexcept;\n\n    bool setCapacity(const uint64_t newCapacity) noexcept;\n\n    uint64_t capacity() const noexcept;\n\n    fifo_t&amp; getUnderlyingFiFo() noexcept;\n\n  private:\n    VariantQueueTypes m_type;\n    fifo_t m_fifo;\n};\n} // namespace cxx\n} // namespace iox\n\n#include \"iceoryx_hoofs/internal/cxx/variant_queue.inl\"\n\n#endif // IOX_HOOFS_CXX_VARIANT_QUEUE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Files/vector_8hpp/","text":"","title":"iceoryx_hoofs/cxx/vector.hpp"},{"location":"API-reference/hoofs/Files/vector_8hpp/#namespaces","text":"Name     iox building block to easily create free function for logging in a library context   iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/vector_8hpp/#classes","text":"Name     class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory.","title":"Classes"},{"location":"API-reference/hoofs/Files/vector_8hpp/#functions","text":"Name     template &lt;typename T ,uint64_t CapacityLeft,uint64_t CapacityRight&gt; bool operator==(const iox::cxx::vector&lt; T, CapacityLeft &gt; &amp; lhs, const iox::cxx::vector&lt; T, CapacityRight &gt; &amp; rhs)   template &lt;typename T ,uint64_t CapacityLeft,uint64_t CapacityRight&gt; bool operator!=(const iox::cxx::vector&lt; T, CapacityLeft &gt; &amp; lhs, const iox::cxx::vector&lt; T, CapacityRight &gt; &amp; rhs)","title":"Functions"},{"location":"API-reference/hoofs/Files/vector_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Files/vector_8hpp/#function-operator","text":"<pre><code>template &lt;typename T ,\nuint64_t CapacityLeft,\nuint64_t CapacityRight&gt;\nbool operator==(\n    const iox::cxx::vector&lt; T, CapacityLeft &gt; &amp; lhs,\n    const iox::cxx::vector&lt; T, CapacityRight &gt; &amp; rhs\n)\n</code></pre>","title":"function operator=="},{"location":"API-reference/hoofs/Files/vector_8hpp/#function-operator_1","text":"<pre><code>template &lt;typename T ,\nuint64_t CapacityLeft,\nuint64_t CapacityRight&gt;\nbool operator!=(\n    const iox::cxx::vector&lt; T, CapacityLeft &gt; &amp; lhs,\n    const iox::cxx::vector&lt; T, CapacityRight &gt; &amp; rhs\n)\n</code></pre>","title":"function operator!="},{"location":"API-reference/hoofs/Files/vector_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_HOOFS_CXX_VECTOR_HPP\n#define IOX_HOOFS_CXX_VECTOR_HPP\n\n#include \"iceoryx_hoofs/cxx/requires.hpp\"\n\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstdio&gt;\n#include &lt;utility&gt;\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;typename T, uint64_t Capacity&gt;\nclass vector\n{\n  public:\n    using value_type = T;\n\n    using iterator = T*;\n    using const_iterator = const T*;\n\n    vector() noexcept = default;\n\n    vector(const uint64_t count, const T&amp; value) noexcept;\n\n    vector(const uint64_t count) noexcept;\n\n    vector(const vector&amp; rhs) noexcept;\n\n    vector(vector&amp;&amp; rhs) noexcept;\n\n    ~vector() noexcept;\n\n    vector&amp; operator=(const vector&amp; rhs) noexcept;\n\n    vector&amp; operator=(vector&amp;&amp; rhs) noexcept;\n\n    iterator begin() noexcept;\n\n    const_iterator begin() const noexcept;\n\n    iterator end() noexcept;\n\n    const_iterator end() const noexcept;\n\n    T* data() noexcept;\n\n    const T* data() const noexcept;\n\n    //          is undefined if the element at index does not exist.\n    T&amp; at(const uint64_t index) noexcept;\n\n    const T&amp; at(const uint64_t index) const noexcept;\n\n    //          is undefined if the element at index does not exist.\n    T&amp; operator[](const uint64_t index) noexcept;\n\n    const T&amp; operator[](const uint64_t index) const noexcept;\n\n    T&amp; front() noexcept;\n\n    const T&amp; front() const noexcept;\n\n    T&amp; back() noexcept;\n\n    const T&amp; back() const noexcept;\n\n    uint64_t capacity() const noexcept;\n\n    uint64_t size() const noexcept;\n\n    bool empty() const noexcept;\n\n    void clear() noexcept;\n\n    template &lt;typename... Targs&gt;\n    bool resize(const uint64_t count, const Targs&amp;... args) noexcept;\n\n    template &lt;typename... Targs&gt;\n    bool emplace(const uint64_t position, Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename... Targs&gt;\n    bool emplace_back(Targs&amp;&amp;... args) noexcept;\n\n    bool push_back(const T&amp; value) noexcept;\n\n    bool push_back(T&amp;&amp; value) noexcept;\n\n    bool pop_back() noexcept;\n\n    iterator erase(iterator position) noexcept;\n\n  private:\n    using element_t = uint8_t[sizeof(T)];\n    alignas(T) element_t m_data[Capacity];\n    uint64_t m_size = 0u;\n};\n} // namespace cxx\n} // namespace iox\n\ntemplate &lt;typename T, uint64_t CapacityLeft, uint64_t CapacityRight&gt;\nbool operator==(const iox::cxx::vector&lt;T, CapacityLeft&gt;&amp; lhs, const iox::cxx::vector&lt;T, CapacityRight&gt;&amp; rhs) noexcept;\n\ntemplate &lt;typename T, uint64_t CapacityLeft, uint64_t CapacityRight&gt;\nbool operator!=(const iox::cxx::vector&lt;T, CapacityLeft&gt;&amp; lhs, const iox::cxx::vector&lt;T, CapacityRight&gt;&amp; rhs) noexcept;\n\n#include \"iceoryx_hoofs/internal/cxx/vector.inl\"\n\n#endif // IOX_HOOFS_CXX_VECTOR_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/hoofs/Namespaces/namespaceDesignPattern/","text":"","title":"DesignPattern"},{"location":"API-reference/hoofs/Namespaces/namespaceDesignPattern/#classes","text":"Name     class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from <code>[Creation]()</code> and your class has three more static factory methods - <code>create</code>, <code>placementCreate</code> and <code>verify</code>. <code>create</code> forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables <code>m_isInitialized</code> and <code>m_errorValue</code>. The user always has to set <code>m_isInitialized</code> to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided <code>m_errorValue</code> variable which is then returned to the user.     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/","text":"<p>building block to easily create free function for logging in a library context  More...</p>","title":"iox"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#namespaces","text":"Name     iox::algorithm   iox::concurrent   iox::cxx   iox::log   iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#classes","text":"Name     class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#types","text":"Name     enum uint32_t Error { }   enum uint32_t ErrorLevel { FATAL, SEVERE, MODERATE}the available error levels FATAL   using std::function&lt; void(const Error error, const std::function&lt; void()&gt;, const ErrorLevel)&gt; HandlerFunction","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#functions","text":"Name     std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, Error value)Convenience stream operator to easily use the Error enum with std::ostream.   void errorHandler(const Error error, const std::function&lt; void()&gt; &amp; errorCallBack =std::function&lt; void()&gt;(), const ErrorLevel level =ErrorLevel::FATAL)Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright!","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#detailed-description","text":"<p>building block to easily create free function for logging in a library context </p> <pre><code>// add this to e.g. foo_logging.hpp\n// the logger can then be used with e.g. foo::LogInfo() of just LogInfo() in the same namespace\n\n#ifndef FOO_LOGGING_HPP_INCLUDED\n#define FOO_LOGGING_HPP_INCLUDED\n\n#include \"iceoryx_hoofs/log/logging_free_function_building_block.hpp\"\n\nnamespace foo\n{\n    struct LoggingComponent\n    {\n        static constexpr char Ctx[] = \"FOO\";\n        static constexpr char Description[] = \"Log context of the FOO component!\";\n    };\n\n    static constexpr auto LogFatal = iox::log::ffbb::LogFatal&lt;LoggingComponent&gt;;\n    static constexpr auto LogError = iox::log::ffbb::LogError&lt;LoggingComponent&gt;;\n    static constexpr auto LogWarn = iox::log::ffbb::LogWarn&lt;LoggingComponent&gt;;\n    static constexpr auto LogInfo = iox::log::ffbb::LogInfo&lt;LoggingComponent&gt;;\n    static constexpr auto LogDebug = iox::log::ffbb::LogDebug&lt;LoggingComponent&gt;;\n    static constexpr auto LogVerbose = iox::log::ffbb::LogVerbose&lt;LoggingComponent&gt;;\n} // namespace foo\n#endif // FOO_LOGGING_HPP_INCLUDED\n\n\n// this needs to be in foo_logging.cpp\n\nnamespace foo\n{\n    constexpr char ComponentPosh::Ctx[];\n    constexpr char ComponentPosh::Description[];\n\n} // namespace foo\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#enum-error","text":"Enumerator Value Description","title":"enum Error"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#enum-errorlevel","text":"Enumerator Value Description     FATAL  Log error entry + Assert + terminate.   SEVERE  warning log entry + Assert   MODERATE  warning log entry    <p>the available error levels FATAL </p> <ul> <li>Log message with FATAL</li> <li>RouDi cannot recover from that error. RouDi is terminated</li> <li>Assert (in DEBUG) and terminate</li> <li>Reporting code must handle this and continue or go to a save state. Error handler could return (e.g. in test) SEVERE</li> <li>Log message with ERROR</li> <li>RouDi can still run. Error is reported</li> <li>Assert in DEBUG, in RELEASE continue to run</li> <li>Reporting code must handle this and continue MODERATE</li> <li>Log message with ERROR</li> <li>RouDi can still run. Error is reported</li> <li>NO assert</li> <li>Reporting code must handle this and continue </li> </ul>","title":"enum ErrorLevel"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#using-handlerfunction","text":"<pre><code>using iox::HandlerFunction = typedef std::function&lt;void(const Error error, const std::function&lt;void()&gt;, const ErrorLevel)&gt;;\n</code></pre>","title":"using HandlerFunction"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#function-operator","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n    Error value\n)\n</code></pre> <p>Convenience stream operator to easily use the Error enum with std::ostream. </p> <p>Parameters: </p> <ul> <li>stream sink to write the message to </li> <li>value to convert to a string literal </li> </ul> <p>Return: the reference to <code>stream</code> which was provided as input parameter </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#function-errorhandler","text":"<pre><code>void errorHandler(\n    const Error error,\n    const std::function&lt; void()&gt; &amp; errorCallBack =std::function&lt; void()&gt;(),\n    const ErrorLevel level =ErrorLevel::FATAL\n)\n</code></pre> <p>Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! </p> <p>2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout &lt;&lt; \"MyCustomCallback\" &lt;&lt; std::endl; }, ErrorLevel::MODERATE );</p> <pre><code>class PrettyClass {\n    float division(float a, float b) {\n        if ( b == 0.0f ) {\n            errorHandler(Error::kPRETTY_CLASS__DIVISION_BY_ZERO);\n        }\n    }\n};\n</code></pre> <pre><code>bool called = false;\nauto temporaryErrorHandler = ErrorHandler::setTemporaryErrorHandler(\n    [&amp;](const Error e, std::function&lt;void()&gt;, const ErrorLevel) {\n        called = true;\n    });\n\nerrorHandler(Error::kTEST__ASSERT_CALLED);\nASSERT_TRUE(called);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function errorHandler"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/","text":"","title":"iox::algorithm"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#functions","text":"Name     template &lt;typename T &gt; constexpr T max(const T &amp; left)Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint.   template &lt;typename T &gt; constexpr T max(const T &amp; left, const T &amp; right)Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one.   template &lt;typename T ,typename... Targs&gt; constexpr T max(const T &amp; left, const T &amp; right, const Targs &amp;... args)Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type.   template &lt;typename T &gt; constexpr T min(const T &amp; left)Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint.   template &lt;typename T &gt; constexpr T min(const T &amp; left, const T &amp; right)Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one.   template &lt;typename T ,typename... Targs&gt; constexpr T min(const T &amp; left, const T &amp; right, const Targs &amp;... args)Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type.   template &lt;typename T ,typename CompareType &gt; constexpr bool doesContainType()Returns true if T is equal to CompareType, otherwise false.   template &lt;typename T ,typename CompareType ,typename Next ,typename... Remainder&gt; constexpr bool doesContainType()Returns true if T is contained the provided type list.   template &lt;typename T &gt; constexpr bool doesContainValue(const T)Finalizes the recursion of doesContainValue.   template &lt;typename T ,typename... ValueList&gt; constexpr bool doesContainValue(const T value, const T firstValueListEntry, const ValueList... remainingValueListEntries)Returns true if value of T is found in the ValueList, otherwise false.   template &lt;typename Container &gt; Container uniqueMergeSortedContainers(const Container &amp; v1, const Container &amp; v2)Merging two sorted containers so that the result is a sorted container where every element is contained only once.","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max","text":"<pre><code>template &lt;typename T &gt;\nconstexpr T max(\n    const T &amp; left\n)\n</code></pre> <p>Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> </ul> <p>Return: returns the given argument left </p>","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max_1","text":"<pre><code>template &lt;typename T &gt;\nconstexpr T max(\n    const T &amp; left,\n    const T &amp; right\n)\n</code></pre> <p>Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> <li>right value which should be compared </li> </ul> <p>Return: returns the maximum value of the set {left, right} </p>","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max_2","text":"<pre><code>template &lt;typename T ,\ntypename... Targs&gt;\nconstexpr T max(\n    const T &amp; left,\n    const T &amp; right,\n    const Targs &amp;... args\n)\n</code></pre> <p>Returns the maximum gained with operator&lt;() of an arbitrary amount of variables of the same type. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> <li>right value which should be compared </li> <li>args... an arbitrary amount of values </li> </ul> <p>Return: returns the maximum value of the set {left, right, args...} </p>","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min","text":"<pre><code>template &lt;typename T &gt;\nconstexpr T min(\n    const T &amp; left\n)\n</code></pre> <p>Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> </ul> <p>Return: returns the given argument left </p>","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min_1","text":"<pre><code>template &lt;typename T &gt;\nconstexpr T min(\n    const T &amp; left,\n    const T &amp; right\n)\n</code></pre> <p>Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> <li>right value which should be compared </li> </ul> <p>Return: returns the minimum of the set {left, right} </p>","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min_2","text":"<pre><code>template &lt;typename T ,\ntypename... Targs&gt;\nconstexpr T min(\n    const T &amp; left,\n    const T &amp; right,\n    const Targs &amp;... args\n)\n</code></pre> <p>Returns the minimum gained with operator&lt;() of an arbitrary amount of variables of the same type. </p> <p>Parameters: </p> <ul> <li>T type which implements operator&lt;() </li> <li>left value which should be compared </li> <li>right value which should be compared </li> <li>args... an arbitrary amount of values </li> </ul> <p>Return: returns the minimum of the set {left, right, args...} </p>","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontaintype","text":"<pre><code>template &lt;typename T ,\ntypename CompareType &gt;\nconstexpr bool doesContainType()\n</code></pre> <p>Returns true if T is equal to CompareType, otherwise false. </p> <p>Parameters: </p> <ul> <li>T type to compare to </li> <li>CompareType the type to which T is compared </li> </ul> <p>Return: true if the types T and CompareType are equal, otherwise false </p>","title":"function doesContainType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontaintype_1","text":"<pre><code>template &lt;typename T ,\ntypename CompareType ,\ntypename Next ,\ntypename... Remainder&gt;\nconstexpr bool doesContainType()\n</code></pre> <p>Returns true if T is contained the provided type list. </p> <p>Parameters: </p> <ul> <li>T type to compare to </li> <li>CompareTypeNextRemainder the type list in which T should be contained </li> </ul> <p>Return: true if the T is contained in the type list, otherwise false </p>","title":"function doesContainType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontainvalue","text":"<pre><code>template &lt;typename T &gt;\ninline constexpr bool doesContainValue(\n    const T\n)\n</code></pre> <p>Finalizes the recursion of doesContainValue. </p> <p>Parameters: </p> <ul> <li>T type of the value to check </li> </ul> <p>Return: always false </p>","title":"function doesContainValue"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontainvalue_1","text":"<pre><code>template &lt;typename T ,\ntypename... ValueList&gt;\ninline constexpr bool doesContainValue(\n    const T value,\n    const T firstValueListEntry,\n    const ValueList... remainingValueListEntries\n)\n</code></pre> <p>Returns true if value of T is found in the ValueList, otherwise false. </p> <p>Parameters: </p> <ul> <li>value to look for in the ValueList </li> <li>firstValueListEntry is the first variadic argument of ValueList </li> <li>remainingValueListEntries are the remaining variadic arguments of ValueList </li> </ul> <p>Template Parameters: </p> <ul> <li>T type of the value to check </li> <li>ValueList is a list of values to check for a specific value </li> </ul>","title":"function doesContainValue"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-uniquemergesortedcontainers","text":"<pre><code>template &lt;typename Container &gt;\nContainer uniqueMergeSortedContainers(\n    const Container &amp; v1,\n    const Container &amp; v2\n)\n</code></pre> <p>Merging two sorted containers so that the result is a sorted container where every element is contained only once. </p> <p>Parameters: </p> <ul> <li>v1 the first sorted input container </li> <li>v2 the second sorted input container </li> </ul> <p>Template Parameters: </p> <ul> <li>Container container type which has to support emplace_back() and size() </li> </ul> <p>Return: sorted container which contains the elements of v1 and v2 and where every element is unique </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function uniqueMergeSortedContainers"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1concurrent/","text":"","title":"iox::concurrent"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1concurrent/#classes","text":"Name     class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity   class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread).     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/","text":"","title":"iox::cxx"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#namespaces","text":"Name     iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#classes","text":"Name     class iox::cxx::convert Collection of static methods for conversion from and to string.   class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off.   struct iox::cxx::success helper struct to create an expected which is signalling success more easily   struct iox::cxx::success&lt; void &gt; helper struct to create an error only expected which is signalling success more easily   struct iox::cxx::error helper struct to create an expected which is signalling an error more easily   class iox::cxx::expected&lt; ErrorType &gt; expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception.   class iox::cxx::expected&lt; ValueType, ErrorType &gt; specialization of the expected class which can contain an error as well as a success value   class iox::cxx::expected&lt; void, ErrorType &gt;   class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation.   class iox::cxx::function_ref   class iox::cxx::function_ref&lt; ReturnType(ArgTypes...)&gt; cxx::function_ref is a non-owning reference to a callable.   class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources.   class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap.   struct iox::cxx::not_null   struct iox::cxx::greater_or_equal   struct iox::cxx::range   struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time   class iox::cxx::list C++11 compatible bi-directional list implementation.   class iox::cxx::ConstMethodCallback   class iox::cxx::MethodCallback   class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods.   struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value.   struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor   class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail.   class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor.   class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation.   class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01.   class iox::cxx::stack stack implementation with a simple push pop interface   struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior   struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier.   struct iox::cxx::add_const_conditionally&lt; T, const C &gt;   struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments.   struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType.   struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature.   struct iox::cxx::is_function_pointer&lt; ReturnType(*)(ArgTypes...)&gt;   class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL.   struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant   struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant   class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions.   class iox::cxx::VariantQueue wrapper of multiple fifo's   class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#types","text":"Name     enum uint64_t perms { none = 0, owner_read = 0400, owner_write = 0200, owner_exec = 0100, owner_all = 0700, group_read = 040, group_write = 020, group_exec = 010, group_all = 070, others_read = 04, others_write = 02, others_exec = 01, others_all = 07, all = 0777, set_uid = 04000, set_gid = 02000, sticky_bit = 01000, mask = 07777, unknown = 0xFFFF}this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>, <code>|=</code>, <code>&amp;=</code> and <code>^=</code> are implemented as free functions as C++17 requires it.   enum MethodCallbackError   enum uint64_t VariantQueueTypes { FiFo_SingleProducerSingleConsumer = 0, SoFi_SingleProducerSingleConsumer = 1, FiFo_MultiProducerSingleConsumer = 2, SoFi_MultiProducerSingleConsumer = 3}list of the supported underlying queue types   template &lt;typename Signature ,uint64_t Capacity =128U&gt; using storable_function&lt; static_storage&lt; Capacity &gt;, Signature &gt; function A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable.   template &lt;typename Derived ,typename ValueType ,typename ErrorType &gt; using internal::FunctionalInterfaceImpl&lt; Derived, ValueType, ErrorType &gt; FunctionalInterface Provides a functional interface for types which have a bool conversion operator. This provides the methods.   template &lt;uint64_t Value&gt; using typename BestFittingType&lt; Value &gt;::Type_t BestFittingType_t   template &lt;typename T ,typename C &gt; using typename add_const_conditionally&lt; T, C &gt;::type add_const_conditionally_t Helper type for add_const_conditionally which adds const to type T if C has the const qualifier.   template &lt;typename C ,typename... Cargs&gt; using std::result_of&lt; C(Cargs...)&gt; invoke_result   template &lt;typename... &gt; using void void_t Maps a sequence of any types to the type void.   using uint8_t byte_t","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#functions","text":"Name     perms **[operator   perms operator&amp;(const perms &amp; lhs, const perms &amp; rhs)Implements the binary and operation.   perms operator^(const perms &amp; lhs, const perms &amp; rhs)Implements the binary exclusive or operation.   perms operator~(const perms &amp; value)Implements the binary complement operation.   perms **[operator   perms operator&amp;=(perms &amp; lhs, const perms &amp; rhs)Implements the binary and assignment operation.   perms operator^=(perms &amp; lhs, const perms &amp; rhs)Implements the binary exclusive or assignment operation.   template &lt;typename StreamType &gt; StreamType &amp; operator&lt;&lt;(StreamType &amp; stream, perms value)The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits.   template &lt;typename T &gt; T align(const T value, const T alignment)   void * alignedAlloc(const uint64_t alignment, const uint64_t size)allocates aligned memory which can only be free'd by alignedFree   void alignedFree(void *const memory)frees aligned memory allocated with alignedAlloc   template &lt;size_t s =0&gt; constexpr size_t maxAlignment()template recursion stopper for maximum alignment calculation   template &lt;typename T ,typename... Args&gt; constexpr size_t maxAlignment()calculate maximum alignment of supplied types   template &lt;size_t s =0&gt; constexpr size_t maxSize()template recursion stopper for maximum size calculation   template &lt;typename T ,typename... Args&gt; constexpr size_t maxSize()calculate maximum size of supplied types   template &lt;typename T ,typename Enumeration &gt; const char * convertEnumToString(T port, const Enumeration source)Convert Enum class type to string.   template &lt;typename enum_type &gt; auto enumTypeAsUnderlyingType(enum_type const value)cast an enum to its underlying type   template &lt;typename Container ,typename Functor &gt; void forEach(Container &amp; c, const Functor &amp; f)   template &lt;uint64_t SizeValue&gt; constexpr uint64_t strlen2(char  const(&amp;)[SizeValue])Get the size of a string represented by a char array at compile time.   constexpr bool isCompiledOn32BitSystem()Returns info whether called on a 32-bit system.   template &lt;typename T &gt; constexpr bool isPowerOfTwo(const T n)Checks if an unsigned integer is a power of two.   template &lt;uint64_t StringCapacity&gt; bool isValidFileName(const string&lt; StringCapacity &gt; &amp; name)checks if the given string is a valid filename   template &lt;uint64_t StringCapacity&gt; bool isValidFilePath(const string&lt; StringCapacity &gt; &amp; name)verifies if the given string is a valid path to a file   template &lt;typename F ,typename T &gt; constexpr T from(const F value)Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted.   template &lt;typename T ,typename F &gt; constexpr T into(const F value)Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when <code>from</code> is implemented. This function shall therefore not be specialized but always the <code>from</code> function.   template &lt;typename OptionalBaseType ,typename... Targs&gt; optional&lt; OptionalBaseType &gt; make_optional(Targs &amp;&amp;... args)Creates an optional which contains a value by forwarding the arguments to the constructor of T.   template &lt;typename T ,typename... CTorArgs&gt; GenericRAII makeScopedStatic(T &amp; memory, CTorArgs &amp;&amp;... ctorArgs)   template &lt;typename T1 ,typename T2 &gt; std::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value    template &lt;typename T1 ,typename T2 ,typename... Targs&gt; std::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value    template &lt;typename T1 ,typename T2 &gt; std::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value &amp;&amp;internal::IsCxxString&lt; T2 &gt;::value)    template &lt;uint64_t Capacity&gt; bool operator==(const std::string &amp; lhs, const string&lt; Capacity &gt; &amp; rhs)checks if a rhs fixed string is equal to a lhs std::string   template &lt;uint64_t Capacity&gt; bool operator==(const string&lt; Capacity &gt; &amp; lhs, const std::string &amp; rhs)checks if a rhs std::string is equal to a lhs fixed string   template &lt;uint64_t Capacity&gt; bool operator!=(const std::string &amp; lhs, const string&lt; Capacity &gt; &amp; rhs)checks if a rhs fixed string is not equal to a lhs std::string   template &lt;uint64_t Capacity&gt; bool operator!=(const string&lt; Capacity &gt; &amp; lhs, const std::string &amp; rhs)checks if a rhs std::string is not equal to a lhs fixed string   template &lt;uint64_t Capacity&gt; bool operator==(const char const lhs, const string&lt; Capacity &gt; &amp; rhs)The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string.   template &lt;uint64_t Capacity&gt; bool operator!=(const char const lhs, const string&lt; Capacity &gt; &amp; rhs)The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string.   template &lt;uint64_t Capacity&gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const string&lt; Capacity &gt; &amp; str)outputs the fixed string on stream   template &lt;typename T ,typename... Types&gt; constexpr bool holds_alternative(const variant&lt; Types... &gt; &amp; variant)returns true if the variant holds a given type T, otherwise false","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#attributes","text":"Name     class IOX_NO_DISCARD expected   constexpr nullopt_t nullopt   constexpr in_place_t in_place   constexpr TruncateToCapacity_t TruncateToCapacity   constexpr bool always_false_v Helper value to bind a static_assert to a type.   constexpr uint64_t INVALID_VARIANT_INDEX value which an invalid variant index occupies","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-perms","text":"Enumerator Value Description     none 0 Deny everything.   owner_read 0400 owner has read permission   owner_write 0200 owner has write permission   owner_exec 0100 owner has execution permission   owner_all 0700 owner has all permissions   group_read 040 group has read permission   group_write 020 group has write permission   group_exec 010 group has execution permission   group_all 070 group has all permissions   others_read 04 others have read permission   others_write 02 others have write permission   others_exec 01 others have execution permission   others_all 07 others have all permissions   all 0777 all permissions for everyone   set_uid 04000 set uid bit   set_gid 02000 set gid bit   sticky_bit 01000 set sticky bit   mask 07777 all permissions for everyone as well as uid, gid and sticky bit   unknown 0xFFFF unknown permissions    <p>this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>, <code>|=</code>, <code>&amp;=</code> and <code>^=</code> are implemented as free functions as C++17 requires it. </p>","title":"enum perms"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-methodcallbackerror","text":"Enumerator Value Description     UNINITIALIZED_CALLBACK","title":"enum MethodCallbackError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-variantqueuetypes","text":"Enumerator Value Description     FiFo_SingleProducerSingleConsumer 0    SoFi_SingleProducerSingleConsumer 1    FiFo_MultiProducerSingleConsumer 2    SoFi_MultiProducerSingleConsumer 3     <p>list of the supported underlying queue types </p> <p>Note: if a new queue type is added the following steps have to be performed:</p> <ol> <li>add queue type here</li> <li>add queue type in m_fifo data member variant type</li> <li>increase numberOfQueueTypes in test_cxx_variant_queue test </li> </ol>","title":"enum VariantQueueTypes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-function","text":"<pre><code>template &lt;typename Signature ,\nuint64_t Capacity =128U&gt;\nusing iox::cxx::function = typedef storable_function&lt;static_storage&lt;Capacity&gt;, Signature&gt;;\n</code></pre> <p>A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable. </p> <p>Template Parameters: </p> <ul> <li>Signature The signature of the callable to be stored, e.g. int (char, void*). </li> <li>Capacity The static storage capacity available to store a callable in bytes.</li> </ul> <p>Note: If the static storage is insufficient to store the callable we get a compile time error. </p> <p>Similarly to std::function, they cannot be stored in Shared Memory to be invoked in a different process.</p> <p>For the API see storable_function.</p>","title":"using function"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-functionalinterface","text":"<pre><code>template &lt;typename Derived ,\ntypename ValueType ,\ntypename ErrorType &gt;\nusing iox::cxx::FunctionalInterface = typedef internal::FunctionalInterfaceImpl&lt;Derived, ValueType, ErrorType&gt;;\n</code></pre> <p>Provides a functional interface for types which have a bool conversion operator. This provides the methods. </p> <p>Note: When inheriting from this type one does not have to write additional unit tests. Instead add a factory for your class to <code>test_cxx_functional_interface_types.hpp</code>, add the type to the FunctionalInterfaceImplementations and all typed tests will be generated. </p> <ul> <li>and_then</li> <li>or_else</li> <li>expect When the class has a value method the method</li> <li>value_or is added and and_then provides a reference in the callback to the underlying value. When the class has a get_error method the or_else method has a parameter to access a reference to the underlying error.</li> </ul>","title":"using FunctionalInterface"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-bestfittingtype_t","text":"<pre><code>template &lt;uint64_t Value&gt;\nusing iox::cxx::BestFittingType_t = typedef typename BestFittingType&lt;Value&gt;::Type_t;\n</code></pre>","title":"using BestFittingType_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-add_const_conditionally_t","text":"<pre><code>template &lt;typename T ,\ntypename C &gt;\nusing iox::cxx::add_const_conditionally_t = typedef typename add_const_conditionally&lt;T, C&gt;::type;\n</code></pre> <p>Helper type for add_const_conditionally which adds const to type T if C has the const qualifier. </p>","title":"using add_const_conditionally_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-invoke_result","text":"<pre><code>template &lt;typename C ,\ntypename... Cargs&gt;\nusing iox::cxx::invoke_result = typedef std::result_of&lt;C(Cargs...)&gt;;\n</code></pre>","title":"using invoke_result"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-void_t","text":"<pre><code>template &lt;typename... &gt;\nusing iox::cxx::void_t = typedef void;\n</code></pre> <p>Maps a sequence of any types to the type void. </p>","title":"using void_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-byte_t","text":"<pre><code>using iox::cxx::byte_t = typedef uint8_t;\n</code></pre>","title":"using byte_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator","text":"<pre><code>perms operator|(\n    const perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary or operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs | rhs </p>","title":"function operator|"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_1","text":"<pre><code>perms operator&amp;(\n    const perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary and operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs &amp; rhs </p>","title":"function operator&amp;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_2","text":"<pre><code>perms operator^(\n    const perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary exclusive or operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs ^ rhs </p>","title":"function operator^"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_3","text":"<pre><code>perms operator~(\n    const perms &amp; value\n)\n</code></pre> <p>Implements the binary complement operation. </p> <p>Parameters: </p> <ul> <li>value the value used for the operation </li> </ul> <p>Return: ~value </p>","title":"function operator~"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_4","text":"<pre><code>perms operator|=(\n    perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary or assignment operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs = lhs | rhs </p>","title":"function operator|="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_5","text":"<pre><code>perms operator&amp;=(\n    perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary and assignment operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs = lhs &amp; rhs </p>","title":"function operator&amp;="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_6","text":"<pre><code>perms operator^=(\n    perms &amp; lhs,\n    const perms &amp; rhs\n)\n</code></pre> <p>Implements the binary exclusive or assignment operation. </p> <p>Parameters: </p> <ul> <li>lhs left hand side of the operation </li> <li>rhs right hand side of the operation </li> </ul> <p>Return: lhs = lhs ^ rhs </p>","title":"function operator^="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_7","text":"<pre><code>template &lt;typename StreamType &gt;\nStreamType &amp; operator&lt;&lt;(\n    StreamType &amp; stream,\n    perms value\n)\n</code></pre> <p>The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits. </p> <p>Parameters: </p> <ul> <li>stream reference to the stream </li> <li>value the file permission </li> </ul> <p>Return: the reference to the stream </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-align","text":"<pre><code>template &lt;typename T &gt;\nT align(\n    const T value,\n    const T alignment\n)\n</code></pre>","title":"function align"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-alignedalloc","text":"<pre><code>void * alignedAlloc(\n    const uint64_t alignment,\n    const uint64_t size\n)\n</code></pre> <p>allocates aligned memory which can only be free'd by alignedFree </p> <p>Parameters: </p> <ul> <li>alignmentalignment of the memory </li> <li>sizememory size </li> </ul> <p>Return: void pointer to the aligned memory </p>","title":"function alignedAlloc"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-alignedfree","text":"<pre><code>void alignedFree(\n    void *const memory\n)\n</code></pre> <p>frees aligned memory allocated with alignedAlloc </p> <p>Parameters: </p> <ul> <li>memorypointer to the aligned memory </li> </ul>","title":"function alignedFree"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxalignment","text":"<pre><code>template &lt;size_t s =0&gt;\nconstexpr size_t maxAlignment()\n</code></pre> <p>template recursion stopper for maximum alignment calculation </p>","title":"function maxAlignment"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxalignment_1","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\nconstexpr size_t maxAlignment()\n</code></pre> <p>calculate maximum alignment of supplied types </p>","title":"function maxAlignment"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxsize","text":"<pre><code>template &lt;size_t s =0&gt;\nconstexpr size_t maxSize()\n</code></pre> <p>template recursion stopper for maximum size calculation </p>","title":"function maxSize"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxsize_1","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\nconstexpr size_t maxSize()\n</code></pre> <p>calculate maximum size of supplied types </p>","title":"function maxSize"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-convertenumtostring","text":"<pre><code>template &lt;typename T ,\ntypename Enumeration &gt;\nconst char * convertEnumToString(\n    T port,\n    const Enumeration source\n)\n</code></pre> <p>Convert Enum class type to string. </p>","title":"function convertEnumToString"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-enumtypeasunderlyingtype","text":"<pre><code>template &lt;typename enum_type &gt;\nauto enumTypeAsUnderlyingType(\n    enum_type const value\n)\n</code></pre> <p>cast an enum to its underlying type </p>","title":"function enumTypeAsUnderlyingType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-foreach","text":"<pre><code>template &lt;typename Container ,\ntypename Functor &gt;\nvoid forEach(\n    Container &amp; c,\n    const Functor &amp; f\n)\n</code></pre> <p>Template Parameters: </p>  <p>calls a given functor for every element in a given container </p>","title":"function forEach"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-strlen2","text":"<pre><code>template &lt;uint64_t SizeValue&gt;\nstatic constexpr uint64_t strlen2(\n    char  const(&amp;)[SizeValue]\n)\n</code></pre> <p>Get the size of a string represented by a char array at compile time. </p> <p>Parameters: </p> <ul> <li>The actual content of the char array is not of interest. Its just the size of the array that matters. </li> </ul> <p>Template Parameters: </p> <ul> <li>The size of the char array filled out by the compiler. </li> </ul> <p>Return: Returns the size of a char array at compile time. </p>","title":"function strlen2"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-iscompiledon32bitsystem","text":"<pre><code>constexpr bool isCompiledOn32BitSystem()\n</code></pre> <p>Returns info whether called on a 32-bit system. </p> <p>Return: True if called on 32-bit, false if not 32-bit system </p>","title":"function isCompiledOn32BitSystem"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-ispoweroftwo","text":"<pre><code>template &lt;typename T &gt;\nconstexpr bool isPowerOfTwo(\n    const T n\n)\n</code></pre> <p>Checks if an unsigned integer is a power of two. </p> <p>Return: true if power of two, otherwise false </p>","title":"function isPowerOfTwo"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-isvalidfilename","text":"<pre><code>template &lt;uint64_t StringCapacity&gt;\nbool isValidFileName(\n    const string&lt; StringCapacity &gt; &amp; name\n)\n</code></pre> <p>checks if the given string is a valid filename </p> <p>Return: true if the string is a filename, otherwise false </p>","title":"function isValidFileName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-isvalidfilepath","text":"<pre><code>template &lt;uint64_t StringCapacity&gt;\nbool isValidFilePath(\n    const string&lt; StringCapacity &gt; &amp; name\n)\n</code></pre> <p>verifies if the given string is a valid path to a file </p> <p>Return: true if the string is a path to a file, otherwise false </p>","title":"function isValidFilePath"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-from","text":"<pre><code>template &lt;typename F ,\ntypename T &gt;\nconstexpr T from(\n    const F value\n)\n</code></pre> <p>Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted. </p> <p>Parameters: </p> <ul> <li>value of type F to convert to T </li> </ul> <p>Template Parameters: </p> <ul> <li>F is the 'from' type </li> <li>T is the 'to' type </li> </ul> <p>Return: converted value of F to corresponding value of T </p> <pre><code>enum class LowLevel\n{\n    FileDescriptorInvalid,\n    FileDescriptorCorrupt,\n    Timeout\n};\n\nenum class HighLevel\n{\n    FileDescriptorError,\n    Timeout\n};\n\nnamespace iox\n{\nnamespace cxx\n{\ntemplate &lt;&gt;\nconstexpr HighLevel from&lt;LowLevel, HighLevel&gt;(LowLevel e) noexcept\n{\n    switch (e)\n    {\n    case LowLevel::FileDescriptorCorrupt:\n        return HighLevel::FileDescriptorError;\n    case LowLevel::FileDescriptorInvalid:\n        return HighLevel::FileDescriptorError;\n    case LowLevel::Timeout:\n        return HighLevel::Timeout;\n    }\n}\n} // namespace cxx\n} // namespace iox\n</code></pre>","title":"function from"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-into","text":"<pre><code>template &lt;typename T ,\ntypename F &gt;\nconstexpr T into(\n    const F value\n)\n</code></pre> <p>Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when <code>from</code> is implemented. This function shall therefore not be specialized but always the <code>from</code> function. </p> <p>Parameters: </p> <ul> <li>value of type F to convert to T </li> </ul> <p>Template Parameters: </p> <ul> <li>T is the 'to' type </li> <li>F is the 'from' type </li> </ul> <p>Return: converted value of F to corresponding value of T </p> <pre><code>Bar b = iox::cxx::into&lt;Bar&gt;(Foo::ENUM_VALUE);\n</code></pre>","title":"function into"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-make_optional","text":"<pre><code>template &lt;typename OptionalBaseType ,\ntypename... Targs&gt;\noptional&lt; OptionalBaseType &gt; make_optional(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>Creates an optional which contains a value by forwarding the arguments to the constructor of T. </p> <p>Parameters: </p> <ul> <li>args arguments which will be perfectly forwarded to the constructor of T </li> </ul> <p>Return: optional which contains T constructed with args </p>","title":"function make_optional"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-makescopedstatic","text":"<pre><code>template &lt;typename T ,\ntypename... CTorArgs&gt;\nGenericRAII makeScopedStatic(\n    T &amp; memory,\n    CTorArgs &amp;&amp;... ctorArgs\n)\n</code></pre> <p>Parameters: </p> <ul> <li>memory is a reference to a memory container, e.g. cxx::optional</li> <li>ctorArgs ctor arguments for the object to construct </li> </ul> <p>Template Parameters: </p> <ul> <li>[in] T memory container which has emplace(...) and reset </li> <li>[in] CTorArgs ctor types for the object to construct </li> </ul> <p>Return: cxx::GenericRAII</p> <p>Todo: better name create a GenericRAII object to cleanup a static optional object at the end of the scope </p>","title":"function makeScopedStatic"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-concatenate","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 &gt;\nstd::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value||internal::IsCxxString&lt; T1 &gt;::value) &amp;&amp;(internal::IsCharArray&lt; T2 &gt;::value||internal::IsCxxString&lt; T2 &gt;::value), string&lt; internal::GetCapa&lt; T1 &gt;::capa+internal::GetCapa&lt; T2 &gt;::capa &gt; &gt;::type concatenate(\n    const T1 &amp; t1,\n    const T2 &amp; t2\n)\n</code></pre> <p>concatenates two fixed strings/string literals </p> <p>Parameters: </p> <ul> <li>fixed strings/string literals to concatenate</li> </ul> <p>Return: a new fixed string with capacity equal to the sum of the capacities of the concatenated strings</p> <pre><code>string&lt;5&gt; fuu(\"cdefg\");\nauto bar = iox::cxx::concatenate(fuu, \"ahc\");\n</code></pre>","title":"function concatenate"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-concatenate_1","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\ntypename... Targs&gt;\nstd::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value||internal::IsCxxString&lt; T1 &gt;::value) &amp;&amp;(internal::IsCharArray&lt; T2 &gt;::value||internal::IsCxxString&lt; T2 &gt;::value), string&lt; internal::SumCapa&lt; T1, T2, Targs... &gt;::value &gt; &gt;::type concatenate(\n    const T1 &amp; t1,\n    const T2 &amp; t2,\n    const Targs &amp;... targs\n)\n</code></pre> <p>concatenates an arbitrary number of fixed strings or string literals </p> <p>Parameters: </p> <ul> <li>fixed strings/string literals to concatenate</li> </ul> <p>Return: a new fixed string with capacity equal to the sum of the capacities of the concatenated strings</p> <pre><code>string&lt;4&gt; fuu(\"cdef\");\nauto bar = iox::cxx::concatenate(fuu, \"g\", \"ah\", fuu);\n</code></pre>","title":"function concatenate"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_8","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 &gt;\nstd::enable_if&lt;(internal::IsCharArray&lt; T1 &gt;::value &amp;&amp;internal::IsCxxString&lt; T2 &gt;::value)||(internal::IsCxxString&lt; T1 &gt;::value &amp;&amp;internal::IsCharArray&lt; T2 &gt;::value)||(internal::IsCxxString&lt; T1 &gt;::value &amp;&amp;internal::IsCxxString&lt; T2 &gt;::value), string&lt; internal::GetCapa&lt; T1 &gt;::capa+internal::GetCapa&lt; T2 &gt;::capa &gt; &gt;::type operator+(\n    const T1 &amp; t1,\n    const T2 &amp; t2\n)\n</code></pre> <p>concatenates two fixed strings or one fixed fixed string and one string literal; concatenation of two string literals is not possible </p> <p>Parameters: </p> <ul> <li>fixed strings/string literal to concatenate</li> </ul> <p>Return: a new fixed string with capacity equal to the sum of the capacities of the concatenated strings </p>","title":"function operator+"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_9","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator==(\n    const std::string &amp; lhs,\n    const string&lt; Capacity &gt; &amp; rhs\n)\n</code></pre> <p>checks if a rhs fixed string is equal to a lhs std::string </p> <p>Parameters: </p> <ul> <li>lhs is the std::string </li> <li>rhs is the fixed string</li> </ul> <p>Return: true if both strings are equal, otherwise false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_10","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator==(\n    const string&lt; Capacity &gt; &amp; lhs,\n    const std::string &amp; rhs\n)\n</code></pre> <p>checks if a rhs std::string is equal to a lhs fixed string </p> <p>Parameters: </p> <ul> <li>lhs is the fixed string </li> <li>rhs is the std::string</li> </ul> <p>Return: true if both strings are equal, otherwise false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_11","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator!=(\n    const std::string &amp; lhs,\n    const string&lt; Capacity &gt; &amp; rhs\n)\n</code></pre> <p>checks if a rhs fixed string is not equal to a lhs std::string </p> <p>Parameters: </p> <ul> <li>lhs is the std::string </li> <li>rhs is the fixed string</li> </ul> <p>Return: true if both strings are not equal, otherwise false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_12","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator!=(\n    const string&lt; Capacity &gt; &amp; lhs,\n    const std::string &amp; rhs\n)\n</code></pre> <p>checks if a rhs std::string is not equal to a lhs fixed string </p> <p>Parameters: </p> <ul> <li>lhs is the fixed string </li> <li>rhs is the std::string</li> </ul> <p>Return: true if both strings are not equal, otherwise false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_13","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator==(\n    const char *const lhs,\n    const string&lt; Capacity &gt; &amp; rhs\n)\n</code></pre> <p>The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. </p> <p>Parameters: </p> <ul> <li>lhs is the char pointer to the array to compare </li> <li>rhs is the fixed string</li> </ul> <p>Return: false </p>","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_14","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline bool operator!=(\n    const char *const lhs,\n    const string&lt; Capacity &gt; &amp; rhs\n)\n</code></pre> <p>The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. </p> <p>Parameters: </p> <ul> <li>lhs is the char pointer to the array to compare </li> <li>rhs is the fixed string</li> </ul> <p>Return: false </p>","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_15","text":"<pre><code>template &lt;uint64_t Capacity&gt;\ninline std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n    const string&lt; Capacity &gt; &amp; str\n)\n</code></pre> <p>outputs the fixed string on stream </p> <p>Parameters: </p> <ul> <li>stream is the output stream </li> <li>str is the fixed string</li> </ul> <p>Return: the stream output of the fixed string </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-holds_alternative","text":"<pre><code>template &lt;typename T ,\ntypename... Types&gt;\nconstexpr bool holds_alternative(\n    const variant&lt; Types... &gt; &amp; variant\n)\n</code></pre> <p>returns true if the variant holds a given type T, otherwise false </p>","title":"function holds_alternative"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-expected","text":"<pre><code>class IOX_NO_DISCARD expected;\n</code></pre>","title":"variable expected"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-nullopt","text":"<pre><code>constexpr nullopt_t nullopt = [nullopt_t](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1cxx_1_1nullopt__t/)();\n</code></pre>","title":"variable nullopt"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-in_place","text":"<pre><code>constexpr in_place_t in_place {};\n</code></pre>","title":"variable in_place"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-truncatetocapacity","text":"<pre><code>constexpr TruncateToCapacity_t TruncateToCapacity {};\n</code></pre>","title":"variable TruncateToCapacity"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-always_false_v","text":"<pre><code>constexpr bool always_false_v = false;\n</code></pre> <p>Helper value to bind a static_assert to a type. </p> <pre><code>static_assert(always_false_v&lt;Foo&gt;, \"Not implemented for the given type!\");\n</code></pre>","title":"variable always_false_v"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-invalid_variant_index","text":"<pre><code>static constexpr uint64_t INVALID_VARIANT_INDEX = std::numeric_limits&lt;uint64_t&gt;::max();\n</code></pre> <p>value which an invalid variant index occupies </p> <pre><code>cxx::variant&lt;int, float&gt; someVariant;\n\n// every unset variant has an invalid variant in the beginning\nif ( someVariant.index() == INVALID_VARIANT_INDEX ) ...\n\ncxx::variant&lt;int, float&gt; someVariant2(cxx::in_place_type&lt;int&gt;, 12);\n\n// variant with setted value therefore the index is not invalid\nif ( someVariant.index() != INVALID_VARIANT_INDEX ) ...\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable INVALID_VARIANT_INDEX"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/","text":"","title":"iox::cxx::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#functions","text":"Name     void Require(const bool condition, const char * file, const int line, const char * function, const char * conditionString)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#attributes","text":"Name     constexpr char ASCII_A   constexpr char ASCII_Z   constexpr char ASCII_CAPITAL_A   constexpr char ASCII_CAPITAL_Z   constexpr char ASCII_0   constexpr char ASCII_9   constexpr char ASCII_MINUS   constexpr char ASCII_DOT   constexpr char ASCII_COLON   constexpr char ASCII_UNDERSCORE","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#function-require","text":"<pre><code>void Require(\n    const bool condition,\n    const char * file,\n    const int line,\n    const char * function,\n    const char * conditionString\n)\n</code></pre>","title":"function Require"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_a","text":"<pre><code>constexpr char ASCII_A = 'a';\n</code></pre>","title":"variable ASCII_A"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_z","text":"<pre><code>constexpr char ASCII_Z = 'z';\n</code></pre>","title":"variable ASCII_Z"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_capital_a","text":"<pre><code>constexpr char ASCII_CAPITAL_A = 'A';\n</code></pre>","title":"variable ASCII_CAPITAL_A"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_capital_z","text":"<pre><code>constexpr char ASCII_CAPITAL_Z = 'Z';\n</code></pre>","title":"variable ASCII_CAPITAL_Z"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_0","text":"<pre><code>constexpr char ASCII_0 = '0';\n</code></pre>","title":"variable ASCII_0"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_9","text":"<pre><code>constexpr char ASCII_9 = '9';\n</code></pre>","title":"variable ASCII_9"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_minus","text":"<pre><code>constexpr char ASCII_MINUS = '-';\n</code></pre>","title":"variable ASCII_MINUS"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_dot","text":"<pre><code>constexpr char ASCII_DOT = '.';\n</code></pre>","title":"variable ASCII_DOT"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_colon","text":"<pre><code>constexpr char ASCII_COLON = ':';\n</code></pre>","title":"variable ASCII_COLON"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_underscore","text":"<pre><code>constexpr char ASCII_UNDERSCORE = '_';\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable ASCII_UNDERSCORE"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/","text":"","title":"iox::log"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#namespaces","text":"Name     iox::log::ffbb","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#classes","text":"Name     struct iox::log::LogEntry   class iox::log::Logger   class iox::log::LogManager   struct iox::log::LogHex   struct iox::log::LogHex8   struct iox::log::LogHex16   struct iox::log::LogHex32   struct iox::log::LogHex64   struct iox::log::LogBin   struct iox::log::LogBin8   struct iox::log::LogBin16   struct iox::log::LogBin32   struct iox::log::LogBin64   struct iox::log::LogRawBuffer   class iox::log::LogStream","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#types","text":"Name     enum uint8_t LogLevel   enum uint8_t LogMode   enum uint8_t LogLevelOutput","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#functions","text":"Name     LogMode **[operator   LogMode &amp; **[operator   LogMode operator&amp;(LogMode lhs, LogMode rhs)   LogMode &amp; operator&amp;=(LogMode &amp; lhs, LogMode rhs)   Logger &amp; createLogger(const std::string &amp; ctxId, const std::string &amp; ctxDescription, const LogLevel appDefLogLevel =LogLevel::kWarn)   constexpr LogHex8 HexFormat(uint8_t value)   constexpr LogHex8 HexFormat(int8_t value)   constexpr LogHex16 HexFormat(uint16_t value)   constexpr LogHex16 HexFormat(int16_t value)   constexpr LogHex32 HexFormat(uint32_t value)   constexpr LogHex32 HexFormat(int32_t value)   constexpr LogHex64 HexFormat(uint64_t value)   constexpr LogHex64 HexFormat(int64_t value)   constexpr LogBin8 BinFormat(uint8_t value)   constexpr LogBin8 BinFormat(int8_t value)   constexpr LogBin16 BinFormat(uint16_t value)   constexpr LogBin16 BinFormat(int16_t value)   constexpr LogBin32 BinFormat(uint32_t value)   constexpr LogBin32 BinFormat(int32_t value)   constexpr LogBin64 BinFormat(uint64_t value)   constexpr LogBin64 BinFormat(int64_t value)   template &lt;typename T ,typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value, std::nullptr_t &gt;::type  =nullptr&gt; constexpr LogRawBuffer RawBuffer(const T &amp; value)   LogStream &amp; operator&lt;&lt;(LogStream &amp; out, LogLevel value)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#attributes","text":"Name     constexpr const char * LogLevelColor   constexpr const char * LogLevelText","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-loglevel","text":"Enumerator Value Description     kOff 0    kFatal     kError     kWarn     kInfo     kDebug     kVerbose","title":"enum LogLevel"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-logmode","text":"Enumerator Value Description     kRemote 0x01    kFile 0x02    kConsole 0x04","title":"enum LogMode"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-logleveloutput","text":"Enumerator Value Description     kDisplayLogLevel 0    kHideLogLevel","title":"enum LogLevelOutput"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator","text":"<pre><code>LogMode operator|(\n    LogMode lhs,\n    LogMode rhs\n)\n</code></pre>","title":"function operator|"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_1","text":"<pre><code>LogMode &amp; operator|=(\n    LogMode &amp; lhs,\n    LogMode rhs\n)\n</code></pre>","title":"function operator|="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_2","text":"<pre><code>LogMode operator&amp;(\n    LogMode lhs,\n    LogMode rhs\n)\n</code></pre>","title":"function operator&amp;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_3","text":"<pre><code>LogMode &amp; operator&amp;=(\n    LogMode &amp; lhs,\n    LogMode rhs\n)\n</code></pre>","title":"function operator&amp;="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-createlogger","text":"<pre><code>Logger &amp; createLogger(\n    const std::string &amp; ctxId,\n    const std::string &amp; ctxDescription,\n    const LogLevel appDefLogLevel =LogLevel::kWarn\n)\n</code></pre>","title":"function createLogger"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat","text":"<pre><code>inline constexpr LogHex8 HexFormat(\n    uint8_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_1","text":"<pre><code>inline constexpr LogHex8 HexFormat(\n    int8_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_2","text":"<pre><code>inline constexpr LogHex16 HexFormat(\n    uint16_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_3","text":"<pre><code>inline constexpr LogHex16 HexFormat(\n    int16_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_4","text":"<pre><code>inline constexpr LogHex32 HexFormat(\n    uint32_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_5","text":"<pre><code>inline constexpr LogHex32 HexFormat(\n    int32_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_6","text":"<pre><code>inline constexpr LogHex64 HexFormat(\n    uint64_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_7","text":"<pre><code>inline constexpr LogHex64 HexFormat(\n    int64_t value\n)\n</code></pre>","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat","text":"<pre><code>inline constexpr LogBin8 BinFormat(\n    uint8_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_1","text":"<pre><code>inline constexpr LogBin8 BinFormat(\n    int8_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_2","text":"<pre><code>inline constexpr LogBin16 BinFormat(\n    uint16_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_3","text":"<pre><code>inline constexpr LogBin16 BinFormat(\n    int16_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_4","text":"<pre><code>inline constexpr LogBin32 BinFormat(\n    uint32_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_5","text":"<pre><code>inline constexpr LogBin32 BinFormat(\n    int32_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_6","text":"<pre><code>inline constexpr LogBin64 BinFormat(\n    uint64_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_7","text":"<pre><code>inline constexpr LogBin64 BinFormat(\n    int64_t value\n)\n</code></pre>","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-rawbuffer","text":"<pre><code>template &lt;typename T ,\ntypename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value, std::nullptr_t &gt;::type  =nullptr&gt;\ninline constexpr LogRawBuffer RawBuffer(\n    const T &amp; value\n)\n</code></pre>","title":"function RawBuffer"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_4","text":"<pre><code>LogStream &amp; operator&lt;&lt;(\n    LogStream &amp; out,\n    LogLevel value\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#variable-loglevelcolor","text":"<pre><code>constexpr const char * LogLevelColor = {\n    \"\",                 \n    \"\\033[0;1;97;41m\",  \n    \"\\033[0;1;31;103m\", \n    \"\\033[0;1;93m\",     \n    \"\\033[0;1;92m\",     \n    \"\\033[0;1;96m\",     \n    \"\\033[0;1;36m\",     \n};\n</code></pre>","title":"variable LogLevelColor"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#variable-logleveltext","text":"<pre><code>constexpr const char * LogLevelText = {\n    \"[  Off  ]\", \n    \"[ Fatal ]\", \n    \"[ Error ]\", \n    \"[Warning]\", \n    \"[ Info  ]\", \n    \"[ Debug ]\", \n    \"[Verbose]\", \n};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable LogLevelText"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/","text":"","title":"iox::log::ffbb"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#functions","text":"Name     template &lt;typename T &gt; Logger &amp; ComponentLogger()   template &lt;typename T &gt; LogStream LogFatal()   template &lt;typename T &gt; LogStream LogError()   template &lt;typename T &gt; LogStream LogWarn()   template &lt;typename T &gt; LogStream LogInfo()   template &lt;typename T &gt; LogStream LogDebug()   template &lt;typename T &gt; LogStream LogVerbose()","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-componentlogger","text":"<pre><code>template &lt;typename T &gt;\nstatic Logger &amp; ComponentLogger()\n</code></pre>","title":"function ComponentLogger"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logfatal","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogFatal()\n</code></pre>","title":"function LogFatal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logerror","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogError()\n</code></pre>","title":"function LogError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logwarn","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogWarn()\n</code></pre>","title":"function LogWarn"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-loginfo","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogInfo()\n</code></pre>","title":"function LogInfo"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logdebug","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogDebug()\n</code></pre>","title":"function LogDebug"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logverbose","text":"<pre><code>template &lt;typename T &gt;\ninline LogStream LogVerbose()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function LogVerbose"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/","text":"","title":"iox::posix"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#namespaces","text":"Name     iox::posix::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#classes","text":"Name     class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page)   class iox::posix::NamedPipe   struct iox::posix::PosixRights   class iox::posix::PosixGroup   class iox::posix::PosixUser   class iox::posix::PosixCallBuilder   struct iox::posix::PosixCallResult result of a posix call   class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call   class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call   struct iox::posix::CreateUnnamedSingleProcessSemaphore_t   struct iox::posix::CreateUnnamedSharedMemorySemaphore_t   struct iox::posix::CreateNamedSemaphore_t   struct iox::posix::OpenNamedSemaphore_t   class iox::posix::Semaphore Posix semaphore C++ Wrapping class.   class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call.   class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred.   class iox::posix::Timer Interface for timers on POSIX operating systems.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#types","text":"Name     enum FileLockError   enum SemaphoreError   enum SemaphoreWaitState   enum int Signal { BUS = SIGBUS, INT = SIGINT, TERM = SIGTERM, HUP = SIGHUP, ABORT = SIGABRT}Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value.   enum TimerError   using void(*)(int) SignalHandlerCallback_t   using cxx::string&lt; MAX_THREAD_NAME_LENGTH &gt; ThreadName_t","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#functions","text":"Name     SignalGuard registerSignalHandler(const Signal signal, const SignalHandlerCallback_t callback)Register a callback for a specific posix signal (SIG***).   void waitForTerminationRequest()convenience function, calls SignalWatcher::getInstance().waitForSignal();   bool hasTerminationRequested()convenience function, calls SignalWatcher::getInstance().wasSignalTriggered();   void setThreadName(pthread_t thread, const ThreadName_t &amp; name)   ThreadName_t getThreadName(pthread_t thread)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#attributes","text":"Name     constexpr int MaxNumberOfGroups   constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE   constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS   constexpr int32_t POSIX_CALL_INVALID_ERRNO   constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore   constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore   constexpr CreateNamedSemaphore_t CreateNamedSemaphore   constexpr OpenNamedSemaphore_t OpenNamedSemaphore   constexpr uint64_t MAX_THREAD_NAME_LENGTH","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-filelockerror","text":"Enumerator Value Description     INVALID_FILE_NAME     LOCKED_BY_OTHER_PROCESS     ACCESS_DENIED     QUOTA_EXHAUSTED     INVALID_CHARACTERS_IN_FILE_NAME     SYSTEM_LIMIT     PROCESS_LIMIT     NO_SUCH_DIRECTORY     SPECIAL_FILE     FILE_TOO_LARGE     FILE_IN_USE     OUT_OF_MEMORY     I_O_ERROR     SYS_CALL_NOT_IMPLEMENTED     INTERNAL_LOGIC_ERROR","title":"enum FileLockError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-semaphoreerror","text":"Enumerator Value Description     CREATION_FAILED     NAME_TOO_LONG     UNABLE_TO_OPEN_HANDLE     INVALID_SEMAPHORE_HANDLE     SEMAPHORE_OVERFLOW     INTERRUPTED_BY_SIGNAL_HANDLER     UNDEFINED","title":"enum SemaphoreError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-semaphorewaitstate","text":"Enumerator Value Description     TIMEOUT     NO_TIMEOUT","title":"enum SemaphoreWaitState"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-signal","text":"Enumerator Value Description     BUS SIGBUS    INT SIGINT    TERM SIGTERM    HUP SIGHUP    ABORT SIGABRT     <p>Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value. </p>","title":"enum Signal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-timererror","text":"Enumerator Value Description     NO_ERROR     TIMER_NOT_INITIALIZED     NO_VALID_CALLBACK     KERNEL_ALLOC_FAILED     INVALID_ARGUMENTS     ALLOC_MEM_FAILED     NO_PERMISSION     INVALID_POINTER     NO_TIMER_TO_DELETE     TIMEOUT_IS_ZERO     INTERNAL_LOGIC_ERROR","title":"enum TimerError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#using-signalhandlercallback_t","text":"<pre><code>using iox::posix::SignalHandlerCallback_t = typedef void (*)(int);\n</code></pre>","title":"using SignalHandlerCallback_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#using-threadname_t","text":"<pre><code>using iox::posix::ThreadName_t = typedef cxx::string&lt;MAX_THREAD_NAME_LENGTH&gt;;\n</code></pre>","title":"using ThreadName_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-registersignalhandler","text":"<pre><code>SignalGuard registerSignalHandler(\n    const Signal signal,\n    const SignalHandlerCallback_t callback\n)\n</code></pre> <p>Register a callback for a specific posix signal (SIG***). </p> <p>Parameters: </p> <ul> <li>Signal the signal to which the callback should be attached </li> <li>callback the callback which should be called when the signal is raised. </li> </ul> <p>Return: SignalGuard, when it goes out of scope the previous signal action is restored. </p> <p>Attention: if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created. </p>","title":"function registerSignalHandler"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-waitforterminationrequest","text":"<pre><code>void waitForTerminationRequest()\n</code></pre> <p>convenience function, calls SignalWatcher::getInstance().waitForSignal(); </p>","title":"function waitForTerminationRequest"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-hasterminationrequested","text":"<pre><code>bool hasTerminationRequested()\n</code></pre> <p>convenience function, calls SignalWatcher::getInstance().wasSignalTriggered(); </p>","title":"function hasTerminationRequested"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-setthreadname","text":"<pre><code>void setThreadName(\n    pthread_t thread,\n    const ThreadName_t &amp; name\n)\n</code></pre>","title":"function setThreadName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-getthreadname","text":"<pre><code>ThreadName_t getThreadName(\n    pthread_t thread\n)\n</code></pre>","title":"function getThreadName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-maxnumberofgroups","text":"<pre><code>static constexpr int MaxNumberOfGroups = 888;\n</code></pre>","title":"variable MaxNumberOfGroups"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_error_string_size","text":"<pre><code>static constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U;\n</code></pre>","title":"variable POSIX_CALL_ERROR_STRING_SIZE"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_eintr_repetitions","text":"<pre><code>static constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U;\n</code></pre>","title":"variable POSIX_CALL_EINTR_REPETITIONS"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_invalid_errno","text":"<pre><code>static constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1;\n</code></pre>","title":"variable POSIX_CALL_INVALID_ERRNO"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createunnamedsingleprocesssemaphore","text":"<pre><code>static constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore =\n    [CreateUnnamedSingleProcessSemaphore_t](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t/)();\n</code></pre>","title":"variable CreateUnnamedSingleProcessSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createunnamedsharedmemorysemaphore","text":"<pre><code>static constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore =\n    [CreateUnnamedSharedMemorySemaphore_t](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t/)();\n</code></pre>","title":"variable CreateUnnamedSharedMemorySemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createnamedsemaphore","text":"<pre><code>static constexpr CreateNamedSemaphore_t CreateNamedSemaphore = [CreateNamedSemaphore_t](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateNamedSemaphore__t/)();\n</code></pre>","title":"variable CreateNamedSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-opennamedsemaphore","text":"<pre><code>static constexpr OpenNamedSemaphore_t OpenNamedSemaphore = [OpenNamedSemaphore_t](/v2.0.0/API-reference/hoofs/Classes/structiox_1_1posix_1_1OpenNamedSemaphore__t/)();\n</code></pre>","title":"variable OpenNamedSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-max_thread_name_length","text":"<pre><code>constexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable MAX_THREAD_NAME_LENGTH"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/","text":"","title":"iox::posix::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#functions","text":"Name     template &lt;typename ReturnType ,typename... FunctionArguments&gt; PosixCallBuilder&lt; ReturnType, FunctionArguments... &gt; createPosixCallBuilder(ReturnType(*)(FunctionArguments...) posixCall, const char * posixFunctionName, const char * file, const int32_t line, const char * callingFunction)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#function-createposixcallbuilder","text":"<pre><code>template &lt;typename ReturnType ,\ntypename... FunctionArguments&gt;\nPosixCallBuilder&lt; ReturnType, FunctionArguments... &gt; createPosixCallBuilder(\n    ReturnType(*)(FunctionArguments...) posixCall,\n    const char * posixFunctionName,\n    const char * file,\n    const int32_t line,\n    const char * callingFunction\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function createPosixCallBuilder"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1units_1_1duration__literals/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::units::duration_literals"},{"location":"API-reference/hoofs/Namespaces/namespacestd/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"std"},{"location":"API-reference/hoofs/Pages/concurrent/","text":"<p>Member iox::cxx::VariantQueue&lt; ValueType, Capacity &gt;::setCapacity  (const uint64_t newCapacity) noexcept</p> <ul> <li>not thread safe  </li> </ul> <p>Class iox::posix::Timer</p> <ul> <li>not thread safe</li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Concurrency"},{"location":"API-reference/hoofs/Pages/todo/","text":"<p>Member iox::cxx::string&lt; Capacity &gt;::operator!=  (const char *const rhs) const noexcept</p> <ul> <li>consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template  bool operator!=(const char (&amp;rhs)[N]) const noexcept    <p>Member iox::cxx::string&lt; Capacity &gt;::operator==  (const char *const rhs) const noexcept</p> <ul> <li>consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template  bool operator==(const char (&amp;rhs)[N]) const noexcept    <p>Class iox::log::Logger</p> <ul> <li>for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/</li> </ul> <p>Member iox::log::Logger::LogStream</p> <ul> <li>LogStream needs to call Log(); do we want to make Log() public?  </li> </ul> <p>Member iox::posix::Timer::now  () noexcept</p> <ul> <li>maybe move this to a clock implementation?  </li> </ul> <p>Member iox::posix::Timer::Timer  (const units::Duration timeToWait) noexcept</p> <ul> <li>refactor this cTor and its functionality to a class called StopWatch </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Todo List"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/","text":"<p>Inherits from iox::client::introspection::IntrospectionApp</p>","title":"iox::client::introspection::IceOryxIntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#public-functions","text":"Name      IceOryxIntrospectionApp(int argc, char * argv[])constructor to create the introspection   virtual void run() overridestarts the execution of introspection","title":"Public Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#additional-inherited-members","text":"<p>Protected Types inherited from iox::client::introspection::IntrospectionApp</p>     Name     enum CmdLineArgumentParsingMode    <p>Public Functions inherited from iox::client::introspection::IntrospectionApp</p>     Name      IntrospectionApp(int argc, char * argv[])constructor to create a introspection   virtual ~IntrospectionApp()    <p>Protected Functions inherited from iox::client::introspection::IntrospectionApp</p>     Name      IntrospectionApp()this is needed for the child classes to extend the parseCmdLineArguments function   void parseCmdLineArguments(int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL)   void runIntrospection(const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection)    <p>Protected Attributes inherited from iox::client::introspection::IntrospectionApp</p>     Name     IntrospectionSelection introspectionSelection   bool doIntrospection","title":"Additional inherited members"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#function-iceoryxintrospectionapp","text":"<pre><code>IceOryxIntrospectionApp(\n    int argc,\n    char * argv[]\n)\n</code></pre> <p>constructor to create the introspection </p> <p>Parameters: </p> <ul> <li>argc forwarding of command line arguments </li> <li>argv forwarding of command line arguments </li> </ul>","title":"function IceOryxIntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#function-run","text":"<pre><code>virtual void run() override\n</code></pre> <p>starts the execution of introspection </p> <p>Reimplements: iox::client::introspection::IntrospectionApp::run</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function run"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/","text":"<p>base class for introspection  More...</p> <p><code>#include &lt;iceoryx_introspection/introspection_app.hpp&gt;</code></p> <p>Inherited by iox::client::introspection::IceOryxIntrospectionApp</p>","title":"iox::client::introspection::IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-types","text":"Name     enum CmdLineArgumentParsingMode","title":"Protected Types"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#public-functions","text":"Name      IntrospectionApp(int argc, char * argv[])constructor to create a introspection   virtual ~IntrospectionApp()   virtual void run() =0interface to start the execution of the introspection","title":"Public Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-functions","text":"Name      IntrospectionApp()this is needed for the child classes to extend the parseCmdLineArguments function   void parseCmdLineArguments(int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL)   void runIntrospection(const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection)","title":"Protected Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-attributes","text":"Name     IntrospectionSelection introspectionSelection   bool doIntrospection","title":"Protected Attributes"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#detailed-description","text":"<pre><code>class iox::client::introspection::IntrospectionApp;\n</code></pre> <p>base class for introspection </p> <p>Todo: Wrap all C calls with posixCall </p>","title":"Detailed Description"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#enum-cmdlineargumentparsingmode","text":"Enumerator Value Description     ALL     ONE","title":"enum CmdLineArgumentParsingMode"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp","text":"<pre><code>IntrospectionApp(\n    int argc,\n    char * argv[]\n)\n</code></pre> <p>constructor to create a introspection </p> <p>Parameters: </p> <ul> <li>argc forwarding of command line arguments </li> <li>argv forwarding of command line arguments </li> </ul>","title":"function IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp_1","text":"<pre><code>inline virtual ~IntrospectionApp()\n</code></pre>","title":"function ~IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-run","text":"<pre><code>virtual void run() =0\n</code></pre> <p>interface to start the execution of the introspection </p> <p>Reimplemented by: iox::client::introspection::IceOryxIntrospectionApp::run</p>","title":"function run"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp_2","text":"<pre><code>IntrospectionApp()\n</code></pre> <p>this is needed for the child classes to extend the parseCmdLineArguments function </p>","title":"function IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-parsecmdlinearguments","text":"<pre><code>void parseCmdLineArguments(\n    int argc,\n    char ** argv,\n    CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL\n)\n</code></pre>","title":"function parseCmdLineArguments"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-runintrospection","text":"<pre><code>void runIntrospection(\n    const iox::units::Duration updatePeriodMs,\n    const IntrospectionSelection introspectionSelection\n)\n</code></pre>","title":"function runIntrospection"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#variable-introspectionselection","text":"<pre><code>IntrospectionSelection introspectionSelection;\n</code></pre>","title":"variable introspectionSelection"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#variable-dointrospection","text":"<pre><code>bool doIntrospection = false;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable doIntrospection"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/","text":"<p>More...</p> <p><code>#include &lt;iceoryx_introspection/introspection_types.hpp&gt;</code></p>","title":"iox::client::introspection::ComposedPublisherPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-functions","text":"Name      ComposedPublisherPortData(const PublisherPortData &amp; portData, const PortThroughputData &amp; throughputData)","title":"Public Functions"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-attributes","text":"Name     const PublisherPortData * portData   const PortThroughputData * throughputData","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#detailed-description","text":"<pre><code>struct iox::client::introspection::ComposedPublisherPortData;\n</code></pre> <p>Note: this contains just pointer to the real data, therefore pay attention to the lifetime of the original data </p>","title":"Detailed Description"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#function-composedpublisherportdata","text":"<pre><code>inline ComposedPublisherPortData(\n    const PublisherPortData &amp; portData,\n    const PortThroughputData &amp; throughputData\n)\n</code></pre>","title":"function ComposedPublisherPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#variable-portdata","text":"<pre><code>const PublisherPortData * portData;\n</code></pre>","title":"variable portData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#variable-throughputdata","text":"<pre><code>const PortThroughputData * throughputData;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable throughputData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/","text":"","title":"iox::client::introspection::ComposedSubscriberPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-functions","text":"Name      ComposedSubscriberPortData(const SubscriberPortData &amp; portData, const SubscriberPortChangingData &amp; subscriberPortChangingData)","title":"Public Functions"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-attributes","text":"Name     const SubscriberPortData * portData   const SubscriberPortChangingData * subscriberPortChangingData","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#function-composedsubscriberportdata","text":"<pre><code>inline ComposedSubscriberPortData(\n    const SubscriberPortData &amp; portData,\n    const SubscriberPortChangingData &amp; subscriberPortChangingData\n)\n</code></pre>","title":"function ComposedSubscriberPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#variable-portdata","text":"<pre><code>const SubscriberPortData * portData;\n</code></pre>","title":"variable portData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#variable-subscriberportchangingdata","text":"<pre><code>const SubscriberPortChangingData * subscriberPortChangingData;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable subscriberPortChangingData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/","text":"","title":"iox::client::introspection::IntrospectionSelection"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#public-attributes","text":"Name     bool mempool   bool process   bool port","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-mempool","text":"<pre><code>bool mempool {false};\n</code></pre>","title":"variable mempool"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-process","text":"<pre><code>bool process {false};\n</code></pre>","title":"variable process"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-port","text":"<pre><code>bool port {false};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable port"},{"location":"API-reference/introspection/Files/dir_18f66dcf58fe6b827bdb3fbbb3336743/","text":"","title":"iceoryx_introspection"},{"location":"API-reference/introspection/Files/dir_18f66dcf58fe6b827bdb3fbbb3336743/#files","text":"Name     iceoryx_introspection/iceoryx_introspection_app.hpp   iceoryx_introspection/introspection_app.hpp   iceoryx_introspection/introspection_types.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/","text":"","title":"iceoryx_introspection/iceoryx_introspection_app.hpp"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#namespaces","text":"Name     iox   iox::client   iox::client::introspection","title":"Namespaces"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#classes","text":"Name     class iox::client::introspection::IceOryxIntrospectionApp","title":"Classes"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP\n#define IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP\n\n#include \"iceoryx_introspection/introspection_app.hpp\"\n\nnamespace iox\n{\nnamespace client\n{\nnamespace introspection\n{\nclass IceOryxIntrospectionApp : public IntrospectionApp\n{\n  public:\n    IceOryxIntrospectionApp(int argc, char* argv[]) noexcept;\n\n    void run() noexcept override;\n};\n\n} // namespace introspection\n} // namespace client\n} // namespace iox\n\n#endif // IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/","text":"","title":"iceoryx_introspection/introspection_app.hpp"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#namespaces","text":"Name     iox   iox::client   iox::client::introspection","title":"Namespaces"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#classes","text":"Name     class iox::client::introspection::IntrospectionApp base class for introspection","title":"Classes"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP\n#define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP\n\n#include \"iceoryx_hoofs/platform/getopt.hpp\"\n#include \"iceoryx_introspection/introspection_types.hpp\"\n#include \"iceoryx_posh/popo/subscriber.hpp\"\n\n#include &lt;map&gt;\n#include &lt;ncurses.h&gt;\n#include &lt;vector&gt;\n\nnamespace iox\n{\nnamespace client\n{\nnamespace introspection\n{\nstatic constexpr option longOptions[] = {{\"help\", no_argument, nullptr, 'h'},\n                                         {\"version\", no_argument, nullptr, 'v'},\n                                         {\"time\", required_argument, nullptr, 't'},\n                                         {\"mempool\", no_argument, nullptr, 0},\n                                         {\"port\", no_argument, nullptr, 0},\n                                         {\"process\", no_argument, nullptr, 0},\n                                         {\"all\", no_argument, nullptr, 0},\n                                         {nullptr, 0, nullptr, 0}};\n\nstatic constexpr const char* shortOptions = \"hvt:\";\n\nstatic constexpr iox::units::Duration MIN_UPDATE_PERIOD = 500_ms;\nstatic constexpr iox::units::Duration DEFAULT_UPDATE_PERIOD = 1000_ms;\nstatic constexpr iox::units::Duration MAX_UPDATE_PERIOD = 10000_ms;\n\nenum class ColorPairs : uint8_t\n{\n    redOnBlack = 1,\n    whiteOnRed\n};\n\nstatic const std::map&lt;PrettyOptions, uint32_t&gt; prettyMap = {\n    {PrettyOptions::title, A_BOLD | COLOR_PAIR(static_cast&lt;uint8_t&gt;(ColorPairs::redOnBlack))},\n    {PrettyOptions::highlight, A_BOLD | A_UNDERLINE},\n    {PrettyOptions::error, A_BOLD | COLOR_PAIR(static_cast&lt;uint8_t&gt;(ColorPairs::whiteOnRed))},\n    {PrettyOptions::bold, A_BOLD},\n    {PrettyOptions::normal, A_NORMAL}};\n\n\nclass IntrospectionApp\n{\n  public:\n    IntrospectionApp(int argc, char* argv[]) noexcept;\n\n    virtual ~IntrospectionApp() noexcept {};\n\n    virtual void run() noexcept = 0;\n\n  protected:\n    enum class CmdLineArgumentParsingMode\n    {\n        ALL,\n        ONE\n    };\n\n    IntrospectionSelection introspectionSelection;\n\n    bool doIntrospection = false;\n\n    IntrospectionApp() noexcept;\n\n    void\n    parseCmdLineArguments(int argc,\n                          char** argv,\n                          CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode::ALL) noexcept;\n\n    void runIntrospection(const iox::units::Duration updatePeriodMs,\n                          const IntrospectionSelection introspectionSelection);\n\n  private:\n    void initTerminal();\n\n    void clearToBottom();\n\n    void closeTerminal();\n\n    void refreshTerminal();\n\n    void updateDisplayYX();\n\n    void waitForUserInput(int32_t timeoutMs);\n\n    void printShortInfo(const std::string&amp; binaryName) noexcept;\n\n    void prettyPrint(const std::string&amp; str, const PrettyOptions pr = PrettyOptions::normal);\n\n    void printProcessIntrospectionData(const ProcessIntrospectionFieldTopic* processIntrospectionField);\n\n    void printMemPoolInfo(const MemPoolIntrospectionInfo&amp; introspectionInfo);\n\n    template &lt;typename Subscriber&gt;\n    bool waitForSubscription(Subscriber&amp; port);\n\n    std::vector&lt;ComposedPublisherPortData&gt;\n    composePublisherPortData(const PortIntrospectionFieldTopic* portData,\n                             const PortThroughputIntrospectionFieldTopic* throughputData);\n\n    std::vector&lt;ComposedSubscriberPortData&gt;\n    composeSubscriberPortData(const PortIntrospectionFieldTopic* portData,\n                              const SubscriberPortChangingIntrospectionFieldTopic* subscriberPortChangingData);\n\n    void printPortIntrospectionData(const std::vector&lt;ComposedPublisherPortData&gt;&amp; publisherPortData,\n                                    const std::vector&lt;ComposedSubscriberPortData&gt;&amp; subscriberPortData);\n\n    void printHelp() noexcept;\n\n    template &lt;typename T&gt;\n    T bounded(T input, T min, T max) noexcept\n    {\n        return ((input &gt;= min) ? ((input &lt;= max) ? input : max) : min);\n    }\n\n    iox::units::Duration updatePeriodMs = DEFAULT_UPDATE_PERIOD;\n\n    WINDOW* pad;\n\n    int32_t yPad{0};\n\n    int32_t xPad{0};\n};\n\n} // namespace introspection\n} // namespace client\n} // namespace iox\n\n#endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/","text":"","title":"iceoryx_introspection/introspection_types.hpp"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#namespaces","text":"Name     iox   iox::client   iox::client::introspection   iox::roudi","title":"Namespaces"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#classes","text":"Name     struct iox::client::introspection::IntrospectionSelection   struct iox::client::introspection::ComposedPublisherPortData   struct iox::client::introspection::ComposedSubscriberPortData","title":"Classes"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP\n#define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP\n\n#include \"iceoryx_posh/roudi/introspection_types.hpp\"\n\nnamespace iox\n{\nnamespace client\n{\nnamespace introspection\n{\nusing namespace iox::roudi;\n\nconstexpr units::Duration WAIT_INTERVAL = 10_ms;\n\nenum class PrettyOptions\n{\n    title,\n    highlight,\n    error,\n    bold,\n    normal\n};\n\nstruct IntrospectionSelection\n{\n    bool mempool{false};\n    bool process{false};\n    bool port{false};\n};\n\nstruct ComposedPublisherPortData\n{\n    ComposedPublisherPortData(const PublisherPortData&amp; portData, const PortThroughputData&amp; throughputData)\n        : portData(&amp;portData)\n        , throughputData(&amp;throughputData)\n    {\n    }\n    const PublisherPortData* portData;\n    const PortThroughputData* throughputData;\n};\n\nstruct ComposedSubscriberPortData\n{\n    ComposedSubscriberPortData(const SubscriberPortData&amp; portData,\n                               const SubscriberPortChangingData&amp; subscriberPortChangingData)\n        : portData(&amp;portData)\n        , subscriberPortChangingData(&amp;subscriberPortChangingData)\n    {\n    }\n    const SubscriberPortData* portData;\n    const SubscriberPortChangingData* subscriberPortChangingData;\n};\n\n} // namespace introspection\n} // namespace client\n} // namespace iox\n\n#endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/introspection/Namespaces/namespaceiox/","text":"","title":"iox"},{"location":"API-reference/introspection/Namespaces/namespaceiox/#namespaces","text":"Name     iox::client     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Namespaces"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client/","text":"","title":"iox::client"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client/#namespaces","text":"Name     iox::client::introspection     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Namespaces"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/","text":"","title":"iox::client::introspection"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#classes","text":"Name     class iox::client::introspection::IceOryxIntrospectionApp   class iox::client::introspection::IntrospectionApp base class for introspection   struct iox::client::introspection::IntrospectionSelection   struct iox::client::introspection::ComposedPublisherPortData   struct iox::client::introspection::ComposedSubscriberPortData","title":"Classes"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#types","text":"Name     enum uint8_t ColorPairs { redOnBlack = 1, whiteOnRed}color pairs for terminal printing   enum PrettyOptions","title":"Types"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#attributes","text":"Name     constexpr option longOptions   constexpr const char * shortOptions   constexpr iox::units::Duration MIN_UPDATE_PERIOD   constexpr iox::units::Duration DEFAULT_UPDATE_PERIOD   constexpr iox::units::Duration MAX_UPDATE_PERIOD   const std::map&lt; PrettyOptions, uint32_t &gt; prettyMap formatting options for terminal printing   constexpr units::Duration WAIT_INTERVAL","title":"Attributes"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#enum-colorpairs","text":"Enumerator Value Description     redOnBlack 1    whiteOnRed      <p>color pairs for terminal printing </p>","title":"enum ColorPairs"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#enum-prettyoptions","text":"Enumerator Value Description     title     highlight     error     bold     normal","title":"enum PrettyOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-longoptions","text":"<pre><code>static constexpr option longOptions = {{\"help\", no_argument, nullptr, 'h'},\n                                         {\"version\", no_argument, nullptr, 'v'},\n                                         {\"time\", required_argument, nullptr, 't'},\n                                         {\"mempool\", no_argument, nullptr, 0},\n                                         {\"port\", no_argument, nullptr, 0},\n                                         {\"process\", no_argument, nullptr, 0},\n                                         {\"all\", no_argument, nullptr, 0},\n                                         {nullptr, 0, nullptr, 0}};\n</code></pre>","title":"variable longOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-shortoptions","text":"<pre><code>static constexpr const char * shortOptions = \"hvt:\";\n</code></pre>","title":"variable shortOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-min_update_period","text":"<pre><code>static constexpr iox::units::Duration MIN_UPDATE_PERIOD = 500_ms;\n</code></pre>","title":"variable MIN_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-default_update_period","text":"<pre><code>static constexpr iox::units::Duration DEFAULT_UPDATE_PERIOD = 1000_ms;\n</code></pre>","title":"variable DEFAULT_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-max_update_period","text":"<pre><code>static constexpr iox::units::Duration MAX_UPDATE_PERIOD = 10000_ms;\n</code></pre>","title":"variable MAX_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-prettymap","text":"<pre><code>static const std::map&lt; PrettyOptions, uint32_t &gt; prettyMap = {\n    {PrettyOptions::title, A_BOLD | COLOR_PAIR(static_cast&lt;uint8_t&gt;(ColorPairs::redOnBlack))},\n    {PrettyOptions::highlight, A_BOLD | A_UNDERLINE},\n    {PrettyOptions::error, A_BOLD | COLOR_PAIR(static_cast&lt;uint8_t&gt;(ColorPairs::whiteOnRed))},\n    {PrettyOptions::bold, A_BOLD},\n    {PrettyOptions::normal, A_NORMAL}};\n</code></pre> <p>formatting options for terminal printing </p>","title":"variable prettyMap"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-wait_interval","text":"<pre><code>constexpr units::Duration WAIT_INTERVAL = 10_ms;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable WAIT_INTERVAL"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1roudi/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::roudi"},{"location":"API-reference/introspection/Pages/todo/","text":"<p>Class iox::client::introspection::IntrospectionApp</p> <ul> <li>Wrap all C calls with posixCall </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Todo List"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/","text":"<p>class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel.  <code>#include &lt;iceoryx_posh/capro/service_description.hpp&gt;</code></p>","title":"iox::capro::ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-classes","text":"Name     struct ClassHash","title":"Public Classes"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-functions","text":"Name     const IdString_t &amp; getServiceIDString() const   const IdString_t &amp; getInstanceIDString() const   const IdString_t &amp; getEventIDString() const   ClassHash getClassHash() const    ServiceDescription()default C'tor    ServiceDescription(const ServiceDescription &amp; ) =default    ServiceDescription(ServiceDescription &amp;&amp; ) =default    ~ServiceDescription() =default    ServiceDescription(const IdString_t &amp; service, const IdString_t &amp; instance, const IdString_t &amp; event, ClassHash m_classHash ={0U, 0U, 0U, 0U}, Interfaces interfaceSource =Interfaces::INTERNAL)construction of the capro service description using fixed strings to create an event service description   bool operator==(const ServiceDescription &amp; rhs) constcompare operator.   bool operator!=(const ServiceDescription &amp; rhs) constnegation of compare operator.   bool operator&lt;(const ServiceDescription &amp; rhs) constUses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set.   ServiceDescription &amp; operator=(const ServiceDescription &amp; ) =default   ServiceDescription &amp; operator=(ServiceDescription &amp;&amp; ) =default    operator cxx::Serialization() constserialization of the capro description.   bool isLocal() const   void setLocal()   Scope getScope() constReturns the scope of a ServiceDescription.   Interfaces getSourceInterface() constReturns the interface form where the service is coming from.   cxx::expected&lt; ServiceDescription, cxx::Serialization::Error &gt; deserialize(const cxx::Serialization &amp; serialized)de-serialization of a ServiceDescription.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getserviceidstring","text":"<pre><code>const IdString_t &amp; getServiceIDString() const\n</code></pre> <p>Getters for the string IDs </p>","title":"function getServiceIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getinstanceidstring","text":"<pre><code>const IdString_t &amp; getInstanceIDString() const\n</code></pre>","title":"function getInstanceIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-geteventidstring","text":"<pre><code>const IdString_t &amp; getEventIDString() const\n</code></pre>","title":"function getEventIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getclasshash","text":"<pre><code>ClassHash getClassHash() const\n</code></pre> <p>Getter for class hash </p>","title":"function getClassHash"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription","text":"<pre><code>ServiceDescription()\n</code></pre> <p>default C'tor </p>","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_1","text":"<pre><code>ServiceDescription(\n    const ServiceDescription &amp; \n) =default\n</code></pre>","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_2","text":"<pre><code>ServiceDescription(\n    ServiceDescription &amp;&amp; \n) =default\n</code></pre>","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_3","text":"<pre><code>~ServiceDescription() =default\n</code></pre>","title":"function ~ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_4","text":"<pre><code>ServiceDescription(\n    const IdString_t &amp; service,\n    const IdString_t &amp; instance,\n    const IdString_t &amp; event,\n    ClassHash m_classHash ={0U, 0U, 0U, 0U},\n    Interfaces interfaceSource =Interfaces::INTERNAL\n)\n</code></pre> <p>construction of the capro service description using fixed strings to create an event service description </p>","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator","text":"<pre><code>bool operator==(\n    const ServiceDescription &amp; rhs\n) const\n</code></pre> <p>compare operator. </p>","title":"function operator=="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_1","text":"<pre><code>bool operator!=(\n    const ServiceDescription &amp; rhs\n) const\n</code></pre> <p>negation of compare operator. </p>","title":"function operator!="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_2","text":"<pre><code>bool operator&lt;(\n    const ServiceDescription &amp; rhs\n) const\n</code></pre> <p>Uses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set. </p>","title":"function operator&lt;"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_3","text":"<pre><code>ServiceDescription &amp; operator=(\n    const ServiceDescription &amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_4","text":"<pre><code>ServiceDescription &amp; operator=(\n    ServiceDescription &amp;&amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator-cxxserialization","text":"<pre><code>explicit operator cxx::Serialization() const\n</code></pre> <p>serialization of the capro description. </p>","title":"function operator cxx::Serialization"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-islocal","text":"<pre><code>bool isLocal() const\n</code></pre>","title":"function isLocal"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-setlocal","text":"<pre><code>void setLocal()\n</code></pre>","title":"function setLocal"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getscope","text":"<pre><code>Scope getScope() const\n</code></pre> <p>Returns the scope of a ServiceDescription. </p>","title":"function getScope"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getsourceinterface","text":"<pre><code>Interfaces getSourceInterface() const\n</code></pre> <p>Returns the interface form where the service is coming from. </p>","title":"function getSourceInterface"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-deserialize","text":"<pre><code>static cxx::expected&lt; ServiceDescription, cxx::Serialization::Error &gt; deserialize(\n    const cxx::Serialization &amp; serialized\n)\n</code></pre> <p>de-serialization of a ServiceDescription. </p> <p>Parameters: </p> <ul> <li>serializedSerialization object from which the ServiceDescription shall be created </li> </ul> <p>Return: cxx::expected that either has a ServiceDescription or cxx::Serialization::Error stored inside </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function deserialize"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/","text":"<p>Inherited by iox::config::CmdLineParserConfigFileOption</p>","title":"iox::config::CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-types","text":"Name     enum CmdLineArgumentParsingMode","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-functions","text":"Name      CmdLineParser() =default   virtual ~CmdLineParser() =default   CmdLineParser &amp; operator=(const CmdLineParser &amp; other)    CmdLineParser(const CmdLineParser &amp; other)   CmdLineParser &amp; operator=(CmdLineParser &amp;&amp; )    CmdLineParser(CmdLineParser &amp;&amp; other)   virtual cxx::expected&lt; CmdLineArgs_t, CmdLineParserResult &gt; parse(int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL)process the passed command line arguments","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#protected-attributes","text":"Name     bool m_run   iox::log::LogLevel m_logLevel   roudi::MonitoringMode m_monitoringMode   version::CompatibilityCheckLevel m_compatibilityCheckLevel   cxx::optional&lt; uint16_t &gt; m_uniqueRouDiId   units::Duration m_processKillDelay","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#enum-cmdlineargumentparsingmode","text":"Enumerator Value Description     ALL     ONE","title":"enum CmdLineArgumentParsingMode"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser","text":"<pre><code>CmdLineParser() =default\n</code></pre>","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_1","text":"<pre><code>virtual ~CmdLineParser() =default\n</code></pre>","title":"function ~CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-operator","text":"<pre><code>CmdLineParser &amp; operator=(\n    const CmdLineParser &amp; other\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_2","text":"<pre><code>CmdLineParser(\n    const CmdLineParser &amp; other\n)\n</code></pre>","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-operator_1","text":"<pre><code>CmdLineParser &amp; operator=(\n    CmdLineParser &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_3","text":"<pre><code>CmdLineParser(\n    CmdLineParser &amp;&amp; other\n)\n</code></pre>","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-parse","text":"<pre><code>virtual cxx::expected&lt; CmdLineArgs_t, CmdLineParserResult &gt; parse(\n    int argc,\n    char * argv[],\n    const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL\n)\n</code></pre> <p>process the passed command line arguments </p> <p>Parameters: </p> <ul> <li>argc forwarding of command line arguments </li> <li>argv forwarding of command line arguments </li> <li>cmdLineParsingMode selects to parse a single option or all options </li> <li>Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult </li> </ul> <p>Reimplemented by: iox::config::CmdLineParserConfigFileOption::parse</p>","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_run","text":"<pre><code>bool m_run {true};\n</code></pre>","title":"variable m_run"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_loglevel","text":"<pre><code>iox::log::LogLevel m_logLevel {iox::log::LogLevel::kWarn};\n</code></pre>","title":"variable m_logLevel"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_monitoringmode","text":"<pre><code>roudi::MonitoringMode m_monitoringMode {roudi::MonitoringMode::ON};\n</code></pre>","title":"variable m_monitoringMode"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_compatibilitychecklevel","text":"<pre><code>version::CompatibilityCheckLevel m_compatibilityCheckLevel {version::CompatibilityCheckLevel::PATCH};\n</code></pre>","title":"variable m_compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_uniqueroudiid","text":"<pre><code>cxx::optional&lt; uint16_t &gt; m_uniqueRouDiId;\n</code></pre>","title":"variable m_uniqueRouDiId"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_processkilldelay","text":"<pre><code>units::Duration m_processKillDelay {roudi::PROCESS_DEFAULT_KILL_DELAY};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_processKillDelay"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/","text":"<p>Inherits from iox::config::CmdLineParser</p>","title":"iox::config::CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#public-functions","text":"Name      CmdLineParserConfigFileOption() =default   virtual ~CmdLineParserConfigFileOption() =default   CmdLineParserConfigFileOption &amp; operator=(const CmdLineParserConfigFileOption &amp; other)    CmdLineParserConfigFileOption(const CmdLineParserConfigFileOption &amp; other)   CmdLineParserConfigFileOption &amp; operator=(CmdLineParserConfigFileOption &amp;&amp; )    CmdLineParserConfigFileOption(CmdLineParserConfigFileOption &amp;&amp; other)   virtual cxx::expected&lt; CmdLineArgs_t, CmdLineParserResult &gt; parse(int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) overrideprocess the passed command line arguments","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#protected-attributes","text":"Name     roudi::ConfigFilePathString_t m_customConfigFilePath","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#additional-inherited-members","text":"<p>Public Types inherited from iox::config::CmdLineParser</p>     Name     enum CmdLineArgumentParsingMode    <p>Public Functions inherited from iox::config::CmdLineParser</p>     Name      CmdLineParser() =default   virtual ~CmdLineParser() =default    CmdLineParser(const CmdLineParser &amp; other)    CmdLineParser(CmdLineParser &amp;&amp; other)    <p>Protected Attributes inherited from iox::config::CmdLineParser</p>     Name     bool m_run   iox::log::LogLevel m_logLevel   roudi::MonitoringMode m_monitoringMode   version::CompatibilityCheckLevel m_compatibilityCheckLevel   cxx::optional&lt; uint16_t &gt; m_uniqueRouDiId   units::Duration m_processKillDelay","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption","text":"<pre><code>CmdLineParserConfigFileOption() =default\n</code></pre>","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_1","text":"<pre><code>virtual ~CmdLineParserConfigFileOption() =default\n</code></pre>","title":"function ~CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-operator","text":"<pre><code>CmdLineParserConfigFileOption &amp; operator=(\n    const CmdLineParserConfigFileOption &amp; other\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_2","text":"<pre><code>CmdLineParserConfigFileOption(\n    const CmdLineParserConfigFileOption &amp; other\n)\n</code></pre>","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-operator_1","text":"<pre><code>CmdLineParserConfigFileOption &amp; operator=(\n    CmdLineParserConfigFileOption &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_3","text":"<pre><code>CmdLineParserConfigFileOption(\n    CmdLineParserConfigFileOption &amp;&amp; other\n)\n</code></pre>","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-parse","text":"<pre><code>virtual cxx::expected&lt; CmdLineArgs_t, CmdLineParserResult &gt; parse(\n    int argc,\n    char * argv[],\n    const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL\n) override\n</code></pre> <p>process the passed command line arguments </p> <p>Parameters: </p> <ul> <li>argc forwarding of command line arguments </li> <li>argv forwarding of command line arguments </li> <li>cmdLineParsingMode selects to parse a single option or all options </li> <li>Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult </li> </ul> <p>Reimplements: iox::config::CmdLineParser::parse</p>","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#variable-m_customconfigfilepath","text":"<pre><code>roudi::ConfigFilePathString_t m_customConfigFilePath;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_customConfigFilePath"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/","text":"<p>The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files.  <code>#include &lt;iceoryx_posh/gateway/toml_gateway_config_parser.hpp&gt;</code></p>","title":"iox::config::TomlGatewayConfigParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#public-functions","text":"Name     cxx::expected&lt; GatewayConfig, TomlGatewayConfigParseError &gt; parse(const roudi::ConfigFilePathString_t &amp; path =roudi::ConfigFilePathString_t(DEFAULT_CONFIG_FILE_PATH))","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#protected-functions","text":"Name     cxx::expected&lt; TomlGatewayConfigParseError &gt; validate(const cpptoml::table &amp; parsedToml)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#function-parse","text":"<pre><code>static cxx::expected&lt; GatewayConfig, TomlGatewayConfigParseError &gt; parse(\n    const roudi::ConfigFilePathString_t &amp; path =roudi::ConfigFilePathString_t(DEFAULT_CONFIG_FILE_PATH)\n)\n</code></pre>","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#function-validate","text":"<pre><code>static cxx::expected&lt; TomlGatewayConfigParseError &gt; validate(\n    const cpptoml::table &amp; parsedToml\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function validate"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/","text":"<p>Inherits from iox::roudi::RouDiConfigFileProvider</p>","title":"iox::config::TomlRouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#public-functions","text":"Name      TomlRouDiConfigFileProvider(iox::config::CmdLineArgs_t &amp; cmdLineArgs)   virtual iox::cxx::expected&lt; iox::RouDiConfig_t, iox::roudi::RouDiConfigFileParseError &gt; parse() overrideinterface to parse a config file which needs to be implemented for a custom parser","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#additional-inherited-members","text":"<p>Protected Attributes inherited from iox::roudi::RouDiConfigFileProvider</p>     Name     ConfigFilePathString_t m_customConfigFilePath","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#function-tomlroudiconfigfileprovider","text":"<pre><code>TomlRouDiConfigFileProvider(\n    iox::config::CmdLineArgs_t &amp; cmdLineArgs\n)\n</code></pre>","title":"function TomlRouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#function-parse","text":"<pre><code>virtual iox::cxx::expected&lt; iox::RouDiConfig_t, iox::roudi::RouDiConfigFileParseError &gt; parse() override\n</code></pre> <p>interface to parse a config file which needs to be implemented for a custom parser </p> <p>Parameters: </p> <ul> <li>configFilePath to the custom RouDi config file </li> </ul> <p>Return: a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error </p> <p>Reimplements: iox::roudi::RouDiConfigFileProvider::parse</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/","text":"<p>A data structure representing a channel between Iceoryx and an external system.  More...</p> <p><code>#include &lt;iceoryx_posh/gateway/channel.hpp&gt;</code></p>","title":"iox::Channel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#public-functions","text":"Name     constexpr Channel(const capro::ServiceDescription &amp; service, const IceoryxTerminalPtr iceoryxTerminal, const ExternalTerminalPtr externalTerminal)   constexpr bool operator==(const Channel&lt; IceoryxTerminal, ExternalTerminal &gt; &amp; rhs) const   capro::ServiceDescription getServiceDescription() const   IceoryxTerminalPtr getIceoryxTerminal() const   ExternalTerminalPtr getExternalTerminal() const   template &lt;typename IceoryxPubSubOptions &gt; cxx::expected&lt; Channel, ChannelError &gt; create(const capro::ServiceDescription &amp; service, const IceoryxPubSubOptions &amp; options)create Creates a channel for the given service whose terminals reside in a static object pool.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#detailed-description","text":"<pre><code>template &lt;typename IceoryxTerminal ,\ntypename ExternalTerminal &gt;\nclass iox::gw::Channel;\n</code></pre> <p>A data structure representing a channel between Iceoryx and an external system. </p> <p>The class couples related iceoryx and external interfaces that communicate with eachother to form the communication channel. These interfaces are conceptualized as channel \"Terminals\".</p> <p>The structure holds pointers to the instances of the terminals. The terminals can be created and managed externally, in which case the structure only serves as a means of coupling the two. This can be achieved by simply calling the constructor with pointers to them.</p> <p>Alternatively, the class can manage the terminals internally in a static object pool, automatically cleaning them up when the channel is discarded. This can be achieved via the Channel::create method. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-channel","text":"<pre><code>constexpr Channel(\n    const capro::ServiceDescription &amp; service,\n    const IceoryxTerminalPtr iceoryxTerminal,\n    const ExternalTerminalPtr externalTerminal\n)\n</code></pre>","title":"function Channel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-operator","text":"<pre><code>constexpr bool operator==(\n    const Channel&lt; IceoryxTerminal, ExternalTerminal &gt; &amp; rhs\n) const\n</code></pre>","title":"function operator=="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-getservicedescription","text":"<pre><code>capro::ServiceDescription getServiceDescription() const\n</code></pre>","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-geticeoryxterminal","text":"<pre><code>IceoryxTerminalPtr getIceoryxTerminal() const\n</code></pre>","title":"function getIceoryxTerminal"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-getexternalterminal","text":"<pre><code>ExternalTerminalPtr getExternalTerminal() const\n</code></pre>","title":"function getExternalTerminal"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-create","text":"<pre><code>template &lt;typename IceoryxPubSubOptions &gt;\nstatic cxx::expected&lt; Channel, ChannelError &gt; create(\n    const capro::ServiceDescription &amp; service,\n    const IceoryxPubSubOptions &amp; options\n)\n</code></pre> <p>create Creates a channel for the given service whose terminals reside in a static object pool. </p> <p>Parameters: </p> <ul> <li>service The service to create the channel for. </li> <li>options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. </li> </ul> <p>Return: A copy of the created channel, if successful. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/","text":"<p>Generic gateway for communication events.  <code>#include &lt;iceoryx_posh/gateway/gateway_base.hpp&gt;</code></p> <p>Inherited by iox::GatewayGeneric&lt; channel_t, gateway_t &gt;</p>","title":"iox::GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-types","text":"Name     using capro::CaproMessage CaproMessage","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-functions","text":"Name      GatewayBase(const capro::Interfaces f_interface)Constructor for creating generic gateway based on type of interface.   GatewayBase &amp; operator=(const GatewayBase &amp; other)    GatewayBase(const GatewayBase &amp; other)    GatewayBase(GatewayBase &amp;&amp; other) =default   GatewayBase &amp; operator=(GatewayBase &amp;&amp; ) =default   virtual ~GatewayBase()   bool getCaProMessage(CaproMessage &amp; msg)Get function for type of capro message - service or event or field.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-functions","text":"Name      GatewayBase() =default   capro::Interfaces getInterface() const","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-attributes","text":"Name     popo::InterfacePort m_interfaceImpl","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#using-capromessage","text":"<pre><code>using iox::gw::GatewayBase::CaproMessage =  capro::CaproMessage;\n</code></pre>","title":"using CaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase","text":"<pre><code>GatewayBase(\n    const capro::Interfaces f_interface\n)\n</code></pre> <p>Constructor for creating generic gateway based on type of interface. </p> <p>Parameters: </p> <ul> <li>f_interface Type of interface </li> </ul>","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-operator","text":"<pre><code>GatewayBase &amp; operator=(\n    const GatewayBase &amp; other\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_1","text":"<pre><code>GatewayBase(\n    const GatewayBase &amp; other\n)\n</code></pre>","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_2","text":"<pre><code>GatewayBase(\n    GatewayBase &amp;&amp; other\n) =default\n</code></pre>","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-operator_1","text":"<pre><code>GatewayBase &amp; operator=(\n    GatewayBase &amp;&amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_3","text":"<pre><code>virtual ~GatewayBase()\n</code></pre>","title":"function ~GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-getcapromessage","text":"<pre><code>bool getCaProMessage(\n    CaproMessage &amp; msg\n)\n</code></pre> <p>Get function for type of capro message - service or event or field. </p> <p>Parameters: </p> <ul> <li>msg Type of caro message </li> </ul>","title":"function getCaProMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_4","text":"<pre><code>GatewayBase() =default\n</code></pre>","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-getinterface","text":"<pre><code>capro::Interfaces getInterface() const\n</code></pre>","title":"function getInterface"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#variable-m_interfaceimpl","text":"<pre><code>popo::InterfacePort m_interfaceImpl {nullptr};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_interfaceImpl"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/","text":"<p>Discover the gateway.  More...</p> <p><code>#include &lt;iceoryx_posh/gateway/gateway_discovery.hpp&gt;</code></p>","title":"iox::GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-types","text":"Name     using capro::CaproMessage CaproMessage","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-functions","text":"Name      GatewayDiscovery(const capro::Interfaces f_interface)Constructor for discovering gateway based on type of interface.   bool getCaproMessage(CaproMessage &amp; msg)Get function for type of capro message - service or event or field.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#protected-functions","text":"Name      GatewayDiscovery(Impl_T interfacePortImpl)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#detailed-description","text":"<pre><code>template &lt;typename Impl_T  =GatewayBase&gt;\nclass iox::gw::GatewayDiscovery;\n</code></pre> <p>Discover the gateway. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#using-capromessage","text":"<pre><code>using iox::gw::GatewayDiscovery&lt; Impl_T &gt;::CaproMessage =  capro::CaproMessage;\n</code></pre>","title":"using CaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-gatewaydiscovery","text":"<pre><code>inline explicit GatewayDiscovery(\n    const capro::Interfaces f_interface\n)\n</code></pre> <p>Constructor for discovering gateway based on type of interface. </p> <p>Parameters: </p> <ul> <li>f_interface Type of interface </li> </ul>","title":"function GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-getcapromessage","text":"<pre><code>inline bool getCaproMessage(\n    CaproMessage &amp; msg\n)\n</code></pre> <p>Get function for type of capro message - service or event or field. </p> <p>Parameters: </p> <ul> <li>msg Type of capro message </li> </ul>","title":"function getCaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-gatewaydiscovery_1","text":"<pre><code>inline explicit GatewayDiscovery(\n    Impl_T interfacePortImpl\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/","text":"<p>A reference generic gateway implementation.  More...</p> <p><code>#include &lt;iceoryx_posh/gateway/gateway_generic.hpp&gt;</code></p> <p>Inherits from iox::GatewayBase</p>","title":"iox::GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#public-functions","text":"Name     virtual ~GatewayGeneric()    GatewayGeneric(const GatewayGeneric &amp; )   GatewayGeneric &amp; operator=(const GatewayGeneric &amp; )    GatewayGeneric(GatewayGeneric &amp;&amp; )   GatewayGeneric &amp; operator=(GatewayGeneric &amp;&amp; )   void runMultithreaded()   void shutdown()   virtual void loadConfiguration(const config::GatewayConfig &amp; config) =0loadConfiguration Load the provided configuration.   virtual void discover(const capro::CaproMessage &amp; msg) =0discover Process discovery messages coming from iceoryx.   virtual void forward(const channel_t &amp; channel) =0forward Forward data between the two terminals of the channel used by the implementation.   uint64_t getNumberOfChannels() const","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#protected-functions","text":"Name      GatewayGeneric(capro::Interfaces interface, units::Duration discoveryPeriod =1000_ms, units::Duration forwardingPeriod =50_ms)   template &lt;typename IceoryxPubSubOptions &gt; cxx::expected&lt; channel_t, GatewayError &gt; addChannel(const capro::ServiceDescription &amp; service, const IceoryxPubSubOptions &amp; options)addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access.   cxx::optional&lt; channel_t &gt; findChannel(const capro::ServiceDescription &amp; service) constfindChannel Searches for a channel for the given service in the internally stored collection and returns it one exists.   void forEachChannel(const cxx::function_ref&lt; void(channel_t &amp;)&gt; f) constforEachChannel Executs the given function for each channel in the internally stored collection.   cxx::expected&lt; GatewayError &gt; discardChannel(const capro::ServiceDescription &amp; service)discardChannel Discard the channel for the given service in the internal collection if one exists.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#additional-inherited-members","text":"<p>Public Types inherited from iox::GatewayBase</p>     Name     using capro::CaproMessage CaproMessage    <p>Public Functions inherited from iox::GatewayBase</p>     Name      GatewayBase(const capro::Interfaces f_interface)Constructor for creating generic gateway based on type of interface.    GatewayBase(const GatewayBase &amp; other)    GatewayBase(GatewayBase &amp;&amp; other) =default   virtual ~GatewayBase()   bool getCaProMessage(CaproMessage &amp; msg)Get function for type of capro message - service or event or field.    <p>Protected Functions inherited from iox::GatewayBase</p>     Name      GatewayBase() =default   capro::Interfaces getInterface() const    <p>Protected Attributes inherited from iox::GatewayBase</p>     Name     popo::InterfacePort m_interfaceImpl","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#detailed-description","text":"<pre><code>template &lt;typename channel_t ,\ntypename gateway_t  =GatewayBase&gt;\nclass iox::gw::GatewayGeneric;\n</code></pre> <p>A reference generic gateway implementation. </p> <p>This class can be extended to quickly implement any type of gateway, only custom initialization, configuration, discovery and forwarding logic needs to be provided.</p> <p>When run, the gateway will automatically call the respective methods when required. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric","text":"<pre><code>virtual ~GatewayGeneric()\n</code></pre>","title":"function ~GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_1","text":"<pre><code>GatewayGeneric(\n    const GatewayGeneric &amp; \n)\n</code></pre>","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-operator","text":"<pre><code>GatewayGeneric &amp; operator=(\n    const GatewayGeneric &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_2","text":"<pre><code>GatewayGeneric(\n    GatewayGeneric &amp;&amp; \n)\n</code></pre>","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-operator_1","text":"<pre><code>GatewayGeneric &amp; operator=(\n    GatewayGeneric &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-runmultithreaded","text":"<pre><code>void runMultithreaded()\n</code></pre>","title":"function runMultithreaded"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-shutdown","text":"<pre><code>void shutdown()\n</code></pre>","title":"function shutdown"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-loadconfiguration","text":"<pre><code>virtual void loadConfiguration(\n    const config::GatewayConfig &amp; config\n) =0\n</code></pre> <p>loadConfiguration Load the provided configuration. </p> <p>Parameters: </p> <ul> <li>config A generic gateway implementation. </li> </ul>","title":"function loadConfiguration"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-discover","text":"<pre><code>virtual void discover(\n    const capro::CaproMessage &amp; msg\n) =0\n</code></pre> <p>discover Process discovery messages coming from iceoryx. </p> <p>Parameters: </p> <ul> <li>msg The discovery message. </li> </ul>","title":"function discover"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-forward","text":"<pre><code>virtual void forward(\n    const channel_t &amp; channel\n) =0\n</code></pre> <p>forward Forward data between the two terminals of the channel used by the implementation. </p> <p>Parameters: </p> <ul> <li>channel The channel to propogate data across. </li> </ul>","title":"function forward"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-getnumberofchannels","text":"<pre><code>uint64_t getNumberOfChannels() const\n</code></pre>","title":"function getNumberOfChannels"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_3","text":"<pre><code>GatewayGeneric(\n    capro::Interfaces interface,\n    units::Duration discoveryPeriod =1000_ms,\n    units::Duration forwardingPeriod =50_ms\n)\n</code></pre>","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-addchannel","text":"<pre><code>template &lt;typename IceoryxPubSubOptions &gt;\ncxx::expected&lt; channel_t, GatewayError &gt; addChannel(\n    const capro::ServiceDescription &amp; service,\n    const IceoryxPubSubOptions &amp; options\n)\n</code></pre> <p>addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access. </p> <p>Parameters: </p> <ul> <li>service The service to create a channel for. </li> <li>options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. </li> </ul> <p>Return: an expected containing a copy of the added channel, otherwise an error</p> <p>Note: </p> <ul> <li>Wildcard services are not allowed and will be ignored.</li> <li>Channels are supposed to be lightweight, consisting only of pointers to the terminals and a copy of the service description, therefore a copy is provided to any entity that requires them. When no more copies of a channel exists in the system, the terminals will automatically be cleaned up via the custom deleters included in their pointers.</li> </ul> <p>The service description is perhaps too large for copying since they contain strings, however this should be addressed with a service description repository feature. </p>","title":"function addChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-findchannel","text":"<pre><code>cxx::optional&lt; channel_t &gt; findChannel(\n    const capro::ServiceDescription &amp; service\n) const\n</code></pre> <p>findChannel Searches for a channel for the given service in the internally stored collection and returns it one exists. </p> <p>Parameters: </p> <ul> <li>service The service to find a channel for. </li> </ul> <p>Return: An optional containining the matching channel if one exists, otherwise an empty optional. </p>","title":"function findChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-foreachchannel","text":"<pre><code>void forEachChannel(\n    const cxx::function_ref&lt; void(channel_t &amp;)&gt; f\n) const\n</code></pre> <p>forEachChannel Executs the given function for each channel in the internally stored collection. </p> <p>Parameters: </p> <ul> <li>f The function to execute. </li> </ul> <p>Note: This operation allows thread-safe access to the internal collection. </p>","title":"function forEachChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-discardchannel","text":"<pre><code>cxx::expected&lt; GatewayError &gt; discardChannel(\n    const capro::ServiceDescription &amp; service\n)\n</code></pre> <p>discardChannel Discard the channel for the given service in the internal collection if one exists. </p> <p>Parameters: </p> <ul> <li>service The service whose channels hiould be discarded. </li> </ul> <p>Return: an empty expected on success, otherwise an error </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function discardChannel"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/","text":"","title":"iox::mepoo::ChunkSettings"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-types","text":"Name     enum Error","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-functions","text":"Name     cxx::expected&lt; ChunkSettings, ChunkSettings::Error &gt; create(const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT)constructs and initializes a ChunkSettings   uint32_t requiredChunkSize() constgetter method for the chunk size fulfilling the user-payload and user-header requirements   uint32_t userPayloadSize() constgetter method for the user-payload size   uint32_t userPayloadAlignment() constgetter method for the user-payload alignment   uint32_t userHeaderSize() constgetter method for the user-header size   uint32_t userHeaderAlignment() constgetter method for the user-header alignment","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#enum-error","text":"Enumerator Value Description     ALIGNMENT_NOT_POWER_OF_TWO     USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT     USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT     REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE","title":"enum Error"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-create","text":"<pre><code>static cxx::expected&lt; ChunkSettings, ChunkSettings::Error &gt; create(\n    const uint32_t userPayloadSize,\n    const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT,\n    const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE,\n    const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT\n)\n</code></pre> <p>constructs and initializes a ChunkSettings</p> <p>Parameters: </p> <ul> <li>chunkSize is the size of the chunk fulfilling the user-payload and user-header requirements </li> <li>userPayloadSize is the size of the user-payload </li> <li>userPayloadAlignment is the alignment of the user-payload </li> <li>userHeaderSize is the size of the user-header </li> <li>userHeaderAlignment is the alignment for the user-header </li> </ul>","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-requiredchunksize","text":"<pre><code>uint32_t requiredChunkSize() const\n</code></pre> <p>getter method for the chunk size fulfilling the user-payload and user-header requirements </p> <p>Return: the chunk size </p>","title":"function requiredChunkSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userpayloadsize","text":"<pre><code>uint32_t userPayloadSize() const\n</code></pre> <p>getter method for the user-payload size </p> <p>Return: the user-payload size </p>","title":"function userPayloadSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userpayloadalignment","text":"<pre><code>uint32_t userPayloadAlignment() const\n</code></pre> <p>getter method for the user-payload alignment </p> <p>Return: the user-payload alignment </p>","title":"function userPayloadAlignment"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userheadersize","text":"<pre><code>uint32_t userHeaderSize() const\n</code></pre> <p>getter method for the user-header size </p> <p>Return: the user-header size </p>","title":"function userHeaderSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userheaderalignment","text":"<pre><code>uint32_t userHeaderAlignment() const\n</code></pre> <p>getter method for the user-header alignment </p> <p>Return: the user-header alignment </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function userHeaderAlignment"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ChunkSender/","text":"<p>More...</p>","title":"iox::popo::ChunkSender"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ChunkSender/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::popo::ChunkSender;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/","text":"<p>The Client class for the request-response messaging pattern in iceoryx.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/client.hpp&gt;</code></p> <p>Inherits from ClientImpl&lt; Req, Res &gt;</p>","title":"iox::popo::Client"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#public-functions","text":"Name     virtual ~Client()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#detailed-description","text":"<pre><code>template &lt;typename Req ,\ntypename Res &gt;\nclass iox::popo::Client;\n</code></pre> <p>The Client class for the request-response messaging pattern in iceoryx. </p> <p>Parameters: </p> <ul> <li>Req type of request data </li> <li>Res type of response data </li> </ul>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#function-client","text":"<pre><code>inline virtual ~Client()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~Client"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/","text":"<p>Inherits from iox::popo::ListenerImpl&lt; MAX_NUMBER_OF_EVENTS_PER_LISTENER &gt;</p>","title":"iox::popo::Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-types","text":"Name     using ListenerImpl&lt; MAX_NUMBER_OF_EVENTS_PER_LISTENER &gt; Parent","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-functions","text":"Name      Listener()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#protected-functions","text":"Name      Listener(ConditionVariableData &amp; conditionVariableData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#additional-inherited-members","text":"<p>Public Functions inherited from iox::popo::ListenerImpl&lt; MAX_NUMBER_OF_EVENTS_PER_LISTENER &gt;</p>     Name      ListenerImpl()    ListenerImpl(const ListenerImpl &amp; )    ListenerImpl(ListenerImpl &amp;&amp; )    ~ListenerImpl()   ListenerImpl &amp; operator=(const ListenerImpl &amp; )   ListenerImpl &amp; operator=(ListenerImpl &amp;&amp; )   template &lt;typename T ,typename EventType ,typename ContextDataType ,typename  =std::enable_if_t::value&gt;&gt; cxx::expected&lt; ListenerError &gt; attachEvent(T &amp; eventOrigin, const EventType eventType, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs.   template &lt;typename T ,typename ContextDataType &gt; cxx::expected&lt; ListenerError &gt; attachEvent(T &amp; eventOrigin, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs.   template &lt;typename T ,typename EventType ,typename  =std::enable_if_t::value&gt;&gt; void detachEvent(T &amp; eventOrigin, const EventType eventType)Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin.   template &lt;typename T &gt; void detachEvent(T &amp; eventOrigin)Detaches an event. Hereby, the event is defined as a class T, the eventOrigin.   uint64_t size() constReturns the size of the Listener.   constexpr uint64_t capacity()Returns the capacity of the Listener.    <p>Protected Functions inherited from iox::popo::ListenerImpl&lt; MAX_NUMBER_OF_EVENTS_PER_LISTENER &gt;</p>     Name      ListenerImpl(ConditionVariableData &amp; conditionVariableData)","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#using-parent","text":"<pre><code>using iox::popo::Listener::Parent =  ListenerImpl&lt;MAX_NUMBER_OF_EVENTS_PER_LISTENER&gt;;\n</code></pre>","title":"using Parent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#function-listener","text":"<pre><code>Listener()\n</code></pre>","title":"function Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#function-listener_1","text":"<pre><code>Listener(\n    ConditionVariableData &amp; conditionVariableData\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/","text":"<p>The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/listener.hpp&gt;</code></p>","title":"iox::popo::ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#public-functions","text":"Name      ListenerImpl()    ListenerImpl(const ListenerImpl &amp; )    ListenerImpl(ListenerImpl &amp;&amp; )    ~ListenerImpl()   ListenerImpl &amp; operator=(const ListenerImpl &amp; )   ListenerImpl &amp; operator=(ListenerImpl &amp;&amp; )   template &lt;typename T ,typename EventType ,typename ContextDataType ,typename  =std::enable_if_t::value&gt;&gt; cxx::expected&lt; ListenerError &gt; attachEvent(T &amp; eventOrigin, const EventType eventType, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs.   template &lt;typename T ,typename ContextDataType &gt; cxx::expected&lt; ListenerError &gt; attachEvent(T &amp; eventOrigin, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs.   template &lt;typename T ,typename EventType ,typename  =std::enable_if_t::value&gt;&gt; void detachEvent(T &amp; eventOrigin, const EventType eventType)Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin.   template &lt;typename T &gt; void detachEvent(T &amp; eventOrigin)Detaches an event. Hereby, the event is defined as a class T, the eventOrigin.   uint64_t size() constReturns the size of the Listener.   constexpr uint64_t capacity()Returns the capacity of the Listener.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#protected-functions","text":"Name      ListenerImpl(ConditionVariableData &amp; conditionVariableData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#detailed-description","text":"<pre><code>template &lt;uint64_t Capacity&gt;\nclass iox::popo::ListenerImpl;\n</code></pre> <p>The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. </p> <p>Note: The Listener is threadsafe and can be used without any restrictions concurrently. </p> <p>Attention: Calling detachEvent for the same event from multiple threads is supported but can cause a race condition if you attach the same event again concurrently from another thread. Example:</p> <ol> <li>One calls detachEvent [1] from thread A, B and C</li> <li>thread B wins and detaches event [1]</li> <li>A new thread D spawns and would like to attach event [1] again while thread A and C are still waiting to detach [1].</li> <li>Thread A wins but cannot detach event [1] since it is not attached.</li> <li>Thread D wins and attaches event [1].</li> <li>Finally thread C can continue and detaches event [1] again.</li> </ol> <p>If thread D is executed last then the event is attached. So depending on the operating system defined execution order the event is either attached or detached.</p> <p>Best practice: Detach a specific event only from one specific thread and not from multiple contexts. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl","text":"<pre><code>ListenerImpl()\n</code></pre>","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_1","text":"<pre><code>ListenerImpl(\n    const ListenerImpl &amp; \n)\n</code></pre>","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_2","text":"<pre><code>ListenerImpl(\n    ListenerImpl &amp;&amp; \n)\n</code></pre>","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_3","text":"<pre><code>~ListenerImpl()\n</code></pre>","title":"function ~ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-operator","text":"<pre><code>ListenerImpl &amp; operator=(\n    const ListenerImpl &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-operator_1","text":"<pre><code>ListenerImpl &amp; operator=(\n    ListenerImpl &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-attachevent","text":"<pre><code>template &lt;typename T ,\ntypename EventType ,\ntypename ContextDataType ,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\ncxx::expected&lt; ListenerError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const EventType eventType,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback\n)\n</code></pre> <p>Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. </p> <p>Template Parameters: </p>  <p>Note: This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-attachevent_1","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType &gt;\ncxx::expected&lt; ListenerError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback\n)\n</code></pre> <p>Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. </p> <p>Template Parameters: </p>  <p>Note: This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-detachevent","text":"<pre><code>template &lt;typename T ,\ntypename EventType ,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\nvoid detachEvent(\n    T &amp; eventOrigin,\n    const EventType eventType\n)\n</code></pre> <p>Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. </p> <p>Template Parameters: </p>  <p>Note: This method can be called from any thread concurrently without any restrictions! </p>","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-detachevent_1","text":"<pre><code>template &lt;typename T &gt;\nvoid detachEvent(\n    T &amp; eventOrigin\n)\n</code></pre> <p>Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. </p> <p>Template Parameters: </p>  <p>Note: This method can be called from any thread concurrently without any restrictions! </p>","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>Returns the size of the Listener. </p> <p>Return: size of the Listener</p>","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-capacity","text":"<pre><code>static constexpr uint64_t capacity()\n</code></pre> <p>Returns the capacity of the Listener. </p> <p>Return: capacity of the Listener</p>","title":"function capacity"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_4","text":"<pre><code>ListenerImpl(\n    ConditionVariableData &amp; conditionVariableData\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/","text":"","title":"iox::popo::ListenerImpl::IndexManager_t"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-types","text":"Name     using concurrent::LoFFLi LoFFLi","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-functions","text":"Name      IndexManager_t()   bool pop(uint32_t &amp; index)   void push(const uint32_t index)   uint64_t indicesInUse() const","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-attributes","text":"Name     LoFFLi::Index_t m_loffliStorage   LoFFLi m_loffli   std::atomic&lt; uint64_t &gt; m_indicesInUse","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#using-loffli","text":"<pre><code>using iox::popo::ListenerImpl&lt; Capacity &gt;::IndexManager_t::LoFFLi =  concurrent::LoFFLi;\n</code></pre>","title":"using LoFFLi"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-indexmanager_t","text":"<pre><code>IndexManager_t()\n</code></pre>","title":"function IndexManager_t"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-pop","text":"<pre><code>bool pop(\n    uint32_t &amp; index\n)\n</code></pre>","title":"function pop"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-push","text":"<pre><code>void push(\n    const uint32_t index\n)\n</code></pre>","title":"function push"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-indicesinuse","text":"<pre><code>uint64_t indicesInUse() const\n</code></pre>","title":"function indicesInUse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_lofflistorage","text":"<pre><code>LoFFLi::Index_t m_loffliStorage;\n</code></pre>","title":"variable m_loffliStorage"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_loffli","text":"<pre><code>LoFFLi m_loffli;\n</code></pre>","title":"variable m_loffli"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_indicesinuse","text":"<pre><code>std::atomic&lt; uint64_t &gt; m_indicesInUse {0U};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_indicesInUse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/","text":"<p>Class which allows accessing private methods to friends of NotificationAttorney. Used for example by the WaitSet. Implements the Client-Attorney Pattern.  <code>#include &lt;iceoryx_posh/popo/notification_attorney.hpp&gt;</code></p>","title":"iox::popo::NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friends","text":"Name     class WaitSet   class ListenerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friend-waitset","text":"<pre><code>friend class WaitSet(\n    WaitSet \n);\n</code></pre>","title":"friend WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friend-listenerimpl","text":"<pre><code>friend class ListenerImpl(\n    ListenerImpl \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/","text":"<p>NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback.  <code>#include &lt;iceoryx_posh/popo/notification_info.hpp&gt;</code></p>","title":"iox::popo::NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-functions","text":"Name      NotificationInfo() =defaultconstructs an empty NotificationInfo   virtual ~NotificationInfo() =default   template &lt;typename T ,typename ContextDataType &gt;  NotificationInfo(T *const notificationOrigin, const uint64_t notificationId, const NotificationCallback&lt; T, ContextDataType &gt; &amp; callback)constructs a NotificationInfo object   uint64_t getNotificationId() constreturns the notification id   template &lt;typename T &gt; bool doesOriginateFrom(T *const notificationOrigin) constconfirms the notificationOrigin   template &lt;typename T &gt; T * getOrigin() constreturns the pointer to the notificationOrigin.   bool operator()() constIf a callback is set it executes the callback.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-attributes","text":"Name     constexpr uint64_t INVALID_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#protected-attributes","text":"Name     void * m_notificationOrigin   void * m_userValue   uint64_t m_notificationOriginTypeHash   uint64_t m_notificationId   internal::GenericCallbackPtr_t m_callbackPtr   internal::TranslationCallbackPtr_t m_callback","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friends","text":"Name     class Trigger","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo","text":"<pre><code>NotificationInfo() =default\n</code></pre> <p>constructs an empty NotificationInfo</p>","title":"function NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo_1","text":"<pre><code>virtual ~NotificationInfo() =default\n</code></pre>","title":"function ~NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo_2","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType &gt;\nNotificationInfo(\n    T *const notificationOrigin,\n    const uint64_t notificationId,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; callback\n)\n</code></pre> <p>constructs a NotificationInfo object </p> <p>Parameters: </p> <ul> <li>notificationOrigin the origin of the event </li> <li>notificationId id of the event </li> <li>callback the callback of the event </li> </ul>","title":"function NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-getnotificationid","text":"<pre><code>uint64_t getNotificationId() const\n</code></pre> <p>returns the notification id </p> <p>Return: the empty NotificationInfo always returns INVALID_ID, otherwise the actual notificationId is returned which can also be INVALID_ID </p>","title":"function getNotificationId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-doesoriginatefrom","text":"<pre><code>template &lt;typename T &gt;\nbool doesOriginateFrom(\n    T *const notificationOrigin\n) const\n</code></pre> <p>confirms the notificationOrigin </p> <p>Parameters: </p> <ul> <li>notificationOrigin the possible notificationOrigin </li> </ul> <p>Return: true if the address is equal to the notificationOrigin, otherwise false. The empty NotificationInfo returns always false. </p>","title":"function doesOriginateFrom"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-getorigin","text":"<pre><code>template &lt;typename T &gt;\nT * getOrigin() const\n</code></pre> <p>returns the pointer to the notificationOrigin. </p> <p>Return: If T equals the Triggerable type it returns the notificationOrigin. Otherwise it calls the errorHandler with a moderate error of kPOPO__EVENT_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN and returns nullptr. </p>","title":"function getOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-operator","text":"<pre><code>bool operator()() const\n</code></pre> <p>If a callback is set it executes the callback. </p> <p>Return: true if the callback was called, otherwise false </p>","title":"function operator()"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-invalid_id","text":"<pre><code>static constexpr uint64_t INVALID_ID = std::numeric_limits&lt;uint64_t&gt;::max();\n</code></pre>","title":"variable INVALID_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationorigin","text":"<pre><code>void * m_notificationOrigin = nullptr;\n</code></pre>","title":"variable m_notificationOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_uservalue","text":"<pre><code>void * m_userValue = nullptr;\n</code></pre>","title":"variable m_userValue"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationorigintypehash","text":"<pre><code>uint64_t m_notificationOriginTypeHash = 0U;\n</code></pre>","title":"variable m_notificationOriginTypeHash"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationid","text":"<pre><code>uint64_t m_notificationId = INVALID_ID;\n</code></pre>","title":"variable m_notificationId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_callbackptr","text":"<pre><code>internal::GenericCallbackPtr_t m_callbackPtr = nullptr;\n</code></pre>","title":"variable m_callbackPtr"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_callback","text":"<pre><code>internal::TranslationCallbackPtr_t m_callback = nullptr;\n</code></pre>","title":"variable m_callback"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friend-trigger","text":"<pre><code>friend class Trigger(\n    Trigger \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/","text":"<p>The Publisher class for the publish-subscribe messaging pattern in iceoryx.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/publisher.hpp&gt;</code></p> <p>Inherits from PublisherImpl&lt; T, mepoo::NoUserHeader &gt;</p>","title":"iox::popo::Publisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename H  =mepoo::NoUserHeader&gt;\nclass iox::popo::Publisher;\n</code></pre> <p>The Publisher class for the publish-subscribe messaging pattern in iceoryx. </p> <p>Parameters: </p> <ul> <li>T user payload type </li> <li>H user header type </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherInterface/","text":"<p>More...</p>","title":"iox::popo::PublisherInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherInterface/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename H &gt;\nclass iox::popo::PublisherInterface;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/","text":"<p>The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/request.hpp&gt;</code></p> <p>Inherits from SmartChunk&lt; RpcInterface&lt; Request&lt; T &gt;, ClientSendError &gt;, T, cxx::add_const_conditionally_t&lt; RequestHeader, T &gt; &gt;</p>","title":"iox::popo::Request"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#public-functions","text":"Name     template &lt;typename S  =T,typename  =ForClientOnly&gt; cxx::expected&lt; ClientSendError &gt; send()Sends the request via the client from which it was loaned and automatically release ownership to it.   cxx::add_const_conditionally_t&lt; RequestHeader, T &gt; &amp; getRequestHeader()Retrieve the request-header of the underlying memory chunk loaned to the sample.   const RequestHeader &amp; getRequestHeader() constRetrieve the request-header of the underlying memory chunk loaned to the sample.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friends","text":"Name     class ClientImpl   class ServerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::popo::Request;\n</code></pre> <p>The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-send","text":"<pre><code>template &lt;typename S  =T,\ntypename  =ForClientOnly&lt;S, T&gt;&gt;\ncxx::expected&lt; ClientSendError &gt; send()\n</code></pre> <p>Sends the request via the client from which it was loaned and automatically release ownership to it. </p> <p>Only available for client (non-const type T) </p>","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-getrequestheader","text":"<pre><code>cxx::add_const_conditionally_t&lt; RequestHeader, T &gt; &amp; getRequestHeader()\n</code></pre> <p>Retrieve the request-header of the underlying memory chunk loaned to the sample. </p> <p>Return: The request-header of the underlying memory chunk. </p>","title":"function getRequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-getrequestheader_1","text":"<pre><code>const RequestHeader &amp; getRequestHeader() const\n</code></pre> <p>Retrieve the request-header of the underlying memory chunk loaned to the sample. </p> <p>Return: The request-header of the underlying memory chunk. </p>","title":"function getRequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friend-clientimpl","text":"<pre><code>friend class ClientImpl(\n    ClientImpl \n);\n</code></pre>","title":"friend ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friend-serverimpl","text":"<pre><code>friend class ServerImpl(\n    ServerImpl \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/","text":"<p>Inherits from iox::popo::RpcBaseHeader</p>","title":"iox::popo::RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#public-functions","text":"Name      RequestHeader(const cxx::UniqueId &amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex)Constructs and initializes a RpcBaseHeader.    RequestHeader(const RequestHeader &amp; other)   RequestHeader &amp; operator=(const RequestHeader &amp; )    RequestHeader(RequestHeader &amp;&amp; rhs) =default   RequestHeader &amp; operator=(RequestHeader &amp;&amp; rhs) =default    ~RequestHeader() =default   void setSequenceId(const int64_t sequenceId)Sets the sequence ID which is used to match a response to a request.   RequestHeader * fromPayload(void *const payload)   const RequestHeader * fromPayload(const void *const payload)","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#additional-inherited-members","text":"<p>Public Functions inherited from iox::popo::RpcBaseHeader</p>     Name      RpcBaseHeader(const cxx::UniqueId &amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion)Constructs and initializes a RpcBaseHeader.    RpcBaseHeader(const RpcBaseHeader &amp; other)    RpcBaseHeader(RpcBaseHeader &amp;&amp; rhs) =default    ~RpcBaseHeader() =default   uint8_t getRpcHeaderVersion() constThe RpcBaseHeader version is used to detect incompatibilities for record&amp;replay functionality.   int64_t getSequenceId() const   mepoo::ChunkHeader * getChunkHeader()Get the pointer to the ChunkHeader.   const mepoo::ChunkHeader * getChunkHeader() constGet the const pointer to the ChunkHeader.   void * getUserPayload()Get the pointer to the user-payload.   const void * getUserPayload() constGet the const pointer to the user-payload.    <p>Public Attributes inherited from iox::popo::RpcBaseHeader</p>     Name     constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g.   constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX   constexpr int64_t START_SEQUENCE_ID    <p>Protected Attributes inherited from iox::popo::RpcBaseHeader</p>     Name     uint8_t m_rpcHeaderVersion   uint32_t m_lastKnownClientQueueIndex   cxx::UniqueId m_uniqueClientQueueId   int64_t m_sequenceId    <p>Friends inherited from iox::popo::RpcBaseHeader</p>     Name     class ServerPortUser","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader","text":"<pre><code>explicit RequestHeader(\n    const cxx::UniqueId &amp; uniqueClientQueueId,\n    const uint32_t lastKnownClientQueueIndex\n)\n</code></pre> <p>Constructs and initializes a RpcBaseHeader. </p> <p>Parameters: </p> <ul> <li>uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered </li> <li>lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup </li> </ul>","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_1","text":"<pre><code>RequestHeader(\n    const RequestHeader &amp; other\n)\n</code></pre>","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-operator","text":"<pre><code>RequestHeader &amp; operator=(\n    const RequestHeader &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_2","text":"<pre><code>RequestHeader(\n    RequestHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-operator_1","text":"<pre><code>RequestHeader &amp; operator=(\n    RequestHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_3","text":"<pre><code>~RequestHeader() =default\n</code></pre>","title":"function ~RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-setsequenceid","text":"<pre><code>void setSequenceId(\n    const int64_t sequenceId\n)\n</code></pre> <p>Sets the sequence ID which is used to match a response to a request. </p> <p>Parameters: </p> <ul> <li>sequenceId is a consecutive number set by the user </li> </ul> <p>Note: The user has to set this manually if multiple requests are sent before a response is read since a server might drop a requests or process the requests out of order and therefore the responses might also be out of order </p>","title":"function setSequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-frompayload","text":"<pre><code>static RequestHeader * fromPayload(\n    void *const payload\n)\n</code></pre>","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-frompayload_1","text":"<pre><code>static const RequestHeader * fromPayload(\n    const void *const payload\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/","text":"<p>The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/response.hpp&gt;</code></p> <p>Inherits from SmartChunk&lt; RpcInterface&lt; Response&lt; T &gt;, ServerSendError &gt;, T, cxx::add_const_conditionally_t&lt; ResponseHeader, T &gt; &gt;</p>","title":"iox::popo::Response"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#public-functions","text":"Name     template &lt;typename S  =T,typename  =ForServerOnly&gt; cxx::expected&lt; ServerSendError &gt; send()Sends the response via the server from which it was loaned and automatically release ownership to it.   cxx::add_const_conditionally_t&lt; ResponseHeader, T &gt; &amp; getResponseHeader()Retrieve the response-header of the underlying memory chunk loaned to the sample.   const ResponseHeader &amp; getResponseHeader() constRetrieve the response-header of the underlying memory chunk loaned to the sample.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friends","text":"Name     class ClientImpl   class ServerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::popo::Response;\n</code></pre> <p>The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-send","text":"<pre><code>template &lt;typename S  =T,\ntypename  =ForServerOnly&lt;S, T&gt;&gt;\ncxx::expected&lt; ServerSendError &gt; send()\n</code></pre> <p>Sends the response via the server from which it was loaned and automatically release ownership to it. </p> <p>Only available for server (non-const type T) </p>","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-getresponseheader","text":"<pre><code>cxx::add_const_conditionally_t&lt; ResponseHeader, T &gt; &amp; getResponseHeader()\n</code></pre> <p>Retrieve the response-header of the underlying memory chunk loaned to the sample. </p> <p>Return: The response-header of the underlying memory chunk. </p>","title":"function getResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-getresponseheader_1","text":"<pre><code>const ResponseHeader &amp; getResponseHeader() const\n</code></pre> <p>Retrieve the response-header of the underlying memory chunk loaned to the sample. </p> <p>Return: The response-header of the underlying memory chunk. </p>","title":"function getResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friend-clientimpl","text":"<pre><code>friend class ClientImpl(\n    ClientImpl \n);\n</code></pre>","title":"friend ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friend-serverimpl","text":"<pre><code>friend class ServerImpl(\n    ServerImpl \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/","text":"<p>Inherits from iox::popo::RpcBaseHeader</p>","title":"iox::popo::ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#public-functions","text":"Name      ResponseHeader(const cxx::UniqueId &amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId)Constructs and initializes a RpcBaseHeader.    ResponseHeader(const ResponseHeader &amp; other)   ResponseHeader &amp; operator=(const ResponseHeader &amp; )    ResponseHeader(ResponseHeader &amp;&amp; rhs) =default   ResponseHeader &amp; operator=(ResponseHeader &amp;&amp; rhs) =default    ~ResponseHeader() =default   void setServerError()Sets the server error flag.   bool hasServerError() constObtains the server error flag.   ResponseHeader * fromPayload(void *const payload)   const ResponseHeader * fromPayload(const void *const payload)","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#additional-inherited-members","text":"<p>Public Functions inherited from iox::popo::RpcBaseHeader</p>     Name      RpcBaseHeader(const cxx::UniqueId &amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion)Constructs and initializes a RpcBaseHeader.    RpcBaseHeader(const RpcBaseHeader &amp; other)    RpcBaseHeader(RpcBaseHeader &amp;&amp; rhs) =default    ~RpcBaseHeader() =default   uint8_t getRpcHeaderVersion() constThe RpcBaseHeader version is used to detect incompatibilities for record&amp;replay functionality.   int64_t getSequenceId() const   mepoo::ChunkHeader * getChunkHeader()Get the pointer to the ChunkHeader.   const mepoo::ChunkHeader * getChunkHeader() constGet the const pointer to the ChunkHeader.   void * getUserPayload()Get the pointer to the user-payload.   const void * getUserPayload() constGet the const pointer to the user-payload.    <p>Public Attributes inherited from iox::popo::RpcBaseHeader</p>     Name     constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g.   constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX   constexpr int64_t START_SEQUENCE_ID    <p>Protected Attributes inherited from iox::popo::RpcBaseHeader</p>     Name     uint8_t m_rpcHeaderVersion   uint32_t m_lastKnownClientQueueIndex   cxx::UniqueId m_uniqueClientQueueId   int64_t m_sequenceId    <p>Friends inherited from iox::popo::RpcBaseHeader</p>     Name     class ServerPortUser","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader","text":"<pre><code>explicit ResponseHeader(\n    const cxx::UniqueId &amp; uniqueClientQueueId,\n    const uint32_t lastKnownClientQueueIndex,\n    const int64_t sequenceId\n)\n</code></pre> <p>Constructs and initializes a RpcBaseHeader. </p> <p>Parameters: </p> <ul> <li>uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered </li> <li>lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup </li> <li>sequenceId is a custom ID to map a response to a request </li> </ul>","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_1","text":"<pre><code>ResponseHeader(\n    const ResponseHeader &amp; other\n)\n</code></pre>","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-operator","text":"<pre><code>ResponseHeader &amp; operator=(\n    const ResponseHeader &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_2","text":"<pre><code>ResponseHeader(\n    ResponseHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-operator_1","text":"<pre><code>ResponseHeader &amp; operator=(\n    ResponseHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_3","text":"<pre><code>~ResponseHeader() =default\n</code></pre>","title":"function ~ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-setservererror","text":"<pre><code>void setServerError()\n</code></pre> <p>Sets the server error flag. </p>","title":"function setServerError"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-hasservererror","text":"<pre><code>bool hasServerError() const\n</code></pre> <p>Obtains the server error flag. </p> <p>Return: true if there is an error, false otherwise </p>","title":"function hasServerError"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-frompayload","text":"<pre><code>static ResponseHeader * fromPayload(\n    void *const payload\n)\n</code></pre>","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-frompayload_1","text":"<pre><code>static const ResponseHeader * fromPayload(\n    const void *const payload\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/","text":"<p>Inherited by iox::popo::RequestHeader, iox::popo::ResponseHeader</p>","title":"iox::popo::RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-functions","text":"Name      RpcBaseHeader(const cxx::UniqueId &amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion)Constructs and initializes a RpcBaseHeader.    RpcBaseHeader(const RpcBaseHeader &amp; other)   RpcBaseHeader &amp; operator=(const RpcBaseHeader &amp; )    RpcBaseHeader(RpcBaseHeader &amp;&amp; rhs) =default   RpcBaseHeader &amp; operator=(RpcBaseHeader &amp;&amp; rhs) =default    ~RpcBaseHeader() =default   uint8_t getRpcHeaderVersion() constThe RpcBaseHeader version is used to detect incompatibilities for record&amp;replay functionality.   int64_t getSequenceId() const   mepoo::ChunkHeader * getChunkHeader()Get the pointer to the ChunkHeader.   const mepoo::ChunkHeader * getChunkHeader() constGet the const pointer to the ChunkHeader.   void * getUserPayload()Get the pointer to the user-payload.   const void * getUserPayload() constGet the const pointer to the user-payload.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-attributes","text":"Name     constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g.   constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX   constexpr int64_t START_SEQUENCE_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#protected-attributes","text":"Name     uint8_t m_rpcHeaderVersion   uint32_t m_lastKnownClientQueueIndex   cxx::UniqueId m_uniqueClientQueueId   int64_t m_sequenceId","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friends","text":"Name     class ServerPortUser","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader","text":"<pre><code>explicit RpcBaseHeader(\n    const cxx::UniqueId &amp; uniqueClientQueueId,\n    const uint32_t lastKnownClientQueueIndex,\n    const int64_t sequenceId,\n    const uint8_t rpcHeaderVersion\n)\n</code></pre> <p>Constructs and initializes a RpcBaseHeader. </p> <p>Parameters: </p> <ul> <li>uniqueClientQueueId is the cxx::UniqueId of the client queue where the response shall be delivered </li> <li>lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup </li> <li>sequenceId is a custom ID to map a response to a request </li> <li>rpcHeaderVersion is set by RequestHeader/ResponseHeader and should be RPC_HEADER_VERSION </li> </ul>","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_1","text":"<pre><code>RpcBaseHeader(\n    const RpcBaseHeader &amp; other\n)\n</code></pre>","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-operator","text":"<pre><code>RpcBaseHeader &amp; operator=(\n    const RpcBaseHeader &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_2","text":"<pre><code>RpcBaseHeader(\n    RpcBaseHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-operator_1","text":"<pre><code>RpcBaseHeader &amp; operator=(\n    RpcBaseHeader &amp;&amp; rhs\n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_3","text":"<pre><code>~RpcBaseHeader() =default\n</code></pre>","title":"function ~RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getrpcheaderversion","text":"<pre><code>uint8_t getRpcHeaderVersion() const\n</code></pre> <p>The RpcBaseHeader version is used to detect incompatibilities for record&amp;replay functionality. </p> <p>Return: the RpcBaseHeader version </p>","title":"function getRpcHeaderVersion"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getsequenceid","text":"<pre><code>int64_t getSequenceId() const\n</code></pre> <p>Return: the sequenceId of the RPC message </p> <p>@briet Obtains the sequence ID of the RPC message </p>","title":"function getSequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getchunkheader","text":"<pre><code>mepoo::ChunkHeader * getChunkHeader()\n</code></pre> <p>Get the pointer to the ChunkHeader. </p> <p>Return: the pointer to the ChunkHeader </p>","title":"function getChunkHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getchunkheader_1","text":"<pre><code>const mepoo::ChunkHeader * getChunkHeader() const\n</code></pre> <p>Get the const pointer to the ChunkHeader. </p> <p>Return: the const pointer to the ChunkHeader </p>","title":"function getChunkHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getuserpayload","text":"<pre><code>void * getUserPayload()\n</code></pre> <p>Get the pointer to the user-payload. </p> <p>Return: the pointer to the user-payload </p>","title":"function getUserPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getuserpayload_1","text":"<pre><code>const void * getUserPayload() const\n</code></pre> <p>Get the const pointer to the user-payload. </p> <p>Return: the const pointer to the user-payload </p>","title":"function getUserPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-rpc_header_version","text":"<pre><code>static constexpr uint8_t RPC_HEADER_VERSION {1U};\n</code></pre> <p>From the 2.0 release onward, this must be incremented for each incompatible change, e.g. </p> <ul> <li>data width of members changes</li> <li>members are rearranged</li> <li>semantic meaning of a member changes in any of RpcBaseHeader, RequestHeader or ResponseHeader! </li> </ul>","title":"variable RPC_HEADER_VERSION"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-unknown_client_queue_index","text":"<pre><code>static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX {std::numeric_limits&lt;uint32_t&gt;::max()};\n</code></pre>","title":"variable UNKNOWN_CLIENT_QUEUE_INDEX"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-start_sequence_id","text":"<pre><code>static constexpr int64_t START_SEQUENCE_ID {0};\n</code></pre>","title":"variable START_SEQUENCE_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_rpcheaderversion","text":"<pre><code>uint8_t m_rpcHeaderVersion {[RPC_HEADER_VERSION](/v2.0.0/API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-rpc_header_version)};\n</code></pre>","title":"variable m_rpcHeaderVersion"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_lastknownclientqueueindex","text":"<pre><code>uint32_t m_lastKnownClientQueueIndex {UNKNOWN_CLIENT_QUEUE_INDEX};\n</code></pre>","title":"variable m_lastKnownClientQueueIndex"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_uniqueclientqueueid","text":"<pre><code>cxx::UniqueId m_uniqueClientQueueId;\n</code></pre>","title":"variable m_uniqueClientQueueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_sequenceid","text":"<pre><code>int64_t m_sequenceId {0};\n</code></pre>","title":"variable m_sequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friend-serverportuser","text":"<pre><code>friend class ServerPortUser(\n    ServerPortUser \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend ServerPortUser"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcInterface/","text":"<p>More...</p>","title":"iox::popo::RpcInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcInterface/#detailed-description","text":"<pre><code>template &lt;typename RpcType ,\ntypename SendErrorEnum &gt;\nclass iox::popo::RpcInterface;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/","text":"<p>The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/sample.hpp&gt;</code></p> <p>Inherits from SmartChunk&lt; PublisherInterface&lt; T, cxx::add_const_conditionally_t&lt; mepoo::NoUserHeader, T &gt; &gt;, T, cxx::add_const_conditionally_t&lt; mepoo::NoUserHeader, T &gt; &gt;</p>","title":"iox::popo::Sample"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-types","text":"Name     template &lt;typename T1 ,typename T2 &gt; using typename BaseType::template ForProducerOnly&lt; T1, T2 &gt; ForPublisherOnly","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-functions","text":"Name     template &lt;typename S  =T,typename  =ForPublisherOnly&gt; void publish()Publish the sample via the publisher from which it was loaned and automatically release ownership to it.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friends","text":"Name     class PublisherImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename H  =cxx::add_const_conditionally_t&lt;mepoo::NoUserHeader, T&gt;&gt;\nclass iox::popo::Sample;\n</code></pre> <p>The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#using-forpublisheronly","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 &gt;\nusing iox::popo::Sample&lt; T, H &gt;::ForPublisherOnly =  typename BaseType::template ForProducerOnly&lt;T1, T2&gt;;\n</code></pre>","title":"using ForPublisherOnly"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#function-publish","text":"<pre><code>template &lt;typename S  =T,\ntypename  =ForPublisherOnly&lt;S, T&gt;&gt;\nvoid publish()\n</code></pre> <p>Publish the sample via the publisher from which it was loaned and automatically release ownership to it. </p> <p>Only available for non-const type T. </p>","title":"function publish"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friend-publisherimpl","text":"<pre><code>friend class PublisherImpl(\n    PublisherImpl \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/","text":"<p>The Server class for the request-response messaging pattern in iceoryx.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/server.hpp&gt;</code></p> <p>Inherits from ServerImpl&lt; Req, Res &gt;</p>","title":"iox::popo::Server"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#public-functions","text":"Name     virtual ~Server()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#detailed-description","text":"<pre><code>template &lt;typename Req ,\ntypename Res &gt;\nclass iox::popo::Server;\n</code></pre> <p>The Server class for the request-response messaging pattern in iceoryx. </p> <p>Parameters: </p> <ul> <li>Req type of request data </li> <li>Res type of response data </li> </ul>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#function-server","text":"<pre><code>inline virtual ~Server()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~Server"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/","text":"<p>The Subscriber class for the publish-subscribe messaging pattern in iceoryx.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/subscriber.hpp&gt;</code></p> <p>Inherits from SubscriberImpl&lt; T, mepoo::NoUserHeader &gt;</p>","title":"iox::popo::Subscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#public-functions","text":"Name     virtual ~Subscriber()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#detailed-description","text":"<pre><code>template &lt;typename T ,\ntypename H  =mepoo::NoUserHeader&gt;\nclass iox::popo::Subscriber;\n</code></pre> <p>The Subscriber class for the publish-subscribe messaging pattern in iceoryx. </p> <p>Parameters: </p> <ul> <li>T user payload type </li> <li>H user header type </li> </ul>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#function-subscriber","text":"<pre><code>inline virtual ~Subscriber()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~Subscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/","text":"<p>The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance.  <code>#include &lt;iceoryx_posh/popo/trigger.hpp&gt;</code></p>","title":"iox::popo::Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-functions","text":"Name      Trigger()    Trigger(const Trigger &amp; )   Trigger &amp; operator=(const Trigger &amp; )   template &lt;typename T ,typename UserType &gt;  Trigger(StateBasedTrigger_t , T *const stateOrigin, const cxx::ConstMethodCallback&lt; bool &gt; &amp; hasTriggeredCallback, const cxx::MethodCallback&lt; void, uint64_t &gt; &amp; resetCallback, const uint64_t notificationId, const NotificationCallback&lt; T, UserType &gt; &amp; callback, const uint64_t uniqueId, const uint64_t stateType, const uint64_t stateTypeHash)Creates a state based Trigger.   template &lt;typename T ,typename UserType &gt;  Trigger(EventBasedTrigger_t , T *const notificationOrigin, const cxx::MethodCallback&lt; void, uint64_t &gt; &amp; resetCallback, const uint64_t notificationId, const NotificationCallback&lt; T, UserType &gt; &amp; callback, const uint64_t uniqueId, const uint64_t notificationType, const uint64_t notificationTypeHash)Creates an event based Trigger.    Trigger(Trigger &amp;&amp; rhs)   Trigger &amp; operator=(Trigger &amp;&amp; rhs)    ~Trigger()calls reset on destruction    operator bool() constreturns true if the Trigger is valid otherwise false A trigger is valid when:   bool isValid() constreturns true if the trigger is valid otherwise false   bool isStateConditionSatisfied() constreturns the result of the provided hasTriggeredCallback   void reset()resets and invalidates the Trigger   void invalidate()invalidates the Trigger without calling the reset callback   uint64_t getUniqueId() constreturns the internal unique id of the trigger   bool isLogicalEqualTo(const void *const notificationOrigin, const uint64_t originTriggerType, const uint64_t originTriggerTypeHash) constreturns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when   template &lt;typename T &gt; void updateOrigin(T &amp; newOrigin)sets a new origin of the trigger   const NotificationInfo &amp; getNotificationInfo() constreturns the NotificationInfo   TriggerType getTriggerType() constreturns the type of trigger","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-attributes","text":"Name     constexpr uint64_t INVALID_TRIGGER_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger","text":"<pre><code>Trigger()\n</code></pre>","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_1","text":"<pre><code>Trigger(\n    const Trigger &amp; \n)\n</code></pre>","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator","text":"<pre><code>Trigger &amp; operator=(\n    const Trigger &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_2","text":"<pre><code>template &lt;typename T ,\ntypename UserType &gt;\nTrigger(\n    StateBasedTrigger_t ,\n    T *const stateOrigin,\n    const cxx::ConstMethodCallback&lt; bool &gt; &amp; hasTriggeredCallback,\n    const cxx::MethodCallback&lt; void, uint64_t &gt; &amp; resetCallback,\n    const uint64_t notificationId,\n    const NotificationCallback&lt; T, UserType &gt; &amp; callback,\n    const uint64_t uniqueId,\n    const uint64_t stateType,\n    const uint64_t stateTypeHash\n)\n</code></pre> <p>Creates a state based Trigger. </p> <p>Parameters: </p> <ul> <li>StateBasedTrigger_t signals that we are creating a state based trigger </li> <li>stateOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state </li> <li>hasTriggeredCallback callback to a method which informs the trigger if it was triggered or not. If an empty callback is set the trigger is in a defined but invalid state. </li> <li>resetCallback callback which is called when the trigger goes out of scope. </li> <li>notificationId id of the corresponding event/state </li> <li>callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. </li> <li>uniqueId a context wide unique id to identify the trigger </li> <li>stateType the uint64_t value of the state origins state enum </li> <li>stateTypeHash the uint64_t type hash of the state enum </li> </ul>","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_3","text":"<pre><code>template &lt;typename T ,\ntypename UserType &gt;\nTrigger(\n    EventBasedTrigger_t ,\n    T *const notificationOrigin,\n    const cxx::MethodCallback&lt; void, uint64_t &gt; &amp; resetCallback,\n    const uint64_t notificationId,\n    const NotificationCallback&lt; T, UserType &gt; &amp; callback,\n    const uint64_t uniqueId,\n    const uint64_t notificationType,\n    const uint64_t notificationTypeHash\n)\n</code></pre> <p>Creates an event based Trigger. </p> <p>Parameters: </p> <ul> <li>EventBasedTrigger_t signals that we are creating an event based trigger </li> <li>notificationOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state </li> <li>resetCallback callback which is called when the trigger goes out of scope. </li> <li>notificationId id of the corresponding event </li> <li>callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. </li> <li>uniqueId a context wide unique id to identify the trigger </li> <li>notificationType the uint64_t value of the events origins event enum </li> <li>notificationTypeHash the uint64_t type hash of the event enum </li> </ul>","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_4","text":"<pre><code>Trigger(\n    Trigger &amp;&amp; rhs\n)\n</code></pre>","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator_1","text":"<pre><code>Trigger &amp; operator=(\n    Trigger &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_5","text":"<pre><code>~Trigger()\n</code></pre> <p>calls reset on destruction </p>","title":"function ~Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>returns true if the Trigger is valid otherwise false A trigger is valid when: </p> <ul> <li>origin != nullptr</li> <li>hasTriggeredCallback is set </li> </ul>","title":"function operator bool"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-isvalid","text":"<pre><code>bool isValid() const\n</code></pre> <p>returns true if the trigger is valid otherwise false </p>","title":"function isValid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-isstateconditionsatisfied","text":"<pre><code>bool isStateConditionSatisfied() const\n</code></pre> <p>returns the result of the provided hasTriggeredCallback </p> <p>Note: an event based trigger returns always true when it's valid </p>","title":"function isStateConditionSatisfied"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-reset","text":"<pre><code>void reset()\n</code></pre> <p>resets and invalidates the Trigger</p>","title":"function reset"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-invalidate","text":"<pre><code>void invalidate()\n</code></pre> <p>invalidates the Trigger without calling the reset callback </p>","title":"function invalidate"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-getuniqueid","text":"<pre><code>uint64_t getUniqueId() const\n</code></pre> <p>returns the internal unique id of the trigger </p>","title":"function getUniqueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-islogicalequalto","text":"<pre><code>bool isLogicalEqualTo(\n    const void *const notificationOrigin,\n    const uint64_t originTriggerType,\n    const uint64_t originTriggerTypeHash\n) const\n</code></pre> <p>returns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when </p> <ul> <li>both Trigger are valid</li> <li>origin == rhs.origin</li> <li>originTriggerType == rhs.originTriggerType</li> <li>originTriggerTypeHash == rhs.originTriggerTypeHash </li> </ul>","title":"function isLogicalEqualTo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-updateorigin","text":"<pre><code>template &lt;typename T &gt;\nvoid updateOrigin(\n    T &amp; newOrigin\n)\n</code></pre> <p>sets a new origin of the trigger </p> <p>Parameters: </p> <ul> <li>newOrigin reference to the new origin </li> </ul>","title":"function updateOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-getnotificationinfo","text":"<pre><code>const NotificationInfo &amp; getNotificationInfo() const\n</code></pre> <p>returns the NotificationInfo</p>","title":"function getNotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-gettriggertype","text":"<pre><code>TriggerType getTriggerType() const\n</code></pre> <p>returns the type of trigger </p>","title":"function getTriggerType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#variable-invalid_trigger_id","text":"<pre><code>static constexpr uint64_t INVALID_TRIGGER_ID = std::numeric_limits&lt;uint64_t&gt;::max();\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable INVALID_TRIGGER_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/","text":"<p>TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable.  <code>#include &lt;iceoryx_posh/popo/trigger_handle.hpp&gt;</code></p>","title":"iox::popo::TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#public-functions","text":"Name      TriggerHandle()    TriggerHandle(ConditionVariableData &amp; conditionVariableData, const cxx::MethodCallback&lt; void, uint64_t &gt; resetCallback, const uint64_t uniqueTriggerId)Creates a TriggerHandle.    TriggerHandle(const TriggerHandle &amp; )   TriggerHandle &amp; operator=(const TriggerHandle &amp; )    TriggerHandle(TriggerHandle &amp;&amp; rhs)   TriggerHandle &amp; operator=(TriggerHandle &amp;&amp; rhs)    ~TriggerHandle()    operator bool() constreturns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr.   bool isValid() constreturns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr.   bool wasTriggered() constReturns true when the TriggerHandle was triggered.   void trigger()triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback   void reset()calls the resetCallback and invalidates the TriggerHandle   void invalidate()invalidates the TriggerHandle without calling the reset callback   uint64_t getUniqueId() constreturns the uniqueTriggerId   ConditionVariableData * getConditionVariableData()returns the pointer to the ConditionVariableData","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle","text":"<pre><code>TriggerHandle()\n</code></pre> <p>Note: explicitly implemented for MSVC and QNX </p>","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_1","text":"<pre><code>TriggerHandle(\n    ConditionVariableData &amp; conditionVariableData,\n    const cxx::MethodCallback&lt; void, uint64_t &gt; resetCallback,\n    const uint64_t uniqueTriggerId\n)\n</code></pre> <p>Creates a TriggerHandle. </p> <p>Parameters: </p> <ul> <li>conditionVariableDataRef reference to a condition variable data struct </li> <li>resetCallback callback which will be called it goes out of scope or reset is called </li> <li>uniqueTriggerId the unique trigger id of the Trigger which corresponds to the TriggerHandle. Usually stored in a Notifyable. It is required for the resetCallback </li> </ul>","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_2","text":"<pre><code>TriggerHandle(\n    const TriggerHandle &amp; \n)\n</code></pre>","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator","text":"<pre><code>TriggerHandle &amp; operator=(\n    const TriggerHandle &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_3","text":"<pre><code>TriggerHandle(\n    TriggerHandle &amp;&amp; rhs\n)\n</code></pre>","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator_1","text":"<pre><code>TriggerHandle &amp; operator=(\n    TriggerHandle &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_4","text":"<pre><code>~TriggerHandle()\n</code></pre>","title":"function ~TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator-bool","text":"<pre><code>explicit operator bool() const\n</code></pre> <p>returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. </p>","title":"function operator bool"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-isvalid","text":"<pre><code>bool isValid() const\n</code></pre> <p>returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. </p>","title":"function isValid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-wastriggered","text":"<pre><code>bool wasTriggered() const\n</code></pre> <p>Returns true when the TriggerHandle was triggered. </p> <p>Note: The TriggerHandle wasTriggered state is set to false again after the underlying ConditionListener gathered all events. </p>","title":"function wasTriggered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-trigger","text":"<pre><code>void trigger()\n</code></pre> <p>triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback </p>","title":"function trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-reset","text":"<pre><code>void reset()\n</code></pre> <p>calls the resetCallback and invalidates the TriggerHandle</p>","title":"function reset"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-invalidate","text":"<pre><code>void invalidate()\n</code></pre> <p>invalidates the TriggerHandle without calling the reset callback </p>","title":"function invalidate"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-getuniqueid","text":"<pre><code>uint64_t getUniqueId() const\n</code></pre> <p>returns the uniqueTriggerId </p>","title":"function getUniqueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-getconditionvariabledata","text":"<pre><code>ConditionVariableData * getConditionVariableData()\n</code></pre> <p>returns the pointer to the ConditionVariableData </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function getConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/","text":"<p>Inherits from UntypedClientImpl&lt;&gt;</p>","title":"iox::popo::UntypedClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#public-functions","text":"Name     virtual ~UntypedClient()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#function-untypedclient","text":"<pre><code>inline virtual ~UntypedClient()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~UntypedClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/","text":"<p>The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx.  <code>#include &lt;iceoryx_posh/popo/untyped_publisher.hpp&gt;</code></p> <p>Inherits from UntypedPublisherImpl&lt;&gt;</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::popo::UntypedPublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/","text":"<p>Inherits from UntypedServerImpl&lt;&gt;</p>","title":"iox::popo::UntypedServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#public-functions","text":"Name     virtual ~UntypedServer()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#function-untypedserver","text":"<pre><code>inline virtual ~UntypedServer()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~UntypedServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/","text":"<p>The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx.  <code>#include &lt;iceoryx_posh/popo/untyped_subscriber.hpp&gt;</code></p> <p>Inherits from UntypedSubscriberImpl&lt;&gt;</p>","title":"iox::popo::UntypedSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#public-functions","text":"Name     virtual ~UntypedSubscriber()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#function-untypedsubscriber","text":"<pre><code>inline virtual ~UntypedSubscriber()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~UntypedSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/","text":"<p>An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class.  <code>#include &lt;iceoryx_posh/popo/user_trigger.hpp&gt;</code></p>","title":"iox::popo::UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#public-functions","text":"Name      UserTrigger()    UserTrigger(const UserTrigger &amp; rhs)    UserTrigger(UserTrigger &amp;&amp; rhs)   UserTrigger &amp; operator=(const UserTrigger &amp; rhs)   UserTrigger &amp; operator=(UserTrigger &amp;&amp; rhs)   void trigger()If it is attached it will trigger otherwise it will do nothing.   bool hasTriggered() constChecks if the UserTrigger was triggered.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friends","text":"Name     class NotificationAttorney","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger","text":"<pre><code>UserTrigger()\n</code></pre>","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger_1","text":"<pre><code>UserTrigger(\n    const UserTrigger &amp; rhs\n)\n</code></pre>","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger_2","text":"<pre><code>UserTrigger(\n    UserTrigger &amp;&amp; rhs\n)\n</code></pre>","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-operator","text":"<pre><code>UserTrigger &amp; operator=(\n    const UserTrigger &amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-operator_1","text":"<pre><code>UserTrigger &amp; operator=(\n    UserTrigger &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-trigger","text":"<pre><code>void trigger()\n</code></pre> <p>If it is attached it will trigger otherwise it will do nothing. </p> <p>Note: a user trigger cannot be triggered when it is not attached </p>","title":"function trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-hastriggered","text":"<pre><code>bool hasTriggered() const\n</code></pre> <p>Checks if the UserTrigger was triggered. </p> <p>Return: true if the UserTrigger is trigger, otherwise false. </p> <p>Note: The hasTrigger state will be reset after it was handled by a WaitSet/Listener </p>","title":"function hasTriggered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friend-notificationattorney","text":"<pre><code>friend class NotificationAttorney(\n    NotificationAttorney \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/","text":"<p>Logical disjunction of a certain number of Triggers.  More...</p> <p><code>#include &lt;iceoryx_posh/popo/wait_set.hpp&gt;</code></p>","title":"iox::popo::WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-types","text":"Name     using cxx::optional&lt; Trigger &gt;[Capacity] TriggerArray   using cxx::vector&lt; const NotificationInfo *, CAPACITY &gt; NotificationInfoVector","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-functions","text":"Name      WaitSet()    ~WaitSet()    WaitSet(const WaitSet &amp; rhs)all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved    WaitSet(WaitSet &amp;&amp; rhs)   WaitSet &amp; operator=(const WaitSet &amp; rhs)   WaitSet &amp; operator=(WaitSet &amp;&amp; rhs)   void markForDestruction()Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait().   template &lt;typename T ,typename EventType ,typename ContextDataType  =internal::NoType_t,typename  =std::enable_if_t::value&gt;&gt; cxx::expected&lt; WaitSetError &gt; attachEvent(T &amp; eventOrigin, const EventType eventType, const uint64_t notificationId =0U, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback ={})attaches an event of a given class to the WaitSet.   template &lt;typename T ,typename EventType ,typename ContextDataType  =internal::NoType_t,typename  =std::enable_if_t::value, void&gt;&gt; cxx::expected&lt; WaitSetError &gt; attachEvent(T &amp; eventOrigin, const EventType eventType, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)attaches an event of a given class to the WaitSet.   template &lt;typename T ,typename ContextDataType  =internal::NoType_t&gt; cxx::expected&lt; WaitSetError &gt; attachEvent(T &amp; eventOrigin, const uint64_t notificationId =0U, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback ={})attaches an event of a given class to the WaitSet.   template &lt;typename T ,typename ContextDataType  =internal::NoType_t&gt; cxx::expected&lt; WaitSetError &gt; attachEvent(T &amp; eventOrigin, const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback)attaches an event of a given class to the WaitSet.   template &lt;typename T ,typename StateType ,typename ContextDataType  =internal::NoType_t,typename  =std::enable_if_t::value&gt;&gt; cxx::expected&lt; WaitSetError &gt; attachState(T &amp; stateOrigin, const StateType stateType, const uint64_t id =0U, const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback ={})attaches a state of a given class to the WaitSet.   template &lt;typename T ,typename StateType ,typename ContextDataType  =internal::NoType_t,typename  =std::enable_if_t::value, void&gt;&gt; cxx::expected&lt; WaitSetError &gt; attachState(T &amp; stateOrigin, const StateType stateType, const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback)attaches a state of a given class to the WaitSet.   template &lt;typename T ,typename ContextDataType  =internal::NoType_t&gt; cxx::expected&lt; WaitSetError &gt; attachState(T &amp; stateOrigin, const uint64_t id =0U, const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback ={})attaches a state of a given class to the WaitSet.   template &lt;typename T ,typename ContextDataType  =internal::NoType_t&gt; cxx::expected&lt; WaitSetError &gt; attachState(T &amp; stateOrigin, const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback)attaches a state of a given class to the WaitSet.   template &lt;typename T ,typename... Targs&gt; void detachEvent(T &amp; eventOrigin, const Targs &amp;... args)detaches an event from the WaitSet   template &lt;typename T ,typename... Targs&gt; void detachState(T &amp; stateOrigin, const Targs &amp;... args)detaches a state based trigger from the WaitSet   NotificationInfoVector timedWait(const units::Duration timeout)Blocking wait with time limit till one or more of the triggers are triggered.   NotificationInfoVector wait()Blocking wait till one or more of the triggers are triggered.   uint64_t size() constReturns the amount of stored Trigger inside of the WaitSet.   constexpr uint64_t capacity()returns the maximum amount of triggers which can be acquired from a waitset","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#protected-functions","text":"Name      WaitSet(ConditionVariableData &amp; condVarData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-attributes","text":"Name     constexpr uint64_t CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#detailed-description","text":"<pre><code>template &lt;uint64_t Capacity =MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET&gt;\nclass iox::popo::WaitSet;\n</code></pre> <p>Logical disjunction of a certain number of Triggers. </p> <p>Parameters: </p> <ul> <li>Capacity the amount of events/states which can be attached to the waitset </li> </ul> <p>The WaitSet stores Triggers and allows the user to wait till one or more of those Triggers are triggered. It works over process borders. With the creation of a WaitSet it requests a condition variable from RouDi and destroys it with the destructor. Hence the lifetime of the condition variable is bound to the lifetime of the WaitSet. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#using-triggerarray","text":"<pre><code>using iox::popo::WaitSet&lt; Capacity &gt;::TriggerArray =  cxx::optional&lt;Trigger&gt;[Capacity];\n</code></pre>","title":"using TriggerArray"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#using-notificationinfovector","text":"<pre><code>using iox::popo::WaitSet&lt; Capacity &gt;::NotificationInfoVector =  cxx::vector&lt;const NotificationInfo*, CAPACITY&gt;;\n</code></pre>","title":"using NotificationInfoVector"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset","text":"<pre><code>WaitSet()\n</code></pre>","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_1","text":"<pre><code>~WaitSet()\n</code></pre>","title":"function ~WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_2","text":"<pre><code>WaitSet(\n    const WaitSet &amp; rhs\n)\n</code></pre> <p>all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved </p>","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_3","text":"<pre><code>WaitSet(\n    WaitSet &amp;&amp; rhs\n)\n</code></pre>","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-operator","text":"<pre><code>WaitSet &amp; operator=(\n    const WaitSet &amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-operator_1","text":"<pre><code>WaitSet &amp; operator=(\n    WaitSet &amp;&amp; rhs\n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-markfordestruction","text":"<pre><code>void markForDestruction()\n</code></pre> <p>Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait(). </p>","title":"function markForDestruction"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent","text":"<pre><code>template &lt;typename T ,\ntypename EventType ,\ntypename ContextDataType  =internal::NoType_t,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\ncxx::expected&lt; WaitSetError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const EventType eventType,\n    const uint64_t notificationId =0U,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback ={}\n)\n</code></pre> <p>attaches an event of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>eventOrigin the class from which the event originates. </li> <li>eventType the event specified by the class </li> <li>notificationId an arbitrary user defined id for the event </li> <li>eventCallback a callback which should be assigned to the event </li> </ul> <p>Note: attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_1","text":"<pre><code>template &lt;typename T ,\ntypename EventType ,\ntypename ContextDataType  =internal::NoType_t,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value, void&gt;&gt;\ncxx::expected&lt; WaitSetError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const EventType eventType,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback\n)\n</code></pre> <p>attaches an event of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>eventOrigin the class from which the event originates. </li> <li>eventType the event specified by the class </li> <li>eventCallback a callback which should be assigned to the event </li> </ul> <p>Note: attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_2","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType  =internal::NoType_t&gt;\ncxx::expected&lt; WaitSetError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const uint64_t notificationId =0U,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback ={}\n)\n</code></pre> <p>attaches an event of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>eventOrigin the class from which the event originates. </li> <li>notificationId an arbitrary user defined id for the event </li> <li>eventCallback a callback which should be assigned to the event </li> </ul> <p>Note: attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_3","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType  =internal::NoType_t&gt;\ncxx::expected&lt; WaitSetError &gt; attachEvent(\n    T &amp; eventOrigin,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; eventCallback\n)\n</code></pre> <p>attaches an event of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>eventOrigin the class from which the event originates. </li> <li>eventCallback a callback which should be assigned to the event </li> </ul> <p>Note: attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. </p>","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate","text":"<pre><code>template &lt;typename T ,\ntypename StateType ,\ntypename ContextDataType  =internal::NoType_t,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;StateType&gt;::value&gt;&gt;\ncxx::expected&lt; WaitSetError &gt; attachState(\n    T &amp; stateOrigin,\n    const StateType stateType,\n    const uint64_t id =0U,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback ={}\n)\n</code></pre> <p>attaches a state of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>stateOrigin the class from which the state originates. </li> <li>stateType the state specified by the class </li> <li>id an arbitrary user defined id for the state </li> <li>stateCallback a callback which should be assigned to the state </li> </ul> <p>Note: attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. </p>","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_1","text":"<pre><code>template &lt;typename T ,\ntypename StateType ,\ntypename ContextDataType  =internal::NoType_t,\ntypename  =std::enable_if_t&lt;std::is_enum&lt;StateType&gt;::value, void&gt;&gt;\ncxx::expected&lt; WaitSetError &gt; attachState(\n    T &amp; stateOrigin,\n    const StateType stateType,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback\n)\n</code></pre> <p>attaches a state of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>stateOrigin the class from which the state originates. </li> <li>stateType the state specified by the class </li> <li>stateCallback a callback which should be assigned to the state </li> </ul> <p>Note: attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. </p>","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_2","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType  =internal::NoType_t&gt;\ncxx::expected&lt; WaitSetError &gt; attachState(\n    T &amp; stateOrigin,\n    const uint64_t id =0U,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback ={}\n)\n</code></pre> <p>attaches a state of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>stateOrigin the class from which the state originates. </li> <li>id an arbitrary user defined id for the state </li> <li>stateCallback a callback which should be assigned to the state </li> </ul> <p>Note: attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. </p>","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_3","text":"<pre><code>template &lt;typename T ,\ntypename ContextDataType  =internal::NoType_t&gt;\ncxx::expected&lt; WaitSetError &gt; attachState(\n    T &amp; stateOrigin,\n    const NotificationCallback&lt; T, ContextDataType &gt; &amp; stateCallback\n)\n</code></pre> <p>attaches a state of a given class to the WaitSet. </p> <p>Parameters: </p> <ul> <li>stateOrigin the class from which the state originates. </li> <li>stateCallback a callback which should be assigned to the state </li> </ul> <p>Note: attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. </p>","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-detachevent","text":"<pre><code>template &lt;typename T ,\ntypename... Targs&gt;\nvoid detachEvent(\n    T &amp; eventOrigin,\n    const Targs &amp;... args\n)\n</code></pre> <p>detaches an event from the WaitSet</p> <p>Parameters: </p> <ul> <li>eventOrigin the origin of the event that should be detached </li> <li>args... additional event identifying arguments </li> </ul>","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-detachstate","text":"<pre><code>template &lt;typename T ,\ntypename... Targs&gt;\nvoid detachState(\n    T &amp; stateOrigin,\n    const Targs &amp;... args\n)\n</code></pre> <p>detaches a state based trigger from the WaitSet</p> <p>Parameters: </p> <ul> <li>stateOrigin the origin of the state that should be detached </li> <li>args... additional state identifying arguments </li> </ul>","title":"function detachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-timedwait","text":"<pre><code>NotificationInfoVector timedWait(\n    const units::Duration timeout\n)\n</code></pre> <p>Blocking wait with time limit till one or more of the triggers are triggered. </p> <p>Parameters: </p> <ul> <li>timeout How long shall we waite for a trigger </li> </ul> <p>Return: NotificationInfoVector of NotificationInfos that have been triggered </p>","title":"function timedWait"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-wait","text":"<pre><code>NotificationInfoVector wait()\n</code></pre> <p>Blocking wait till one or more of the triggers are triggered. </p> <p>Return: NotificationInfoVector of NotificationInfos that have been triggered </p>","title":"function wait"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>Returns the amount of stored Trigger inside of the WaitSet. </p>","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-capacity","text":"<pre><code>static constexpr uint64_t capacity()\n</code></pre> <p>returns the maximum amount of triggers which can be acquired from a waitset </p>","title":"function capacity"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_4","text":"<pre><code>explicit WaitSet(\n    ConditionVariableData &amp; condVarData\n)\n</code></pre>","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#variable-capacity","text":"<pre><code>static constexpr uint64_t CAPACITY = Capacity;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable CAPACITY"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/","text":"<p>The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case.  More...</p> <p><code>#include &lt;iceoryx_posh/roudi/memory/generic_memory_block.hpp&gt;</code></p> <p>Inherits from iox::roudi::MemoryBlock</p>","title":"iox::roudi::GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#public-functions","text":"Name      GenericMemoryBlock() =default    ~GenericMemoryBlock()    GenericMemoryBlock(const GenericMemoryBlock &amp; )    GenericMemoryBlock(GenericMemoryBlock &amp;&amp; )   GenericMemoryBlock &amp; operator=(const GenericMemoryBlock &amp; )   GenericMemoryBlock &amp; operator=(GenericMemoryBlock &amp;&amp; )   virtual uint64_t size() const overrideThis function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory.   virtual uint64_t alignment() const overrideThis function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider.   template &lt;typename... Targs&gt; cxx::optional&lt; T * &gt; emplace(Targs &amp;&amp;... args)A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called.   cxx::optional&lt; T * &gt; value() constThis function enables the access to the underlying type.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#protected-functions","text":"Name     virtual void destroy() overrideThe MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friends","text":"Name     class MemoryProvider","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#additional-inherited-members","text":"<p>Public Functions inherited from iox::roudi::MemoryBlock</p>     Name      MemoryBlock() =default   virtual ~MemoryBlock() =default    MemoryBlock(const MemoryBlock &amp; )    MemoryBlock(MemoryBlock &amp;&amp; )   cxx::optional&lt; void * &gt; memory() constThis function provides the pointer to the requested memory.    <p>Protected Functions inherited from iox::roudi::MemoryBlock</p>     Name     virtual void onMemoryAvailable(cxx::not_null&lt; void * &gt; memory)This function is called once the memory is available and is therefore the earliest possibility to use the memory.","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#detailed-description","text":"<pre><code>template &lt;typename T &gt;\nclass iox::roudi::GenericMemoryBlock;\n</code></pre> <p>The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. </p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock","text":"<pre><code>GenericMemoryBlock() =default\n</code></pre>","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_1","text":"<pre><code>~GenericMemoryBlock()\n</code></pre>","title":"function ~GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_2","text":"<pre><code>GenericMemoryBlock(\n    const GenericMemoryBlock &amp; \n)\n</code></pre>","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_3","text":"<pre><code>GenericMemoryBlock(\n    GenericMemoryBlock &amp;&amp; \n)\n</code></pre>","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-operator","text":"<pre><code>GenericMemoryBlock &amp; operator=(\n    const GenericMemoryBlock &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-operator_1","text":"<pre><code>GenericMemoryBlock &amp; operator=(\n    GenericMemoryBlock &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-size","text":"<pre><code>virtual uint64_t size() const override\n</code></pre> <p>This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. </p> <p>Return: the required memory as multiple of the alignment </p> <p>Note: The size of the underlying type T </p> <p>Reimplements: iox::roudi::MemoryBlock::size</p>","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-alignment","text":"<pre><code>virtual uint64_t alignment() const override\n</code></pre> <p>This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider. </p> <p>Return: the alignment of the underlying data. </p> <p>Note: The alignment of the underlying type T </p> <p>Reimplements: iox::roudi::MemoryBlock::alignment</p>","title":"function alignment"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-emplace","text":"<pre><code>template &lt;typename... Targs&gt;\ncxx::optional&lt; T * &gt; emplace(\n    Targs &amp;&amp;... args\n)\n</code></pre> <p>A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called. </p> <p>Parameters: </p> <ul> <li>args are perfectly forwarded to the constructor of T to perform a placement new </li> </ul> <p>Return: an optional pointer to the underlying type, cxx::nullopt_t if memory was not yet available </p>","title":"function emplace"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-value","text":"<pre><code>cxx::optional&lt; T * &gt; value() const\n</code></pre> <p>This function enables the access to the underlying type. </p> <p>Return: an optional pointer to the underlying type, cxx::nullopt_t if value is not initialized </p>","title":"function value"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-destroy","text":"<pre><code>virtual void destroy() override\n</code></pre> <p>The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. </p> <p>Note: </p> <ul> <li>This function can be called multiple times. Make sure that the implementation can handle this. </li> <li>This will destroy the underlying type T </li> </ul> <p>Reimplements: iox::roudi::MemoryBlock::destroy</p>","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friend-memoryprovider","text":"<pre><code>friend class MemoryProvider(\n    MemoryProvider \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/","text":"<p>Inherits from iox::roudi::RouDiApp</p>","title":"iox::roudi::IceOryxRouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#public-functions","text":"Name      IceOryxRouDiApp(const config::CmdLineArgs_t &amp; cmdLineArgs, const RouDiConfig_t &amp; roudiConfig)constructor to create the RouDi daemon with a given config   virtual uint8_t run() overridestarts the execution of the RouDi daemon","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#additional-inherited-members","text":"<p>Public Functions inherited from iox::roudi::RouDiApp</p>     Name     void roudiSigHandler(int32_t signal)Method passed to the OS signal handler.    RouDiApp(const config::CmdLineArgs_t &amp; cmdLineArgs, const RouDiConfig_t &amp; config)C'tor with command line parser, which has already parsed the command line parameters.   virtual ~RouDiApp()    <p>Protected Functions inherited from iox::roudi::RouDiApp</p>     Name     void registerSigHandler()Tells the OS which signals shall be hooked.   bool waitForSignal()waits for the next signal to RouDi daemon    <p>Protected Attributes inherited from iox::roudi::RouDiApp</p>     Name     iox::log::LogLevel m_logLevel   roudi::MonitoringMode m_monitoringMode   bool m_run   RouDiConfig_t m_config   posix::Semaphore m_semaphore   version::CompatibilityCheckLevel m_compatibilityCheckLevel   units::Duration m_processKillDelay","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#function-iceoryxroudiapp","text":"<pre><code>IceOryxRouDiApp(\n    const config::CmdLineArgs_t &amp; cmdLineArgs,\n    const RouDiConfig_t &amp; roudiConfig\n)\n</code></pre> <p>constructor to create the RouDi daemon with a given config </p> <p>Parameters: </p> <ul> <li>Command liner parser object, that provides the settings </li> <li>RouDi config for mempool configuration </li> </ul>","title":"function IceOryxRouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#function-run","text":"<pre><code>virtual uint8_t run() override\n</code></pre> <p>starts the execution of the RouDi daemon </p> <p>Return: Return code for programm execution </p> <p>Reimplements: iox::roudi::RouDiApp::run</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/","text":"<p>Inherits from iox::roudi::RouDiMemoryInterface</p>","title":"iox::roudi::IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#public-functions","text":"Name      IceOryxRouDiMemoryManager(const RouDiConfig_t &amp; roudiConfig)   virtual ~IceOryxRouDiMemoryManager() =defaultThe Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider.    IceOryxRouDiMemoryManager(IceOryxRouDiMemoryManager &amp;&amp; )   IceOryxRouDiMemoryManager &amp; operator=(IceOryxRouDiMemoryManager &amp;&amp; )    IceOryxRouDiMemoryManager(const IceOryxRouDiMemoryManager &amp; )   IceOryxRouDiMemoryManager &amp; operator=(const IceOryxRouDiMemoryManager &amp; )   virtual cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory() overrideThe RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks.   virtual cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory() overrideThe RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data.   virtual const PosixShmMemoryProvider * mgmtMemoryProvider() const override   virtual cxx::optional&lt; PortPool * &gt; portPool() override   virtual cxx::optional&lt; mepoo::MemoryManager * &gt; introspectionMemoryManager() const override   virtual cxx::optional&lt; mepoo::SegmentManager&lt;&gt; * &gt; segmentManager() const override","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#additional-inherited-members","text":"<p>Public Functions inherited from iox::roudi::RouDiMemoryInterface</p>     Name      RouDiMemoryInterface() =default   virtual ~RouDiMemoryInterface() =defaultThe Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider.    RouDiMemoryInterface(RouDiMemoryInterface &amp;&amp; )    RouDiMemoryInterface(const RouDiMemoryInterface &amp; )","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager","text":"<pre><code>IceOryxRouDiMemoryManager(\n    const RouDiConfig_t &amp; roudiConfig\n)\n</code></pre>","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_1","text":"<pre><code>virtual ~IceOryxRouDiMemoryManager() =default\n</code></pre> <p>The Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider. </p>","title":"function ~IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_2","text":"<pre><code>IceOryxRouDiMemoryManager(\n    IceOryxRouDiMemoryManager &amp;&amp; \n)\n</code></pre>","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-operator","text":"<pre><code>IceOryxRouDiMemoryManager &amp; operator=(\n    IceOryxRouDiMemoryManager &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_3","text":"<pre><code>IceOryxRouDiMemoryManager(\n    const IceOryxRouDiMemoryManager &amp; \n)\n</code></pre>","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-operator_1","text":"<pre><code>IceOryxRouDiMemoryManager &amp; operator=(\n    const IceOryxRouDiMemoryManager &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-createandannouncememory","text":"<pre><code>virtual cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory() override\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. </p> <p>Return: an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success </p> <p>Reimplements: iox::roudi::RouDiMemoryInterface::createAndAnnounceMemory</p>","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-destroymemory","text":"<pre><code>virtual cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory() override\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. </p> <p>Reimplements: iox::roudi::RouDiMemoryInterface::destroyMemory</p>","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-mgmtmemoryprovider","text":"<pre><code>virtual const PosixShmMemoryProvider * mgmtMemoryProvider() const override\n</code></pre> <p>Reimplements: iox::roudi::RouDiMemoryInterface::mgmtMemoryProvider</p>","title":"function mgmtMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-portpool","text":"<pre><code>virtual cxx::optional&lt; PortPool * &gt; portPool() override\n</code></pre> <p>Reimplements: iox::roudi::RouDiMemoryInterface::portPool</p>","title":"function portPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-introspectionmemorymanager","text":"<pre><code>virtual cxx::optional&lt; mepoo::MemoryManager * &gt; introspectionMemoryManager() const override\n</code></pre> <p>Reimplements: iox::roudi::RouDiMemoryInterface::introspectionMemoryManager</p>","title":"function introspectionMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-segmentmanager","text":"<pre><code>virtual cxx::optional&lt; mepoo::SegmentManager&lt;&gt; * &gt; segmentManager() const override\n</code></pre> <p>Reimplements: iox::roudi::RouDiMemoryInterface::segmentManager</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function segmentManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/","text":"<p>The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider, which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case.  <code>#include &lt;iceoryx_posh/roudi/memory/memory_block.hpp&gt;</code></p> <p>Inherited by iox::roudi::GenericMemoryBlock&lt; T &gt;</p>","title":"iox::roudi::MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#public-functions","text":"Name      MemoryBlock() =default   virtual ~MemoryBlock() =default    MemoryBlock(const MemoryBlock &amp; )    MemoryBlock(MemoryBlock &amp;&amp; )   MemoryBlock &amp; operator=(const MemoryBlock &amp; )   MemoryBlock &amp; operator=(MemoryBlock &amp;&amp; )   virtual uint64_t size() const =0This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory.   virtual uint64_t alignment() const =0This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider.   cxx::optional&lt; void * &gt; memory() constThis function provides the pointer to the requested memory.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#protected-functions","text":"Name     virtual void destroy() =0The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor.   virtual void onMemoryAvailable(cxx::not_null&lt; void * &gt; memory)This function is called once the memory is available and is therefore the earliest possibility to use the memory.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friends","text":"Name     class MemoryProvider","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock","text":"<pre><code>MemoryBlock() =default\n</code></pre>","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_1","text":"<pre><code>virtual ~MemoryBlock() =default\n</code></pre>","title":"function ~MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_2","text":"<pre><code>MemoryBlock(\n    const MemoryBlock &amp; \n)\n</code></pre> <p>Note: this is intentional not movable/copyable, since a pointer to the memory block is registered at a MemoryProvider and therefore an instance of a MemoryBlock must be pinned to memory </p>","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_3","text":"<pre><code>MemoryBlock(\n    MemoryBlock &amp;&amp; \n)\n</code></pre>","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-operator","text":"<pre><code>MemoryBlock &amp; operator=(\n    const MemoryBlock &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-operator_1","text":"<pre><code>MemoryBlock &amp; operator=(\n    MemoryBlock &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-size","text":"<pre><code>virtual uint64_t size() const =0\n</code></pre> <p>This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. </p> <p>Return: the required memory as multiple of the alignment </p> <p>Reimplemented by: iox::roudi::GenericMemoryBlock::size</p>","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-alignment","text":"<pre><code>virtual uint64_t alignment() const =0\n</code></pre> <p>This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider. </p> <p>Return: the alignment of the underlying data. </p> <p>Reimplemented by: iox::roudi::GenericMemoryBlock::alignment</p>","title":"function alignment"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memory","text":"<pre><code>cxx::optional&lt; void * &gt; memory() const\n</code></pre> <p>This function provides the pointer to the requested memory. </p> <p>Return: an optional pointer to a memory block with the requested size and alignment if the memory is available, otherwise a cxx::nullopt_t </p>","title":"function memory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-destroy","text":"<pre><code>virtual void destroy() =0\n</code></pre> <p>The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. </p> <p>Note: This function can be called multiple times. Make sure that the implementation can handle this. </p> <p>Reimplemented by: iox::roudi::GenericMemoryBlock::destroy</p>","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-onmemoryavailable","text":"<pre><code>virtual void onMemoryAvailable(\n    cxx::not_null&lt; void * &gt; memory\n)\n</code></pre> <p>This function is called once the memory is available and is therefore the earliest possibility to use the memory. </p> <p>Parameters: </p> <ul> <li>memory pointer to a valid memory block, the same one that the memory() member function would return </li> </ul>","title":"function onMemoryAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friend-memoryprovider","text":"<pre><code>friend class MemoryProvider(\n    MemoryProvider \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/","text":"<p>This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider.  <code>#include &lt;iceoryx_posh/roudi/memory/memory_provider.hpp&gt;</code></p> <p>Inherited by iox::roudi::PosixShmMemoryProvider</p>","title":"iox::roudi::MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#public-functions","text":"Name      MemoryProvider() =default   virtual ~MemoryProvider()    MemoryProvider(const MemoryProvider &amp; )    MemoryProvider(MemoryProvider &amp;&amp; )   MemoryProvider &amp; operator=(const MemoryProvider &amp; )   MemoryProvider &amp; operator=(MemoryProvider &amp;&amp; )   cxx::expected&lt; MemoryProviderError &gt; addMemoryBlock(cxx::not_null&lt; MemoryBlock * &gt; memoryBlock)This function add a MemoryBlock to the list of memory requester.   cxx::expected&lt; MemoryProviderError &gt; create()With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider.   void announceMemoryAvailable()This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider.   cxx::expected&lt; MemoryProviderError &gt; destroy()This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider.   cxx::optional&lt; void * &gt; baseAddress() constThis function provides the base address of the created memory.   uint64_t size() constThis function provides the size of the created memory.   cxx::optional&lt; uint64_t &gt; segmentId() constThis function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider.   bool isAvailable() constThis function can be used to check if the requested memory is already available.   bool isAvailableAnnounced() constThis function can be used to check if the availability of the memory was announced to the MemoryBlocks.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#protected-functions","text":"Name     virtual cxx::expected&lt; void *, MemoryProviderError &gt; createMemory(const uint64_t size, const uint64_t alignment) =0This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function.   virtual cxx::expected&lt; MemoryProviderError &gt; destroyMemory() =0This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function.   const char * getErrorString(const MemoryProviderError error)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friends","text":"Name     class RouDiMemoryManager","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider","text":"<pre><code>MemoryProvider() =default\n</code></pre>","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_1","text":"<pre><code>virtual ~MemoryProvider()\n</code></pre>","title":"function ~MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_2","text":"<pre><code>MemoryProvider(\n    const MemoryProvider &amp; \n)\n</code></pre> <p>Note: this is intentional not movable/copyable, since a pointer to the memory provider is registered at the RouDiMemoryManager and therefore an instance of a MemoryProvider must be pinned to memory </p>","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_3","text":"<pre><code>MemoryProvider(\n    MemoryProvider &amp;&amp; \n)\n</code></pre>","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-operator","text":"<pre><code>MemoryProvider &amp; operator=(\n    const MemoryProvider &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-operator_1","text":"<pre><code>MemoryProvider &amp; operator=(\n    MemoryProvider &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-addmemoryblock","text":"<pre><code>cxx::expected&lt; MemoryProviderError &gt; addMemoryBlock(\n    cxx::not_null&lt; MemoryBlock * &gt; memoryBlock\n)\n</code></pre> <p>This function add a MemoryBlock to the list of memory requester. </p> <p>Parameters: </p> <ul> <li>memoryBlock is a pointer to a user defined MemoryBlock</li> </ul> <p>Return: an MemoryProviderError::MEMORY_BLOCKS_EXHAUSTED error if no further memory blocks can be added, otherwise success </p>","title":"function addMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-create","text":"<pre><code>cxx::expected&lt; MemoryProviderError &gt; create()\n</code></pre> <p>With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider. </p> <p>Return: an MemoryProviderError if memory allocation was not successful, otherwise success </p>","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-announcememoryavailable","text":"<pre><code>void announceMemoryAvailable()\n</code></pre> <p>This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider. </p>","title":"function announceMemoryAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-destroy","text":"<pre><code>cxx::expected&lt; MemoryProviderError &gt; destroy()\n</code></pre> <p>This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider. </p> <p>Return: an error if memory destruction was not successful, otherwise success </p>","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-baseaddress","text":"<pre><code>cxx::optional&lt; void * &gt; baseAddress() const\n</code></pre> <p>This function provides the base address of the created memory. </p> <p>Return: an optional pointer to the base address of the created memory if the memory is available, otherwise a cxx::nullopt_t </p>","title":"function baseAddress"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-size","text":"<pre><code>uint64_t size() const\n</code></pre> <p>This function provides the size of the created memory. </p> <p>Return: the size of the created memory </p>","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-segmentid","text":"<pre><code>cxx::optional&lt; uint64_t &gt; segmentId() const\n</code></pre> <p>This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider. </p> <p>Return: an optional segment id for the created memory if the memory is available, otherwise cxx::nullopt_t </p>","title":"function segmentId"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-isavailable","text":"<pre><code>bool isAvailable() const\n</code></pre> <p>This function can be used to check if the requested memory is already available. </p> <p>Return: true if the requested memory is available, false otherwise </p>","title":"function isAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-isavailableannounced","text":"<pre><code>bool isAvailableAnnounced() const\n</code></pre> <p>This function can be used to check if the availability of the memory was announced to the MemoryBlocks. </p> <p>Return: true if the availability of the memory was announced to the MemoryBlocks, false otherwise </p>","title":"function isAvailableAnnounced"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-creatememory","text":"<pre><code>virtual cxx::expected&lt; void *, MemoryProviderError &gt; createMemory(\n    const uint64_t size,\n    const uint64_t alignment\n) =0\n</code></pre> <p>This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. </p> <p>Parameters: </p> <ul> <li>size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements </li> <li>alignment the required alignment for the memory </li> </ul> <p>Return: the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created </p> <p>Reimplemented by: iox::roudi::PosixShmMemoryProvider::createMemory</p>","title":"function createMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-destroymemory","text":"<pre><code>virtual cxx::expected&lt; MemoryProviderError &gt; destroyMemory() =0\n</code></pre> <p>This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. </p> <p>Return: a MemoryProviderError if the destruction failed, otherwise success </p> <p>Reimplemented by: iox::roudi::PosixShmMemoryProvider::destroyMemory</p>","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-geterrorstring","text":"<pre><code>static const char * getErrorString(\n    const MemoryProviderError error\n)\n</code></pre>","title":"function getErrorString"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friend-roudimemorymanager","text":"<pre><code>friend class RouDiMemoryManager(\n    RouDiMemoryManager \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/","text":"","title":"iox::roudi::PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#public-functions","text":"Name      PortPool(PortPoolData &amp; portPoolData)   virtual ~PortPool() =default   cxx::vector&lt; PublisherPortRouDiType::MemberType_t *, MAX_PUBLISHERS &gt; getPublisherPortDataList()   cxx::vector&lt; SubscriberPortType::MemberType_t *, MAX_SUBSCRIBERS &gt; getSubscriberPortDataList()   cxx::vector&lt; popo::ClientPortData *, MAX_CLIENTS &gt; getClientPortDataList()   cxx::vector&lt; popo::ServerPortData *, MAX_SERVERS &gt; getServerPortDataList()   cxx::vector&lt; popo::InterfacePortData *, MAX_INTERFACE_NUMBER &gt; getInterfacePortDataList()   cxx::vector&lt; runtime::NodeData *, MAX_NODE_NUMBER &gt; getNodeDataList()   cxx::vector&lt; popo::ConditionVariableData *, MAX_NUMBER_OF_CONDITION_VARIABLES &gt; getConditionVariableDataList()   cxx::expected&lt; PublisherPortRouDiType::MemberType_t *, PortPoolError &gt; addPublisherPort(const capro::ServiceDescription &amp; serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t &amp; runtimeName, const popo::PublisherOptions &amp; publisherOptions, const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo())   cxx::expected&lt; SubscriberPortType::MemberType_t *, PortPoolError &gt; addSubscriberPort(const capro::ServiceDescription &amp; serviceDescription, const RuntimeName_t &amp; runtimeName, const popo::SubscriberOptions &amp; subscriberOptions, const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo())   template &lt;typename T ,std::enable_if_t&lt; std::is_same&lt; T, iox::build::ManyToManyPolicy &gt;::value &gt; *  =nullptr&gt; iox::popo::SubscriberPortData * constructSubscriber(const capro::ServiceDescription &amp; serviceDescription, const RuntimeName_t &amp; runtimeName, const popo::SubscriberOptions &amp; subscriberOptions, const mepoo::MemoryInfo &amp; memoryInfo)   template &lt;typename T ,std::enable_if_t&lt; std::is_same&lt; T, iox::build::OneToManyPolicy &gt;::value &gt; *  =nullptr&gt; iox::popo::SubscriberPortData * constructSubscriber(const capro::ServiceDescription &amp; serviceDescription, const RuntimeName_t &amp; runtimeName, const popo::SubscriberOptions &amp; subscriberOptions, const mepoo::MemoryInfo &amp; memoryInfo)   cxx::expected&lt; popo::ClientPortData *, PortPoolError &gt; addClientPort(const capro::ServiceDescription &amp; serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t &amp; runtimeName, const popo::ClientOptions &amp; clientOptions, const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo())Adds a ClientPortData to the internal pool and returns a pointer for further usage.   cxx::expected&lt; popo::ServerPortData *, PortPoolError &gt; addServerPort(const capro::ServiceDescription &amp; serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t &amp; runtimeName, const popo::ServerOptions &amp; serverOptions, const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo())Adds a ServerPortData to the internal pool and returns a pointer for further usage.   cxx::expected&lt; popo::InterfacePortData *, PortPoolError &gt; addInterfacePort(const RuntimeName_t &amp; runtimeName, const capro::Interfaces interface)   cxx::expected&lt; runtime::NodeData *, PortPoolError &gt; addNodeData(const RuntimeName_t &amp; runtimeName, const NodeName_t &amp; nodeName, const uint64_t nodeDeviceIdentifier)   cxx::expected&lt; popo::ConditionVariableData *, PortPoolError &gt; addConditionVariableData(const RuntimeName_t &amp; runtimeName)   void removePublisherPort(const PublisherPortRouDiType::MemberType_t *const portData)Removes a PublisherPortData from the internal pool.   void removeSubscriberPort(const SubscriberPortType::MemberType_t *const portData)Removes a SubscriberPortData from the internal pool.   void removeClientPort(const popo::ClientPortData *const portData)Removes a ClientPortData from the internal pool.   void removeServerPort(const popo::ServerPortData *const portData)Removes a ServerPortData from the internal pool.   void removeInterfacePort(const popo::InterfacePortData *const portData)Removes a InterfacePortData from the internal pool.   void removeNodeData(const runtime::NodeData *const nodeData)Removes a NodeData from the internal pool.   void removeConditionVariableData(const popo::ConditionVariableData *const conditionVariableData)Removes a ConditionVariableData from the internal pool.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-portpool","text":"<pre><code>PortPool(\n    PortPoolData &amp; portPoolData\n)\n</code></pre>","title":"function PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-portpool_1","text":"<pre><code>virtual ~PortPool() =default\n</code></pre>","title":"function ~PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getpublisherportdatalist","text":"<pre><code>cxx::vector&lt; PublisherPortRouDiType::MemberType_t *, MAX_PUBLISHERS &gt; getPublisherPortDataList()\n</code></pre> <p>Todo: don't create the vector with each call but only when the data really change there could be a member \"cxx::vector&lt;popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed </p>","title":"function getPublisherPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getsubscriberportdatalist","text":"<pre><code>cxx::vector&lt; SubscriberPortType::MemberType_t *, MAX_SUBSCRIBERS &gt; getSubscriberPortDataList()\n</code></pre>","title":"function getSubscriberPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getclientportdatalist","text":"<pre><code>cxx::vector&lt; popo::ClientPortData *, MAX_CLIENTS &gt; getClientPortDataList()\n</code></pre>","title":"function getClientPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getserverportdatalist","text":"<pre><code>cxx::vector&lt; popo::ServerPortData *, MAX_SERVERS &gt; getServerPortDataList()\n</code></pre>","title":"function getServerPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getinterfaceportdatalist","text":"<pre><code>cxx::vector&lt; popo::InterfacePortData *, MAX_INTERFACE_NUMBER &gt; getInterfacePortDataList()\n</code></pre>","title":"function getInterfacePortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getnodedatalist","text":"<pre><code>cxx::vector&lt; runtime::NodeData *, MAX_NODE_NUMBER &gt; getNodeDataList()\n</code></pre>","title":"function getNodeDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getconditionvariabledatalist","text":"<pre><code>cxx::vector&lt; popo::ConditionVariableData *, MAX_NUMBER_OF_CONDITION_VARIABLES &gt; getConditionVariableDataList()\n</code></pre>","title":"function getConditionVariableDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addpublisherport","text":"<pre><code>cxx::expected&lt; PublisherPortRouDiType::MemberType_t *, PortPoolError &gt; addPublisherPort(\n    const capro::ServiceDescription &amp; serviceDescription,\n    mepoo::MemoryManager *const memoryManager,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::PublisherOptions &amp; publisherOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo()\n)\n</code></pre>","title":"function addPublisherPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addsubscriberport","text":"<pre><code>cxx::expected&lt; SubscriberPortType::MemberType_t *, PortPoolError &gt; addSubscriberPort(\n    const capro::ServiceDescription &amp; serviceDescription,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::SubscriberOptions &amp; subscriberOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo()\n)\n</code></pre>","title":"function addSubscriberPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-constructsubscriber","text":"<pre><code>template &lt;typename T ,\nstd::enable_if_t&lt; std::is_same&lt; T, iox::build::ManyToManyPolicy &gt;::value &gt; *  =nullptr&gt;\ninline iox::popo::SubscriberPortData * constructSubscriber(\n    const capro::ServiceDescription &amp; serviceDescription,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::SubscriberOptions &amp; subscriberOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo\n)\n</code></pre>","title":"function constructSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-constructsubscriber_1","text":"<pre><code>template &lt;typename T ,\nstd::enable_if_t&lt; std::is_same&lt; T, iox::build::OneToManyPolicy &gt;::value &gt; *  =nullptr&gt;\niox::popo::SubscriberPortData * constructSubscriber(\n    const capro::ServiceDescription &amp; serviceDescription,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::SubscriberOptions &amp; subscriberOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo\n)\n</code></pre>","title":"function constructSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addclientport","text":"<pre><code>cxx::expected&lt; popo::ClientPortData *, PortPoolError &gt; addClientPort(\n    const capro::ServiceDescription &amp; serviceDescription,\n    mepoo::MemoryManager *const memoryManager,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::ClientOptions &amp; clientOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo()\n)\n</code></pre> <p>Adds a ClientPortData to the internal pool and returns a pointer for further usage. </p> <p>Parameters: </p> <ul> <li>serviceDescription for the new client port </li> <li>memoryManager to acquire chunks for the requests </li> <li>runtimeName of the runtime the new client port belongs to </li> <li>clientOptions for the new client port </li> <li>memoryInfo for the new client port </li> </ul> <p>Return: on success a pointer to a ClientPortData; on error a PortPoolError </p>","title":"function addClientPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addserverport","text":"<pre><code>cxx::expected&lt; popo::ServerPortData *, PortPoolError &gt; addServerPort(\n    const capro::ServiceDescription &amp; serviceDescription,\n    mepoo::MemoryManager *const memoryManager,\n    const RuntimeName_t &amp; runtimeName,\n    const popo::ServerOptions &amp; serverOptions,\n    const mepoo::MemoryInfo &amp; memoryInfo =mepoo::MemoryInfo()\n)\n</code></pre> <p>Adds a ServerPortData to the internal pool and returns a pointer for further usage. </p> <p>Parameters: </p> <ul> <li>serviceDescription for the new server port </li> <li>memoryManager to acquire chunks for the responses </li> <li>runtimeName of the runtime the new server port belongs to </li> <li>serverOptions for the new server port </li> <li>memoryInfo for the new server port </li> </ul> <p>Return: on success a pointer to a ServerPortData; on error a PortPoolError </p>","title":"function addServerPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addinterfaceport","text":"<pre><code>cxx::expected&lt; popo::InterfacePortData *, PortPoolError &gt; addInterfacePort(\n    const RuntimeName_t &amp; runtimeName,\n    const capro::Interfaces interface\n)\n</code></pre>","title":"function addInterfacePort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addnodedata","text":"<pre><code>cxx::expected&lt; runtime::NodeData *, PortPoolError &gt; addNodeData(\n    const RuntimeName_t &amp; runtimeName,\n    const NodeName_t &amp; nodeName,\n    const uint64_t nodeDeviceIdentifier\n)\n</code></pre>","title":"function addNodeData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addconditionvariabledata","text":"<pre><code>cxx::expected&lt; popo::ConditionVariableData *, PortPoolError &gt; addConditionVariableData(\n    const RuntimeName_t &amp; runtimeName\n)\n</code></pre>","title":"function addConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removepublisherport","text":"<pre><code>void removePublisherPort(\n    const PublisherPortRouDiType::MemberType_t *const portData\n)\n</code></pre> <p>Removes a PublisherPortData from the internal pool. </p> <p>Parameters: </p> <ul> <li>portData is a pointer to the PublisherPortData to be removed </li> </ul> <p>Note: after this call the provided PublisherPortData is no longer available for usage </p>","title":"function removePublisherPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removesubscriberport","text":"<pre><code>void removeSubscriberPort(\n    const SubscriberPortType::MemberType_t *const portData\n)\n</code></pre> <p>Removes a SubscriberPortData from the internal pool. </p> <p>Parameters: </p> <ul> <li>portData is a pointer to the SubscriberPortData to be removed </li> </ul> <p>Note: after this call the provided SubscriberPortData is no longer available for usage </p>","title":"function removeSubscriberPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeclientport","text":"<pre><code>void removeClientPort(\n    const popo::ClientPortData *const portData\n)\n</code></pre> <p>Removes a ClientPortData from the internal pool. </p> <p>Parameters: </p> <ul> <li>portData is a pointer to the ClientPortData to be removed </li> </ul> <p>Note: after this call the provided ClientPortData is no longer available for usage </p>","title":"function removeClientPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeserverport","text":"<pre><code>void removeServerPort(\n    const popo::ServerPortData *const portData\n)\n</code></pre> <p>Removes a ServerPortData from the internal pool. </p> <p>Parameters: </p> <ul> <li>portData is a pointer to the ServerPortData to be removed </li> </ul> <p>Note: after this call the provided ServerPortData is no longer available for usage </p>","title":"function removeServerPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeinterfaceport","text":"<pre><code>void removeInterfacePort(\n    const popo::InterfacePortData *const portData\n)\n</code></pre> <p>Removes a InterfacePortData from the internal pool. </p> <p>Parameters: </p> <ul> <li>portData is a pointer to the InterfacePortData to be removed </li> </ul> <p>Note: after this call the provided InterfacePortData is no longer available for usage </p>","title":"function removeInterfacePort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removenodedata","text":"<pre><code>void removeNodeData(\n    const runtime::NodeData *const nodeData\n)\n</code></pre> <p>Removes a NodeData from the internal pool. </p> <p>Parameters: </p> <ul> <li>nodeData is a pointer to the NodeData to be removed </li> </ul> <p>Note: after this call the provided NodeData is no longer available for usage </p>","title":"function removeNodeData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeconditionvariabledata","text":"<pre><code>void removeConditionVariableData(\n    const popo::ConditionVariableData *const conditionVariableData\n)\n</code></pre> <p>Removes a ConditionVariableData from the internal pool. </p> <p>Parameters: </p> <ul> <li>conditionVariableData is a pointer to the ConditionVariableData to be removed </li> </ul> <p>Note: after this call the provided ConditionVariableData is no longer available for usage </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function removeConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/","text":"<p>Creates the shared memory based on a provided configuration.  <code>#include &lt;iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp&gt;</code></p> <p>Inherits from iox::roudi::MemoryProvider</p>","title":"iox::roudi::PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#public-functions","text":"Name      PosixShmMemoryProvider(const ShmName_t &amp; shmName, const posix::AccessMode accessMode, const posix::OpenMode openMode)Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks.    ~PosixShmMemoryProvider()    PosixShmMemoryProvider(PosixShmMemoryProvider &amp;&amp; )   PosixShmMemoryProvider &amp; operator=(PosixShmMemoryProvider &amp;&amp; )    PosixShmMemoryProvider(const PosixShmMemoryProvider &amp; )   PosixShmMemoryProvider &amp; operator=(const PosixShmMemoryProvider &amp; )","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#protected-functions","text":"Name     virtual cxx::expected&lt; void *, MemoryProviderError &gt; createMemory(const uint64_t size, const uint64_t alignment)This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function.   virtual cxx::expected&lt; MemoryProviderError &gt; destroyMemory()This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#additional-inherited-members","text":"<p>Public Functions inherited from iox::roudi::MemoryProvider</p>     Name      MemoryProvider() =default   virtual ~MemoryProvider()    MemoryProvider(const MemoryProvider &amp; )    MemoryProvider(MemoryProvider &amp;&amp; )   cxx::expected&lt; MemoryProviderError &gt; addMemoryBlock(cxx::not_null&lt; MemoryBlock * &gt; memoryBlock)This function add a MemoryBlock to the list of memory requester.   cxx::expected&lt; MemoryProviderError &gt; create()With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider.   void announceMemoryAvailable()This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider.   cxx::expected&lt; MemoryProviderError &gt; destroy()This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider.   cxx::optional&lt; void * &gt; baseAddress() constThis function provides the base address of the created memory.   uint64_t size() constThis function provides the size of the created memory.   cxx::optional&lt; uint64_t &gt; segmentId() constThis function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider.   bool isAvailable() constThis function can be used to check if the requested memory is already available.   bool isAvailableAnnounced() constThis function can be used to check if the availability of the memory was announced to the MemoryBlocks.    <p>Protected Functions inherited from iox::roudi::MemoryProvider</p>     Name     const char * getErrorString(const MemoryProviderError error)    <p>Friends inherited from iox::roudi::MemoryProvider</p>     Name     class RouDiMemoryManager","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider","text":"<pre><code>PosixShmMemoryProvider(\n    const ShmName_t &amp; shmName,\n    const posix::AccessMode accessMode,\n    const posix::OpenMode openMode\n)\n</code></pre> <p>Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks. </p> <p>Parameters: </p> <ul> <li>shmName is the name of the posix share memory </li> <li>accessMode defines the read and write access to the memory </li> <li>openMode defines the creation/open mode of the shared memory. </li> </ul>","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_1","text":"<pre><code>~PosixShmMemoryProvider()\n</code></pre>","title":"function ~PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_2","text":"<pre><code>PosixShmMemoryProvider(\n    PosixShmMemoryProvider &amp;&amp; \n)\n</code></pre>","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-operator","text":"<pre><code>PosixShmMemoryProvider &amp; operator=(\n    PosixShmMemoryProvider &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_3","text":"<pre><code>PosixShmMemoryProvider(\n    const PosixShmMemoryProvider &amp; \n)\n</code></pre>","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-operator_1","text":"<pre><code>PosixShmMemoryProvider &amp; operator=(\n    const PosixShmMemoryProvider &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-creatememory","text":"<pre><code>virtual cxx::expected&lt; void *, MemoryProviderError &gt; createMemory(\n    const uint64_t size,\n    const uint64_t alignment\n)\n</code></pre> <p>This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. </p> <p>Parameters: </p> <ul> <li>size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements </li> <li>alignment the required alignment for the memory </li> </ul> <p>Return: the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created </p> <p>Note: This creates and maps a POSIX shared memory to the address space of the application </p> <p>Reimplements: iox::roudi::MemoryProvider::createMemory</p>","title":"function createMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-destroymemory","text":"<pre><code>virtual cxx::expected&lt; MemoryProviderError &gt; destroyMemory()\n</code></pre> <p>This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. </p> <p>Return: a MemoryProviderError if the destruction failed, otherwise success </p> <p>Note: This closes and unmaps a POSIX shared memory </p> <p>Reimplements: iox::roudi::MemoryProvider::destroyMemory</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/","text":"<p>base class for RouDi daemons  <code>#include &lt;iceoryx_posh/roudi/roudi_app.hpp&gt;</code></p> <p>Inherited by iox::roudi::IceOryxRouDiApp</p>","title":"iox::roudi::RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#public-functions","text":"Name     void roudiSigHandler(int32_t signal)Method passed to the OS signal handler.    RouDiApp(const config::CmdLineArgs_t &amp; cmdLineArgs, const RouDiConfig_t &amp; config)C'tor with command line parser, which has already parsed the command line parameters.   virtual ~RouDiApp()   virtual uint8_t run() =0interface to start the execution of the RouDi daemon","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-functions","text":"Name     void registerSigHandler()Tells the OS which signals shall be hooked.   bool waitForSignal()waits for the next signal to RouDi daemon","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-attributes","text":"Name     iox::log::LogLevel m_logLevel   roudi::MonitoringMode m_monitoringMode   bool m_run   RouDiConfig_t m_config   posix::Semaphore m_semaphore   version::CompatibilityCheckLevel m_compatibilityCheckLevel   units::Duration m_processKillDelay","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudisighandler","text":"<pre><code>static void roudiSigHandler(\n    int32_t signal\n)\n</code></pre> <p>Method passed to the OS signal handler. </p>","title":"function roudiSigHandler"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudiapp","text":"<pre><code>RouDiApp(\n    const config::CmdLineArgs_t &amp; cmdLineArgs,\n    const RouDiConfig_t &amp; config\n)\n</code></pre> <p>C'tor with command line parser, which has already parsed the command line parameters. </p> <p>Parameters: </p> <ul> <li>cmdLineParser reference to a command line parser object </li> <li>config the configuration to use </li> </ul>","title":"function RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudiapp_1","text":"<pre><code>inline virtual ~RouDiApp()\n</code></pre>","title":"function ~RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-run","text":"<pre><code>virtual uint8_t run() =0\n</code></pre> <p>interface to start the execution of the RouDi daemon </p> <p>Return: Return code for programm execution </p> <p>Reimplemented by: iox::roudi::IceOryxRouDiApp::run</p>","title":"function run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-registersighandler","text":"<pre><code>void registerSigHandler()\n</code></pre> <p>Tells the OS which signals shall be hooked. </p>","title":"function registerSigHandler"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-waitforsignal","text":"<pre><code>bool waitForSignal()\n</code></pre> <p>waits for the next signal to RouDi daemon </p>","title":"function waitForSignal"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_loglevel","text":"<pre><code>iox::log::LogLevel m_logLevel {iox::log::LogLevel::kWarn};\n</code></pre>","title":"variable m_logLevel"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_monitoringmode","text":"<pre><code>roudi::MonitoringMode m_monitoringMode {roudi::MonitoringMode::ON};\n</code></pre>","title":"variable m_monitoringMode"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_run","text":"<pre><code>bool m_run {true};\n</code></pre>","title":"variable m_run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_config","text":"<pre><code>RouDiConfig_t m_config;\n</code></pre>","title":"variable m_config"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_semaphore","text":"<pre><code>posix::Semaphore m_semaphore =\n        std::move(posix::Semaphore::create(posix::CreateUnnamedSingleProcessSemaphore, 0u)\n                      .or_else([](posix::SemaphoreError&amp;) {\n                          errorHandler(Error::kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE, nullptr, ErrorLevel::FATAL);\n                      })\n                      .value());\n</code></pre>","title":"variable m_semaphore"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_compatibilitychecklevel","text":"<pre><code>version::CompatibilityCheckLevel m_compatibilityCheckLevel {version::CompatibilityCheckLevel::PATCH};\n</code></pre>","title":"variable m_compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_processkilldelay","text":"<pre><code>units::Duration m_processKillDelay {roudi::PROCESS_DEFAULT_KILL_DELAY};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_processKillDelay"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/","text":"<p>Base class for a config file provider.  <code>#include &lt;iceoryx_posh/roudi/roudi_config_file_provider.hpp&gt;</code></p> <p>Inherited by iox::config::TomlRouDiConfigFileProvider</p>","title":"iox::roudi::RouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#public-functions","text":"Name     virtual cxx::expected&lt; RouDiConfig_t, RouDiConfigFileParseError &gt; parse() =0interface to parse a config file which needs to be implemented for a custom parser","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#protected-attributes","text":"Name     ConfigFilePathString_t m_customConfigFilePath","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#function-parse","text":"<pre><code>virtual cxx::expected&lt; RouDiConfig_t, RouDiConfigFileParseError &gt; parse() =0\n</code></pre> <p>interface to parse a config file which needs to be implemented for a custom parser </p> <p>Parameters: </p> <ul> <li>configFilePath to the custom RouDi config file </li> </ul> <p>Return: a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error </p> <p>Reimplemented by: iox::config::TomlRouDiConfigFileProvider::parse</p>","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#variable-m_customconfigfilepath","text":"<pre><code>ConfigFilePathString_t m_customConfigFilePath;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_customConfigFilePath"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/","text":"<p>Inherited by iox::roudi::IceOryxRouDiMemoryManager</p>","title":"iox::roudi::RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#public-functions","text":"Name      RouDiMemoryInterface() =default   virtual ~RouDiMemoryInterface() =defaultThe Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider.    RouDiMemoryInterface(RouDiMemoryInterface &amp;&amp; )   RouDiMemoryInterface &amp; operator=(RouDiMemoryInterface &amp;&amp; )    RouDiMemoryInterface(const RouDiMemoryInterface &amp; )   RouDiMemoryInterface &amp; operator=(const RouDiMemoryInterface &amp; )   virtual cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory() =0The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks.   virtual cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory() =0The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data.   virtual const PosixShmMemoryProvider * mgmtMemoryProvider() const =0   virtual cxx::optional&lt; PortPool * &gt; portPool() =0   virtual cxx::optional&lt; mepoo::MemoryManager * &gt; introspectionMemoryManager() const =0   virtual cxx::optional&lt; mepoo::SegmentManager&lt;&gt; * &gt; segmentManager() const =0","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface","text":"<pre><code>RouDiMemoryInterface() =default\n</code></pre>","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_1","text":"<pre><code>virtual ~RouDiMemoryInterface() =default\n</code></pre> <p>The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider. </p>","title":"function ~RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_2","text":"<pre><code>RouDiMemoryInterface(\n    RouDiMemoryInterface &amp;&amp; \n)\n</code></pre>","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-operator","text":"<pre><code>RouDiMemoryInterface &amp; operator=(\n    RouDiMemoryInterface &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_3","text":"<pre><code>RouDiMemoryInterface(\n    const RouDiMemoryInterface &amp; \n)\n</code></pre>","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-operator_1","text":"<pre><code>RouDiMemoryInterface &amp; operator=(\n    const RouDiMemoryInterface &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-createandannouncememory","text":"<pre><code>virtual cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory() =0\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. </p> <p>Return: an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success </p> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::createAndAnnounceMemory</p>","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-destroymemory","text":"<pre><code>virtual cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory() =0\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. </p> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::destroyMemory</p>","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-mgmtmemoryprovider","text":"<pre><code>virtual const PosixShmMemoryProvider * mgmtMemoryProvider() const =0\n</code></pre> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::mgmtMemoryProvider</p>","title":"function mgmtMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-portpool","text":"<pre><code>virtual cxx::optional&lt; PortPool * &gt; portPool() =0\n</code></pre> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::portPool</p>","title":"function portPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-introspectionmemorymanager","text":"<pre><code>virtual cxx::optional&lt; mepoo::MemoryManager * &gt; introspectionMemoryManager() const =0\n</code></pre> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::introspectionMemoryManager</p>","title":"function introspectionMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-segmentmanager","text":"<pre><code>virtual cxx::optional&lt; mepoo::SegmentManager&lt;&gt; * &gt; segmentManager() const =0\n</code></pre> <p>Reimplemented by: iox::roudi::IceOryxRouDiMemoryManager::segmentManager</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function segmentManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/","text":"","title":"iox::roudi::RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#public-functions","text":"Name      RouDiMemoryManager() =default   virtual ~RouDiMemoryManager()The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider.    RouDiMemoryManager(RouDiMemoryManager &amp;&amp; )   RouDiMemoryManager &amp; operator=(RouDiMemoryManager &amp;&amp; )    RouDiMemoryManager(const RouDiMemoryManager &amp; )   RouDiMemoryManager &amp; operator=(const RouDiMemoryManager &amp; )   cxx::expected&lt; RouDiMemoryManagerError &gt; addMemoryProvider(MemoryProvider * memoryProvider)This function add a MemoryProvider to the memory manager.   cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory()The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks.   cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory()The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager","text":"<pre><code>RouDiMemoryManager() =default\n</code></pre>","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_1","text":"<pre><code>virtual ~RouDiMemoryManager()\n</code></pre> <p>The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider. </p>","title":"function ~RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_2","text":"<pre><code>RouDiMemoryManager(\n    RouDiMemoryManager &amp;&amp; \n)\n</code></pre>","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-operator","text":"<pre><code>RouDiMemoryManager &amp; operator=(\n    RouDiMemoryManager &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_3","text":"<pre><code>RouDiMemoryManager(\n    const RouDiMemoryManager &amp; \n)\n</code></pre>","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-operator_1","text":"<pre><code>RouDiMemoryManager &amp; operator=(\n    const RouDiMemoryManager &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-addmemoryprovider","text":"<pre><code>cxx::expected&lt; RouDiMemoryManagerError &gt; addMemoryProvider(\n    MemoryProvider * memoryProvider\n)\n</code></pre> <p>This function add a MemoryProvider to the memory manager. </p> <p>Parameters: </p> <ul> <li>memoryProvider is a pointer to a user defined MemoryProvider</li> </ul> <p>Return: an RouDiMemoryManagerError::MEMORY_PROVIDER_EXHAUSTED error if no further memory provider can be added, otherwise success </p>","title":"function addMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-createandannouncememory","text":"<pre><code>cxx::expected&lt; RouDiMemoryManagerError &gt; createAndAnnounceMemory()\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. </p> <p>Return: an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success </p>","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-destroymemory","text":"<pre><code>cxx::expected&lt; RouDiMemoryManagerError &gt; destroyMemory()\n</code></pre> <p>The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/","text":"<p>class which represents a node  <code>#include &lt;iceoryx_posh/runtime/node.hpp&gt;</code></p>","title":"iox::runtime::Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#public-functions","text":"Name      Node(const NodeName_t &amp; nodeName)constructor which requires the name of the node    ~Node()destructor    Node(const Node &amp; )   Node &amp; operator=(const Node &amp; )    Node(Node &amp;&amp; rhs)move constructor   Node &amp; operator=(Node &amp;&amp; rhs)move assignment operator   NodeName_t getNodeName() constreturns the name of the node   RuntimeName_t getRuntimeName() constreturns the name of the application's runtime","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-functions","text":"Name      Node(NodeData *const data)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-attributes","text":"Name     NodeData * m_data","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node","text":"<pre><code>Node(\n    const NodeName_t &amp; nodeName\n)\n</code></pre> <p>constructor which requires the name of the node </p> <p>Parameters: </p> <ul> <li>nodeName name of the node </li> </ul>","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_1","text":"<pre><code>~Node()\n</code></pre> <p>destructor </p>","title":"function ~Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_2","text":"<pre><code>Node(\n    const Node &amp; \n)\n</code></pre>","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-operator","text":"<pre><code>Node &amp; operator=(\n    const Node &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_3","text":"<pre><code>Node(\n    Node &amp;&amp; rhs\n)\n</code></pre> <p>move constructor </p> <p>Parameters: </p> <ul> <li>rhs source object </li> </ul>","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-operator_1","text":"<pre><code>Node &amp; operator=(\n    Node &amp;&amp; rhs\n)\n</code></pre> <p>move assignment operator </p> <p>Parameters: </p> <ul> <li>rhs source object, where to move from </li> </ul>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-getnodename","text":"<pre><code>NodeName_t getNodeName() const\n</code></pre> <p>returns the name of the node </p> <p>Return: string which contains the node name </p>","title":"function getNodeName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-getruntimename","text":"<pre><code>RuntimeName_t getRuntimeName() const\n</code></pre> <p>returns the name of the application's runtime </p> <p>Return: string which contains the runtime name </p>","title":"function getRuntimeName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_4","text":"<pre><code>Node(\n    NodeData *const data\n)\n</code></pre>","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#variable-m_data","text":"<pre><code>NodeData * m_data = nullptr;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_data"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/","text":"<p>The runtime that is needed for each application to communicate with the RouDi daemon.  <code>#include &lt;iceoryx_posh/runtime/posh_runtime.hpp&gt;</code></p>","title":"iox::runtime::PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-types","text":"Name     using PoshRuntime &amp;(*)(cxx::optional&lt; const RuntimeName_t * &gt;) factory_t","title":"Protected Types"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#public-functions","text":"Name      PoshRuntime(const PoshRuntime &amp; )   PoshRuntime &amp; operator=(const PoshRuntime &amp; )    PoshRuntime(PoshRuntime &amp;&amp; )   PoshRuntime &amp; operator=(PoshRuntime &amp;&amp; )   virtual ~PoshRuntime() =default   RuntimeName_t getInstanceName() constget the name that was used to register with RouDi   void shutdown()initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set   virtual PublisherPortUserType::MemberType_t * getMiddlewarePublisher(const capro::ServiceDescription &amp; service, const popo::PublisherOptions &amp; publisherOptions ={}, const PortConfigInfo &amp; portConfigInfo ={}) =0request the RouDi daemon to create a publisher port   virtual SubscriberPortUserType::MemberType_t * getMiddlewareSubscriber(const capro::ServiceDescription &amp; service, const popo::SubscriberOptions &amp; subscriberOptions ={}, const PortConfigInfo &amp; portConfigInfo ={}) =0request the RouDi daemon to create a subscriber port   virtual popo::ClientPortData * getMiddlewareClient(const capro::ServiceDescription &amp; service, const popo::ClientOptions &amp; clientOptions ={}, const PortConfigInfo &amp; portConfigInfo =PortConfigInfo()) =0request the RouDi daemon to create a client port   virtual popo::ServerPortData * getMiddlewareServer(const capro::ServiceDescription &amp; service, const popo::ServerOptions &amp; serverOptions ={}, const PortConfigInfo &amp; portConfigInfo =PortConfigInfo()) =0request the RouDi daemon to create a server port   virtual popo::InterfacePortData * getMiddlewareInterface(const capro::Interfaces interface, const NodeName_t &amp; nodeName ={}) =0request the RouDi daemon to create an interface port   virtual popo::ConditionVariableData * getMiddlewareConditionVariable() =0request the RouDi daemon to create a condition variable   virtual NodeData * createNode(const NodeProperty &amp; nodeProperty) =0request the RouDi daemon to create a node   virtual bool sendRequestToRouDi(const IpcMessage &amp; msg, IpcMessage &amp; answer) =0send a request to the RouDi daemon and get the response currently each request is followed by a response   PoshRuntime &amp; getInstance()returns active runtime   PoshRuntime &amp; initRuntime(const RuntimeName_t &amp; name)creates the runtime with given name","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-functions","text":"Name      PoshRuntime(cxx::optional&lt; const RuntimeName_t * &gt; name)   const RuntimeName_t &amp; verifyInstanceName(cxx::optional&lt; const RuntimeName_t * &gt; name)checks the given application name for certain constraints like length or if is empty   PoshRuntime &amp; defaultRuntimeFactory(cxx::optional&lt; const RuntimeName_t * &gt; name)   factory_t &amp; getRuntimeFactory()gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory.   void setRuntimeFactory(const factory_t &amp; factory)sets runtime factory, terminates if given factory is empty   PoshRuntime &amp; getInstance(cxx::optional&lt; const RuntimeName_t * &gt; name)creates the runtime or returns the already existing one -&gt; Singleton","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-attributes","text":"Name     const RuntimeName_t m_appName   std::atomic&lt; bool &gt; m_shutdownRequested","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friends","text":"Name     class roudi::RuntimeTestInterface","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#using-factory_t","text":"<pre><code>using iox::runtime::PoshRuntime::factory_t =  PoshRuntime&amp; (*)(cxx::optional&lt;const RuntimeName_t*&gt;);\n</code></pre>","title":"using factory_t"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime","text":"<pre><code>PoshRuntime(\n    const PoshRuntime &amp; \n)\n</code></pre>","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-operator","text":"<pre><code>PoshRuntime &amp; operator=(\n    const PoshRuntime &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_1","text":"<pre><code>PoshRuntime(\n    PoshRuntime &amp;&amp; \n)\n</code></pre>","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-operator_1","text":"<pre><code>PoshRuntime &amp; operator=(\n    PoshRuntime &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_2","text":"<pre><code>virtual ~PoshRuntime() =default\n</code></pre>","title":"function ~PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstancename","text":"<pre><code>RuntimeName_t getInstanceName() const\n</code></pre> <p>get the name that was used to register with RouDi </p> <p>Return: name of the registered application </p>","title":"function getInstanceName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-shutdown","text":"<pre><code>void shutdown()\n</code></pre> <p>initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set </p>","title":"function shutdown"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewarepublisher","text":"<pre><code>virtual PublisherPortUserType::MemberType_t * getMiddlewarePublisher(\n    const capro::ServiceDescription &amp; service,\n    const popo::PublisherOptions &amp; publisherOptions ={},\n    const PortConfigInfo &amp; portConfigInfo ={}\n) =0\n</code></pre> <p>request the RouDi daemon to create a publisher port </p> <p>Parameters: </p> <ul> <li>serviceDescription service description for the new publisher port </li> <li>publisherOptions like the history capacity of a publisher </li> <li>portConfigInfo configuration information for the port (i.e. what type of port is requested, device where its payload memory is located on etc.) </li> </ul> <p>Return: pointer to a created publisher port user </p>","title":"function getMiddlewarePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewaresubscriber","text":"<pre><code>virtual SubscriberPortUserType::MemberType_t * getMiddlewareSubscriber(\n    const capro::ServiceDescription &amp; service,\n    const popo::SubscriberOptions &amp; subscriberOptions ={},\n    const PortConfigInfo &amp; portConfigInfo ={}\n) =0\n</code></pre> <p>request the RouDi daemon to create a subscriber port </p> <p>Parameters: </p> <ul> <li>serviceDescription service description for the new subscriber port </li> <li>subscriberOptions like the queue capacity and history requested by a subscriber </li> <li>portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) </li> </ul> <p>Return: pointer to a created subscriber port data </p>","title":"function getMiddlewareSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareclient","text":"<pre><code>virtual popo::ClientPortData * getMiddlewareClient(\n    const capro::ServiceDescription &amp; service,\n    const popo::ClientOptions &amp; clientOptions ={},\n    const PortConfigInfo &amp; portConfigInfo =PortConfigInfo()\n) =0\n</code></pre> <p>request the RouDi daemon to create a client port </p> <p>Parameters: </p> <ul> <li>serviceDescription service description for the new client port </li> <li>clientOptions like the queue capacity and queue full policy by a client </li> <li>portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) </li> </ul> <p>Return: pointer to a created client port data </p>","title":"function getMiddlewareClient"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareserver","text":"<pre><code>virtual popo::ServerPortData * getMiddlewareServer(\n    const capro::ServiceDescription &amp; service,\n    const popo::ServerOptions &amp; serverOptions ={},\n    const PortConfigInfo &amp; portConfigInfo =PortConfigInfo()\n) =0\n</code></pre> <p>request the RouDi daemon to create a server port </p> <p>Parameters: </p> <ul> <li>serviceDescription service description for the new server port </li> <li>serverOptions like the queue capacity and queue full policy by a server </li> <li>portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) </li> </ul> <p>Return: pointer to a created server port data </p>","title":"function getMiddlewareServer"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareinterface","text":"<pre><code>virtual popo::InterfacePortData * getMiddlewareInterface(\n    const capro::Interfaces interface,\n    const NodeName_t &amp; nodeName ={}\n) =0\n</code></pre> <p>request the RouDi daemon to create an interface port </p> <p>Parameters: </p> <ul> <li>interface interface to create </li> <li>nodeName name of the node where the interface should belong to </li> </ul> <p>Return: pointer to a created interface port data </p>","title":"function getMiddlewareInterface"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareconditionvariable","text":"<pre><code>virtual popo::ConditionVariableData * getMiddlewareConditionVariable() =0\n</code></pre> <p>request the RouDi daemon to create a condition variable </p> <p>Return: pointer to a created condition variable data </p>","title":"function getMiddlewareConditionVariable"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-createnode","text":"<pre><code>virtual NodeData * createNode(\n    const NodeProperty &amp; nodeProperty\n) =0\n</code></pre> <p>request the RouDi daemon to create a node </p> <p>Parameters: </p> <ul> <li>nodeProperty class which contains all properties which the node should have </li> </ul> <p>Return: pointer to the data of the node </p>","title":"function createNode"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-sendrequesttoroudi","text":"<pre><code>virtual bool sendRequestToRouDi(\n    const IpcMessage &amp; msg,\n    IpcMessage &amp; answer\n) =0\n</code></pre> <p>send a request to the RouDi daemon and get the response currently each request is followed by a response </p> <p>Parameters: </p> <ul> <li>msg request message to send </li> <li>response from the RouDi daemon </li> </ul> <p>Return: true if sucessful request/response, false on error </p>","title":"function sendRequestToRouDi"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstance","text":"<pre><code>static PoshRuntime &amp; getInstance()\n</code></pre> <p>returns active runtime </p> <p>Return: active runtime </p>","title":"function getInstance"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-initruntime","text":"<pre><code>static PoshRuntime &amp; initRuntime(\n    const RuntimeName_t &amp; name\n)\n</code></pre> <p>creates the runtime with given name </p> <p>Parameters: </p> <ul> <li>name used for registering the process with the RouDi daemon</li> </ul> <p>Return: active runtime </p>","title":"function initRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_3","text":"<pre><code>PoshRuntime(\n    cxx::optional&lt; const RuntimeName_t * &gt; name\n)\n</code></pre>","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-verifyinstancename","text":"<pre><code>const RuntimeName_t &amp; verifyInstanceName(\n    cxx::optional&lt; const RuntimeName_t * &gt; name\n)\n</code></pre> <p>checks the given application name for certain constraints like length or if is empty </p>","title":"function verifyInstanceName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-defaultruntimefactory","text":"<pre><code>static PoshRuntime &amp; defaultRuntimeFactory(\n    cxx::optional&lt; const RuntimeName_t * &gt; name\n)\n</code></pre>","title":"function defaultRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getruntimefactory","text":"<pre><code>static factory_t &amp; getRuntimeFactory()\n</code></pre> <p>gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory. </p> <p>Return: current runtime factory </p>","title":"function getRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-setruntimefactory","text":"<pre><code>static void setRuntimeFactory(\n    const factory_t &amp; factory\n)\n</code></pre> <p>sets runtime factory, terminates if given factory is empty </p> <p>Parameters: </p> <ul> <li>factory std::function to which the runtime factory should be set </li> </ul>","title":"function setRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstance_1","text":"<pre><code>static PoshRuntime &amp; getInstance(\n    cxx::optional&lt; const RuntimeName_t * &gt; name\n)\n</code></pre> <p>creates the runtime or returns the already existing one -&gt; Singleton </p> <p>Parameters: </p> <ul> <li>name optional containing the name used for registering with the RouDi daemon</li> </ul> <p>Return: active runtime </p>","title":"function getInstance"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#variable-m_appname","text":"<pre><code>const RuntimeName_t m_appName;\n</code></pre>","title":"variable m_appName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#variable-m_shutdownrequested","text":"<pre><code>std::atomic&lt; bool &gt; m_shutdownRequested {false};\n</code></pre>","title":"variable m_shutdownRequested"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friend-roudiruntimetestinterface","text":"<pre><code>friend class roudi::RuntimeTestInterface(\n    roudi::RuntimeTestInterface \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend roudi::RuntimeTestInterface"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/","text":"<p>Inherits from PoshRuntimeImpl</p>","title":"iox::runtime::PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#public-functions","text":"Name      PoshRuntimeSingleProcess(const RuntimeName_t &amp; name)    ~PoshRuntimeSingleProcess()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#function-poshruntimesingleprocess","text":"<pre><code>PoshRuntimeSingleProcess(\n    const RuntimeName_t &amp; name\n)\n</code></pre>","title":"function PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#function-poshruntimesingleprocess_1","text":"<pre><code>~PoshRuntimeSingleProcess()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function ~PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/","text":"","title":"iox::runtime::ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#public-functions","text":"Name      ServiceDiscovery()    ServiceDiscovery(const ServiceDiscovery &amp; )   ServiceDiscovery &amp; operator=(const ServiceDiscovery &amp; )    ServiceDiscovery(ServiceDiscovery &amp;&amp; )   ServiceDiscovery &amp; operator=(ServiceDiscovery &amp;&amp; )    ~ServiceDiscovery() =default   void findService(const cxx::optional&lt; capro::IdString_t &gt; &amp; service, const cxx::optional&lt; capro::IdString_t &gt; &amp; instance, const cxx::optional&lt; capro::IdString_t &gt; &amp; event, const cxx::function_ref&lt; void(const capro::ServiceDescription &amp;)&gt; &amp; callableForEach, const popo::MessagingPattern pattern)Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery","text":"<pre><code>ServiceDiscovery()\n</code></pre>","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_1","text":"<pre><code>ServiceDiscovery(\n    const ServiceDiscovery &amp; \n)\n</code></pre>","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-operator","text":"<pre><code>ServiceDiscovery &amp; operator=(\n    const ServiceDiscovery &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_2","text":"<pre><code>ServiceDiscovery(\n    ServiceDiscovery &amp;&amp; \n)\n</code></pre>","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-operator_1","text":"<pre><code>ServiceDiscovery &amp; operator=(\n    ServiceDiscovery &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_3","text":"<pre><code>~ServiceDiscovery() =default\n</code></pre>","title":"function ~ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-findservice","text":"<pre><code>void findService(\n    const cxx::optional&lt; capro::IdString_t &gt; &amp; service,\n    const cxx::optional&lt; capro::IdString_t &gt; &amp; instance,\n    const cxx::optional&lt; capro::IdString_t &gt; &amp; event,\n    const cxx::function_ref&lt; void(const capro::ServiceDescription &amp;)&gt; &amp; callableForEach,\n    const popo::MessagingPattern pattern\n)\n</code></pre> <p>Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. </p> <p>Parameters: </p> <ul> <li>service service string to search for, a nullopt corresponds to a wildcard </li> <li>instance instance string to search for, a nullopt corresponds to a wildcard </li> <li>event event string to search for, a nullopt corresponds to a wildcard </li> <li>callableForEach callable to apply to all matching services </li> <li>pattern messaging pattern of the service to search </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function findService"},{"location":"API-reference/posh/Classes/structiox_1_1Config/","text":"<p>More...</p> <p>Inherits from ConfigParts</p>","title":"iox::Config"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#public-functions","text":"Name     Config &amp; setDefaults()   template &lt;typename T &gt; Config &amp; setModuleDefaults()   Config &amp; optimize()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#detailed-description","text":"<pre><code>template &lt;typename... ConfigParts&gt;\nstruct iox::Config;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-setdefaults","text":"<pre><code>inline Config &amp; setDefaults()\n</code></pre>","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-setmoduledefaults","text":"<pre><code>template &lt;typename T &gt;\ninline Config &amp; setModuleDefaults()\n</code></pre>","title":"function setModuleDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-optimize","text":"<pre><code>inline Config &amp; optimize()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/","text":"","title":"iox::DefaultChunkDistributorConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#public-attributes","text":"Name     constexpr uint32_t MAX_QUEUES   constexpr uint64_t MAX_HISTORY_CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#variable-max_queues","text":"<pre><code>static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER;\n</code></pre>","title":"variable MAX_QUEUES"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#variable-max_history_capacity","text":"<pre><code>static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable MAX_HISTORY_CAPACITY"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/","text":"","title":"iox::DefaultChunkQueueConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#public-attributes","text":"Name     constexpr uint64_t MAX_QUEUE_CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#variable-max_queue_capacity","text":"<pre><code>static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable MAX_QUEUE_CAPACITY"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/","text":"","title":"iox::capro::ServiceDescription::ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#public-functions","text":"Name      ClassHash()    ClassHash(const std::initializer_list&lt; uint32_t &gt; &amp; values)   uint32_t &amp; operator[](iox::cxx::range&lt; uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 &gt; index)   const uint32_t &amp; operator[](iox::cxx::range&lt; uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 &gt; index) const   bool operator==(const ClassHash &amp; rhs) const   bool operator!=(const ClassHash &amp; rhs) const","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-classhash","text":"<pre><code>ClassHash()\n</code></pre>","title":"function ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-classhash_1","text":"<pre><code>ClassHash(\n    const std::initializer_list&lt; uint32_t &gt; &amp; values\n)\n</code></pre>","title":"function ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator","text":"<pre><code>uint32_t &amp; operator[](\n    iox::cxx::range&lt; uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 &gt; index\n)\n</code></pre>","title":"function operator[]"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_1","text":"<pre><code>const uint32_t &amp; operator[](\n    iox::cxx::range&lt; uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 &gt; index\n) const\n</code></pre>","title":"function operator[]"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_2","text":"<pre><code>bool operator==(\n    const ClassHash &amp; rhs\n) const\n</code></pre>","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_3","text":"<pre><code>bool operator!=(\n    const ClassHash &amp; rhs\n) const\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function operator!="},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/","text":"","title":"iox::config::CmdLineArgs_t"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#public-attributes","text":"Name     roudi::MonitoringMode monitoringMode   iox::log::LogLevel logLevel   version::CompatibilityCheckLevel compatibilityCheckLevel   units::Duration processKillDelay   cxx::optional&lt; uint16_t &gt; uniqueRouDiId   bool run   roudi::ConfigFilePathString_t configFilePath","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-monitoringmode","text":"<pre><code>roudi::MonitoringMode monitoringMode {roudi::MonitoringMode::ON};\n</code></pre>","title":"variable monitoringMode"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-loglevel","text":"<pre><code>iox::log::LogLevel logLevel {iox::log::LogLevel::kWarn};\n</code></pre>","title":"variable logLevel"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-compatibilitychecklevel","text":"<pre><code>version::CompatibilityCheckLevel compatibilityCheckLevel {version::CompatibilityCheckLevel::PATCH};\n</code></pre>","title":"variable compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-processkilldelay","text":"<pre><code>units::Duration processKillDelay {roudi::PROCESS_DEFAULT_KILL_DELAY};\n</code></pre>","title":"variable processKillDelay"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-uniqueroudiid","text":"<pre><code>cxx::optional&lt; uint16_t &gt; uniqueRouDiId {cxx::nullopt};\n</code></pre>","title":"variable uniqueRouDiId"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-run","text":"<pre><code>bool run {true};\n</code></pre>","title":"variable run"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-configfilepath","text":"<pre><code>roudi::ConfigFilePathString_t configFilePath;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable configFilePath"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/","text":"<p>Generic configuration for gateways.  <code>#include &lt;iceoryx_posh/gateway/gateway_config.hpp&gt;</code></p>","title":"iox::config::GatewayConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-classes","text":"Name     struct ServiceEntry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-functions","text":"Name     void setDefaults()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-attributes","text":"Name     iox::cxx::vector&lt; ServiceEntry, MAX_GATEWAY_SERVICES &gt; m_configuredServices","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#function-setdefaults","text":"<pre><code>void setDefaults()\n</code></pre>","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#variable-m_configuredservices","text":"<pre><code>iox::cxx::vector&lt; ServiceEntry, MAX_GATEWAY_SERVICES &gt; m_configuredServices;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_configuredServices"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/","text":"","title":"iox::config::GatewayConfig::ServiceEntry"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#public-attributes","text":"Name     capro::ServiceDescription m_serviceDescription","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#variable-m_servicedescription","text":"<pre><code>capro::ServiceDescription m_serviceDescription;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_serviceDescription"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/","text":"","title":"iox::config::RouDiConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#public-functions","text":"Name     RouDiConfig &amp; setDefaults()   RouDiConfig &amp; optimize()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#function-setdefaults","text":"<pre><code>RouDiConfig &amp; setDefaults()\n</code></pre>","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#function-optimize","text":"<pre><code>RouDiConfig &amp; optimize()\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize/","text":"<p>More...</p>","title":"iox::helper::Optimize"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize/#detailed-description","text":"<pre><code>template &lt;typename... ConfigParts&gt;\nstruct iox::helper::Optimize;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/","text":"<p>More...</p>","title":"iox::helper::Optimize&lt; FinalArg &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#public-functions","text":"Name     template &lt;typename BaseType &gt; void apply(BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#detailed-description","text":"<pre><code>template &lt;typename FinalArg &gt;\nstruct iox::helper::Optimize&lt; FinalArg &gt;;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#function-apply","text":"<pre><code>template &lt;typename BaseType &gt;\nstatic inline void apply(\n    BaseType * me\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/","text":"<p>More...</p>","title":"iox::helper::Optimize&lt; FirstArg, RemainderArgs... &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions","text":"Name     template &lt;typename BaseType &gt; void apply(BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#detailed-description","text":"<pre><code>template &lt;typename FirstArg ,\ntypename... RemainderArgs&gt;\nstruct iox::helper::Optimize&lt; FirstArg, RemainderArgs... &gt;;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#function-apply","text":"<pre><code>template &lt;typename BaseType &gt;\nstatic inline void apply(\n    BaseType * me\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults/","text":"<p>More...</p>","title":"iox::helper::SetDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults/#detailed-description","text":"<pre><code>template &lt;typename... ConfigParts&gt;\nstruct iox::helper::SetDefaults;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/","text":"<p>More...</p>","title":"iox::helper::SetDefaults&lt; FinalArg &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#public-functions","text":"Name     template &lt;typename BaseType &gt; void apply(BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#detailed-description","text":"<pre><code>template &lt;typename FinalArg &gt;\nstruct iox::helper::SetDefaults&lt; FinalArg &gt;;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#function-apply","text":"<pre><code>template &lt;typename BaseType &gt;\nstatic inline void apply(\n    BaseType * me\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/","text":"<p>More...</p>","title":"iox::helper::SetDefaults&lt; FirstArg, RemainderArgs... &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions","text":"Name     template &lt;typename BaseType &gt; void apply(BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#detailed-description","text":"<pre><code>template &lt;typename FirstArg ,\ntypename... RemainderArgs&gt;\nstruct iox::helper::SetDefaults&lt; FirstArg, RemainderArgs... &gt;;\n</code></pre>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#function-apply","text":"<pre><code>template &lt;typename BaseType &gt;\nstatic inline void apply(\n    BaseType * me\n)\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/","text":"","title":"iox::mepoo::ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-types","text":"Name     using uint32_t UserPayloadOffset_t","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-functions","text":"Name      ChunkHeader(const uint32_t chunkSize, const ChunkSettings &amp; chunkSettings)constructs and initializes a ChunkHeader    ChunkHeader(const ChunkHeader &amp; )    ChunkHeader(ChunkHeader &amp;&amp; )   ChunkHeader &amp; operator=(const ChunkHeader &amp; )   ChunkHeader &amp; operator=(ChunkHeader &amp;&amp; )   uint8_t chunkHeaderVersion() constThe ChunkHeader version is used to detect incompatibilities for record&amp;replay functionality.   uint16_t userHeaderId() constThe id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER.   void * userHeader()Get the pointer to the user-header.   const void * userHeader() constGet the const pointer to the user-header.   void * userPayload()Get a pointer to the user-payload carried by the chunk.   const void * userPayload() constGet a const pointer to the user-payload carried by the chunk.   uint32_t usedSizeOfChunk() constCalculates the used size of the chunk with the ChunkHeader, user-heander and user-payload.   uint32_t chunkSize() constThe size of the whole chunk, including the header.   uint32_t userHeaderSize() constThe size of the chunk occupied by the user-header.   uint32_t userPayloadSize() constThe size of the chunk occupied by the user-payload.   uint32_t userPayloadAlignment() constThe alignment of the chunk occupied by the user-payload.   popo::UniquePortId originId() constThe unique identifier of the publisher the chunk was sent from.   uint64_t sequenceNumber() constA serial number for the sent chunks.   ChunkHeader * fromUserPayload(void *const userPayload)Get a pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-payload of the chunk.   const ChunkHeader * fromUserPayload(const void *const userPayload)Get a const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-payload of the chunk.   ChunkHeader * fromUserHeader(void *const userHeader)Get a pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-header of the chunk.   const ChunkHeader * fromUserHeader(const void *const userHeader)Get a const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-header of the chunk.","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-attributes","text":"Name     constexpr uint8_t CHUNK_HEADER_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g.   constexpr uint16_t NO_USER_HEADER User-Header id for no user-header.   constexpr uint16_t UNKNOWN_USER_HEADER User-Header id for an unknown user-header.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friends","text":"Name     class popo::ChunkSender","title":"Friends"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#using-userpayloadoffset_t","text":"<pre><code>using iox::mepoo::ChunkHeader::UserPayloadOffset_t =  uint32_t;\n</code></pre>","title":"using UserPayloadOffset_t"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader","text":"<pre><code>ChunkHeader(\n    const uint32_t chunkSize,\n    const ChunkSettings &amp; chunkSettings\n)\n</code></pre> <p>constructs and initializes a ChunkHeader</p> <p>Parameters: </p> <ul> <li>chunkSize is the size of the chunk the ChunkHeader is constructed </li> <li>chunkSettings are the settings like user-payload size and user-header alignment </li> </ul>","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader_1","text":"<pre><code>ChunkHeader(\n    const ChunkHeader &amp; \n)\n</code></pre>","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader_2","text":"<pre><code>ChunkHeader(\n    ChunkHeader &amp;&amp; \n)\n</code></pre>","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-operator","text":"<pre><code>ChunkHeader &amp; operator=(\n    const ChunkHeader &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-operator_1","text":"<pre><code>ChunkHeader &amp; operator=(\n    ChunkHeader &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheaderversion","text":"<pre><code>uint8_t chunkHeaderVersion() const\n</code></pre> <p>The ChunkHeader version is used to detect incompatibilities for record&amp;replay functionality. </p> <p>Return: the ChunkHeader version </p>","title":"function chunkHeaderVersion"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheaderid","text":"<pre><code>uint16_t userHeaderId() const\n</code></pre> <p>The id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER. </p> <p>Return: the user-header id of the chunk </p>","title":"function userHeaderId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheader","text":"<pre><code>void * userHeader()\n</code></pre> <p>Get the pointer to the user-header. </p> <p>Return: the pointer to the user-header </p>","title":"function userHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheader_1","text":"<pre><code>const void * userHeader() const\n</code></pre> <p>Get the const pointer to the user-header. </p> <p>Return: the const pointer to the user-header </p>","title":"function userHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayload","text":"<pre><code>void * userPayload()\n</code></pre> <p>Get a pointer to the user-payload carried by the chunk. </p> <p>Return: the pointer to the user-payload </p>","title":"function userPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayload_1","text":"<pre><code>const void * userPayload() const\n</code></pre> <p>Get a const pointer to the user-payload carried by the chunk. </p> <p>Return: the const pointer to the user-payload </p>","title":"function userPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-usedsizeofchunk","text":"<pre><code>uint32_t usedSizeOfChunk() const\n</code></pre> <p>Calculates the used size of the chunk with the ChunkHeader, user-heander and user-payload. </p> <p>Return: the used size of the chunk </p>","title":"function usedSizeOfChunk"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunksize","text":"<pre><code>uint32_t chunkSize() const\n</code></pre> <p>The size of the whole chunk, including the header. </p> <p>Return: the chunk size </p>","title":"function chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheadersize","text":"<pre><code>uint32_t userHeaderSize() const\n</code></pre> <p>The size of the chunk occupied by the user-header. </p> <p>Return: the user-header size </p>","title":"function userHeaderSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayloadsize","text":"<pre><code>uint32_t userPayloadSize() const\n</code></pre> <p>The size of the chunk occupied by the user-payload. </p> <p>Return: the user-payload size </p>","title":"function userPayloadSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayloadalignment","text":"<pre><code>uint32_t userPayloadAlignment() const\n</code></pre> <p>The alignment of the chunk occupied by the user-payload. </p> <p>Return: the user-payload alignment </p>","title":"function userPayloadAlignment"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-originid","text":"<pre><code>popo::UniquePortId originId() const\n</code></pre> <p>The unique identifier of the publisher the chunk was sent from. </p> <p>Return: the id of the publisher the chunk was sent from </p>","title":"function originId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-sequencenumber","text":"<pre><code>uint64_t sequenceNumber() const\n</code></pre> <p>A serial number for the sent chunks. </p> <p>the serquence number of the chunk </p>","title":"function sequenceNumber"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserpayload","text":"<pre><code>static ChunkHeader * fromUserPayload(\n    void *const userPayload\n)\n</code></pre> <p>Get a pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-payload of the chunk. </p> <p>Parameters: </p> <ul> <li>userPayload is the pointer to the user-payload of the chunk </li> </ul> <p>Return: the pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> or a <code>nullptr</code> if <code>userPayload</code> is a <code>nullptr</code></p>","title":"function fromUserPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserpayload_1","text":"<pre><code>static const ChunkHeader * fromUserPayload(\n    const void *const userPayload\n)\n</code></pre> <p>Get a const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-payload of the chunk. </p> <p>Parameters: </p> <ul> <li>userPayload is the const pointer to the user-payload of the chunk </li> </ul> <p>Return: the const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> or a <code>nullptr</code> if <code>userPayload</code> is a <code>nullptr</code></p>","title":"function fromUserPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserheader","text":"<pre><code>static ChunkHeader * fromUserHeader(\n    void *const userHeader\n)\n</code></pre> <p>Get a pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-header of the chunk. </p> <p>Parameters: </p> <ul> <li>userHeader is the pointer to the user-header of the chunk </li> </ul> <p>Return: the pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> or a <code>nullptr</code> if <code>userHeader</code> is a <code>nullptr</code></p>","title":"function fromUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserheader_1","text":"<pre><code>static const ChunkHeader * fromUserHeader(\n    const void *const userHeader\n)\n</code></pre> <p>Get a const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> associated to the user-header of the chunk. </p> <p>Parameters: </p> <ul> <li>userHeader is the const pointer to the user-header of the chunk </li> </ul> <p>Return: the const pointer to the <code>[ChunkHeader](/v2.0.0/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/)</code> or a <code>nullptr</code> if <code>userPayload</code> is a <code>nullptr</code></p>","title":"function fromUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-chunk_header_version","text":"<pre><code>static constexpr uint8_t CHUNK_HEADER_VERSION {1U};\n</code></pre> <p>From the 1.0 release onward, this must be incremented for each incompatible change, e.g. </p> <ul> <li>data width of members changes</li> <li>members are rearranged</li> <li>semantic meaning of a member changes </li> </ul>","title":"variable CHUNK_HEADER_VERSION"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-no_user_header","text":"<pre><code>static constexpr uint16_t NO_USER_HEADER {0x0000};\n</code></pre> <p>User-Header id for no user-header. </p>","title":"variable NO_USER_HEADER"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-unknown_user_header","text":"<pre><code>static constexpr uint16_t UNKNOWN_USER_HEADER {0xFFFF};\n</code></pre> <p>User-Header id for an unknown user-header. </p>","title":"variable UNKNOWN_USER_HEADER"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friend-popochunksender","text":"<pre><code>friend class popo::ChunkSender(\n    popo::ChunkSender \n);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"friend popo::ChunkSender"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/","text":"","title":"iox::mepoo::MePooConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-classes","text":"Name     struct Entry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-types","text":"Name     using cxx::vector&lt; Entry, MAX_NUMBER_OF_MEMPOOLS &gt; MePooConfigContainerType","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-functions","text":"Name      MePooConfig() =defaultDefault constructor to set the configuration for memory pools.   const MePooConfigContainerType * getMemPoolConfig() constGet function for receiving memory pool configuration.   void addMemPool(Entry f_entry)Function for adding new entry.   MePooConfig &amp; setDefaults()Function for creating default memory pools.   MePooConfig &amp; optimize()Function for optimizing the size of memory pool according to new entry.","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-attributes","text":"Name     MePooConfigContainerType m_mempoolConfig","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#using-mepooconfigcontainertype","text":"<pre><code>using iox::mepoo::MePooConfig::MePooConfigContainerType =  cxx::vector&lt;Entry, MAX_NUMBER_OF_MEMPOOLS&gt;;\n</code></pre>","title":"using MePooConfigContainerType"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-mepooconfig","text":"<pre><code>MePooConfig() =default\n</code></pre> <p>Default constructor to set the configuration for memory pools. </p>","title":"function MePooConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-getmempoolconfig","text":"<pre><code>const MePooConfigContainerType * getMemPoolConfig() const\n</code></pre> <p>Get function for receiving memory pool configuration. </p> <p>Return: cxx::vector of config information size and count of chunks </p>","title":"function getMemPoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-addmempool","text":"<pre><code>void addMemPool(\n    Entry f_entry\n)\n</code></pre> <p>Function for adding new entry. </p> <p>Parameters: </p> <ul> <li>Entry structure of mempool configuration </li> </ul>","title":"function addMemPool"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-setdefaults","text":"<pre><code>MePooConfig &amp; setDefaults()\n</code></pre> <p>Function for creating default memory pools. </p>","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-optimize","text":"<pre><code>MePooConfig &amp; optimize()\n</code></pre> <p>Function for optimizing the size of memory pool according to new entry. </p>","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#variable-m_mempoolconfig","text":"<pre><code>MePooConfigContainerType m_mempoolConfig;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_mempoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/","text":"","title":"iox::mepoo::MePooConfig::Entry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-functions","text":"Name      Entry(uint32_t f_size, uint32_t f_chunkCount)set the size and count of memory chunks","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-attributes","text":"Name     uint32_t m_size   uint32_t m_chunkCount","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#function-entry","text":"<pre><code>inline Entry(\n    uint32_t f_size,\n    uint32_t f_chunkCount\n)\n</code></pre> <p>set the size and count of memory chunks </p>","title":"function Entry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#variable-m_size","text":"<pre><code>uint32_t m_size {0};\n</code></pre>","title":"variable m_size"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#variable-m_chunkcount","text":"<pre><code>uint32_t m_chunkCount {0};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_chunkCount"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/","text":"<p>Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics.  <code>#include &lt;iceoryx_posh/mepoo/memory_info.hpp&gt;</code></p>","title":"iox::mepoo::MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-functions","text":"Name      MemoryInfo(const MemoryInfo &amp; ) =default    MemoryInfo(MemoryInfo &amp;&amp; ) =default   MemoryInfo &amp; operator=(const MemoryInfo &amp; ) =default   MemoryInfo &amp; operator=(MemoryInfo &amp;&amp; ) =default    MemoryInfo(uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE)creates a MemoryInfo object   bool operator==(const MemoryInfo &amp; rhs) constcomparison operator","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-attributes","text":"Name     constexpr uint32_t DEFAULT_DEVICE_ID   constexpr uint32_t DEFAULT_MEMORY_TYPE   uint32_t deviceId   uint32_t memoryType","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo","text":"<pre><code>MemoryInfo(\n    const MemoryInfo &amp; \n) =default\n</code></pre>","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo_1","text":"<pre><code>MemoryInfo(\n    MemoryInfo &amp;&amp; \n) =default\n</code></pre>","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator","text":"<pre><code>MemoryInfo &amp; operator=(\n    const MemoryInfo &amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator_1","text":"<pre><code>MemoryInfo &amp; operator=(\n    MemoryInfo &amp;&amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo_2","text":"<pre><code>explicit MemoryInfo(\n    uint32_t deviceId =DEFAULT_DEVICE_ID,\n    uint32_t memoryType =DEFAULT_MEMORY_TYPE\n)\n</code></pre> <p>creates a MemoryInfo object </p> <p>Parameters: </p> <ul> <li>deviceId specifies the device where the memory is located </li> <li>memoryType encodes additional information about the memory </li> </ul>","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator_2","text":"<pre><code>bool operator==(\n    const MemoryInfo &amp; rhs\n) const\n</code></pre> <p>comparison operator </p> <p>Parameters: </p> <ul> <li>rhs the right hand side of the comparison </li> </ul>","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-default_device_id","text":"<pre><code>static constexpr uint32_t DEFAULT_DEVICE_ID {0U};\n</code></pre>","title":"variable DEFAULT_DEVICE_ID"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-default_memory_type","text":"<pre><code>static constexpr uint32_t DEFAULT_MEMORY_TYPE {0U};\n</code></pre>","title":"variable DEFAULT_MEMORY_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-deviceid","text":"<pre><code>uint32_t deviceId {DEFAULT_DEVICE_ID};\n</code></pre>","title":"variable deviceId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-memorytype","text":"<pre><code>uint32_t memoryType {DEFAULT_MEMORY_TYPE};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable memoryType"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1NoUserHeader/","text":"<p>Helper struct to use as default template parameter when no user-header is used.  <code>#include &lt;iceoryx_posh/mepoo/chunk_header.hpp&gt;</code></p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::mepoo::NoUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/","text":"","title":"iox::mepoo::SegmentConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-classes","text":"Name     struct SegmentEntry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-functions","text":"Name     SegmentConfig &amp; setDefaults()Set Function for default values to be added in SegmentConfig.   SegmentConfig &amp; optimize()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-attributes","text":"Name     cxx::vector&lt; SegmentEntry, MAX_SHM_SEGMENTS &gt; m_sharedMemorySegments","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#function-setdefaults","text":"<pre><code>SegmentConfig &amp; setDefaults()\n</code></pre> <p>Set Function for default values to be added in SegmentConfig. </p>","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#function-optimize","text":"<pre><code>SegmentConfig &amp; optimize()\n</code></pre>","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#variable-m_sharedmemorysegments","text":"<pre><code>cxx::vector&lt; SegmentEntry, MAX_SHM_SEGMENTS &gt; m_sharedMemorySegments;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_sharedMemorySegments"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/","text":"","title":"iox::mepoo::SegmentConfig::SegmentEntry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-functions","text":"Name      SegmentEntry(const posix::PosixGroup::string_t &amp; readerGroup, const posix::PosixGroup::string_t &amp; writerGroup, const MePooConfig &amp; memPoolConfig, iox::mepoo::MemoryInfo memoryInfo =iox::mepoo::MemoryInfo())","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-attributes","text":"Name     posix::PosixGroup::string_t m_readerGroup   posix::PosixGroup::string_t m_writerGroup   MePooConfig m_mempoolConfig   iox::mepoo::MemoryInfo m_memoryInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#function-segmententry","text":"<pre><code>inline SegmentEntry(\n    const posix::PosixGroup::string_t &amp; readerGroup,\n    const posix::PosixGroup::string_t &amp; writerGroup,\n    const MePooConfig &amp; memPoolConfig,\n    iox::mepoo::MemoryInfo memoryInfo =iox::mepoo::MemoryInfo()\n)\n</code></pre>","title":"function SegmentEntry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_readergroup","text":"<pre><code>posix::PosixGroup::string_t m_readerGroup;\n</code></pre>","title":"variable m_readerGroup"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_writergroup","text":"<pre><code>posix::PosixGroup::string_t m_writerGroup;\n</code></pre>","title":"variable m_writerGroup"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_mempoolconfig","text":"<pre><code>MePooConfig m_mempoolConfig;\n</code></pre>","title":"variable m_mempoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_memoryinfo","text":"<pre><code>iox::mepoo::MemoryInfo m_memoryInfo;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_memoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/","text":"<p>This struct is used to configure the client.  <code>#include &lt;iceoryx_posh/popo/client_options.hpp&gt;</code></p>","title":"iox::popo::ClientOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-functions","text":"Name     cxx::Serialization serialize() constserialization of the ClientOptions   bool operator==(const ClientOptions &amp; rhs) constcomparison operator   cxx::expected&lt; ClientOptions, cxx::Serialization::Error &gt; deserialize(const cxx::Serialization &amp; serialized)deserialization of the ClientOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-attributes","text":"Name     uint64_t responseQueueCapacity The size of the response queue where chunks are stored before they are passed to the user.   iox::NodeName_t nodeName The name of the node where the client should belong to.   bool connectOnCreate The option whether the client shall try to connect when creating it.   QueueFullPolicy responseQueueFullPolicy The option whether the server should block when the response queue is full.   ConsumerTooSlowPolicy serverTooSlowPolicy The option whether the client should block when the request queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-serialize","text":"<pre><code>cxx::Serialization serialize() const\n</code></pre> <p>serialization of the ClientOptions</p>","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-operator","text":"<pre><code>bool operator==(\n    const ClientOptions &amp; rhs\n) const\n</code></pre> <p>comparison operator </p> <p>Parameters: </p> <ul> <li>rhs the right hand side of the comparison </li> </ul>","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-deserialize","text":"<pre><code>static cxx::expected&lt; ClientOptions, cxx::Serialization::Error &gt; deserialize(\n    const cxx::Serialization &amp; serialized\n)\n</code></pre> <p>deserialization of the ClientOptions</p>","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-responsequeuecapacity","text":"<pre><code>uint64_t responseQueueCapacity {ClientChunkQueueData_t::MAX_CAPACITY};\n</code></pre> <p>The size of the response queue where chunks are stored before they are passed to the user. </p> <p>Attention: Depending on the underlying queue there can be a different overflow behavior </p>","title":"variable responseQueueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-nodename","text":"<pre><code>iox::NodeName_t nodeName {\"\"};\n</code></pre> <p>The name of the node where the client should belong to. </p>","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-connectoncreate","text":"<pre><code>bool connectOnCreate {true};\n</code></pre> <p>The option whether the client shall try to connect when creating it. </p>","title":"variable connectOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-responsequeuefullpolicy","text":"<pre><code>QueueFullPolicy responseQueueFullPolicy {QueueFullPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the server should block when the response queue is full. </p> <p>Note: Corresponds with ServerOptions::clientTooSlowPolicy</p>","title":"variable responseQueueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-servertooslowpolicy","text":"<pre><code>ConsumerTooSlowPolicy serverTooSlowPolicy {ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the client should block when the request queue is full. </p> <p>Note: Corresponds with ServerOptions::requestQueueFullPolicy</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable serverTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventBasedTrigger__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::popo::EventBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventCallback/","text":"<p>More...</p>","title":"iox::popo::EventCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventCallback/#detailed-description","text":"<pre><code>template &lt;typename OriginType ,\ntypename ContextDataType &gt;\nstruct iox::popo::EventCallback;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/","text":"<p>the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener More...</p> <p><code>#include &lt;iceoryx_posh/popo/notification_callback.hpp&gt;</code></p>","title":"iox::popo::NotificationCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-types","text":"Name     using void(&amp;)(OriginType const, ContextDataType const) Ref_t   using void()(OriginType const, ContextDataType *const) Ptr_t","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-attributes","text":"Name     Ptr_t m_callback   ContextDataType * m_contextData","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#detailed-description","text":"<pre><code>template &lt;typename OriginType ,\ntypename ContextDataType &gt;\nstruct iox::popo::NotificationCallback;\n</code></pre> <p>the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener</p>","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#using-ref_t","text":"<pre><code>using iox::popo::NotificationCallback&lt; OriginType, ContextDataType &gt;::Ref_t =  void (&amp;)(OriginType* const, ContextDataType* const);\n</code></pre>","title":"using Ref_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#using-ptr_t","text":"<pre><code>using iox::popo::NotificationCallback&lt; OriginType, ContextDataType &gt;::Ptr_t =  void (*)(OriginType* const, ContextDataType* const);\n</code></pre>","title":"using Ptr_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#variable-m_callback","text":"<pre><code>Ptr_t m_callback = nullptr;\n</code></pre>","title":"variable m_callback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#variable-m_contextdata","text":"<pre><code>ContextDataType * m_contextData = nullptr;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_contextData"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/","text":"<p>This struct is used to configure the publisher.  <code>#include &lt;iceoryx_posh/popo/publisher_options.hpp&gt;</code></p>","title":"iox::popo::PublisherOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-functions","text":"Name     cxx::Serialization serialize() constserialization of the PublisherOptions   cxx::expected&lt; PublisherOptions, cxx::Serialization::Error &gt; deserialize(const cxx::Serialization &amp; serialized)deserialization of the PublisherOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-attributes","text":"Name     uint64_t historyCapacity The size of the history chunk queue.   iox::NodeName_t nodeName The name of the node where the publisher should belong to.   bool offerOnCreate The option whether the publisher should already be offered when creating it.   ConsumerTooSlowPolicy subscriberTooSlowPolicy The option whether the publisher should block when the subscriber queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#function-serialize","text":"<pre><code>cxx::Serialization serialize() const\n</code></pre> <p>serialization of the PublisherOptions</p>","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#function-deserialize","text":"<pre><code>static cxx::expected&lt; PublisherOptions, cxx::Serialization::Error &gt; deserialize(\n    const cxx::Serialization &amp; serialized\n)\n</code></pre> <p>deserialization of the PublisherOptions</p>","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-historycapacity","text":"<pre><code>uint64_t historyCapacity {0U};\n</code></pre> <p>The size of the history chunk queue. </p>","title":"variable historyCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-nodename","text":"<pre><code>iox::NodeName_t nodeName {\"\"};\n</code></pre> <p>The name of the node where the publisher should belong to. </p>","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-offeroncreate","text":"<pre><code>bool offerOnCreate {true};\n</code></pre> <p>The option whether the publisher should already be offered when creating it. </p>","title":"variable offerOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-subscribertooslowpolicy","text":"<pre><code>ConsumerTooSlowPolicy subscriberTooSlowPolicy {ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the publisher should block when the subscriber queue is full. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable subscriberTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/","text":"<p>This struct is used to configure the server.  <code>#include &lt;iceoryx_posh/popo/server_options.hpp&gt;</code></p>","title":"iox::popo::ServerOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-functions","text":"Name     cxx::Serialization serialize() constserialization of the ServerOptions   bool operator==(const ServerOptions &amp; rhs) constcomparison operator   cxx::expected&lt; ServerOptions, cxx::Serialization::Error &gt; deserialize(const cxx::Serialization &amp; serialized)deserialization of the ServerOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-attributes","text":"Name     uint64_t requestQueueCapacity The size of the request queue where chunks are stored before they are passed to the user.   iox::NodeName_t nodeName The name of the node where the server should belong to.   bool offerOnCreate The option whether the server should already be offered when creating it.   QueueFullPolicy requestQueueFullPolicy The option whether the client should block when the request queue is full.   ConsumerTooSlowPolicy clientTooSlowPolicy The option whether the server should block when the response queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-serialize","text":"<pre><code>cxx::Serialization serialize() const\n</code></pre> <p>serialization of the ServerOptions</p>","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-operator","text":"<pre><code>bool operator==(\n    const ServerOptions &amp; rhs\n) const\n</code></pre> <p>comparison operator </p> <p>Parameters: </p> <ul> <li>rhs the right hand side of the comparison </li> </ul>","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-deserialize","text":"<pre><code>static cxx::expected&lt; ServerOptions, cxx::Serialization::Error &gt; deserialize(\n    const cxx::Serialization &amp; serialized\n)\n</code></pre> <p>deserialization of the ServerOptions</p>","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-requestqueuecapacity","text":"<pre><code>uint64_t requestQueueCapacity {ServerChunkQueueData_t::MAX_CAPACITY};\n</code></pre> <p>The size of the request queue where chunks are stored before they are passed to the user. </p> <p>Attention: Depending on the underlying queue there can be a different overflow behavior </p>","title":"variable requestQueueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-nodename","text":"<pre><code>iox::NodeName_t nodeName {\"\"};\n</code></pre> <p>The name of the node where the server should belong to. </p>","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-offeroncreate","text":"<pre><code>bool offerOnCreate {true};\n</code></pre> <p>The option whether the server should already be offered when creating it. </p>","title":"variable offerOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-requestqueuefullpolicy","text":"<pre><code>QueueFullPolicy requestQueueFullPolicy {QueueFullPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the client should block when the request queue is full. </p> <p>Note: Corresponds with ClientOptions::serverTooSlowPolicy</p>","title":"variable requestQueueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-clienttooslowpolicy","text":"<pre><code>ConsumerTooSlowPolicy clientTooSlowPolicy {ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the server should block when the response queue is full. </p> <p>Note: Corresponds with ClientOptions::responseQueueFullPolicy</p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable clientTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1StateBasedTrigger__t/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::popo::StateBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/","text":"<p>This struct is used to configure the subscriber.  <code>#include &lt;iceoryx_posh/popo/subscriber_options.hpp&gt;</code></p>","title":"iox::popo::SubscriberOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-functions","text":"Name     cxx::Serialization serialize() constserialization of the SubscriberOptions   cxx::expected&lt; SubscriberOptions, cxx::Serialization::Error &gt; deserialize(const cxx::Serialization &amp; serialized)deserialization of the SubscriberOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-attributes","text":"Name     uint64_t queueCapacity The size of the receiver queue where chunks are stored before they are passed to the user.   uint64_t historyRequest The max number of chunks received after subscription if chunks are available.   iox::NodeName_t nodeName The name of the node where the subscriber should belong to.   bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it.   QueueFullPolicy queueFullPolicy The option whether the publisher should block when the subscriber queue is full.   bool requiresPublisherHistorySupport Indicates whether to enforce history support of the publisher, i.e. require historyCapacity &gt; 0 to be eligible to be connected.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#function-serialize","text":"<pre><code>cxx::Serialization serialize() const\n</code></pre> <p>serialization of the SubscriberOptions</p>","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#function-deserialize","text":"<pre><code>static cxx::expected&lt; SubscriberOptions, cxx::Serialization::Error &gt; deserialize(\n    const cxx::Serialization &amp; serialized\n)\n</code></pre> <p>deserialization of the SubscriberOptions</p>","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-queuecapacity","text":"<pre><code>uint64_t queueCapacity {SubscriberChunkQueueData_t::MAX_CAPACITY};\n</code></pre> <p>The size of the receiver queue where chunks are stored before they are passed to the user. </p> <p>Attention: Depending on the underlying queue there can be a different overflow behavior </p>","title":"variable queueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-historyrequest","text":"<pre><code>uint64_t historyRequest {0U};\n</code></pre> <p>The max number of chunks received after subscription if chunks are available. </p>","title":"variable historyRequest"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-nodename","text":"<pre><code>iox::NodeName_t nodeName {\"\"};\n</code></pre> <p>The name of the node where the subscriber should belong to. </p>","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-subscribeoncreate","text":"<pre><code>bool subscribeOnCreate {true};\n</code></pre> <p>The option whether the subscriber shall try to subscribe when creating it. </p>","title":"variable subscribeOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-queuefullpolicy","text":"<pre><code>QueueFullPolicy queueFullPolicy {QueueFullPolicy::DISCARD_OLDEST_DATA};\n</code></pre> <p>The option whether the publisher should block when the subscriber queue is full. </p>","title":"variable queueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-requirespublisherhistorysupport","text":"<pre><code>bool requiresPublisherHistorySupport {false};\n</code></pre> <p>Indicates whether to enforce history support of the publisher, i.e. require historyCapacity &gt; 0 to be eligible to be connected. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable requiresPublisherHistorySupport"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/","text":"","title":"iox::roudi::DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-functions","text":"Name      DefaultRouDiMemory(const RouDiConfig_t &amp; roudiConfig)   virtual ~DefaultRouDiMemory() =default    DefaultRouDiMemory(DefaultRouDiMemory &amp;&amp; )   DefaultRouDiMemory &amp; operator=(DefaultRouDiMemory &amp;&amp; )    DefaultRouDiMemory(const DefaultRouDiMemory &amp; )   DefaultRouDiMemory &amp; operator=(const DefaultRouDiMemory &amp; )   mepoo::MePooConfig introspectionMemPoolConfig() const","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-attributes","text":"Name     MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock   MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock   PosixShmMemoryProvider m_managementShm","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory","text":"<pre><code>DefaultRouDiMemory(\n    const RouDiConfig_t &amp; roudiConfig\n)\n</code></pre>","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_1","text":"<pre><code>virtual ~DefaultRouDiMemory() =default\n</code></pre>","title":"function ~DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_2","text":"<pre><code>DefaultRouDiMemory(\n    DefaultRouDiMemory &amp;&amp; \n)\n</code></pre>","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-operator","text":"<pre><code>DefaultRouDiMemory &amp; operator=(\n    DefaultRouDiMemory &amp;&amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_3","text":"<pre><code>DefaultRouDiMemory(\n    const DefaultRouDiMemory &amp; \n)\n</code></pre>","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-operator_1","text":"<pre><code>DefaultRouDiMemory &amp; operator=(\n    const DefaultRouDiMemory &amp; \n)\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-introspectionmempoolconfig","text":"<pre><code>mepoo::MePooConfig introspectionMemPoolConfig() const\n</code></pre>","title":"function introspectionMemPoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_introspectionmempoolblock","text":"<pre><code>MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock;\n</code></pre>","title":"variable m_introspectionMemPoolBlock"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_segmentmanagerblock","text":"<pre><code>MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock;\n</code></pre>","title":"variable m_segmentManagerBlock"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_managementshm","text":"<pre><code>PosixShmMemoryProvider m_managementShm;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_managementShm"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/","text":"","title":"iox::roudi::IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-functions","text":"Name      IceOryxRouDiComponents(const RouDiConfig_t &amp; roudiConfig)   virtual ~IceOryxRouDiComponents() =default","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-attributes","text":"Name     IceOryxRouDiMemoryManager rouDiMemoryManager Handles MemoryProvider and MemoryBlocks.   PortManager portManager Handles the ports in shared memory.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#function-iceoryxroudicomponents","text":"<pre><code>IceOryxRouDiComponents(\n    const RouDiConfig_t &amp; roudiConfig\n)\n</code></pre>","title":"function IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#function-iceoryxroudicomponents_1","text":"<pre><code>virtual ~IceOryxRouDiComponents() =default\n</code></pre>","title":"function ~IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#variable-roudimemorymanager","text":"<pre><code>IceOryxRouDiMemoryManager rouDiMemoryManager;\n</code></pre> <p>Handles MemoryProvider and MemoryBlocks. </p>","title":"variable rouDiMemoryManager"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#variable-portmanager","text":"<pre><code>PortManager portManager;\n</code></pre> <p>Handles the ports in shared memory. </p>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable portManager"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/","text":"<p>struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools.  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p>","title":"iox::roudi::MemPoolInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#public-attributes","text":"Name     uint32_t m_usedChunks   uint32_t m_minFreeChunks   uint32_t m_numChunks   uint32_t m_chunkSize   uint32_t m_chunkPayloadSize","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_usedchunks","text":"<pre><code>uint32_t m_usedChunks {0};\n</code></pre>","title":"variable m_usedChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_minfreechunks","text":"<pre><code>uint32_t m_minFreeChunks {0};\n</code></pre>","title":"variable m_minFreeChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_numchunks","text":"<pre><code>uint32_t m_numChunks {0};\n</code></pre>","title":"variable m_numChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_chunksize","text":"<pre><code>uint32_t m_chunkSize {0};\n</code></pre>","title":"variable m_chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_chunkpayloadsize","text":"<pre><code>uint32_t m_chunkPayloadSize {0};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_chunkPayloadSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/","text":"<p>the topic for the mempool introspection that a user can subscribe to  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p>","title":"iox::roudi::MemPoolIntrospectionInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#public-attributes","text":"Name     uint32_t m_id   cxx::string&lt; MAX_GROUP_NAME_LENGTH &gt; m_writerGroupName   cxx::string&lt; MAX_GROUP_NAME_LENGTH &gt; m_readerGroupName   MemPoolInfoContainer m_mempoolInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_id","text":"<pre><code>uint32_t m_id;\n</code></pre>","title":"variable m_id"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_writergroupname","text":"<pre><code>cxx::string&lt; MAX_GROUP_NAME_LENGTH &gt; m_writerGroupName;\n</code></pre>","title":"variable m_writerGroupName"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_readergroupname","text":"<pre><code>cxx::string&lt; MAX_GROUP_NAME_LENGTH &gt; m_readerGroupName;\n</code></pre>","title":"variable m_readerGroupName"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_mempoolinfo","text":"<pre><code>MemPoolInfoContainer m_mempoolInfo;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_mempoolInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/","text":"<p>container for common port data which is related to the subscriber port as well as the publisher port  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p> <p>Inherited by iox::roudi::PublisherPortData</p>","title":"iox::roudi::PortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#public-attributes","text":"Name     RuntimeName_t m_name   capro::IdString_t m_caproInstanceID   capro::IdString_t m_caproServiceID   capro::IdString_t m_caproEventMethodID   NodeName_t m_node","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_name","text":"<pre><code>RuntimeName_t m_name;\n</code></pre>","title":"variable m_name"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproinstanceid","text":"<pre><code>capro::IdString_t m_caproInstanceID;\n</code></pre>","title":"variable m_caproInstanceID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproserviceid","text":"<pre><code>capro::IdString_t m_caproServiceID;\n</code></pre>","title":"variable m_caproServiceID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproeventmethodid","text":"<pre><code>capro::IdString_t m_caproEventMethodID;\n</code></pre>","title":"variable m_caproEventMethodID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_node","text":"<pre><code>NodeName_t m_node;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_node"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/","text":"<p>the topic for the port introspection that a user can subscribe to  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p>","title":"iox::roudi::PortIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#public-attributes","text":"Name     cxx::vector&lt; SubscriberPortData, MAX_SUBSCRIBERS &gt; m_subscriberList   cxx::vector&lt; PublisherPortData, MAX_PUBLISHERS &gt; m_publisherList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#variable-m_subscriberlist","text":"<pre><code>cxx::vector&lt; SubscriberPortData, MAX_SUBSCRIBERS &gt; m_subscriberList;\n</code></pre>","title":"variable m_subscriberList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#variable-m_publisherlist","text":"<pre><code>cxx::vector&lt; PublisherPortData, MAX_PUBLISHERS &gt; m_publisherList;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_publisherList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/","text":"","title":"iox::roudi::PortThroughputData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#public-attributes","text":"Name     uint64_t m_publisherPortID   uint32_t m_sampleSize   uint32_t m_chunkSize   double m_chunksPerMinute   uint64_t m_lastSendIntervalInNanoseconds   bool m_isField","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_publisherportid","text":"<pre><code>uint64_t m_publisherPortID {0};\n</code></pre>","title":"variable m_publisherPortID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_samplesize","text":"<pre><code>uint32_t m_sampleSize {0};\n</code></pre>","title":"variable m_sampleSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_chunksize","text":"<pre><code>uint32_t m_chunkSize {0};\n</code></pre>","title":"variable m_chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_chunksperminute","text":"<pre><code>double m_chunksPerMinute {0};\n</code></pre>","title":"variable m_chunksPerMinute"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_lastsendintervalinnanoseconds","text":"<pre><code>uint64_t m_lastSendIntervalInNanoseconds {0};\n</code></pre>","title":"variable m_lastSendIntervalInNanoseconds"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_isfield","text":"<pre><code>bool m_isField {false};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_isField"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/","text":"<p>the topic for the port throughput that a user can subscribe to  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p>","title":"iox::roudi::PortThroughputIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#public-attributes","text":"Name     cxx::vector&lt; PortThroughputData, MAX_PUBLISHERS &gt; m_throughputList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#variable-m_throughputlist","text":"<pre><code>cxx::vector&lt; PortThroughputData, MAX_PUBLISHERS &gt; m_throughputList;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_throughputList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/","text":"","title":"iox::roudi::ProcessIntrospectionData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#public-attributes","text":"Name     int m_pid   RuntimeName_t m_name   cxx::vector&lt; NodeName_t, MAX_NODE_PER_PROCESS &gt; m_nodes","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_pid","text":"<pre><code>int m_pid {0};\n</code></pre>","title":"variable m_pid"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_name","text":"<pre><code>RuntimeName_t m_name;\n</code></pre>","title":"variable m_name"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_nodes","text":"<pre><code>cxx::vector&lt; NodeName_t, MAX_NODE_PER_PROCESS &gt; m_nodes;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_nodes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/","text":"<p>the topic for the process introspection that a user can subscribe to  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p>","title":"iox::roudi::ProcessIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#public-attributes","text":"Name     cxx::vector&lt; ProcessIntrospectionData, MAX_PROCESS_NUMBER &gt; m_processList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#variable-m_processlist","text":"<pre><code>cxx::vector&lt; ProcessIntrospectionData, MAX_PROCESS_NUMBER &gt; m_processList;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_processList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/","text":"<p>container for publisher port introspection data.  <code>#include &lt;iceoryx_posh/roudi/introspection_types.hpp&gt;</code></p> <p>Inherits from iox::roudi::PortData</p>","title":"iox::roudi::PublisherPortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#public-attributes","text":"Name     uint64_t m_publisherPortID   iox::capro::Interfaces m_sourceInterface","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#additional-inherited-members","text":"<p>Public Attributes inherited from iox::roudi::PortData</p>     Name     RuntimeName_t m_name   capro::IdString_t m_caproInstanceID   capro::IdString_t m_caproServiceID   capro::IdString_t m_caproEventMethodID   NodeName_t m_node","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#variable-m_publisherportid","text":"<pre><code>uint64_t m_publisherPortID {0};\n</code></pre>","title":"variable m_publisherPortID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#variable-m_sourceinterface","text":"<pre><code>iox::capro::Interfaces m_sourceInterface {iox::capro::Interfaces::INTERFACE_END};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable m_sourceInterface"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/","text":"","title":"iox::roudi::SubscriberPortChangingData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#public-attributes","text":"Name     uint64_t fifoSize   uint64_t fifoCapacity   iox::SubscribeState subscriptionState   capro::Scope propagationScope","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-fifosize","text":"<pre><code>uint64_t fifoSize {0};\n</code></pre>","title":"variable fifoSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-fifocapacity","text":"<pre><code>uint64_t fifoCapacity {0};\n</code></pre>","title":"variable fifoCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-subscriptionstate","text":"<pre><code>iox::SubscribeState subscriptionState {iox::SubscribeState::NOT_SUBSCRIBED};\n</code></pre>","title":"variable subscriptionState"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-propagationscope","text":"<pre><code>capro::Scope propagationScope {capro::Scope::INVALID};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable propagationScope"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/","text":"","title":"iox::roudi::SubscriberPortChangingIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#public-attributes","text":"Name     cxx::vector&lt; SubscriberPortChangingData, MAX_SUBSCRIBERS &gt; subscriberPortChangingDataList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#variable-subscriberportchangingdatalist","text":"<pre><code>cxx::vector&lt; SubscriberPortChangingData, MAX_SUBSCRIBERS &gt; subscriberPortChangingDataList;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable subscriberPortChangingDataList"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/","text":"<p>Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU).  <code>#include &lt;iceoryx_posh/runtime/port_config_info.hpp&gt;</code></p>","title":"iox::runtime::PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-functions","text":"Name      PortConfigInfo(const PortConfigInfo &amp; ) =default    PortConfigInfo(PortConfigInfo &amp;&amp; ) =default   PortConfigInfo &amp; operator=(const PortConfigInfo &amp; ) =default   PortConfigInfo &amp; operator=(PortConfigInfo &amp;&amp; ) =default    PortConfigInfo(uint32_t portType =DEFAULT_PORT_TYPE, uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE)creates a PortConfigInfo object    PortConfigInfo(const cxx::Serialization &amp; serialization)creates a PortConfigInfo object from its serialization    operator cxx::Serialization() constcreates a serilaization of the PortConfigInfo   bool operator==(const PortConfigInfo &amp; rhs) constcomparison operator","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-attributes","text":"Name     constexpr uint32_t DEFAULT_PORT_TYPE   constexpr uint32_t DEFAULT_DEVICE_ID   constexpr uint32_t DEFAULT_MEMORY_TYPE   uint32_t portType   iox::mepoo::MemoryInfo memoryInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo","text":"<pre><code>PortConfigInfo(\n    const PortConfigInfo &amp; \n) =default\n</code></pre>","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_1","text":"<pre><code>PortConfigInfo(\n    PortConfigInfo &amp;&amp; \n) =default\n</code></pre>","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator","text":"<pre><code>PortConfigInfo &amp; operator=(\n    const PortConfigInfo &amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator_1","text":"<pre><code>PortConfigInfo &amp; operator=(\n    PortConfigInfo &amp;&amp; \n) =default\n</code></pre>","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_2","text":"<pre><code>PortConfigInfo(\n    uint32_t portType =DEFAULT_PORT_TYPE,\n    uint32_t deviceId =DEFAULT_DEVICE_ID,\n    uint32_t memoryType =DEFAULT_MEMORY_TYPE\n)\n</code></pre> <p>creates a PortConfigInfo object </p> <p>Parameters: </p> <ul> <li>portType specifies the type of port to be created </li> <li>deviceId specifies the device the port operates on (CPU, GPUx etc.) </li> <li>memoryType encodes additional information about the memory used by the port </li> </ul>","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_3","text":"<pre><code>PortConfigInfo(\n    const cxx::Serialization &amp; serialization\n)\n</code></pre> <p>creates a PortConfigInfo object from its serialization </p> <p>Parameters: </p> <ul> <li>serialization specifies the serialization from which the port is created </li> </ul>","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator-cxxserialization","text":"<pre><code>operator cxx::Serialization() const\n</code></pre> <p>creates a serilaization of the PortConfigInfo</p>","title":"function operator cxx::Serialization"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator_2","text":"<pre><code>bool operator==(\n    const PortConfigInfo &amp; rhs\n) const\n</code></pre> <p>comparison operator </p> <p>Parameters: </p> <ul> <li>rhs the right hand side of the comparison </li> </ul>","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_port_type","text":"<pre><code>static constexpr uint32_t DEFAULT_PORT_TYPE {0U};\n</code></pre>","title":"variable DEFAULT_PORT_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_device_id","text":"<pre><code>static constexpr uint32_t DEFAULT_DEVICE_ID {0U};\n</code></pre>","title":"variable DEFAULT_DEVICE_ID"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_memory_type","text":"<pre><code>static constexpr uint32_t DEFAULT_MEMORY_TYPE {0U};\n</code></pre>","title":"variable DEFAULT_MEMORY_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-porttype","text":"<pre><code>uint32_t portType {DEFAULT_PORT_TYPE};\n</code></pre>","title":"variable portType"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-memoryinfo","text":"<pre><code>iox::mepoo::MemoryInfo memoryInfo;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable memoryInfo"},{"location":"API-reference/posh/Files/channel_8hpp/","text":"","title":"iceoryx_posh/gateway/channel.hpp"},{"location":"API-reference/posh/Files/channel_8hpp/#namespaces","text":"Name     iox   iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/channel_8hpp/#classes","text":"Name     class iox::Channel A data structure representing a channel between Iceoryx and an external system.","title":"Classes"},{"location":"API-reference/posh/Files/channel_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_GW_CHANNEL_HPP\n#define IOX_POSH_GW_CHANNEL_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/internal/objectpool/objectpool.hpp\"\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;memory&gt;\n\nnamespace iox\n{\nnamespace gw\n{\nenum class ChannelError : uint8_t\n{\n    OBJECT_POOL_FULL\n};\n\ntemplate &lt;typename IceoryxTerminal, typename ExternalTerminal&gt;\nclass Channel\n{\n    using IceoryxTerminalPtr = std::shared_ptr&lt;IceoryxTerminal&gt;;\n    using IceoryxTerminalPool = cxx::ObjectPool&lt;IceoryxTerminal, MAX_CHANNEL_NUMBER&gt;;\n    using ExternalTerminalPtr = std::shared_ptr&lt;ExternalTerminal&gt;;\n    using ExternalTerminalPool = cxx::ObjectPool&lt;ExternalTerminal, MAX_CHANNEL_NUMBER&gt;;\n\n  public:\n    constexpr Channel(const capro::ServiceDescription&amp; service,\n                      const IceoryxTerminalPtr iceoryxTerminal,\n                      const ExternalTerminalPtr externalTerminal) noexcept;\n\n    constexpr bool operator==(const Channel&lt;IceoryxTerminal, ExternalTerminal&gt;&amp; rhs) const noexcept;\n\n    template &lt;typename IceoryxPubSubOptions&gt;\n    static cxx::expected&lt;Channel, ChannelError&gt; create(const capro::ServiceDescription&amp; service,\n                                                       const IceoryxPubSubOptions&amp; options) noexcept;\n\n    capro::ServiceDescription getServiceDescription() const noexcept;\n    IceoryxTerminalPtr getIceoryxTerminal() const noexcept;\n    ExternalTerminalPtr getExternalTerminal() const noexcept;\n\n  private:\n    static IceoryxTerminalPool s_iceoryxTerminals;\n    static ExternalTerminalPool s_externalTerminals;\n\n    capro::ServiceDescription m_service;\n    IceoryxTerminalPtr m_iceoryxTerminal;\n    ExternalTerminalPtr m_externalTerminal;\n};\n\n} // namespace gw\n} // namespace iox\n\n#include \"iceoryx_posh/internal/gateway/channel.inl\"\n\n#endif // IOX_POSH_GW_CHANNEL_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/chunk__header_8hpp/","text":"","title":"iceoryx_posh/mepoo/chunk_header.hpp"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#namespaces","text":"Name     iox   iox::popo   iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#classes","text":"Name     struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used.   struct iox::mepoo::ChunkHeader","title":"Classes"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_MEPOO_CHUNK_HEADER_HPP\n#define IOX_POSH_MEPOO_CHUNK_HEADER_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/unique_port_id.hpp\"\n#include \"iceoryx_posh/mepoo/chunk_settings.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename T&gt;\nclass ChunkSender;\n}\n\nnamespace mepoo\n{\nstruct NoUserHeader\n{\n};\n\nstruct ChunkHeader\n{\n    using UserPayloadOffset_t = uint32_t;\n\n    ChunkHeader(const uint32_t chunkSize, const ChunkSettings&amp; chunkSettings) noexcept;\n\n    // copy/move ctors/assignment operators are deleted since the calculations for the user-header and user-payload\n    // alignment are dependent on the address of the this pointer\n    ChunkHeader(const ChunkHeader&amp;) = delete;\n    ChunkHeader(ChunkHeader&amp;&amp;) = delete;\n\n    ChunkHeader&amp; operator=(const ChunkHeader&amp;) = delete;\n    ChunkHeader&amp; operator=(ChunkHeader&amp;&amp;) = delete;\n\n    static constexpr uint8_t CHUNK_HEADER_VERSION{1U};\n\n    static constexpr uint16_t NO_USER_HEADER{0x0000};\n    static constexpr uint16_t UNKNOWN_USER_HEADER{0xFFFF};\n\n    uint8_t chunkHeaderVersion() const noexcept;\n\n    uint16_t userHeaderId() const noexcept;\n\n    void* userHeader() noexcept;\n\n    const void* userHeader() const noexcept;\n\n    void* userPayload() noexcept;\n\n    const void* userPayload() const noexcept;\n\n    static ChunkHeader* fromUserPayload(void* const userPayload) noexcept;\n\n    static const ChunkHeader* fromUserPayload(const void* const userPayload) noexcept;\n\n    static ChunkHeader* fromUserHeader(void* const userHeader) noexcept;\n\n    static const ChunkHeader* fromUserHeader(const void* const userHeader) noexcept;\n\n    uint32_t usedSizeOfChunk() const noexcept;\n\n    uint32_t chunkSize() const noexcept;\n\n    uint32_t userHeaderSize() const noexcept;\n\n    uint32_t userPayloadSize() const noexcept;\n\n    uint32_t userPayloadAlignment() const noexcept;\n\n    popo::UniquePortId originId() const noexcept;\n\n    uint64_t sequenceNumber() const noexcept;\n\n  private:\n    template &lt;typename T&gt;\n    friend class popo::ChunkSender;\n\n    void setOriginId(const popo::UniquePortId originId) noexcept;\n\n    void setSequenceNumber(const uint64_t sequenceNumber) noexcept;\n\n    uint64_t overflowSafeUsedSizeOfChunk() const noexcept;\n\n  private:\n    // the order of these members must be changed carefully and if this happens, the m_chunkHeaderVersion\n    // needs to be adapted in order to be able to detect incompatibilities between publisher/subscriber\n    // or record&amp;replay, m_chunkSize and m_chunkHeaderVersion should therefore neither changed the type,\n    // nor the position\n\n    // size of the whole chunk, including the header\n    uint32_t m_chunkSize{0U};\n    uint8_t m_chunkHeaderVersion{CHUNK_HEADER_VERSION};\n    // reserved for future functionality and used to indicate the padding bytes; currently not used and set to `0`\n    uint8_t m_reserved{0};\n    // currently just a placeholder\n    uint16_t m_userHeaderId{NO_USER_HEADER};\n    popo::UniquePortId m_originId{popo::InvalidPortId};\n    uint64_t m_sequenceNumber{0U};\n    uint32_t m_userHeaderSize{0U};\n    uint32_t m_userPayloadSize{0U};\n    uint32_t m_userPayloadAlignment{1U};\n    UserPayloadOffset_t m_userPayloadOffset{sizeof(ChunkHeader)};\n};\n\n} // namespace mepoo\n} // namespace iox\n\n#endif // IOX_POSH_MEPOO_CHUNK_HEADER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/","text":"","title":"iceoryx_posh/mepoo/chunk_settings.hpp"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#namespaces","text":"Name     iox   iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#classes","text":"Name     class iox::mepoo::ChunkSettings","title":"Classes"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP\n#define IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace mepoo\n{\nclass ChunkSettings\n{\n  public:\n    enum class Error\n    {\n        ALIGNMENT_NOT_POWER_OF_TWO,\n        USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT,\n        USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT,\n        REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE,\n    };\n\n    static cxx::expected&lt;ChunkSettings, ChunkSettings::Error&gt;\n    create(const uint32_t userPayloadSize,\n           const uint32_t userPayloadAlignment = iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT,\n           const uint32_t userHeaderSize = iox::CHUNK_NO_USER_HEADER_SIZE,\n           const uint32_t userHeaderAlignment = iox::CHUNK_NO_USER_HEADER_ALIGNMENT) noexcept;\n\n    uint32_t requiredChunkSize() const noexcept;\n\n    uint32_t userPayloadSize() const noexcept;\n\n    uint32_t userPayloadAlignment() const noexcept;\n\n    uint32_t userHeaderSize() const noexcept;\n\n    uint32_t userHeaderAlignment() const noexcept;\n\n  private:\n    ChunkSettings(const uint32_t userPayloadSize,\n                  const uint32_t userPayloadAlignment,\n                  const uint32_t userHeaderSize,\n                  const uint32_t userHeaderAlignment,\n                  const uint32_t requiredChunkSize) noexcept;\n\n    static uint64_t calculateRequiredChunkSize(const uint32_t userPayloadSize,\n                                               const uint32_t userPayloadAlignment,\n                                               const uint32_t userHeaderSize) noexcept;\n\n  private:\n    uint32_t m_userPayloadSize{0U};\n    uint32_t m_userPayloadAlignment{0U};\n    uint32_t m_userHeaderSize{0U};\n    uint32_t m_userHeaderAlignment{0U};\n    uint32_t m_requiredChunkSize{0U};\n};\n\n} // namespace mepoo\n} // namespace iox\n\n#endif // IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/client_8hpp/","text":"","title":"iceoryx_posh/popo/client.hpp"},{"location":"API-reference/posh/Files/client_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/client_8hpp/#classes","text":"Name     class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/client_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_CLIENT_HPP\n#define IOX_POSH_POPO_CLIENT_HPP\n\n#include \"iceoryx_posh/internal/popo/client_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename Req, typename Res&gt;\nclass Client : public ClientImpl&lt;Req, Res&gt;\n{\n    using Impl = ClientImpl&lt;Req, Res&gt;;\n\n  public:\n    using ClientImpl&lt;Req, Res&gt;::ClientImpl;\n\n    virtual ~Client() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_CLIENT_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/client__options_8hpp/","text":"","title":"iceoryx_posh/popo/client_options.hpp"},{"location":"API-reference/posh/Files/client__options_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/client__options_8hpp/#classes","text":"Name     struct iox::popo::ClientOptions This struct is used to configure the client.","title":"Classes"},{"location":"API-reference/posh/Files/client__options_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_CLIENT_OPTIONS_HPP\n#define IOX_POSH_POPO_CLIENT_OPTIONS_HPP\n\n#include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\"\n#include \"iceoryx_posh/popo/port_queue_policies.hpp\"\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nstruct ClientOptions\n{\n    uint64_t responseQueueCapacity{ClientChunkQueueData_t::MAX_CAPACITY};\n\n    iox::NodeName_t nodeName{\"\"};\n\n    bool connectOnCreate{true};\n\n    QueueFullPolicy responseQueueFullPolicy{QueueFullPolicy::DISCARD_OLDEST_DATA};\n\n    ConsumerTooSlowPolicy serverTooSlowPolicy{ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n\n    cxx::Serialization serialize() const noexcept;\n    static cxx::expected&lt;ClientOptions, cxx::Serialization::Error&gt;\n    deserialize(const cxx::Serialization&amp; serialized) noexcept;\n\n    bool operator==(const ClientOptions&amp; rhs) const noexcept;\n};\n\n} // namespace popo\n} // namespace iox\n#endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/","text":"","title":"iceoryx_posh/roudi/cmd_line_args.hpp"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#classes","text":"Name     struct iox::config::CmdLineArgs_t","title":"Classes"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP\n#define IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP\n\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/version/compatibility_check_level.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace config\n{\nstruct CmdLineArgs_t\n{\n    roudi::MonitoringMode monitoringMode{roudi::MonitoringMode::ON};\n    iox::log::LogLevel logLevel{iox::log::LogLevel::kWarn};\n    version::CompatibilityCheckLevel compatibilityCheckLevel{version::CompatibilityCheckLevel::PATCH};\n    units::Duration processKillDelay{roudi::PROCESS_DEFAULT_KILL_DELAY};\n    cxx::optional&lt;uint16_t&gt; uniqueRouDiId{cxx::nullopt};\n    bool run{true};\n    roudi::ConfigFilePathString_t configFilePath;\n};\n\ninline iox::log::LogStream&amp; operator&lt;&lt;(iox::log::LogStream&amp; logstream, const CmdLineArgs_t&amp; cmdLineArgs) noexcept\n{\n    logstream &lt;&lt; \"Log level: \" &lt;&lt; cmdLineArgs.logLevel &lt;&lt; \"\\n\";\n    logstream &lt;&lt; \"Monitoring mode: \" &lt;&lt; cmdLineArgs.monitoringMode &lt;&lt; \"\\n\";\n    logstream &lt;&lt; \"Compatibility check level: \" &lt;&lt; cmdLineArgs.compatibilityCheckLevel &lt;&lt; \"\\n\";\n    cmdLineArgs.uniqueRouDiId.and_then([&amp;logstream](auto&amp; id) { logstream &lt;&lt; \"Unique RouDi ID: \" &lt;&lt; id &lt;&lt; \"\\n\"; })\n        .or_else([&amp;logstream] { logstream &lt;&lt; \"Unique RouDi ID: &lt; unset &gt;\\n\"; });\n    logstream &lt;&lt; \"Process kill delay: \" &lt;&lt; cmdLineArgs.processKillDelay.toSeconds() &lt;&lt; \" s\\n\";\n    if (!cmdLineArgs.configFilePath.empty())\n    {\n        logstream &lt;&lt; \"Config file used is: \" &lt;&lt; cmdLineArgs.configFilePath;\n    }\n    else\n    {\n        logstream &lt;&lt; \"Config file used is: &lt; none &gt;\";\n    }\n    return logstream;\n}\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/","text":"","title":"iceoryx_posh/version/compatibility_check_level.hpp"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/#namespaces","text":"Name     iox   iox::version","title":"Namespaces"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP\n#define IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP\n\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n\nnamespace iox\n{\nnamespace version\n{\nenum class CompatibilityCheckLevel\n{\n    OFF,\n    MAJOR,\n    MINOR,\n    PATCH,\n    COMMIT_ID,\n    BUILD_DATE\n};\n\ninline iox::log::LogStream&amp; operator&lt;&lt;(iox::log::LogStream&amp; logstream,\n                                       const version::CompatibilityCheckLevel&amp; level) noexcept\n{\n    switch (level)\n    {\n    case CompatibilityCheckLevel::OFF:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::OFF\";\n        break;\n    case CompatibilityCheckLevel::MAJOR:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::MAJOR\";\n        break;\n    case CompatibilityCheckLevel::MINOR:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::MINOR\";\n        break;\n    case CompatibilityCheckLevel::PATCH:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::PATCH\";\n        break;\n    case CompatibilityCheckLevel::COMMIT_ID:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::COMMIT_ID\";\n        break;\n    case CompatibilityCheckLevel::BUILD_DATE:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::BUILD_DATE\";\n        break;\n    default:\n        logstream &lt;&lt; \"CompatibilityCheckLevel::UNDEFINED\";\n        break;\n    }\n    return logstream;\n}\n\n} // namespace version\n} // namespace iox\n#endif // IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/default_roudi_memory.hpp"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#classes","text":"Name     struct iox::roudi::DefaultRouDiMemory","title":"Classes"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP\n#define IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP\n\n#include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\"\n#include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nstruct DefaultRouDiMemory\n{\n  public:\n    DefaultRouDiMemory(const RouDiConfig_t&amp; roudiConfig) noexcept;\n    virtual ~DefaultRouDiMemory() noexcept = default;\n\n    DefaultRouDiMemory(DefaultRouDiMemory&amp;&amp;) = delete;\n    DefaultRouDiMemory&amp; operator=(DefaultRouDiMemory&amp;&amp;) = delete;\n\n    DefaultRouDiMemory(const DefaultRouDiMemory&amp;) = delete;\n    DefaultRouDiMemory&amp; operator=(const DefaultRouDiMemory&amp;) = delete;\n\n    mepoo::MePooConfig introspectionMemPoolConfig() const noexcept;\n\n    MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock;\n    MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock;\n    PosixShmMemoryProvider m_managementShm;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/dir_1151a212187b560a7f722eb27ccfc7c0/","text":"","title":"iceoryx_posh/runtime"},{"location":"API-reference/posh/Files/dir_1151a212187b560a7f722eb27ccfc7c0/#files","text":"Name     iceoryx_posh/runtime/node.hpp   iceoryx_posh/runtime/port_config_info.hpp   iceoryx_posh/runtime/posh_runtime.hpp   iceoryx_posh/runtime/posh_runtime_single_process.hpp   iceoryx_posh/runtime/service_discovery.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_1b67add0cf43a7d102340612f5a4e07f/","text":"","title":"iceoryx_posh/mepoo"},{"location":"API-reference/posh/Files/dir_1b67add0cf43a7d102340612f5a4e07f/#files","text":"Name     iceoryx_posh/mepoo/chunk_header.hpp   iceoryx_posh/mepoo/chunk_settings.hpp   iceoryx_posh/mepoo/memory_info.hpp   iceoryx_posh/mepoo/mepoo_config.hpp   iceoryx_posh/mepoo/segment_config.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/","text":"","title":"iceoryx_posh/roudi"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/#directories","text":"Name     iceoryx_posh/roudi/memory","title":"Directories"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/#files","text":"Name     iceoryx_posh/roudi/cmd_line_args.hpp   iceoryx_posh/roudi/iceoryx_roudi_app.hpp   iceoryx_posh/roudi/iceoryx_roudi_components.hpp   iceoryx_posh/roudi/introspection_types.hpp   iceoryx_posh/roudi/port_pool.hpp   iceoryx_posh/roudi/port_pool.inl   iceoryx_posh/roudi/roudi_app.hpp   iceoryx_posh/roudi/roudi_cmd_line_parser.hpp   iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp   iceoryx_posh/roudi/roudi_config.hpp   iceoryx_posh/roudi/roudi_config_file_provider.hpp   iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_419dceea7b650cada8c28739688bd20d/","text":"","title":"iceoryx_posh/popo"},{"location":"API-reference/posh/Files/dir_419dceea7b650cada8c28739688bd20d/#files","text":"Name     iceoryx_posh/popo/client.hpp   iceoryx_posh/popo/client_options.hpp   iceoryx_posh/popo/enum_trigger_type.hpp   iceoryx_posh/popo/listener.hpp   iceoryx_posh/popo/notification_attorney.hpp   iceoryx_posh/popo/notification_callback.hpp   iceoryx_posh/popo/notification_info.hpp   iceoryx_posh/popo/port_queue_policies.hpp   iceoryx_posh/popo/publisher.hpp   iceoryx_posh/popo/publisher_options.hpp   iceoryx_posh/popo/request.hpp   iceoryx_posh/popo/response.hpp   iceoryx_posh/popo/rpc_header.hpp   iceoryx_posh/popo/sample.hpp   iceoryx_posh/popo/server.hpp   iceoryx_posh/popo/server_options.hpp   iceoryx_posh/popo/subscriber.hpp   iceoryx_posh/popo/subscriber_options.hpp   iceoryx_posh/popo/trigger.hpp   iceoryx_posh/popo/trigger_handle.hpp   iceoryx_posh/popo/untyped_client.hpp   iceoryx_posh/popo/untyped_publisher.hpp   iceoryx_posh/popo/untyped_server.hpp   iceoryx_posh/popo/untyped_subscriber.hpp   iceoryx_posh/popo/user_trigger.hpp   iceoryx_posh/popo/wait_set.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/","text":"","title":"iceoryx_posh"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/#directories","text":"Name     iceoryx_posh/capro   iceoryx_posh/gateway   iceoryx_posh/mepoo   iceoryx_posh/popo   iceoryx_posh/roudi   iceoryx_posh/runtime   iceoryx_posh/version","title":"Directories"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/#files","text":"Name     iceoryx_posh/iceoryx_posh_config.hpp   iceoryx_posh/iceoryx_posh_types.hpp   iceoryx_posh/iceoryx_posh_types.inl     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_84fa8189f26ca4adb173569b8d483802/","text":"","title":"iceoryx_posh/gateway"},{"location":"API-reference/posh/Files/dir_84fa8189f26ca4adb173569b8d483802/#files","text":"Name     iceoryx_posh/gateway/channel.hpp   iceoryx_posh/gateway/gateway_base.hpp   iceoryx_posh/gateway/gateway_config.hpp   iceoryx_posh/gateway/gateway_discovery.hpp   iceoryx_posh/gateway/gateway_generic.hpp   iceoryx_posh/gateway/toml_gateway_config_parser.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_b79ea52762aefbdfcef432ced10e3c8e/","text":"","title":"iceoryx_posh/roudi/memory"},{"location":"API-reference/posh/Files/dir_b79ea52762aefbdfcef432ced10e3c8e/#files","text":"Name     iceoryx_posh/roudi/memory/default_roudi_memory.hpp   iceoryx_posh/roudi/memory/generic_memory_block.hpp   iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp   iceoryx_posh/roudi/memory/memory_block.hpp   iceoryx_posh/roudi/memory/memory_provider.hpp   iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp   iceoryx_posh/roudi/memory/roudi_memory_interface.hpp   iceoryx_posh/roudi/memory/roudi_memory_manager.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_d0fffd83abc47c1fbeae6c4f48164f96/","text":"","title":"iceoryx_posh/version"},{"location":"API-reference/posh/Files/dir_d0fffd83abc47c1fbeae6c4f48164f96/#files","text":"Name     iceoryx_posh/version/compatibility_check_level.hpp   iceoryx_posh/version/version_info.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/dir_fa868a754275b86affbf0a162bbaf072/","text":"","title":"iceoryx_posh/capro"},{"location":"API-reference/posh/Files/dir_fa868a754275b86affbf0a162bbaf072/#files","text":"Name     iceoryx_posh/capro/service_description.hpp     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Files"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/","text":"","title":"iceoryx_posh/popo/enum_trigger_type.hpp"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP\n#define IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nusing StateEnumIdentifier = uint64_t;\nusing EventEnumIdentifier = int64_t;\n\ntemplate &lt;typename T&gt;\nconstexpr bool IS_EVENT_ENUM =\n    std::is_enum&lt;T&gt;::value&amp;&amp; std::is_same&lt;std::underlying_type_t&lt;T&gt;, EventEnumIdentifier&gt;::value;\n\ntemplate &lt;typename T&gt;\nconstexpr bool IS_STATE_ENUM =\n    std::is_enum&lt;T&gt;::value&amp;&amp; std::is_same&lt;std::underlying_type_t&lt;T&gt;, StateEnumIdentifier&gt;::value;\n} // namespace popo\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/gateway__base_8hpp/","text":"","title":"iceoryx_posh/gateway/gateway_base.hpp"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#namespaces","text":"Name     iox   iox::capro   iox::popo   iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#classes","text":"Name     class iox::GatewayBase Generic gateway for communication events.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_GW_GATEWAY_BASE_HPP\n#define IOX_POSH_GW_GATEWAY_BASE_HPP\n\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\"\n\n#include &lt;memory&gt;\n\nnamespace iox\n{\nnamespace capro\n{\nclass CaproMessage;\n}\n\nnamespace popo\n{\nclass InterfacePort;\n}\n\nnamespace gw\n{\nclass GatewayBase\n{\n  public:\n    using CaproMessage = capro::CaproMessage;\n\n    GatewayBase(const capro::Interfaces f_interface) noexcept;\n\n    GatewayBase&amp; operator=(const GatewayBase&amp; other) = delete;\n    GatewayBase(const GatewayBase&amp; other) = delete;\n    GatewayBase(GatewayBase&amp;&amp; other) noexcept = default;\n    GatewayBase&amp; operator=(GatewayBase&amp;&amp;) noexcept = default;\n\n    virtual ~GatewayBase() noexcept;\n    bool getCaProMessage(CaproMessage&amp; msg) noexcept;\n\n  protected:\n    // Needed for unit testing\n    GatewayBase() noexcept = default;\n    capro::Interfaces getInterface() const noexcept;\n\n  protected:\n    popo::InterfacePort m_interfaceImpl{nullptr};\n};\n\n} // namespace gw\n} // namespace iox\n\n#endif // IOX_POSH_GW_GATEWAY_BASE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/gateway__config_8hpp/","text":"","title":"iceoryx_posh/gateway/gateway_config.hpp"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#classes","text":"Name     struct iox::config::GatewayConfig Generic configuration for gateways.   struct iox::config::GatewayConfig::ServiceEntry","title":"Classes"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_GW_GATEWAY_CONFIG_HPP\n#define IOX_POSH_GW_GATEWAY_CONFIG_HPP\n\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace config\n{\nstruct GatewayConfig\n{\n    struct ServiceEntry\n    {\n        capro::ServiceDescription m_serviceDescription;\n    };\n    iox::cxx::vector&lt;ServiceEntry, MAX_GATEWAY_SERVICES&gt; m_configuredServices;\n\n    void setDefaults() noexcept;\n};\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_GW_GATEWAY_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/","text":"","title":"iceoryx_posh/gateway/gateway_discovery.hpp"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#namespaces","text":"Name     iox   iox::capro   iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#classes","text":"Name     class iox::GatewayDiscovery Discover the gateway.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_GW_GATEWAY_DISCOVERY_HPP\n#define IOX_POSH_GW_GATEWAY_DISCOVERY_HPP\n\n#include \"iceoryx_posh/gateway/gateway_base.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace capro\n{\nclass CaproMessage;\n}\nnamespace gw\n{\nclass InterfacePort;\n\ntemplate &lt;typename Impl_T = GatewayBase&gt;\nclass GatewayDiscovery\n{\n  public:\n    using CaproMessage = capro::CaproMessage;\n\n    explicit GatewayDiscovery(const capro::Interfaces f_interface) noexcept\n        : m_impl(f_interface)\n    {\n    }\n\n    bool getCaproMessage(CaproMessage&amp; msg) noexcept\n    {\n        return m_impl.getCaProMessage(msg);\n    }\n\n  protected:\n    // needed for unit testing\n    explicit GatewayDiscovery(Impl_T interfacePortImpl) noexcept\n        : m_impl(interfacePortImpl)\n    {\n    }\n\n  private:\n    Impl_T m_impl;\n};\n} // namespace gw\n} // namespace iox\n\n#endif // IOX_POSH_GW_GATEWAY_DISCOVERY_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/","text":"","title":"iceoryx_posh/gateway/gateway_generic.hpp"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#namespaces","text":"Name     iox   iox::gw   iox::units::duration_literals","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#classes","text":"Name     class iox::GatewayGeneric A reference generic gateway implementation.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_GW_GATEWAY_GENERIC_HPP\n#define IOX_POSH_GW_GATEWAY_GENERIC_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/gateway/gateway_base.hpp\"\n#include \"iceoryx_posh/gateway/gateway_config.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_config.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;thread&gt;\n\nnamespace iox\n{\nnamespace gw\n{\nusing namespace iox::units::duration_literals;\n\nenum class GatewayError : uint8_t\n{\n    UNSUPPORTED_SERVICE_TYPE,\n    UNSUCCESSFUL_CHANNEL_CREATION,\n    NONEXISTANT_CHANNEL\n};\n\ntemplate &lt;typename channel_t, typename gateway_t = GatewayBase&gt;\nclass GatewayGeneric : public gateway_t\n{\n    using ChannelVector = cxx::vector&lt;channel_t, MAX_CHANNEL_NUMBER&gt;;\n    using ConcurrentChannelVector = concurrent::smart_lock&lt;ChannelVector&gt;;\n\n  public:\n    virtual ~GatewayGeneric() noexcept;\n\n    GatewayGeneric(const GatewayGeneric&amp;) = delete;\n    GatewayGeneric&amp; operator=(const GatewayGeneric&amp;) = delete;\n    GatewayGeneric(GatewayGeneric&amp;&amp;) = delete;\n    GatewayGeneric&amp; operator=(GatewayGeneric&amp;&amp;) = delete;\n\n    void runMultithreaded() noexcept;\n    void shutdown() noexcept;\n\n    virtual void loadConfiguration(const config::GatewayConfig&amp; config) noexcept = 0;\n    virtual void discover(const capro::CaproMessage&amp; msg) noexcept = 0;\n    virtual void forward(const channel_t&amp; channel) noexcept = 0;\n\n    uint64_t getNumberOfChannels() const noexcept;\n\n  protected:\n    GatewayGeneric(capro::Interfaces interface,\n                   units::Duration discoveryPeriod = 1000_ms,\n                   units::Duration forwardingPeriod = 50_ms) noexcept;\n\n    template &lt;typename IceoryxPubSubOptions&gt;\n    cxx::expected&lt;channel_t, GatewayError&gt; addChannel(const capro::ServiceDescription&amp; service,\n                                                      const IceoryxPubSubOptions&amp; options) noexcept;\n\n    cxx::optional&lt;channel_t&gt; findChannel(const capro::ServiceDescription&amp; service) const noexcept;\n\n    void forEachChannel(const cxx::function_ref&lt;void(channel_t&amp;)&gt; f) const noexcept;\n\n    cxx::expected&lt;GatewayError&gt; discardChannel(const capro::ServiceDescription&amp; service) noexcept;\n\n  private:\n    ConcurrentChannelVector m_channels;\n\n    std::atomic_bool m_isRunning{false};\n\n    units::Duration m_discoveryPeriod;\n    units::Duration m_forwardingPeriod;\n\n    std::thread m_discoveryThread;\n    std::thread m_forwardingThread;\n\n    void forwardingLoop() noexcept;\n    void discoveryLoop() noexcept;\n};\n\n} // namespace gw\n} // namespace iox\n\n#include \"iceoryx_posh/internal/gateway/gateway_generic.inl\"\n\n#endif // IOX_POSH_GW_GATEWAY_GENERIC_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/generic_memory_block.hpp"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#classes","text":"Name     class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case.","title":"Classes"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP\n#define IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP\n\n#include \"iceoryx_posh/roudi/memory/memory_block.hpp\"\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\ntemplate &lt;typename T&gt;\nclass GenericMemoryBlock final : public MemoryBlock\n{\n    friend class MemoryProvider;\n\n  public:\n    GenericMemoryBlock() noexcept = default;\n    ~GenericMemoryBlock() noexcept;\n\n    GenericMemoryBlock(const GenericMemoryBlock&amp;) = delete;\n    GenericMemoryBlock(GenericMemoryBlock&amp;&amp;) = delete;\n    GenericMemoryBlock&amp; operator=(const GenericMemoryBlock&amp;) = delete;\n    GenericMemoryBlock&amp; operator=(GenericMemoryBlock&amp;&amp;) = delete;\n\n    uint64_t size() const noexcept override;\n\n    uint64_t alignment() const noexcept override;\n\n    template &lt;typename... Targs&gt;\n    cxx::optional&lt;T*&gt; emplace(Targs&amp;&amp;... args) noexcept;\n\n    cxx::optional&lt;T*&gt; value() const noexcept;\n\n  protected:\n    void destroy() noexcept override;\n\n  private:\n    T* m_value{nullptr};\n};\n\n} // namespace roudi\n} // namespace iox\n\n#include \"iceoryx_posh/internal/roudi/memory/generic_memory_block.inl\"\n\n#endif // IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/","text":"","title":"iceoryx_posh/iceoryx_posh_config.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#namespaces","text":"Name     iox   iox::helper","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#classes","text":"Name     struct iox::helper::SetDefaults&lt; FirstArg, RemainderArgs... &gt;   struct iox::helper::SetDefaults&lt; FinalArg &gt;   struct iox::helper::Optimize&lt; FirstArg, RemainderArgs... &gt;   struct iox::helper::Optimize&lt; FinalArg &gt;   struct iox::Config","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ICEORYX_POSH_CONFIG_HPP\n#define IOX_POSH_ICEORYX_POSH_CONFIG_HPP\n\n#include \"iceoryx_posh/mepoo/segment_config.hpp\"\n#include \"roudi/roudi_config.hpp\"\n\nnamespace iox\n{\nnamespace helper\n{\ntemplate &lt;typename... ConfigParts&gt;\nstruct SetDefaults;\n\ntemplate &lt;typename FirstArg, typename... RemainderArgs&gt;\nstruct SetDefaults&lt;FirstArg, RemainderArgs...&gt;\n{\n    template &lt;typename BaseType&gt;\n    static void apply(BaseType* me) noexcept\n    {\n        SetDefaults&lt;FirstArg&gt;::apply(me);\n        SetDefaults&lt;RemainderArgs...&gt;::apply(me);\n    }\n};\n\ntemplate &lt;typename FinalArg&gt;\nstruct SetDefaults&lt;FinalArg&gt;\n{\n    template &lt;typename BaseType&gt;\n    static void apply(BaseType* me) noexcept\n    {\n        static_cast&lt;FinalArg*&gt;(me)-&gt;setDefaults();\n    }\n};\n\ntemplate &lt;typename... ConfigParts&gt;\nstruct Optimize;\n\ntemplate &lt;typename FirstArg, typename... RemainderArgs&gt;\nstruct Optimize&lt;FirstArg, RemainderArgs...&gt;\n{\n    template &lt;typename BaseType&gt;\n    static void apply(BaseType* me) noexcept\n    {\n        Optimize&lt;FirstArg&gt;::apply(me);\n        Optimize&lt;RemainderArgs...&gt;::apply(me);\n    }\n};\n\ntemplate &lt;typename FinalArg&gt;\nstruct Optimize&lt;FinalArg&gt;\n{\n    template &lt;typename BaseType&gt;\n    static void apply(BaseType* me) noexcept\n    {\n        static_cast&lt;FinalArg*&gt;(me)-&gt;optimize();\n    }\n};\n} // namespace helper\n\ntemplate &lt;typename... ConfigParts&gt;\nstruct Config : public ConfigParts...\n{\n    Config&amp; setDefaults() noexcept\n    {\n        helper::SetDefaults&lt;ConfigParts...&gt;::apply(this);\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n    Config&amp; setModuleDefaults() noexcept\n    {\n        T::setDefaults();\n        return *this;\n    }\n\n    Config&amp; optimize() noexcept\n    {\n        helper::Optimize&lt;ConfigParts...&gt;::apply(this);\n        return *this;\n    }\n};\n\nusing RouDiConfig_t = Config&lt;mepoo::SegmentConfig, config::RouDiConfig&gt;;\n} // namespace iox\n\n#endif // IOX_POSH_ICEORYX_POSH_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/","text":"","title":"iceoryx_posh/iceoryx_posh_types.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#namespaces","text":"Name     iox   iox::popo   iox::capro   iox::runtime   iox::roudi   iox::mepoo   iox::version","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#classes","text":"Name     struct iox::DefaultChunkDistributorConfig   struct iox::DefaultChunkQueueConfig","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ICEORYX_POSH_TYPES_HPP\n#define IOX_POSH_ICEORYX_POSH_TYPES_HPP\n\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/cxx/variant_queue.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n#include \"iceoryx_hoofs/platform/platform_settings.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_deployment.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass UniquePortId;\nstruct BasePortData;\n\nclass PublisherPortRouDi;\nclass PublisherPortUser;\nclass SubscriberPortRouDi;\nclass SubscriberPortUser;\n} // namespace popo\nnamespace capro\n{\nclass ServiceDescription;\n}\n\nusing PublisherPortRouDiType = iox::popo::PublisherPortRouDi;\nusing PublisherPortUserType = iox::popo::PublisherPortUser;\nusing SubscriberPortRouDiType = iox::popo::SubscriberPortRouDi;\nusing SubscriberPortUserType = iox::popo::SubscriberPortUser;\n\nusing SubscriberPortType = iox::build::CommunicationPolicy;\n\n//--------- Communication Resources Start---------------------\n// Publisher\nconstexpr uint32_t MAX_PUBLISHERS = build::IOX_MAX_PUBLISHERS;\nconstexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build::IOX_MAX_SUBSCRIBERS_PER_PUBLISHER;\nconstexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY =\n    build::IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY;\nconstexpr uint64_t MAX_PUBLISHER_HISTORY = build::IOX_MAX_PUBLISHER_HISTORY;\n// Subscriber\nconstexpr uint32_t MAX_SUBSCRIBERS = build::IOX_MAX_SUBSCRIBERS;\nconstexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY =\n    build::IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY;\nconstexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY;\n// Introspection is using the following publisherPorts, which reduced the number of ports available for the user\n// 1x publisherPort mempool introspection\n// 1x publisherPort process introspection\n// 3x publisherPort port introspection\nconstexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5;\nconstexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1;\nconstexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS =\n    PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY;\n// Gateway\nconstexpr uint32_t MAX_INTERFACE_NUMBER = build::IOX_MAX_INTERFACE_NUMBER;\nconstexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS;\nconstexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS;\nconstexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER;\n// Client\nconstexpr uint32_t MAX_CLIENTS = build::IOX_MAX_SUBSCRIBERS; \nconstexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U;\nconstexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U;\nconstexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U;\n// Server\nconstexpr uint32_t MAX_SERVERS = build::IOX_MAX_PUBLISHERS; \nconstexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U;\nconstexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U;\nconstexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY;\nconstexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024;\n// Waitset\nnamespace popo\n{\nusing WaitSetIsConditionSatisfiedCallback = cxx::ConstMethodCallback&lt;bool&gt;;\n}\nconstexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U;\n\nconstexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build::IOX_MAX_NUMBER_OF_NOTIFIERS;\nconstexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS;\nconstexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS;\n//--------- Communication Resources End---------------------\n\n// Memory\nconstexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U;\nconstexpr uint32_t MAX_SHM_SEGMENTS = 100U;\n\nconstexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U;\nconstexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U;\n\nconstexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT{8U};\nconstexpr uint32_t CHUNK_NO_USER_HEADER_SIZE{0U};\nconstexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT{1U};\n\n// Message Queue\nconstexpr uint32_t ROUDI_MAX_MESSAGES = 5U;\nconstexpr uint32_t ROUDI_MESSAGE_SIZE = 512U;\nconstexpr uint32_t APP_MAX_MESSAGES = 5U;\nconstexpr uint32_t APP_MESSAGE_SIZE = 512U;\n\n\n// Processes\nconstexpr uint32_t MAX_PROCESS_NUMBER = 300U;\n\n// Service Discovery\nconstexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS;\nconstexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY;\n\nconstexpr const char SERVICE_DISCOVERY_SERVICE_NAME[] = \"ServiceDiscovery\";\nconstexpr const char SERVICE_DISCOVERY_INSTANCE_NAME[] = \"RouDi_ID\";\nconstexpr const char SERVICE_DISCOVERY_EVENT_NAME[] = \"ServiceRegistry\";\n\nnamespace runtime\n{\nusing ServiceContainer = iox::cxx::vector&lt;capro::ServiceDescription, MAX_FINDSERVICE_RESULT_SIZE&gt;;\n}\n\n// Nodes\nconstexpr uint32_t MAX_NODE_NUMBER = 1000U;\nconstexpr uint32_t MAX_NODE_PER_PROCESS = 50U;\n\nconstexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH;\n\n\nstatic_assert(MAX_PROCESS_NUMBER * MAX_NODE_PER_PROCESS &gt; MAX_NODE_NUMBER, \"Invalid configuration for nodes\");\n\nenum class SubscribeState : uint32_t\n{\n    NOT_SUBSCRIBED = 0,\n    SUBSCRIBE_REQUESTED,\n    SUBSCRIBED,\n    UNSUBSCRIBE_REQUESTED,\n    WAIT_FOR_OFFER\n};\n\nenum class ConnectionState : uint32_t\n{\n    NOT_CONNECTED = 0,\n    CONNECT_REQUESTED,\n    CONNECTED,\n    DISCONNECT_REQUESTED,\n    WAIT_FOR_OFFER\n};\n\ninline constexpr const char* asStringLiteral(ConnectionState value) noexcept;\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, ConnectionState value) noexcept;\n\ninline log::LogStream&amp; operator&lt;&lt;(log::LogStream&amp; stream, ConnectionState value) noexcept;\n\n// Default properties of ChunkDistributorData\nstruct DefaultChunkDistributorConfig\n{\n    static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER;\n    static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY;\n};\n\n// Default properties of ChunkQueueData\nstruct DefaultChunkQueueConfig\n{\n    static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY;\n};\n\n// alias for cxx::string\nusing RuntimeName_t = cxx::string&lt;MAX_RUNTIME_NAME_LENGTH&gt;;\n// NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers)\nusing NodeName_t = cxx::string&lt;100&gt;;\n// NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers)\nusing ShmName_t = cxx::string&lt;128&gt;;\n\nnamespace capro\n{\n// NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers)\nusing IdString_t = cxx::string&lt;100&gt;;\n} // namespace capro\n\nnamespace roudi\n{\n// NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers)\nusing ConfigFilePathString_t = cxx::string&lt;1024&gt;;\n\nconstexpr const char ROUDI_LOCK_NAME[] = \"iox-unique-roudi\";\nconstexpr const char IPC_CHANNEL_ROUDI_NAME[] = \"roudi\";\n\nconstexpr const char SHM_NAME[] = \"iceoryx_mgmt\";\n\n// this is used by the UniquePortId\nconstexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID{0U};\n\n// Timeout\nusing namespace units::duration_literals;\nconstexpr units::Duration PROCESS_DEFAULT_KILL_DELAY = 45_s;\nconstexpr units::Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250_ms;\nconstexpr units::Duration DISCOVERY_INTERVAL = 100_ms;\n\nenum class MonitoringMode\n{\n    ON,\n    OFF\n};\n\niox::log::LogStream&amp; operator&lt;&lt;(iox::log::LogStream&amp; logstream, const MonitoringMode&amp; mode) noexcept;\n} // namespace roudi\n\nnamespace mepoo\n{\nusing SequenceNumber_t = std::uint64_t;\nusing BaseClock_t = std::chrono::steady_clock;\n\n// use signed integer for duration;\n// there is a bug in gcc 4.8 which leads to a wrong calculated time\n// when sleep_until() is used with a timepoint in the past\nusing DurationNs_t = std::chrono::duration&lt;std::int64_t, std::nano&gt;;\nusing TimePointNs_t = std::chrono::time_point&lt;BaseClock_t, DurationNs_t&gt;;\n} // namespace mepoo\n\nnamespace runtime\n{\nusing namespace units::duration_literals;\nconstexpr units::Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60_s;\nconstexpr units::Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi::DISCOVERY_INTERVAL;  // &gt; DISCOVERY_INTERVAL\nconstexpr units::Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL; // &gt; PROCESS_KEEP_ALIVE_INTERVAL\n} // namespace runtime\n\nnamespace version\n{\nstatic const uint64_t COMMIT_ID_STRING_SIZE = 12U;\nusing CommitIdString_t = cxx::string&lt;COMMIT_ID_STRING_SIZE&gt;;\nstatic const uint64_t BUILD_DATE_STRING_SIZE = 36U;\nusing BuildDateString_t = cxx::string&lt;BUILD_DATE_STRING_SIZE&gt;;\n} // namespace version\n\n} // namespace iox\n\n#include \"iceoryx_posh/iceoryx_posh_types.inl\"\n\n#endif // IOX_POSH_ICEORYX_POSH_TYPES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/","text":"","title":"iceoryx_posh/iceoryx_posh_types.inl"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#defines","text":"Name      IOX_POSH_ICEORYX_POSH_TYPES_INL","title":"Defines"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#define-iox_posh_iceoryx_posh_types_inl","text":"<pre><code>#define IOX_POSH_ICEORYX_POSH_TYPES_INL \n</code></pre>","title":"define IOX_POSH_ICEORYX_POSH_TYPES_INL"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ICEORYX_POSH_TYPES_INL\n#define IOX_POSH_ICEORYX_POSH_TYPES_INL\n\nnamespace iox\n{\ninline constexpr const char* asStringLiteral(ConnectionState value) noexcept\n{\n    switch (value)\n    {\n    case ConnectionState::NOT_CONNECTED:\n        return \"ConnectionState::NOT_CONNECTED\";\n    case ConnectionState::CONNECT_REQUESTED:\n        return \"ConnectionState::CONNECT_REQUESTED\";\n    case ConnectionState::WAIT_FOR_OFFER:\n        return \"ConnectionState::WAIT_FOR_OFFER\";\n    case ConnectionState::CONNECTED:\n        return \"ConnectionState::CONNECTED\";\n    case ConnectionState::DISCONNECT_REQUESTED:\n        return \"ConnectionState::DISCONNECT_REQUESTED\";\n    }\n\n    return \"[Undefined ConnectionState]\";\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, ConnectionState value) noexcept\n{\n    stream &lt;&lt; asStringLiteral(value);\n    return stream;\n}\n\nlog::LogStream&amp; operator&lt;&lt;(log::LogStream&amp; stream, ConnectionState value) noexcept\n{\n    stream &lt;&lt; asStringLiteral(value);\n    return stream;\n}\n\nnamespace roudi\n{\ninline iox::log::LogStream&amp; operator&lt;&lt;(iox::log::LogStream&amp; logstream, const MonitoringMode&amp; mode) noexcept\n{\n    switch (mode)\n    {\n    case MonitoringMode::OFF:\n        logstream &lt;&lt; \"MonitoringMode::OFF\";\n        break;\n    case MonitoringMode::ON:\n        logstream &lt;&lt; \"MonitoringMode::ON\";\n        break;\n    default:\n        logstream &lt;&lt; \"MonitoringMode::UNDEFINED\";\n        break;\n    }\n    return logstream;\n}\n} // namespace roudi\n\n} // namespace iox\n\n#endif // IOX_POSH_ICEORYX_POSH_TYPES_INL\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/","text":"","title":"iceoryx_posh/roudi/iceoryx_roudi_app.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#classes","text":"Name     class iox::roudi::IceOryxRouDiApp","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019, 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP\n#define IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP\n\n#include \"iceoryx_posh/roudi/roudi_app.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nclass IceOryxRouDiApp : public RouDiApp\n{\n  public:\n    IceOryxRouDiApp(const config::CmdLineArgs_t&amp; cmdLineArgs, const RouDiConfig_t&amp; roudiConfig) noexcept;\n\n    uint8_t run() noexcept override;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/","text":"","title":"iceoryx_posh/roudi/iceoryx_roudi_components.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#classes","text":"Name     struct iox::roudi::IceOryxRouDiComponents","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP\n#define IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/generic_raii.hpp\"\n#include \"iceoryx_posh/internal/roudi/port_manager.hpp\"\n#include \"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nstruct IceOryxRouDiComponents\n{\n  public:\n    IceOryxRouDiComponents(const RouDiConfig_t&amp; roudiConfig) noexcept;\n\n    virtual ~IceOryxRouDiComponents() = default;\n\n    IceOryxRouDiMemoryManager rouDiMemoryManager;\n\n    PortManager portManager;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#classes","text":"Name     class iox::roudi::IceOryxRouDiMemoryManager","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP\n#define IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP\n\n#include \"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/file_lock.hpp\"\n#include \"iceoryx_posh/internal/log/posh_logging.hpp\"\n#include \"iceoryx_posh/roudi/memory/default_roudi_memory.hpp\"\n#include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\"\n#include \"iceoryx_posh/roudi/port_pool.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nclass IceOryxRouDiMemoryManager : public RouDiMemoryInterface\n{\n  public:\n    IceOryxRouDiMemoryManager(const RouDiConfig_t&amp; roudiConfig) noexcept;\n    virtual ~IceOryxRouDiMemoryManager() noexcept = default;\n\n    IceOryxRouDiMemoryManager(IceOryxRouDiMemoryManager&amp;&amp;) = delete;\n    IceOryxRouDiMemoryManager&amp; operator=(IceOryxRouDiMemoryManager&amp;&amp;) = delete;\n\n    IceOryxRouDiMemoryManager(const IceOryxRouDiMemoryManager&amp;) = delete;\n    IceOryxRouDiMemoryManager&amp; operator=(const IceOryxRouDiMemoryManager&amp;) = delete;\n\n    cxx::expected&lt;RouDiMemoryManagerError&gt; createAndAnnounceMemory() noexcept override;\n\n    cxx::expected&lt;RouDiMemoryManagerError&gt; destroyMemory() noexcept override;\n\n    const PosixShmMemoryProvider* mgmtMemoryProvider() const noexcept override;\n    cxx::optional&lt;PortPool*&gt; portPool() noexcept override;\n    cxx::optional&lt;mepoo::MemoryManager*&gt; introspectionMemoryManager() const noexcept override;\n    cxx::optional&lt;mepoo::SegmentManager&lt;&gt;*&gt; segmentManager() const noexcept override;\n\n  private:\n    // in order to prevent a second RouDi to cleanup the memory resources of a running RouDi, this resources are\n    // protected by a file lock\n    posix::FileLock fileLock =\n        std::move(posix::FileLock::create(ROUDI_LOCK_NAME)\n                      .or_else([](auto&amp; error) {\n                          if (error == posix::FileLockError::LOCKED_BY_OTHER_PROCESS)\n                          {\n                              LogFatal() &lt;&lt; \"Could not acquire lock, is RouDi still running?\";\n                              errorHandler(Error::kICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING,\n                                           nullptr,\n                                           iox::ErrorLevel::FATAL);\n                          }\n                          else\n                          {\n                              LogFatal() &lt;&lt; \"Error occurred while acquiring file lock named \" &lt;&lt; ROUDI_LOCK_NAME;\n                              errorHandler(Error::kICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK,\n                                           nullptr,\n                                           iox::ErrorLevel::FATAL);\n                          }\n                      })\n                      .value());\n\n    PortPoolMemoryBlock m_portPoolBlock;\n    cxx::optional&lt;PortPool&gt; m_portPool;\n    DefaultRouDiMemory m_defaultMemory;\n    RouDiMemoryManager m_memoryManager;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/introspection__types_8hpp/","text":"","title":"iceoryx_posh/roudi/introspection_types.hpp"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#classes","text":"Name     struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools.   struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to   struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port   struct iox::roudi::PublisherPortData container for publisher port introspection data.   struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to   struct iox::roudi::PortThroughputData   struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to   struct iox::roudi::SubscriberPortChangingData   struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic   struct iox::roudi::ProcessIntrospectionData   struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to","title":"Classes"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP\n#define IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP\n\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/mepoo/mepoo_config.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nconstexpr const char INTROSPECTION_SERVICE_ID[] = \"Introspection\";\nconstexpr const char INTROSPECTION_APP_NAME[] = \"introspection\";\nconstexpr const char INTROSPECTION_NODE_NAME[] = \"introspection\";\nconst capro::ServiceDescription IntrospectionMempoolService(INTROSPECTION_SERVICE_ID, \"RouDi_ID\", \"MemPool\");\nconstexpr int MAX_GROUP_NAME_LENGTH = 32;\n\nstruct MemPoolInfo\n{\n    uint32_t m_usedChunks{0};\n    uint32_t m_minFreeChunks{0};\n    uint32_t m_numChunks{0};\n    uint32_t m_chunkSize{0};\n    uint32_t m_chunkPayloadSize{0};\n};\n\nusing MemPoolInfoContainer = cxx::vector&lt;MemPoolInfo, MAX_NUMBER_OF_MEMPOOLS&gt;;\n\nstruct MemPoolIntrospectionInfo\n{\n    uint32_t m_id;\n    cxx::string&lt;MAX_GROUP_NAME_LENGTH&gt; m_writerGroupName;\n    cxx::string&lt;MAX_GROUP_NAME_LENGTH&gt; m_readerGroupName;\n    MemPoolInfoContainer m_mempoolInfo;\n};\n\nusing MemPoolIntrospectionInfoContainer = cxx::vector&lt;MemPoolIntrospectionInfo, MAX_SHM_SEGMENTS + 1&gt;;\n\nconst capro::ServiceDescription IntrospectionPortService(INTROSPECTION_SERVICE_ID, \"RouDi_ID\", \"Port\");\n\nstruct PortData\n{\n    RuntimeName_t m_name;\n    capro::IdString_t m_caproInstanceID;\n    capro::IdString_t m_caproServiceID;\n    capro::IdString_t m_caproEventMethodID;\n    NodeName_t m_node;\n};\n\nusing SubscriberPortData = PortData;\n\nstruct PublisherPortData : public PortData\n{\n    uint64_t m_publisherPortID{0};\n    iox::capro::Interfaces m_sourceInterface{iox::capro::Interfaces::INTERFACE_END};\n};\n\nstruct PortIntrospectionFieldTopic\n{\n    cxx::vector&lt;SubscriberPortData, MAX_SUBSCRIBERS&gt; m_subscriberList;\n    cxx::vector&lt;PublisherPortData, MAX_PUBLISHERS&gt; m_publisherList;\n};\n\nconst capro::ServiceDescription\n    IntrospectionPortThroughputService(INTROSPECTION_SERVICE_ID, \"RouDi_ID\", \"PortThroughput\");\n\nstruct PortThroughputData\n{\n    uint64_t m_publisherPortID{0};\n    uint32_t m_sampleSize{0};\n    uint32_t m_chunkSize{0};\n    double m_chunksPerMinute{0};\n    uint64_t m_lastSendIntervalInNanoseconds{0};\n    bool m_isField{false};\n};\n\nstruct PortThroughputIntrospectionFieldTopic\n{\n    cxx::vector&lt;PortThroughputData, MAX_PUBLISHERS&gt; m_throughputList;\n};\n\nconst capro::ServiceDescription\n    IntrospectionSubscriberPortChangingDataService(INTROSPECTION_SERVICE_ID, \"RouDi_ID\", \"SubscriberPortsData\");\n\nstruct SubscriberPortChangingData\n{\n    // index used to identify subscriber is same as in PortIntrospectionFieldTopic-&gt;subscriberList\n    uint64_t fifoSize{0};\n    uint64_t fifoCapacity{0};\n    iox::SubscribeState subscriptionState{iox::SubscribeState::NOT_SUBSCRIBED};\n    capro::Scope propagationScope{capro::Scope::INVALID};\n};\n\nstruct SubscriberPortChangingIntrospectionFieldTopic\n{\n    cxx::vector&lt;SubscriberPortChangingData, MAX_SUBSCRIBERS&gt; subscriberPortChangingDataList;\n};\n\nconst capro::ServiceDescription IntrospectionProcessService(INTROSPECTION_SERVICE_ID, \"RouDi_ID\", \"Process\");\n\nstruct ProcessIntrospectionData\n{\n    int m_pid{0};\n    RuntimeName_t m_name;\n    cxx::vector&lt;NodeName_t, MAX_NODE_PER_PROCESS&gt; m_nodes;\n};\n\nstruct ProcessIntrospectionFieldTopic\n{\n    cxx::vector&lt;ProcessIntrospectionData, MAX_PROCESS_NUMBER&gt; m_processList;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/listener_8hpp/","text":"","title":"iceoryx_posh/popo/listener.hpp"},{"location":"API-reference/posh/Files/listener_8hpp/#namespaces","text":"Name     iox   iox::popo   iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Files/listener_8hpp/#classes","text":"Name     class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class.   class iox::popo::Listener","title":"Classes"},{"location":"API-reference/posh/Files/listener_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_LISTENER_HPP\n#define IOX_POSH_POPO_LISTENER_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/loffli.hpp\"\n#include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\"\n#include \"iceoryx_posh/popo/enum_trigger_type.hpp\"\n#include \"iceoryx_posh/popo/notification_attorney.hpp\"\n#include \"iceoryx_posh/popo/notification_callback.hpp\"\n#include \"iceoryx_posh/popo/trigger_handle.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n\n#include &lt;thread&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nnamespace internal\n{\nclass Event_t\n{\n  public:\n    ~Event_t() noexcept;\n\n    bool isEqualTo(const void* const origin, const uint64_t eventType, const uint64_t eventTypeHash) const noexcept;\n    bool reset() noexcept;\n    bool init(const uint64_t eventId,\n              void* const origin,\n              void* const userType,\n              const uint64_t eventType,\n              const uint64_t eventTypeHash,\n              internal::GenericCallbackRef_t callback,\n              internal::TranslationCallbackRef_t translationCallback,\n              const cxx::MethodCallback&lt;void, uint64_t&gt; invalidationCallback) noexcept;\n    void executeCallback() noexcept;\n    bool isInitialized() const noexcept;\n\n  private:\n    static constexpr uint64_t INVALID_ID = std::numeric_limits&lt;uint64_t&gt;::max();\n\n    void* m_origin = nullptr;\n    uint64_t m_eventType = INVALID_ID;\n    uint64_t m_eventTypeHash = INVALID_ID;\n\n    internal::GenericCallbackPtr_t m_callback = nullptr;\n    internal::TranslationCallbackPtr_t m_translationCallback = nullptr;\n    void* m_userType = nullptr;\n\n    uint64_t m_eventId = INVALID_ID;\n    cxx::MethodCallback&lt;void, uint64_t&gt; m_invalidationCallback;\n};\n} // namespace internal\n\nenum class ListenerError\n{\n    LISTENER_FULL,\n    EVENT_ALREADY_ATTACHED,\n    EMPTY_EVENT_CALLBACK,\n    EMPTY_INVALIDATION_CALLBACK\n};\n\ntemplate &lt;uint64_t Capacity&gt;\nclass ListenerImpl\n{\n  public:\n    ListenerImpl() noexcept;\n    ListenerImpl(const ListenerImpl&amp;) = delete;\n    ListenerImpl(ListenerImpl&amp;&amp;) = delete;\n    ~ListenerImpl() noexcept;\n\n    ListenerImpl&amp; operator=(const ListenerImpl&amp;) = delete;\n    ListenerImpl&amp; operator=(ListenerImpl&amp;&amp;) = delete;\n\n    template &lt;typename T,\n              typename EventType,\n              typename ContextDataType,\n              typename = std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\n    cxx::expected&lt;ListenerError&gt; attachEvent(T&amp; eventOrigin,\n                                             const EventType eventType,\n                                             const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback) noexcept;\n\n    template &lt;typename T, typename ContextDataType&gt;\n    cxx::expected&lt;ListenerError&gt; attachEvent(T&amp; eventOrigin,\n                                             const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback) noexcept;\n\n    template &lt;typename T, typename EventType, typename = std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\n    void detachEvent(T&amp; eventOrigin, const EventType eventType) noexcept;\n\n    template &lt;typename T&gt;\n    void detachEvent(T&amp; eventOrigin) noexcept;\n\n    static constexpr uint64_t capacity() noexcept;\n\n    uint64_t size() const noexcept;\n\n  protected:\n    ListenerImpl(ConditionVariableData&amp; conditionVariableData) noexcept;\n\n  private:\n    class Event_t;\n\n    void threadLoop() noexcept;\n    cxx::expected&lt;uint32_t, ListenerError&gt;\n    addEvent(void* const origin,\n             void* const userType,\n             const uint64_t eventType,\n             const uint64_t eventTypeHash,\n             internal::GenericCallbackRef_t callback,\n             internal::TranslationCallbackRef_t translationCallback,\n             const cxx::MethodCallback&lt;void, uint64_t&gt; invalidationCallback) noexcept;\n\n    void removeTrigger(const uint64_t index) noexcept;\n\n  private:\n    enum class NoEnumUsed : EventEnumIdentifier\n    {\n        PLACEHOLDER = 0\n    };\n\n\n    class IndexManager_t\n    {\n      public:\n        IndexManager_t() noexcept;\n        bool pop(uint32_t&amp; index) noexcept;\n        void push(const uint32_t index) noexcept;\n        uint64_t indicesInUse() const noexcept;\n\n        using LoFFLi = concurrent::LoFFLi;\n        LoFFLi::Index_t m_loffliStorage[LoFFLi::requiredIndexMemorySize(Capacity) / sizeof(uint32_t)];\n        LoFFLi m_loffli;\n        std::atomic&lt;uint64_t&gt; m_indicesInUse{0U};\n    } m_indexManager;\n\n\n    std::thread m_thread;\n    concurrent::smart_lock&lt;internal::Event_t, std::recursive_mutex&gt; m_events[Capacity];\n    std::mutex m_addEventMutex;\n\n    std::atomic_bool m_wasDtorCalled{false};\n    ConditionVariableData* m_conditionVariableData = nullptr;\n    ConditionListener m_conditionListener;\n};\n\nclass Listener : public ListenerImpl&lt;MAX_NUMBER_OF_EVENTS_PER_LISTENER&gt;\n{\n  public:\n    using Parent = ListenerImpl&lt;MAX_NUMBER_OF_EVENTS_PER_LISTENER&gt;;\n    Listener() noexcept;\n\n  protected:\n    Listener(ConditionVariableData&amp; conditionVariableData) noexcept;\n};\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/listener.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/memory__block_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/memory_block.hpp"},{"location":"API-reference/posh/Files/memory__block_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__block_8hpp/#classes","text":"Name     class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider, which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case.","title":"Classes"},{"location":"API-reference/posh/Files/memory__block_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP\n#define IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass MemoryBlock\n{\n    friend class MemoryProvider;\n\n  public:\n    MemoryBlock() noexcept = default;\n    virtual ~MemoryBlock() noexcept = default;\n\n    MemoryBlock(const MemoryBlock&amp;) = delete;\n    MemoryBlock(MemoryBlock&amp;&amp;) = delete;\n    MemoryBlock&amp; operator=(const MemoryBlock&amp;) = delete;\n    MemoryBlock&amp; operator=(MemoryBlock&amp;&amp;) = delete;\n\n    virtual uint64_t size() const noexcept = 0;\n\n    virtual uint64_t alignment() const noexcept = 0;\n\n    cxx::optional&lt;void*&gt; memory() const noexcept;\n\n  protected:\n    virtual void destroy() noexcept = 0;\n\n    virtual void onMemoryAvailable(cxx::not_null&lt;void*&gt; memory) noexcept;\n\n  private:\n    void* m_memory{nullptr};\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/memory__info_8hpp/","text":"","title":"iceoryx_posh/mepoo/memory_info.hpp"},{"location":"API-reference/posh/Files/memory__info_8hpp/#namespaces","text":"Name     iox   iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__info_8hpp/#classes","text":"Name     struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics.","title":"Classes"},{"location":"API-reference/posh/Files/memory__info_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_MEPOO_MEMORY_INFO_HPP\n#define IOX_POSH_MEPOO_MEMORY_INFO_HPP\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace mepoo\n{\nstruct MemoryInfo\n{\n    static constexpr uint32_t DEFAULT_DEVICE_ID{0U};\n    static constexpr uint32_t DEFAULT_MEMORY_TYPE{0U};\n\n    // These are intentionally not defined as enum classes for flexibility and extendibility.\n    // Currently only the defaults are used.\n    // This will change when we support different devices (CPU, GPUs, ...)\n    // and other properties that influence how memory is accessed.\n\n    uint32_t deviceId{DEFAULT_DEVICE_ID};\n    uint32_t memoryType{DEFAULT_MEMORY_TYPE};\n\n    MemoryInfo(const MemoryInfo&amp;) noexcept = default;\n    MemoryInfo(MemoryInfo&amp;&amp;) noexcept = default;\n    MemoryInfo&amp; operator=(const MemoryInfo&amp;) noexcept = default;\n    MemoryInfo&amp; operator=(MemoryInfo&amp;&amp;) noexcept = default;\n\n    explicit MemoryInfo(uint32_t deviceId = DEFAULT_DEVICE_ID, uint32_t memoryType = DEFAULT_MEMORY_TYPE) noexcept;\n\n    bool operator==(const MemoryInfo&amp; rhs) const noexcept;\n};\n} // namespace mepoo\n} // namespace iox\n\n#endif // IOX_POSH_MEPOO_MEMORY_INFO_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/memory__provider_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/memory_provider.hpp"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#classes","text":"Name     class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider.","title":"Classes"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP\n#define IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass MemoryBlock;\n\nenum class MemoryProviderError\n{\n    MEMORY_BLOCKS_EXHAUSTED,\n    NO_MEMORY_BLOCKS_PRESENT,\n    MEMORY_ALREADY_CREATED,\n    MEMORY_CREATION_FAILED,\n    MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE,\n    MEMORY_ALLOCATION_FAILED,\n    MEMORY_MAPPING_FAILED,\n    MEMORY_NOT_AVAILABLE,\n    MEMORY_DESTRUCTION_FAILED,\n    MEMORY_DEALLOCATION_FAILED,\n    MEMORY_UNMAPPING_FAILED,\n    SIGACTION_CALL_FAILED,\n};\n\nclass MemoryProvider\n{\n    friend class RouDiMemoryManager;\n\n  public:\n    MemoryProvider() noexcept = default;\n    virtual ~MemoryProvider() noexcept;\n\n    MemoryProvider(const MemoryProvider&amp;) = delete;\n    MemoryProvider(MemoryProvider&amp;&amp;) = delete;\n    MemoryProvider&amp; operator=(const MemoryProvider&amp;) = delete;\n    MemoryProvider&amp; operator=(MemoryProvider&amp;&amp;) = delete;\n\n    cxx::expected&lt;MemoryProviderError&gt; addMemoryBlock(cxx::not_null&lt;MemoryBlock*&gt; memoryBlock) noexcept;\n\n    cxx::expected&lt;MemoryProviderError&gt; create() noexcept;\n\n    void announceMemoryAvailable() noexcept;\n\n    cxx::expected&lt;MemoryProviderError&gt; destroy() noexcept;\n\n    cxx::optional&lt;void*&gt; baseAddress() const noexcept;\n\n    uint64_t size() const noexcept;\n\n    cxx::optional&lt;uint64_t&gt; segmentId() const noexcept;\n\n    bool isAvailable() const noexcept;\n\n    bool isAvailableAnnounced() const noexcept;\n\n  protected:\n    virtual cxx::expected&lt;void*, MemoryProviderError&gt; createMemory(const uint64_t size,\n                                                                   const uint64_t alignment) noexcept = 0;\n\n    virtual cxx::expected&lt;MemoryProviderError&gt; destroyMemory() noexcept = 0;\n\n    static const char* getErrorString(const MemoryProviderError error) noexcept;\n\n  private:\n    void* m_memory{nullptr};\n    uint64_t m_size{0};\n    uint64_t m_segmentId{0};\n    bool m_memoryAvailableAnnounced{false};\n    cxx::vector&lt;MemoryBlock*, MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER&gt; m_memoryBlocks;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/","text":"","title":"iceoryx_posh/mepoo/mepoo_config.hpp"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#namespaces","text":"Name     iox   iox::roudi   iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#classes","text":"Name     struct iox::mepoo::MePooConfig   struct iox::mepoo::MePooConfig::Entry","title":"Classes"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_MEPOO_MEPOO_CONFIG_HPP\n#define IOX_POSH_MEPOO_MEPOO_CONFIG_HPP\n\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass PortManager;\n}\nnamespace mepoo\n{\nstruct MePooConfig\n{\n  public:\n    struct Entry\n    {\n        Entry(uint32_t f_size, uint32_t f_chunkCount) noexcept\n            : m_size(f_size)\n            , m_chunkCount(f_chunkCount)\n        {\n        }\n        uint32_t m_size{0};\n        uint32_t m_chunkCount{0};\n    };\n\n    using MePooConfigContainerType = cxx::vector&lt;Entry, MAX_NUMBER_OF_MEMPOOLS&gt;;\n    MePooConfigContainerType m_mempoolConfig;\n\n    MePooConfig() noexcept = default;\n\n    const MePooConfigContainerType* getMemPoolConfig() const noexcept;\n\n    void addMemPool(Entry f_entry) noexcept;\n\n    MePooConfig&amp; setDefaults() noexcept;\n\n    MePooConfig&amp; optimize() noexcept;\n};\n\n} // namespace mepoo\n} // namespace iox\n\n#endif // IOX_POSH_MEPOO_MEPOO_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/node_8hpp/","text":"","title":"iceoryx_posh/runtime/node.hpp"},{"location":"API-reference/posh/Files/node_8hpp/#namespaces","text":"Name     iox   iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/node_8hpp/#classes","text":"Name     class iox::runtime::Node class which represents a node","title":"Classes"},{"location":"API-reference/posh/Files/node_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_RUNTIME_NODE_HPP\n#define IOX_POSH_RUNTIME_NODE_HPP\n\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace runtime\n{\nclass NodeData;\n\nclass Node\n{\n  public:\n    Node(const NodeName_t&amp; nodeName) noexcept;\n\n    ~Node() noexcept;\n\n    Node(const Node&amp;) = delete;\n    Node&amp; operator=(const Node&amp;) = delete;\n\n    Node(Node&amp;&amp; rhs) noexcept;\n\n    Node&amp; operator=(Node&amp;&amp; rhs) noexcept;\n\n    NodeName_t getNodeName() const noexcept;\n\n    RuntimeName_t getRuntimeName() const noexcept;\n\n  protected:\n    Node(NodeData* const data) noexcept;\n\n    NodeData* m_data = nullptr;\n};\n} // namespace runtime\n} // namespace iox\n\n#endif // IOX_POSH_RUNTIME_NODE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/","text":"","title":"iceoryx_posh/popo/notification_attorney.hpp"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#classes","text":"Name     class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney. Used for example by the WaitSet. Implements the Client-Attorney Pattern.","title":"Classes"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP\n#define IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP\n\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass NotificationAttorney\n{\n    template &lt;uint64_t&gt;\n    friend class WaitSet;\n    template &lt;uint64_t&gt;\n    friend class ListenerImpl;\n\n  private:\n    template &lt;typename T, typename... Targs&gt;\n    static void enableEvent(T&amp; eventOrigin, Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    static void disableEvent(T&amp; eventOrigin, Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    static void enableState(T&amp; stateOrigin, Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    static void disableState(T&amp; stateOrigin, Targs&amp;&amp;... args) noexcept;\n\n    template &lt;typename T&gt;\n    static cxx::MethodCallback&lt;void, uint64_t&gt; getInvalidateTriggerMethod(T&amp; eventOrigin) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    static WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied(T&amp; eventOrigin,\n                                                                                       Targs&amp;&amp;... args) noexcept;\n};\n\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/notification_attorney.inl\"\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/notification__callback_8hpp/","text":"","title":"iceoryx_posh/popo/notification_callback.hpp"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#namespaces","text":"Name     iox   iox::popo   iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#classes","text":"Name     struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener","title":"Classes"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_EVENT_CALLBACK_HPP\n#define IOX_POSH_POPO_EVENT_CALLBACK_HPP\n\n#include \"iceoryx_hoofs/cxx/attributes.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename OriginType, typename ContextDataType&gt;\nstruct EventCallback;\n\nnamespace internal\n{\nstruct NoType_t\n{\n};\n\nusing GenericCallbackPtr_t = void (*)();\nusing GenericCallbackRef_t = void (&amp;)();\n\nusing TranslationCallbackRef_t = void (&amp;)(void* const, void* const, GenericCallbackPtr_t const);\nusing TranslationCallbackPtr_t = void (*)(void* const, void* const, GenericCallbackPtr_t const);\n\ntemplate &lt;typename T, typename ContextDataType&gt;\nstruct TranslateAndCallTypelessCallback\n{\n    static void call(void* const origin, void* const userType, GenericCallbackPtr_t underlyingCallback) noexcept;\n};\n\ntemplate &lt;typename T&gt;\nstruct TranslateAndCallTypelessCallback&lt;T, NoType_t&gt;\n{\n    static void call(void* const origin, void* const userType, GenericCallbackPtr_t underlyingCallback) noexcept;\n};\n} // namespace internal\n\ntemplate &lt;typename OriginType, typename ContextDataType&gt;\nstruct NotificationCallback\n{\n    using Ref_t = void (&amp;)(OriginType* const, ContextDataType* const);\n    using Ptr_t = void (*)(OriginType* const, ContextDataType* const);\n\n    Ptr_t m_callback = nullptr;\n    ContextDataType* m_contextData = nullptr;\n};\n\ntemplate &lt;typename OriginType&gt;\nstruct NotificationCallback&lt;OriginType, internal::NoType_t&gt;\n{\n    using Ref_t = void (&amp;)(OriginType* const);\n    using Ptr_t = void (*)(OriginType* const);\n\n    Ptr_t m_callback = nullptr;\n    internal::NoType_t* m_contextData = nullptr;\n};\n\ntemplate &lt;typename OriginType, typename ContextDataType = internal::NoType_t&gt;\nNotificationCallback&lt;OriginType, ContextDataType&gt;\ncreateNotificationCallback(void (&amp;callback)(OriginType* const)) noexcept;\n\ntemplate &lt;typename OriginType, typename ContextDataType&gt;\nNotificationCallback&lt;OriginType, ContextDataType&gt; createNotificationCallback(void (&amp;callback)(OriginType* const,\n                                                                                              ContextDataType* const),\n                                                                             ContextDataType&amp; userValue) noexcept;\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/notification_callback.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/notification__info_8hpp/","text":"","title":"iceoryx_posh/popo/notification_info.hpp"},{"location":"API-reference/posh/Files/notification__info_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__info_8hpp/#classes","text":"Name     class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback.","title":"Classes"},{"location":"API-reference/posh/Files/notification__info_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_NOTIFICATION_INFO_HPP\n#define IOX_POSH_POPO_NOTIFICATION_INFO_HPP\n\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/error_handling/error_handling.hpp\"\n#include \"iceoryx_posh/internal/log/posh_logging.hpp\"\n#include \"iceoryx_posh/popo/notification_callback.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass NotificationInfo\n{\n  public:\n    static constexpr uint64_t INVALID_ID = std::numeric_limits&lt;uint64_t&gt;::max();\n\n    NotificationInfo() noexcept = default;\n    virtual ~NotificationInfo() noexcept = default;\n\n    template &lt;typename T, typename ContextDataType&gt;\n    NotificationInfo(T* const notificationOrigin,\n                     const uint64_t notificationId,\n                     const NotificationCallback&lt;T, ContextDataType&gt;&amp; callback) noexcept;\n\n    uint64_t getNotificationId() const noexcept;\n\n    template &lt;typename T&gt;\n    bool doesOriginateFrom(T* const notificationOrigin) const noexcept;\n\n    template &lt;typename T&gt;\n    T* getOrigin() const noexcept;\n\n    bool operator()() const noexcept;\n\n    friend class Trigger;\n\n  protected:\n    void* m_notificationOrigin = nullptr;\n    void* m_userValue = nullptr;\n    uint64_t m_notificationOriginTypeHash = 0U;\n    uint64_t m_notificationId = INVALID_ID;\n\n    internal::GenericCallbackPtr_t m_callbackPtr = nullptr;\n    internal::TranslationCallbackPtr_t m_callback = nullptr;\n};\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/notification_info.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/port__config__info_8hpp/","text":"","title":"iceoryx_posh/runtime/port_config_info.hpp"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#namespaces","text":"Name     iox   iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#classes","text":"Name     struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU).","title":"Classes"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP\n#define IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n#include \"iceoryx_posh/mepoo/memory_info.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace runtime\n{\nstruct PortConfigInfo\n{\n    static constexpr uint32_t DEFAULT_PORT_TYPE{0U};\n    static constexpr uint32_t DEFAULT_DEVICE_ID{0U};\n    static constexpr uint32_t DEFAULT_MEMORY_TYPE{0U};\n\n    // these are intentionally not defined as enum classes for flexibility and extendibility\n    // with specific user defined codes used by custom ports\n    // values will be resolved at lower level, (i.e. in the port creation factory)\n\n    uint32_t portType{DEFAULT_PORT_TYPE};\n    iox::mepoo::MemoryInfo memoryInfo;\n\n    PortConfigInfo(const PortConfigInfo&amp;) noexcept = default;\n    PortConfigInfo(PortConfigInfo&amp;&amp;) noexcept = default;\n    PortConfigInfo&amp; operator=(const PortConfigInfo&amp;) noexcept = default;\n    PortConfigInfo&amp; operator=(PortConfigInfo&amp;&amp;) noexcept = default;\n\n    PortConfigInfo(uint32_t portType = DEFAULT_PORT_TYPE,\n                   uint32_t deviceId = DEFAULT_DEVICE_ID,\n                   uint32_t memoryType = DEFAULT_MEMORY_TYPE) noexcept;\n\n    PortConfigInfo(const cxx::Serialization&amp; serialization) noexcept;\n\n    operator cxx::Serialization() const noexcept;\n\n    bool operator==(const PortConfigInfo&amp; rhs) const noexcept;\n};\n\n} // namespace runtime\n} // namespace iox\n\n#endif // IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/port__pool_8hpp/","text":"","title":"iceoryx_posh/roudi/port_pool.hpp"},{"location":"API-reference/posh/Files/port__pool_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/port__pool_8hpp/#classes","text":"Name     class iox::roudi::PortPool","title":"Classes"},{"location":"API-reference/posh/Files/port__pool_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_PORT_POOL_HPP\n#define IOX_POSH_ROUDI_PORT_POOL_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/client_port_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/client_port_roudi.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/publisher_port_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/publisher_port_roudi.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/server_port_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/server_port_roudi.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/subscriber_port_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/subscriber_port_multi_producer.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/subscriber_port_single_producer.hpp\"\n#include \"iceoryx_posh/internal/roudi/port_pool_data.hpp\"\n#include \"iceoryx_posh/internal/runtime/node_data.hpp\"\n#include \"iceoryx_posh/popo/client_options.hpp\"\n#include \"iceoryx_posh/popo/publisher_options.hpp\"\n#include \"iceoryx_posh/popo/server_options.hpp\"\n#include \"iceoryx_posh/popo/subscriber_options.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nstruct PortPoolDataBase;\n\nenum class PortPoolError : uint8_t\n{\n    UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS,\n    INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN,\n    PUBLISHER_PORT_LIST_FULL,\n    SUBSCRIBER_PORT_LIST_FULL,\n    INTERFACE_PORT_LIST_FULL,\n    CLIENT_PORT_LIST_FULL,\n    UNIQUE_SERVER_PORT_ALREADY_EXISTS,\n    SERVER_PORT_LIST_FULL,\n    NODE_DATA_LIST_FULL,\n    CONDITION_VARIABLE_LIST_FULL,\n    EVENT_VARIABLE_LIST_FULL,\n};\n\nclass PortPool\n{\n  public:\n    PortPool(PortPoolData&amp; portPoolData) noexcept;\n\n    virtual ~PortPool() noexcept = default;\n\n    cxx::vector&lt;PublisherPortRouDiType::MemberType_t*, MAX_PUBLISHERS&gt; getPublisherPortDataList() noexcept;\n    cxx::vector&lt;SubscriberPortType::MemberType_t*, MAX_SUBSCRIBERS&gt; getSubscriberPortDataList() noexcept;\n    cxx::vector&lt;popo::ClientPortData*, MAX_CLIENTS&gt; getClientPortDataList() noexcept;\n    cxx::vector&lt;popo::ServerPortData*, MAX_SERVERS&gt; getServerPortDataList() noexcept;\n    cxx::vector&lt;popo::InterfacePortData*, MAX_INTERFACE_NUMBER&gt; getInterfacePortDataList() noexcept;\n    cxx::vector&lt;runtime::NodeData*, MAX_NODE_NUMBER&gt; getNodeDataList() noexcept;\n    cxx::vector&lt;popo::ConditionVariableData*, MAX_NUMBER_OF_CONDITION_VARIABLES&gt;\n    getConditionVariableDataList() noexcept;\n\n    cxx::expected&lt;PublisherPortRouDiType::MemberType_t*, PortPoolError&gt;\n    addPublisherPort(const capro::ServiceDescription&amp; serviceDescription,\n                     mepoo::MemoryManager* const memoryManager,\n                     const RuntimeName_t&amp; runtimeName,\n                     const popo::PublisherOptions&amp; publisherOptions,\n                     const mepoo::MemoryInfo&amp; memoryInfo = mepoo::MemoryInfo()) noexcept;\n\n    cxx::expected&lt;SubscriberPortType::MemberType_t*, PortPoolError&gt;\n    addSubscriberPort(const capro::ServiceDescription&amp; serviceDescription,\n                      const RuntimeName_t&amp; runtimeName,\n                      const popo::SubscriberOptions&amp; subscriberOptions,\n                      const mepoo::MemoryInfo&amp; memoryInfo = mepoo::MemoryInfo()) noexcept;\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same&lt;T, iox::build::ManyToManyPolicy&gt;::value&gt;* = nullptr&gt;\n    iox::popo::SubscriberPortData* constructSubscriber(const capro::ServiceDescription&amp; serviceDescription,\n                                                       const RuntimeName_t&amp; runtimeName,\n                                                       const popo::SubscriberOptions&amp; subscriberOptions,\n                                                       const mepoo::MemoryInfo&amp; memoryInfo) noexcept;\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same&lt;T, iox::build::OneToManyPolicy&gt;::value&gt;* = nullptr&gt;\n    iox::popo::SubscriberPortData* constructSubscriber(const capro::ServiceDescription&amp; serviceDescription,\n                                                       const RuntimeName_t&amp; runtimeName,\n                                                       const popo::SubscriberOptions&amp; subscriberOptions,\n                                                       const mepoo::MemoryInfo&amp; memoryInfo) noexcept;\n\n    cxx::expected&lt;popo::ClientPortData*, PortPoolError&gt;\n    addClientPort(const capro::ServiceDescription&amp; serviceDescription,\n                  mepoo::MemoryManager* const memoryManager,\n                  const RuntimeName_t&amp; runtimeName,\n                  const popo::ClientOptions&amp; clientOptions,\n                  const mepoo::MemoryInfo&amp; memoryInfo = mepoo::MemoryInfo()) noexcept;\n\n    cxx::expected&lt;popo::ServerPortData*, PortPoolError&gt;\n    addServerPort(const capro::ServiceDescription&amp; serviceDescription,\n                  mepoo::MemoryManager* const memoryManager,\n                  const RuntimeName_t&amp; runtimeName,\n                  const popo::ServerOptions&amp; serverOptions,\n                  const mepoo::MemoryInfo&amp; memoryInfo = mepoo::MemoryInfo()) noexcept;\n\n    cxx::expected&lt;popo::InterfacePortData*, PortPoolError&gt; addInterfacePort(const RuntimeName_t&amp; runtimeName,\n                                                                            const capro::Interfaces interface) noexcept;\n\n    cxx::expected&lt;runtime::NodeData*, PortPoolError&gt; addNodeData(const RuntimeName_t&amp; runtimeName,\n                                                                 const NodeName_t&amp; nodeName,\n                                                                 const uint64_t nodeDeviceIdentifier) noexcept;\n\n    cxx::expected&lt;popo::ConditionVariableData*, PortPoolError&gt;\n    addConditionVariableData(const RuntimeName_t&amp; runtimeName) noexcept;\n\n    void removePublisherPort(const PublisherPortRouDiType::MemberType_t* const portData) noexcept;\n\n    void removeSubscriberPort(const SubscriberPortType::MemberType_t* const portData) noexcept;\n\n    void removeClientPort(const popo::ClientPortData* const portData) noexcept;\n\n    void removeServerPort(const popo::ServerPortData* const portData) noexcept;\n\n    void removeInterfacePort(const popo::InterfacePortData* const portData) noexcept;\n\n    void removeNodeData(const runtime::NodeData* const nodeData) noexcept;\n\n    void removeConditionVariableData(const popo::ConditionVariableData* const conditionVariableData) noexcept;\n\n  private:\n    PortPoolData* m_portPoolData;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#include \"iceoryx_posh/roudi/port_pool.inl\"\n\n#endif // IOX_POSH_ROUDI_PORT_POOL_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/port__pool_8inl/","text":"","title":"iceoryx_posh/roudi/port_pool.inl"},{"location":"API-reference/posh/Files/port__pool_8inl/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/port__pool_8inl/#defines","text":"Name      IOX_POSH_ROUDI_PORT_POOL_INL","title":"Defines"},{"location":"API-reference/posh/Files/port__pool_8inl/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/posh/Files/port__pool_8inl/#define-iox_posh_roudi_port_pool_inl","text":"<pre><code>#define IOX_POSH_ROUDI_PORT_POOL_INL \n</code></pre>","title":"define IOX_POSH_ROUDI_PORT_POOL_INL"},{"location":"API-reference/posh/Files/port__pool_8inl/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_PORT_POOL_INL\n#define IOX_POSH_ROUDI_PORT_POOL_INL\n\nnamespace iox\n{\nnamespace roudi\n{\ntemplate &lt;typename T, std::enable_if_t&lt;std::is_same&lt;T, iox::build::ManyToManyPolicy&gt;::value&gt;*&gt;\ninline iox::popo::SubscriberPortData* PortPool::constructSubscriber(const capro::ServiceDescription&amp; serviceDescription,\n                                                                    const RuntimeName_t&amp; runtimeName,\n                                                                    const popo::SubscriberOptions&amp; subscriberOptions,\n                                                                    const mepoo::MemoryInfo&amp; memoryInfo) noexcept\n{\n    return m_portPoolData-&gt;m_subscriberPortMembers.insert(\n        serviceDescription,\n        runtimeName,\n        (subscriberOptions.queueFullPolicy == popo::QueueFullPolicy::DISCARD_OLDEST_DATA)\n            ? cxx::VariantQueueTypes::SoFi_MultiProducerSingleConsumer\n            : cxx::VariantQueueTypes::FiFo_MultiProducerSingleConsumer,\n        subscriberOptions,\n        memoryInfo);\n}\n\ntemplate &lt;typename T, std::enable_if_t&lt;std::is_same&lt;T, iox::build::OneToManyPolicy&gt;::value&gt;*&gt;\ninline iox::popo::SubscriberPortData* PortPool::constructSubscriber(const capro::ServiceDescription&amp; serviceDescription,\n                                                                    const RuntimeName_t&amp; runtimeName,\n                                                                    const popo::SubscriberOptions&amp; subscriberOptions,\n                                                                    const mepoo::MemoryInfo&amp; memoryInfo) noexcept\n{\n    return m_portPoolData-&gt;m_subscriberPortMembers.insert(\n        serviceDescription,\n        runtimeName,\n        (subscriberOptions.queueFullPolicy == popo::QueueFullPolicy::DISCARD_OLDEST_DATA)\n            ? cxx::VariantQueueTypes::SoFi_SingleProducerSingleConsumer\n            : cxx::VariantQueueTypes::FiFo_SingleProducerSingleConsumer,\n        subscriberOptions,\n        memoryInfo);\n}\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_PORT_POOL_INL\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/","text":"","title":"iceoryx_posh/popo/port_queue_policies.hpp"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP\n#define IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nenum class ConsumerTooSlowPolicy : uint8_t\n{\n    WAIT_FOR_CONSUMER,\n    DISCARD_OLDEST_DATA\n};\n\nenum class QueueFullPolicy : uint8_t\n{\n    BLOCK_PRODUCER,\n    DISCARD_OLDEST_DATA\n};\n\n} // namespace popo\n} // namespace iox\n#endif // IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/","text":"","title":"iceoryx_posh/runtime/posh_runtime.hpp"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#namespaces","text":"Name     iox   iox::roudi   iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#classes","text":"Name     class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon.","title":"Classes"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_HPP\n#define IOX_POSH_RUNTIME_POSH_RUNTIME_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_posh/capro/service_description.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/publisher_port_user.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/subscriber_port_user.hpp\"\n#include \"iceoryx_posh/internal/runtime/ipc_runtime_interface.hpp\"\n#include \"iceoryx_posh/internal/runtime/node_property.hpp\"\n#include \"iceoryx_posh/popo/client_options.hpp\"\n#include \"iceoryx_posh/popo/server_options.hpp\"\n#include \"iceoryx_posh/popo/subscriber_options.hpp\"\n#include \"iceoryx_posh/runtime/port_config_info.hpp\"\n\n#include &lt;atomic&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass RuntimeTestInterface;\n} // namespace roudi\n\nnamespace runtime\n{\nclass Node;\nclass NodeData;\n\nclass PoshRuntime\n{\n  public:\n    PoshRuntime(const PoshRuntime&amp;) = delete;\n    PoshRuntime&amp; operator=(const PoshRuntime&amp;) = delete;\n    PoshRuntime(PoshRuntime&amp;&amp;) = delete;\n    PoshRuntime&amp; operator=(PoshRuntime&amp;&amp;) = delete;\n    virtual ~PoshRuntime() noexcept = default;\n\n    static PoshRuntime&amp; getInstance() noexcept;\n\n    static PoshRuntime&amp; initRuntime(const RuntimeName_t&amp; name) noexcept;\n\n    RuntimeName_t getInstanceName() const noexcept;\n\n    void shutdown() noexcept;\n\n    virtual PublisherPortUserType::MemberType_t*\n    getMiddlewarePublisher(const capro::ServiceDescription&amp; service,\n                           const popo::PublisherOptions&amp; publisherOptions = {},\n                           const PortConfigInfo&amp; portConfigInfo = {}) noexcept = 0;\n\n    virtual SubscriberPortUserType::MemberType_t*\n    getMiddlewareSubscriber(const capro::ServiceDescription&amp; service,\n                            const popo::SubscriberOptions&amp; subscriberOptions = {},\n                            const PortConfigInfo&amp; portConfigInfo = {}) noexcept = 0;\n\n    virtual popo::ClientPortData*\n    getMiddlewareClient(const capro::ServiceDescription&amp; service,\n                        const popo::ClientOptions&amp; clientOptions = {},\n                        const PortConfigInfo&amp; portConfigInfo = PortConfigInfo()) noexcept = 0;\n\n    virtual popo::ServerPortData*\n    getMiddlewareServer(const capro::ServiceDescription&amp; service,\n                        const popo::ServerOptions&amp; serverOptions = {},\n                        const PortConfigInfo&amp; portConfigInfo = PortConfigInfo()) noexcept = 0;\n\n    virtual popo::InterfacePortData* getMiddlewareInterface(const capro::Interfaces interface,\n                                                            const NodeName_t&amp; nodeName = {}) noexcept = 0;\n\n    virtual popo::ConditionVariableData* getMiddlewareConditionVariable() noexcept = 0;\n\n    virtual NodeData* createNode(const NodeProperty&amp; nodeProperty) noexcept = 0;\n\n    virtual bool sendRequestToRouDi(const IpcMessage&amp; msg, IpcMessage&amp; answer) noexcept = 0;\n\n  protected:\n    friend class roudi::RuntimeTestInterface;\n    using factory_t = PoshRuntime&amp; (*)(cxx::optional&lt;const RuntimeName_t*&gt;);\n\n    // Protected constructor for derived classes\n    PoshRuntime(cxx::optional&lt;const RuntimeName_t*&gt; name) noexcept;\n\n    static PoshRuntime&amp; defaultRuntimeFactory(cxx::optional&lt;const RuntimeName_t*&gt; name) noexcept;\n\n    static factory_t&amp; getRuntimeFactory() noexcept;\n\n    static void setRuntimeFactory(const factory_t&amp; factory) noexcept;\n\n    static PoshRuntime&amp; getInstance(cxx::optional&lt;const RuntimeName_t*&gt; name) noexcept;\n\n    const RuntimeName_t&amp; verifyInstanceName(cxx::optional&lt;const RuntimeName_t*&gt; name) noexcept;\n\n    const RuntimeName_t m_appName;\n    std::atomic&lt;bool&gt; m_shutdownRequested{false};\n};\n\n} // namespace runtime\n} // namespace iox\n\n#endif // IOX_POSH_RUNTIME_POSH_RUNTIME_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/","text":"","title":"iceoryx_posh/runtime/posh_runtime_single_process.hpp"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#namespaces","text":"Name     iox   iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#classes","text":"Name     class iox::runtime::PoshRuntimeSingleProcess","title":"Classes"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP\n#define IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/runtime/posh_runtime_impl.hpp\"\n\nnamespace iox\n{\nnamespace runtime\n{\nclass PoshRuntimeSingleProcess : public PoshRuntimeImpl\n{\n  public:\n    PoshRuntimeSingleProcess(const RuntimeName_t&amp; name) noexcept;\n    ~PoshRuntimeSingleProcess();\n};\n} // namespace runtime\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#classes","text":"Name     class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration.","title":"Classes"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP\n#define IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP\n\n#include \"iceoryx_posh/roudi/memory/memory_provider.hpp\"\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass PosixShmMemoryProvider : public MemoryProvider\n{\n  public:\n    PosixShmMemoryProvider(const ShmName_t&amp; shmName,\n                           const posix::AccessMode accessMode,\n                           const posix::OpenMode openMode) noexcept;\n    ~PosixShmMemoryProvider() noexcept;\n\n    PosixShmMemoryProvider(PosixShmMemoryProvider&amp;&amp;) = delete;\n    PosixShmMemoryProvider&amp; operator=(PosixShmMemoryProvider&amp;&amp;) = delete;\n\n    PosixShmMemoryProvider(const PosixShmMemoryProvider&amp;) = delete;\n    PosixShmMemoryProvider&amp; operator=(const PosixShmMemoryProvider&amp;) = delete;\n\n  protected:\n    cxx::expected&lt;void*, MemoryProviderError&gt; createMemory(const uint64_t size, const uint64_t alignment) noexcept;\n\n    cxx::expected&lt;MemoryProviderError&gt; destroyMemory() noexcept;\n\n  private:\n    ShmName_t m_shmName;\n    posix::AccessMode m_accessMode{posix::AccessMode::READ_ONLY};\n    posix::OpenMode m_openMode{posix::OpenMode::OPEN_EXISTING};\n    cxx::optional&lt;posix::SharedMemoryObject&gt; m_shmObject;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/publisher_8hpp/","text":"","title":"iceoryx_posh/popo/publisher.hpp"},{"location":"API-reference/posh/Files/publisher_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/publisher_8hpp/#classes","text":"Name     class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/publisher_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_TYPED_PUBLISHER_HPP\n#define IOX_POSH_POPO_TYPED_PUBLISHER_HPP\n\n#include \"iceoryx_posh/internal/popo/publisher_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename T, typename H = mepoo::NoUserHeader&gt;\nclass Publisher : public PublisherImpl&lt;T, H&gt;\n{\n  public:\n    using PublisherImpl&lt;T, H&gt;::PublisherImpl;\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_TYPED_PUBLISHER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/publisher__options_8hpp/","text":"","title":"iceoryx_posh/popo/publisher_options.hpp"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#classes","text":"Name     struct iox::popo::PublisherOptions This struct is used to configure the publisher.","title":"Classes"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP\n#define IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"port_queue_policies.hpp\"\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nstruct PublisherOptions\n{\n    uint64_t historyCapacity{0U};\n\n    iox::NodeName_t nodeName{\"\"};\n\n    bool offerOnCreate{true};\n\n    ConsumerTooSlowPolicy subscriberTooSlowPolicy{ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n\n    cxx::Serialization serialize() const noexcept;\n    static cxx::expected&lt;PublisherOptions, cxx::Serialization::Error&gt;\n    deserialize(const cxx::Serialization&amp; serialized) noexcept;\n};\n\n} // namespace popo\n} // namespace iox\n#endif // IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/request_8hpp/","text":"","title":"iceoryx_posh/popo/request.hpp"},{"location":"API-reference/posh/Files/request_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/request_8hpp/#classes","text":"Name     class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/request_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_REQUEST_HPP\n#define IOX_POSH_POPO_REQUEST_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/cxx/unique_ptr.hpp\"\n#include \"iceoryx_posh/internal/log/posh_logging.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\"\n#include \"iceoryx_posh/internal/popo/smart_chunk.hpp\"\n#include \"iceoryx_posh/mepoo/chunk_header.hpp\"\n#include \"iceoryx_posh/popo/rpc_header.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename RpcType, typename SendErrorEnum&gt;\nclass RpcInterface;\n\ntemplate &lt;typename T&gt;\nclass Request\n    : public SmartChunk&lt;RpcInterface&lt;Request&lt;T&gt;, ClientSendError&gt;, T, cxx::add_const_conditionally_t&lt;RequestHeader, T&gt;&gt;\n{\n    using BaseType =\n        SmartChunk&lt;RpcInterface&lt;Request&lt;T&gt;, ClientSendError&gt;, T, cxx::add_const_conditionally_t&lt;RequestHeader, T&gt;&gt;;\n\n    template &lt;typename S, typename TT&gt;\n    using ForClientOnly = typename BaseType::template ForProducerOnly&lt;S, TT&gt;;\n\n  public:\n    using BaseType::BaseType;\n\n    template &lt;typename S = T, typename = ForClientOnly&lt;S, T&gt;&gt;\n    cxx::expected&lt;ClientSendError&gt; send() noexcept;\n\n    cxx::add_const_conditionally_t&lt;RequestHeader, T&gt;&amp; getRequestHeader() noexcept;\n\n    const RequestHeader&amp; getRequestHeader() const noexcept;\n\n  private:\n    template &lt;typename, typename, typename&gt;\n    friend class ClientImpl;\n    template &lt;typename, typename, typename&gt;\n    friend class ServerImpl;\n\n    using BaseType::release;\n\n    using BaseType::m_members;\n};\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/request.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/response_8hpp/","text":"","title":"iceoryx_posh/popo/response.hpp"},{"location":"API-reference/posh/Files/response_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/response_8hpp/#classes","text":"Name     class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/response_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_RESPONSE_HPP\n#define IOX_POSH_POPO_RESPONSE_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/cxx/unique_ptr.hpp\"\n#include \"iceoryx_posh/internal/log/posh_logging.hpp\"\n#include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\"\n#include \"iceoryx_posh/internal/popo/smart_chunk.hpp\"\n#include \"iceoryx_posh/mepoo/chunk_header.hpp\"\n#include \"iceoryx_posh/popo/rpc_header.hpp\"\n\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename RpcType, typename SendErrorEnum&gt;\nclass RpcInterface;\n\ntemplate &lt;typename T&gt;\nclass Response : public SmartChunk&lt;RpcInterface&lt;Response&lt;T&gt;, ServerSendError&gt;,\n                                   T,\n                                   cxx::add_const_conditionally_t&lt;ResponseHeader, T&gt;&gt;\n{\n    using BaseType =\n        SmartChunk&lt;RpcInterface&lt;Response&lt;T&gt;, ServerSendError&gt;, T, cxx::add_const_conditionally_t&lt;ResponseHeader, T&gt;&gt;;\n\n    template &lt;typename S, typename TT&gt;\n    using ForServerOnly = typename BaseType::template ForProducerOnly&lt;S, TT&gt;;\n\n  public:\n    using BaseType::BaseType;\n\n    template &lt;typename S = T, typename = ForServerOnly&lt;S, T&gt;&gt;\n    cxx::expected&lt;ServerSendError&gt; send() noexcept;\n\n    cxx::add_const_conditionally_t&lt;ResponseHeader, T&gt;&amp; getResponseHeader() noexcept;\n\n    const ResponseHeader&amp; getResponseHeader() const noexcept;\n\n  private:\n    template &lt;typename, typename, typename&gt;\n    friend class ClientImpl;\n    template &lt;typename, typename, typename&gt;\n    friend class ServerImpl;\n\n    using BaseType::release;\n\n    using BaseType::m_members;\n};\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/response.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__app_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_app.hpp"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#classes","text":"Name     class iox::roudi::RouDiApp base class for RouDi daemons","title":"Classes"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_APP_HPP\n#define IOX_POSH_ROUDI_ROUDI_APP_HPP\n\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n#include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_config.hpp\"\n#include \"iceoryx_posh/mepoo/mepoo_config.hpp\"\n#include \"iceoryx_posh/roudi/cmd_line_args.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;cstdio&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass RouDiApp\n{\n  public:\n    static void roudiSigHandler(int32_t signal) noexcept;\n\n    RouDiApp(const config::CmdLineArgs_t&amp; cmdLineArgs, const RouDiConfig_t&amp; config) noexcept;\n\n    virtual ~RouDiApp() noexcept {};\n\n    virtual uint8_t run() noexcept = 0;\n\n  protected:\n    void registerSigHandler() noexcept;\n\n    bool waitForSignal() noexcept;\n\n    iox::log::LogLevel m_logLevel{iox::log::LogLevel::kWarn};\n    roudi::MonitoringMode m_monitoringMode{roudi::MonitoringMode::ON};\n    bool m_run{true};\n    RouDiConfig_t m_config;\n\n    posix::Semaphore m_semaphore =\n        std::move(posix::Semaphore::create(posix::CreateUnnamedSingleProcessSemaphore, 0u)\n                      .or_else([](posix::SemaphoreError&amp;) {\n                          errorHandler(Error::kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE, nullptr, ErrorLevel::FATAL);\n                      })\n                      .value());\n    version::CompatibilityCheckLevel m_compatibilityCheckLevel{version::CompatibilityCheckLevel::PATCH};\n    units::Duration m_processKillDelay{roudi::PROCESS_DEFAULT_KILL_DELAY};\n\n  private:\n    bool checkAndOptimizeConfig(const RouDiConfig_t&amp; config) noexcept;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_APP_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#classes","text":"Name     class iox::config::CmdLineParser","title":"Classes"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP\n#define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/internal/units/duration.hpp\"\n#include \"iceoryx_hoofs/log/logcommon.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/roudi/cmd_line_args.hpp\"\n#include \"iceoryx_posh/version/compatibility_check_level.hpp\"\n\nnamespace iox\n{\nnamespace config\n{\nenum class CmdLineParserResult\n{\n    UNKNOWN_OPTION_USED,\n    INFO_OUTPUT_ONLY \n};\n\nclass CmdLineParser\n{\n  public:\n    enum class CmdLineArgumentParsingMode\n    {\n        ALL,\n        ONE\n    };\n\n    CmdLineParser() noexcept = default;\n    virtual ~CmdLineParser() noexcept = default;\n    CmdLineParser&amp; operator=(const CmdLineParser&amp; other) = delete;\n    CmdLineParser(const CmdLineParser&amp; other) = delete;\n    CmdLineParser&amp; operator=(CmdLineParser&amp;&amp;) = delete;\n    CmdLineParser(CmdLineParser&amp;&amp; other) = delete;\n\n    virtual cxx::expected&lt;CmdLineArgs_t, CmdLineParserResult&gt;\n    parse(int argc,\n          char* argv[],\n          const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode::ALL) noexcept;\n\n  protected:\n    bool m_run{true};\n    iox::log::LogLevel m_logLevel{iox::log::LogLevel::kWarn};\n    roudi::MonitoringMode m_monitoringMode{roudi::MonitoringMode::ON};\n    version::CompatibilityCheckLevel m_compatibilityCheckLevel{version::CompatibilityCheckLevel::PATCH};\n    cxx::optional&lt;uint16_t&gt; m_uniqueRouDiId;\n    units::Duration m_processKillDelay{roudi::PROCESS_DEFAULT_KILL_DELAY};\n};\n\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#classes","text":"Name     class iox::config::CmdLineParserConfigFileOption","title":"Classes"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP\n#define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP\n\n#include \"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp\"\n\nnamespace iox\n{\nnamespace config\n{\nclass CmdLineParserConfigFileOption : public CmdLineParser\n{\n  public:\n    CmdLineParserConfigFileOption() noexcept = default;\n    virtual ~CmdLineParserConfigFileOption() noexcept = default;\n    CmdLineParserConfigFileOption&amp; operator=(const CmdLineParserConfigFileOption&amp; other) = delete;\n    CmdLineParserConfigFileOption(const CmdLineParserConfigFileOption&amp; other) = delete;\n    CmdLineParserConfigFileOption&amp; operator=(CmdLineParserConfigFileOption&amp;&amp;) = delete;\n    CmdLineParserConfigFileOption(CmdLineParserConfigFileOption&amp;&amp; other) = delete;\n\n    cxx::expected&lt;CmdLineArgs_t, CmdLineParserResult&gt;\n    parse(int argc,\n          char* argv[],\n          const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode::ALL) noexcept override;\n\n  protected:\n    roudi::ConfigFilePathString_t m_customConfigFilePath;\n};\n\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_config.hpp"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#classes","text":"Name     struct iox::config::RouDiConfig","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_HPP\n#define IOX_POSH_ROUDI_ROUDI_CONFIG_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace config\n{\nstruct RouDiConfig\n{\n    RouDiConfig&amp; setDefaults() noexcept;\n    RouDiConfig&amp; optimize() noexcept;\n};\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_config_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#classes","text":"Name     class iox::roudi::RouDiConfigFileProvider Base class for a config file provider.","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP\n#define IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_config.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace roudi\n{\nenum class RouDiConfigFileParseError\n{\n    NO_GENERAL_SECTION,\n    INVALID_CONFIG_FILE_VERSION,\n    NO_SEGMENTS,\n    MAX_NUMBER_OF_SEGMENTS_EXCEEDED,\n    SEGMENT_WITHOUT_MEMPOOL,\n    MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED,\n    MEMPOOL_WITHOUT_CHUNK_SIZE,\n    MEMPOOL_WITHOUT_CHUNK_COUNT,\n    EXCEPTION_IN_PARSER\n};\n\nconstexpr const char* ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS[] = {\"NO_GENERAL_SECTION\",\n                                                                 \"INVALID_CONFIG_FILE_VERSION\",\n                                                                 \"NO_SEGMENTS\",\n                                                                 \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\",\n                                                                 \"SEGMENT_WITHOUT_MEMPOOL\",\n                                                                 \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\",\n                                                                 \"MEMPOOL_WITHOUT_CHUNK_SIZE\",\n                                                                 \"MEMPOOL_WITHOUT_CHUNK_COUNT\",\n                                                                 \"EXCEPTION_IN_PARSER\"};\n\nclass RouDiConfigFileProvider\n{\n  public:\n    virtual cxx::expected&lt;RouDiConfig_t, RouDiConfigFileParseError&gt; parse() noexcept = 0;\n\n  protected:\n    ConfigFilePathString_t m_customConfigFilePath;\n};\n\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/","text":"","title":"iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#classes","text":"Name     class iox::config::TomlRouDiConfigFileProvider","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP\n#define IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP\n\n#include \"iceoryx_posh/roudi/cmd_line_args.hpp\"\n#include \"iceoryx_posh/roudi/roudi_config_file_provider.hpp\"\n\nnamespace iox\n{\nnamespace config\n{\nstatic constexpr char defaultConfigFilePath[] = \"/etc/iceoryx/roudi_config.toml\";\n\nclass TomlRouDiConfigFileProvider : public iox::roudi::RouDiConfigFileProvider\n{\n  public:\n    TomlRouDiConfigFileProvider(iox::config::CmdLineArgs_t&amp; cmdLineArgs) noexcept;\n\n    iox::cxx::expected&lt;iox::RouDiConfig_t, iox::roudi::RouDiConfigFileParseError&gt; parse() noexcept override;\n};\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#classes","text":"Name     class iox::roudi::RouDiMemoryInterface","title":"Classes"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020, 2021 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP\n#define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP\n\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\"\n#include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\"\n#include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\"\n#include \"iceoryx_posh/roudi/port_pool.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass MemoryProvider;\n\nclass RouDiMemoryInterface\n{\n  public:\n    RouDiMemoryInterface() noexcept = default;\n    virtual ~RouDiMemoryInterface() noexcept = default;\n\n    RouDiMemoryInterface(RouDiMemoryInterface&amp;&amp;) = delete;\n    RouDiMemoryInterface&amp; operator=(RouDiMemoryInterface&amp;&amp;) = delete;\n\n    RouDiMemoryInterface(const RouDiMemoryInterface&amp;) = delete;\n    RouDiMemoryInterface&amp; operator=(const RouDiMemoryInterface&amp;) = delete;\n\n    virtual cxx::expected&lt;RouDiMemoryManagerError&gt; createAndAnnounceMemory() noexcept = 0;\n\n    virtual cxx::expected&lt;RouDiMemoryManagerError&gt; destroyMemory() noexcept = 0;\n\n    virtual const PosixShmMemoryProvider* mgmtMemoryProvider() const noexcept = 0;\n    virtual cxx::optional&lt;PortPool*&gt; portPool() noexcept = 0;\n    virtual cxx::optional&lt;mepoo::MemoryManager*&gt; introspectionMemoryManager() const noexcept = 0;\n    virtual cxx::optional&lt;mepoo::SegmentManager&lt;&gt;*&gt; segmentManager() const noexcept = 0;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/","text":"","title":"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#namespaces","text":"Name     iox   iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#classes","text":"Name     class iox::roudi::RouDiMemoryManager","title":"Classes"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP\n#define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\"\n#include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\"\n#include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\"\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_hoofs/cxx/optional.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace roudi\n{\nclass MemoryProvider;\n\nenum class RouDiMemoryManagerError\n{\n    MEMORY_PROVIDER_EXHAUSTED,\n    NO_MEMORY_PROVIDER_PRESENT,\n    MEMORY_CREATION_FAILED,\n    MEMORY_DESTRUCTION_FAILED,\n};\n\niox::log::LogStream&amp; operator&lt;&lt;(iox::log::LogStream&amp; logstream, const RouDiMemoryManagerError&amp; error) noexcept;\n\nclass RouDiMemoryManager\n{\n  public:\n    RouDiMemoryManager() noexcept = default;\n    virtual ~RouDiMemoryManager() noexcept;\n\n    RouDiMemoryManager(RouDiMemoryManager&amp;&amp;) = delete;\n    RouDiMemoryManager&amp; operator=(RouDiMemoryManager&amp;&amp;) = delete;\n\n    RouDiMemoryManager(const RouDiMemoryManager&amp;) = delete;\n    RouDiMemoryManager&amp; operator=(const RouDiMemoryManager&amp;) = delete;\n\n    cxx::expected&lt;RouDiMemoryManagerError&gt; addMemoryProvider(MemoryProvider* memoryProvider) noexcept;\n\n    cxx::expected&lt;RouDiMemoryManagerError&gt; createAndAnnounceMemory() noexcept;\n\n    cxx::expected&lt;RouDiMemoryManagerError&gt; destroyMemory() noexcept;\n\n  private:\n    mepoo::MePooConfig introspectionMemPoolConfig() const noexcept;\n    cxx::vector&lt;MemoryProvider*, MAX_NUMBER_OF_MEMORY_PROVIDER&gt; m_memoryProvider;\n};\n} // namespace roudi\n} // namespace iox\n\n#endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/rpc__header_8hpp/","text":"","title":"iceoryx_posh/popo/rpc_header.hpp"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#classes","text":"Name     class iox::popo::RpcBaseHeader   class iox::popo::RequestHeader   class iox::popo::ResponseHeader","title":"Classes"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_RPC_HEADER_HPP\n#define IOX_POSH_POPO_RPC_HEADER_HPP\n\n#include \"iceoryx_hoofs/internal/cxx/unique_id.hpp\"\n#include \"iceoryx_posh/mepoo/chunk_header.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass RpcBaseHeader\n{\n  public:\n    explicit RpcBaseHeader(const cxx::UniqueId&amp; uniqueClientQueueId,\n                           const uint32_t lastKnownClientQueueIndex,\n                           const int64_t sequenceId,\n                           const uint8_t rpcHeaderVersion) noexcept;\n\n    RpcBaseHeader(const RpcBaseHeader&amp; other) = delete;\n    RpcBaseHeader&amp; operator=(const RpcBaseHeader&amp;) = delete;\n    RpcBaseHeader(RpcBaseHeader&amp;&amp; rhs) noexcept = default;\n    RpcBaseHeader&amp; operator=(RpcBaseHeader&amp;&amp; rhs) noexcept = default;\n    ~RpcBaseHeader() noexcept = default;\n\n    static constexpr uint8_t RPC_HEADER_VERSION{1U};\n\n    static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX{std::numeric_limits&lt;uint32_t&gt;::max()};\n    static constexpr int64_t START_SEQUENCE_ID{0};\n\n    uint8_t getRpcHeaderVersion() const noexcept;\n\n    int64_t getSequenceId() const noexcept;\n\n    mepoo::ChunkHeader* getChunkHeader() noexcept;\n\n    const mepoo::ChunkHeader* getChunkHeader() const noexcept;\n\n    void* getUserPayload() noexcept;\n\n    const void* getUserPayload() const noexcept;\n\n    friend class ServerPortUser;\n\n  protected:\n    uint8_t m_rpcHeaderVersion{RPC_HEADER_VERSION};\n    uint32_t m_lastKnownClientQueueIndex{UNKNOWN_CLIENT_QUEUE_INDEX};\n    cxx::UniqueId m_uniqueClientQueueId;\n    int64_t m_sequenceId{0};\n};\n\nclass RequestHeader : public RpcBaseHeader\n{\n  public:\n    explicit RequestHeader(const cxx::UniqueId&amp; uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex) noexcept;\n\n    RequestHeader(const RequestHeader&amp; other) = delete;\n    RequestHeader&amp; operator=(const RequestHeader&amp;) = delete;\n    RequestHeader(RequestHeader&amp;&amp; rhs) noexcept = default;\n    RequestHeader&amp; operator=(RequestHeader&amp;&amp; rhs) noexcept = default;\n    ~RequestHeader() noexcept = default;\n\n    void setSequenceId(const int64_t sequenceId) noexcept;\n\n    static RequestHeader* fromPayload(void* const payload) noexcept;\n    static const RequestHeader* fromPayload(const void* const payload) noexcept;\n};\n\nclass ResponseHeader : public RpcBaseHeader\n{\n  public:\n    explicit ResponseHeader(const cxx::UniqueId&amp; uniqueClientQueueId,\n                            const uint32_t lastKnownClientQueueIndex,\n                            const int64_t sequenceId) noexcept;\n\n    ResponseHeader(const ResponseHeader&amp; other) = delete;\n    ResponseHeader&amp; operator=(const ResponseHeader&amp;) = delete;\n    ResponseHeader(ResponseHeader&amp;&amp; rhs) noexcept = default;\n    ResponseHeader&amp; operator=(ResponseHeader&amp;&amp; rhs) noexcept = default;\n    ~ResponseHeader() noexcept = default;\n\n    void setServerError() noexcept;\n\n    bool hasServerError() const noexcept;\n\n    static ResponseHeader* fromPayload(void* const payload) noexcept;\n    static const ResponseHeader* fromPayload(const void* const payload) noexcept;\n\n  private:\n    bool m_hasServerError{false};\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_RPC_HEADER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/sample_8hpp/","text":"","title":"iceoryx_posh/popo/sample.hpp"},{"location":"API-reference/posh/Files/sample_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/sample_8hpp/#classes","text":"Name     class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/sample_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_SAMPLE_HPP\n#define IOX_POSH_POPO_SAMPLE_HPP\n\n#include \"iceoryx_hoofs/cxx/type_traits.hpp\"\n#include \"iceoryx_hoofs/cxx/unique_ptr.hpp\"\n#include \"iceoryx_posh/internal/log/posh_logging.hpp\"\n#include \"iceoryx_posh/internal/popo/smart_chunk.hpp\"\n#include \"iceoryx_posh/mepoo/chunk_header.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename T, typename H&gt;\nclass PublisherInterface;\n\ntemplate &lt;typename T, typename H = cxx::add_const_conditionally_t&lt;mepoo::NoUserHeader, T&gt;&gt;\nclass Sample : public SmartChunk&lt;PublisherInterface&lt;T, H&gt;, T, H&gt;\n{\n    using BaseType = SmartChunk&lt;PublisherInterface&lt;T, H&gt;, T, H&gt;;\n\n  public:\n    template &lt;typename T1, typename T2&gt;\n    using ForPublisherOnly = typename BaseType::template ForProducerOnly&lt;T1, T2&gt;;\n\n    using BaseType::BaseType;\n\n    using BaseType::getUserHeader;\n\n    template &lt;typename S = T, typename = ForPublisherOnly&lt;S, T&gt;&gt;\n    void publish() noexcept;\n\n  private:\n    template &lt;typename, typename, typename&gt;\n    friend class PublisherImpl;\n\n    using BaseType::release;\n\n    using BaseType::m_members;\n};\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/sample.inl\"\n\n#endif // IOX_POSH_POPO_SAMPLE_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/segment__config_8hpp/","text":"","title":"iceoryx_posh/mepoo/segment_config.hpp"},{"location":"API-reference/posh/Files/segment__config_8hpp/#namespaces","text":"Name     iox   iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/segment__config_8hpp/#classes","text":"Name     struct iox::mepoo::SegmentConfig   struct iox::mepoo::SegmentConfig::SegmentEntry","title":"Classes"},{"location":"API-reference/posh/Files/segment__config_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP\n#define IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP\n\n#include \"iceoryx_posh/mepoo/memory_info.hpp\"\n#include \"iceoryx_posh/mepoo/mepoo_config.hpp\"\n\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\nnamespace iox\n{\nnamespace mepoo\n{\nstruct SegmentConfig\n{\n    struct SegmentEntry\n    {\n        SegmentEntry(const posix::PosixGroup::string_t&amp; readerGroup,\n                     const posix::PosixGroup::string_t&amp; writerGroup,\n                     const MePooConfig&amp; memPoolConfig,\n                     iox::mepoo::MemoryInfo memoryInfo = iox::mepoo::MemoryInfo()) noexcept\n            : m_readerGroup(readerGroup)\n            , m_writerGroup(writerGroup)\n            , m_mempoolConfig(memPoolConfig)\n            , m_memoryInfo(memoryInfo)\n\n        {\n        }\n\n        posix::PosixGroup::string_t m_readerGroup;\n        posix::PosixGroup::string_t m_writerGroup;\n        MePooConfig m_mempoolConfig;\n        iox::mepoo::MemoryInfo m_memoryInfo;\n    };\n\n    cxx::vector&lt;SegmentEntry, MAX_SHM_SEGMENTS&gt; m_sharedMemorySegments;\n\n    SegmentConfig&amp; setDefaults() noexcept;\n\n    SegmentConfig&amp; optimize() noexcept;\n};\n} // namespace mepoo\n} // namespace iox\n\n#endif // IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/server_8hpp/","text":"","title":"iceoryx_posh/popo/server.hpp"},{"location":"API-reference/posh/Files/server_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/server_8hpp/#classes","text":"Name     class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/server_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_SERVER_HPP\n#define IOX_POSH_POPO_SERVER_HPP\n\n#include \"iceoryx_posh/internal/popo/server_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename Req, typename Res&gt;\nclass Server : public ServerImpl&lt;Req, Res&gt;\n{\n    using Impl = ServerImpl&lt;Req, Res&gt;;\n\n  public:\n    using ServerImpl&lt;Req, Res&gt;::ServerImpl;\n\n    virtual ~Server() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_SERVER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/server__options_8hpp/","text":"","title":"iceoryx_posh/popo/server_options.hpp"},{"location":"API-reference/posh/Files/server__options_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/server__options_8hpp/#classes","text":"Name     struct iox::popo::ServerOptions This struct is used to configure the server.","title":"Classes"},{"location":"API-reference/posh/Files/server__options_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_SERVER_OPTIONS_HPP\n#define IOX_POSH_POPO_SERVER_OPTIONS_HPP\n\n#include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\"\n#include \"iceoryx_posh/popo/port_queue_policies.hpp\"\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nstruct ServerOptions\n{\n    uint64_t requestQueueCapacity{ServerChunkQueueData_t::MAX_CAPACITY};\n\n    iox::NodeName_t nodeName{\"\"};\n\n    bool offerOnCreate{true};\n\n    QueueFullPolicy requestQueueFullPolicy{QueueFullPolicy::DISCARD_OLDEST_DATA};\n\n    ConsumerTooSlowPolicy clientTooSlowPolicy{ConsumerTooSlowPolicy::DISCARD_OLDEST_DATA};\n\n    cxx::Serialization serialize() const noexcept;\n    static cxx::expected&lt;ServerOptions, cxx::Serialization::Error&gt;\n    deserialize(const cxx::Serialization&amp; serialized) noexcept;\n\n    bool operator==(const ServerOptions&amp; rhs) const noexcept;\n};\n\n} // namespace popo\n} // namespace iox\n#endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/service__description_8hpp/","text":"","title":"iceoryx_posh/capro/service_description.hpp"},{"location":"API-reference/posh/Files/service__description_8hpp/#namespaces","text":"Name     iox   iox::capro","title":"Namespaces"},{"location":"API-reference/posh/Files/service__description_8hpp/#classes","text":"Name     class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel.   struct iox::capro::ServiceDescription::ClassHash","title":"Classes"},{"location":"API-reference/posh/Files/service__description_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP\n#define IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_hoofs/log/logstream.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cstdint&gt;\n#include &lt;initializer_list&gt;\n\nnamespace iox\n{\nnamespace capro\n{\nusing Wildcard_t = iox::cxx::nullopt_t;\nconstexpr Wildcard_t Wildcard;\n\nstatic constexpr int32_t MAX_NUMBER_OF_CHARS = 64;\nstatic constexpr size_t CLASS_HASH_ELEMENT_COUNT{4U};\n\nenum class Interfaces : uint16_t\n{\n    INTERNAL = 0,\n    ESOC,\n    SOMEIP,\n    AMQP,\n    MQTT,\n    DDS,\n    SIGNAL,\n    MTA,\n    ROS1,\n    INTERFACE_END\n};\n\nconstexpr const char* INTERFACE_NAMES[] = {\"INTERNAL\", \"ESOC\", \"SOMEIP\", \"AMQP\", \"DDS\", \"SIGNAL\", \"MTA\", \"ROS1\", \"END\"};\n\nenum class Scope : uint16_t\n{\n    WORLDWIDE,\n    LOCAL,\n    INVALID\n};\n\nconstexpr char ScopeTypeString[][MAX_NUMBER_OF_CHARS] = {\"WORLDWIDE\", \"INTERNAL\", \"INVALID\"};\n\nclass ServiceDescription\n{\n  public:\n    struct ClassHash\n    {\n        ClassHash() noexcept;\n        ClassHash(const std::initializer_list&lt;uint32_t&gt;&amp; values) noexcept;\n        uint32_t&amp; operator[](iox::cxx::range&lt;uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1&gt; index) noexcept;\n        const uint32_t&amp; operator[](iox::cxx::range&lt;uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1&gt; index) const noexcept;\n        bool operator==(const ClassHash&amp; rhs) const noexcept;\n        bool operator!=(const ClassHash&amp; rhs) const noexcept;\n\n      private:\n        uint32_t data[CLASS_HASH_ELEMENT_COUNT];\n    };\n\n    ServiceDescription() noexcept;\n    ServiceDescription(const ServiceDescription&amp;) noexcept = default;\n    ServiceDescription(ServiceDescription&amp;&amp;) noexcept = default;\n    ~ServiceDescription() noexcept = default;\n\n    ServiceDescription(const IdString_t&amp; service,\n                       const IdString_t&amp; instance,\n                       const IdString_t&amp; event,\n                       ClassHash m_classHash = {0U, 0U, 0U, 0U},\n                       Interfaces interfaceSource = Interfaces::INTERNAL) noexcept;\n\n    bool operator==(const ServiceDescription&amp; rhs) const noexcept;\n\n    bool operator!=(const ServiceDescription&amp; rhs) const noexcept;\n\n    bool operator&lt;(const ServiceDescription&amp; rhs) const noexcept;\n\n    ServiceDescription&amp; operator=(const ServiceDescription&amp;) noexcept = default;\n    ServiceDescription&amp; operator=(ServiceDescription&amp;&amp;) noexcept = default;\n\n    explicit operator cxx::Serialization() const noexcept;\n\n    static cxx::expected&lt;ServiceDescription, cxx::Serialization::Error&gt;\n    deserialize(const cxx::Serialization&amp; serialized) noexcept;\n\n    // @brief Returns if this service description is used for an RouDi-internal channel\n    bool isLocal() const noexcept;\n    // @brief Set this service description to be is used for an RouDi-internal channel\n    void setLocal() noexcept;\n    Scope getScope() const noexcept;\n\n\n    const IdString_t&amp; getServiceIDString() const noexcept;\n    const IdString_t&amp; getInstanceIDString() const noexcept;\n    const IdString_t&amp; getEventIDString() const noexcept;\n\n    ClassHash getClassHash() const noexcept;\n\n    Interfaces getSourceInterface() const noexcept;\n\n  private:\n    IdString_t m_serviceString;\n    IdString_t m_instanceString;\n    IdString_t m_eventString;\n\n    ClassHash m_classHash{0, 0, 0, 0};\n\n    Scope m_scope{Scope::WORLDWIDE};\n\n    Interfaces m_interfaceSource{Interfaces::INTERNAL};\n};\n\nbool serviceMatch(const ServiceDescription&amp; first, const ServiceDescription&amp; second) noexcept;\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const ServiceDescription&amp; service) noexcept;\n\nlog::LogStream&amp; operator&lt;&lt;(log::LogStream&amp; stream, const ServiceDescription&amp; service) noexcept;\n\n} // namespace capro\n} // namespace iox\n\n#endif // IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/service__discovery_8hpp/","text":"","title":"iceoryx_posh/runtime/service_discovery.hpp"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#namespaces","text":"Name     iox   iox::popo   iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#classes","text":"Name     class iox::runtime::ServiceDiscovery","title":"Classes"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP\n#define IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP\n\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/roudi/service_registry.hpp\"\n#include \"iceoryx_posh/popo/subscriber.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nenum class MessagingPattern\n{\n    PUB_SUB,\n    REQ_RES\n};\n} // namespace popo\nnamespace runtime\n{\nenum class ServiceDiscoveryEvent : popo::EventEnumIdentifier\n{\n    SERVICE_REGISTRY_CHANGED\n};\nclass ServiceDiscovery\n{\n  public:\n    ServiceDiscovery() noexcept;\n\n    ServiceDiscovery(const ServiceDiscovery&amp;) = delete;\n    ServiceDiscovery&amp; operator=(const ServiceDiscovery&amp;) = delete;\n    ServiceDiscovery(ServiceDiscovery&amp;&amp;) = delete;\n    ServiceDiscovery&amp; operator=(ServiceDiscovery&amp;&amp;) = delete;\n    ~ServiceDiscovery() noexcept = default;\n\n    void findService(const cxx::optional&lt;capro::IdString_t&gt;&amp; service,\n                     const cxx::optional&lt;capro::IdString_t&gt;&amp; instance,\n                     const cxx::optional&lt;capro::IdString_t&gt;&amp; event,\n                     const cxx::function_ref&lt;void(const capro::ServiceDescription&amp;)&gt;&amp; callableForEach,\n                     const popo::MessagingPattern pattern) noexcept;\n\n    friend iox::popo::NotificationAttorney;\n\n  private:\n    void enableEvent(popo::TriggerHandle&amp;&amp; triggerHandle, const ServiceDiscoveryEvent event) noexcept;\n    void disableEvent(const ServiceDiscoveryEvent event) noexcept;\n    void invalidateTrigger(const uint64_t uniqueTriggerId);\n    iox::popo::WaitSetIsConditionSatisfiedCallback\n    getCallbackForIsStateConditionSatisfied(const popo::SubscriberState state);\n\n    // use dynamic memory to reduce stack usage\n    std::unique_ptr&lt;roudi::ServiceRegistry&gt; m_serviceRegistry{new iox::roudi::ServiceRegistry};\n    std::mutex m_serviceRegistryMutex;\n\n    popo::Subscriber&lt;roudi::ServiceRegistry&gt; m_serviceRegistrySubscriber{\n        {SERVICE_DISCOVERY_SERVICE_NAME, SERVICE_DISCOVERY_INSTANCE_NAME, SERVICE_DISCOVERY_EVENT_NAME},\n        {1U, 1U, iox::NodeName_t(\"Service Registry\"), true}};\n\n    void update();\n};\n\n} // namespace runtime\n} // namespace iox\n\n#endif // IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/subscriber_8hpp/","text":"","title":"iceoryx_posh/popo/subscriber.hpp"},{"location":"API-reference/posh/Files/subscriber_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/subscriber_8hpp/#classes","text":"Name     class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/subscriber_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP\n#define IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP\n\n#include \"iceoryx_posh/internal/popo/subscriber_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\ntemplate &lt;typename T, typename H = mepoo::NoUserHeader&gt;\nclass Subscriber : public SubscriberImpl&lt;T, H&gt;\n{\n    using Impl = SubscriberImpl&lt;T, H&gt;;\n\n  public:\n    using SubscriberImpl&lt;T, H&gt;::SubscriberImpl;\n\n    virtual ~Subscriber() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/","text":"","title":"iceoryx_posh/popo/subscriber_options.hpp"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#classes","text":"Name     struct iox::popo::SubscriberOptions This struct is used to configure the subscriber.","title":"Classes"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP\n#define IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP\n\n#include \"iceoryx_posh/internal/popo/ports/pub_sub_port_types.hpp\"\n#include \"port_queue_policies.hpp\"\n\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nstruct SubscriberOptions\n{\n    uint64_t queueCapacity{SubscriberChunkQueueData_t::MAX_CAPACITY};\n\n    uint64_t historyRequest{0U};\n\n    iox::NodeName_t nodeName{\"\"};\n\n    bool subscribeOnCreate{true};\n\n    QueueFullPolicy queueFullPolicy{QueueFullPolicy::DISCARD_OLDEST_DATA};\n\n    bool requiresPublisherHistorySupport{false};\n\n    cxx::Serialization serialize() const noexcept;\n    static cxx::expected&lt;SubscriberOptions, cxx::Serialization::Error&gt;\n    deserialize(const cxx::Serialization&amp; serialized) noexcept;\n};\n\n} // namespace popo\n} // namespace iox\n#endif // IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/","text":"","title":"iceoryx_posh/gateway/toml_gateway_config_parser.hpp"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#namespaces","text":"Name     iox   iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#classes","text":"Name     class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files.","title":"Classes"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP\n#define IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP\n\n#include \"iceoryx_hoofs/cxx/expected.hpp\"\n#include \"iceoryx_posh/gateway/gateway_config.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n\n#include &lt;cpptoml.h&gt;\n\nnamespace iox\n{\nnamespace config\n{\nenum TomlGatewayConfigParseError\n{\n    FILE_NOT_FOUND,\n    INCOMPLETE_CONFIGURATION,\n    INCOMPLETE_SERVICE_DESCRIPTION,\n    INVALID_SERVICE_DESCRIPTION,\n    EXCEPTION_IN_PARSER,\n    MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\n};\n\nconstexpr const char* TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS[] = {\"FILE_NOT_FOUND\",\n                                                                        \"INCOMPLETE_CONFIGURATION\",\n                                                                        \"INCOMPLETE_SERVICE_DESCRIPTION\",\n                                                                        \"INVALID_SERVICE_DESCRIPTION\",\n                                                                        \"EXCEPTION_IN_PARSER\",\n                                                                        \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\"};\n\nstatic constexpr const char REGEX_VALID_CHARACTERS[] = \"^[a-zA-Z_][a-zA-Z0-9_]*$\";\n\nstatic constexpr const char DEFAULT_CONFIG_FILE_PATH[] = \"/etc/iceoryx/gateway_config.toml\";\nstatic constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME[] = \"services\";\nstatic constexpr const char GATEWAY_CONFIG_SERVICE_NAME[] = \"service\";\nstatic constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME[] = \"instance\";\nstatic constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME[] = \"event\";\n\nclass TomlGatewayConfigParser\n{\n  public:\n    static cxx::expected&lt;GatewayConfig, TomlGatewayConfigParseError&gt;\n    parse(const roudi::ConfigFilePathString_t&amp; path = roudi::ConfigFilePathString_t(DEFAULT_CONFIG_FILE_PATH)) noexcept;\n\n  protected:\n    static cxx::expected&lt;TomlGatewayConfigParseError&gt; validate(const cpptoml::table&amp; parsedToml) noexcept;\n\n  private:\n    static bool hasInvalidCharacter(const std::string&amp; s) noexcept;\n};\n\n} // namespace config\n} // namespace iox\n\n#endif // IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/trigger_8hpp/","text":"","title":"iceoryx_posh/popo/trigger.hpp"},{"location":"API-reference/posh/Files/trigger_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/trigger_8hpp/#classes","text":"Name     struct iox::popo::StateBasedTrigger_t   struct iox::popo::EventBasedTrigger_t   class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance.","title":"Classes"},{"location":"API-reference/posh/Files/trigger_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_TRIGGER_HPP\n#define IOX_POSH_POPO_TRIGGER_HPP\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\"\n#include \"iceoryx_posh/popo/notification_callback.hpp\"\n#include \"iceoryx_posh/popo/notification_info.hpp\"\n\n#include &lt;type_traits&gt;\n#include &lt;typeinfo&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nstruct StateBasedTrigger_t\n{\n};\nconstexpr StateBasedTrigger_t StateBasedTrigger{};\n\nstruct EventBasedTrigger_t\n{\n};\nconstexpr EventBasedTrigger_t EventBasedTrigger{};\n\nenum class TriggerType\n{\n    STATE_BASED,\n    EVENT_BASED,\n    INVALID\n};\n\nclass Trigger\n{\n  public:\n    static constexpr uint64_t INVALID_TRIGGER_ID = std::numeric_limits&lt;uint64_t&gt;::max();\n\n    Trigger() noexcept = delete;\n    Trigger(const Trigger&amp;) = delete;\n    Trigger&amp; operator=(const Trigger&amp;) = delete;\n\n    template &lt;typename T, typename UserType&gt;\n    Trigger(StateBasedTrigger_t,\n            T* const stateOrigin,\n            const cxx::ConstMethodCallback&lt;bool&gt;&amp; hasTriggeredCallback,\n            const cxx::MethodCallback&lt;void, uint64_t&gt;&amp; resetCallback,\n            const uint64_t notificationId,\n            const NotificationCallback&lt;T, UserType&gt;&amp; callback,\n            const uint64_t uniqueId,\n            const uint64_t stateType,\n            const uint64_t stateTypeHash) noexcept;\n\n    template &lt;typename T, typename UserType&gt;\n    Trigger(EventBasedTrigger_t,\n            T* const notificationOrigin,\n            const cxx::MethodCallback&lt;void, uint64_t&gt;&amp; resetCallback,\n            const uint64_t notificationId,\n            const NotificationCallback&lt;T, UserType&gt;&amp; callback,\n            const uint64_t uniqueId,\n            const uint64_t notificationType,\n            const uint64_t notificationTypeHash) noexcept;\n\n    Trigger(Trigger&amp;&amp; rhs) noexcept;\n    Trigger&amp; operator=(Trigger&amp;&amp; rhs) noexcept;\n\n    ~Trigger() noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool isValid() const noexcept;\n\n    bool isStateConditionSatisfied() const noexcept;\n\n    void reset() noexcept;\n\n    void invalidate() noexcept;\n\n    uint64_t getUniqueId() const noexcept;\n\n    bool isLogicalEqualTo(const void* const notificationOrigin,\n                          const uint64_t originTriggerType,\n                          const uint64_t originTriggerTypeHash) const noexcept;\n\n    template &lt;typename T&gt;\n    void updateOrigin(T&amp; newOrigin) noexcept;\n\n    const NotificationInfo&amp; getNotificationInfo() const noexcept;\n\n    TriggerType getTriggerType() const noexcept;\n\n  private:\n    template &lt;typename T, typename ContextDataType&gt;\n    Trigger(T* const notificationOrigin,\n            const cxx::ConstMethodCallback&lt;bool&gt;&amp; hasTriggeredCallback,\n            const cxx::MethodCallback&lt;void, uint64_t&gt;&amp; resetCallback,\n            const uint64_t notificationId,\n            const NotificationCallback&lt;T, ContextDataType&gt;&amp; callback,\n            const uint64_t uniqueId,\n            const TriggerType triggerType,\n            const uint64_t originTriggerType,\n            const uint64_t originTriggerTypeHash) noexcept;\n\n  private:\n    NotificationInfo m_notificationInfo;\n\n    cxx::ConstMethodCallback&lt;bool&gt; m_hasTriggeredCallback;\n    cxx::MethodCallback&lt;void, uint64_t&gt; m_resetCallback;\n    uint64_t m_uniqueId = INVALID_TRIGGER_ID;\n\n    TriggerType m_triggerType = TriggerType::STATE_BASED;\n    uint64_t m_originTriggerType = INVALID_TRIGGER_ID;\n    uint64_t m_originTriggerTypeHash = INVALID_TRIGGER_ID;\n};\n\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/trigger.inl\"\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/","text":"","title":"iceoryx_posh/popo/trigger_handle.hpp"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#classes","text":"Name     class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable.","title":"Classes"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_TRIGGER_HANDLE_HPP\n#define IOX_POSH_POPO_TRIGGER_HANDLE_HPP\n\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\"\n#include \"iceoryx_posh/popo/trigger.hpp\"\n\n#include &lt;limits&gt;\n#include &lt;mutex&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass TriggerHandle\n{\n  public:\n    TriggerHandle() noexcept;\n\n    TriggerHandle(ConditionVariableData&amp; conditionVariableData,\n                  const cxx::MethodCallback&lt;void, uint64_t&gt; resetCallback,\n                  const uint64_t uniqueTriggerId) noexcept;\n    TriggerHandle(const TriggerHandle&amp;) = delete;\n    TriggerHandle&amp; operator=(const TriggerHandle&amp;) = delete;\n\n    TriggerHandle(TriggerHandle&amp;&amp; rhs) noexcept;\n    TriggerHandle&amp; operator=(TriggerHandle&amp;&amp; rhs) noexcept;\n    ~TriggerHandle() noexcept;\n\n    explicit operator bool() const noexcept;\n\n    bool isValid() const noexcept;\n\n    bool wasTriggered() const noexcept;\n\n    void trigger() noexcept;\n\n    void reset() noexcept;\n\n    void invalidate() noexcept;\n\n    uint64_t getUniqueId() const noexcept;\n\n    ConditionVariableData* getConditionVariableData() noexcept;\n\n  private:\n    ConditionVariableData* m_conditionVariableDataPtr = nullptr;\n    cxx::MethodCallback&lt;void, uint64_t&gt; m_resetCallback;\n    uint64_t m_uniqueTriggerId = Trigger::INVALID_TRIGGER_ID;\n    mutable std::recursive_mutex m_mutex;\n};\n} // namespace popo\n} // namespace iox\n\n#endif\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/untyped__client_8hpp/","text":"","title":"iceoryx_posh/popo/untyped_client.hpp"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#classes","text":"Name     class iox::popo::UntypedClient","title":"Classes"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_UNTYPED_CLIENT_HPP\n#define IOX_POSH_POPO_UNTYPED_CLIENT_HPP\n\n#include \"iceoryx_posh/internal/popo/untyped_client_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\nclass UntypedClient : public UntypedClientImpl&lt;&gt;\n{\n    using Impl = UntypedClientImpl&lt;&gt;;\n\n  public:\n    using UntypedClientImpl&lt;&gt;::UntypedClientImpl;\n\n    virtual ~UntypedClient() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_UNTYPED_CLIENT_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/","text":"","title":"iceoryx_posh/popo/untyped_publisher.hpp"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#classes","text":"Name     class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP\n#define IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP\n\n#include \"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\nclass UntypedPublisher : public UntypedPublisherImpl&lt;&gt;\n{\n  public:\n    using UntypedPublisherImpl&lt;&gt;::UntypedPublisherImpl;\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/untyped__server_8hpp/","text":"","title":"iceoryx_posh/popo/untyped_server.hpp"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#classes","text":"Name     class iox::popo::UntypedServer","title":"Classes"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_UNTYPED_SERVER_HPP\n#define IOX_POSH_POPO_UNTYPED_SERVER_HPP\n\n#include \"iceoryx_posh/internal/popo/untyped_server_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\nclass UntypedServer : public UntypedServerImpl&lt;&gt;\n{\n    using Impl = UntypedServerImpl&lt;&gt;;\n\n  public:\n    using UntypedServerImpl&lt;&gt;::UntypedServerImpl;\n\n    virtual ~UntypedServer() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_UNTYPED_SERVER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/","text":"","title":"iceoryx_posh/popo/untyped_subscriber.hpp"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#classes","text":"Name     class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP\n#define IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP\n\n#include \"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp\"\n\nnamespace iox\n{\nnamespace popo\n{\nclass UntypedSubscriber : public UntypedSubscriberImpl&lt;&gt;\n{\n    using Impl = UntypedSubscriberImpl&lt;&gt;;\n\n  public:\n    using UntypedSubscriberImpl&lt;&gt;::UntypedSubscriberImpl;\n\n    virtual ~UntypedSubscriber() noexcept\n    {\n        Impl::m_trigger.reset();\n    }\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/user__trigger_8hpp/","text":"","title":"iceoryx_posh/popo/user_trigger.hpp"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#classes","text":"Name     class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class.","title":"Classes"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_POPO_USER_TRIGGER_HPP\n#define IOX_POSH_POPO_USER_TRIGGER_HPP\n\n#include \"iceoryx_posh/popo/trigger.hpp\"\n#include \"iceoryx_posh/popo/wait_set.hpp\"\n\n#include &lt;atomic&gt;\n#include &lt;mutex&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass UserTrigger\n{\n  public:\n    UserTrigger() noexcept;\n    UserTrigger(const UserTrigger&amp; rhs) = delete;\n    UserTrigger(UserTrigger&amp;&amp; rhs) = delete;\n    UserTrigger&amp; operator=(const UserTrigger&amp; rhs) = delete;\n    UserTrigger&amp; operator=(UserTrigger&amp;&amp; rhs) = delete;\n\n    void trigger() noexcept;\n\n    bool hasTriggered() const noexcept;\n\n    friend class NotificationAttorney;\n\n  private:\n    void invalidateTrigger(const uint64_t uniqueTriggerId) noexcept;\n\n    void enableEvent(iox::popo::TriggerHandle&amp;&amp; triggerHandle) noexcept;\n\n    void disableEvent() noexcept;\n\n  private:\n    TriggerHandle m_trigger;\n};\n\n} // namespace popo\n} // namespace iox\n\n#endif // IOX_POSH_POPO_USER_TRIGGER_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/version__info_8hpp/","text":"","title":"iceoryx_posh/version/version_info.hpp"},{"location":"API-reference/posh/Files/version__info_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_VERSION_VERSION_INFO_HPP\n#define IOX_POSH_VERSION_VERSION_INFO_HPP\n\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/serialization.hpp\"\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/version/compatibility_check_level.hpp\"\n#include \"iceoryx_versions.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace iox\n{\nnamespace version\n{\nclass VersionInfo\n{\n  public:\n    VersionInfo(const uint16_t versionMajor,\n                const uint16_t versionMinor,\n                const uint16_t versionPatch,\n                const uint16_t versionTweak,\n                const BuildDateString_t&amp; buildDateString,\n                const CommitIdString_t&amp; commitIdString) noexcept;\n\n    VersionInfo(const cxx::Serialization&amp; serial) noexcept;\n\n    operator cxx::Serialization() const noexcept;\n\n    bool operator==(const VersionInfo&amp; rhs) const noexcept;\n\n    bool operator!=(const VersionInfo&amp; rhs) const noexcept;\n\n    bool checkCompatibility(const VersionInfo&amp; other,\n                            const CompatibilityCheckLevel compatibilityCheckLevel) const noexcept;\n\n    bool isValid() noexcept;\n\n    static VersionInfo getCurrentVersion() noexcept;\n\n  protected:\n    static const uint64_t SERIALIZATION_STRING_SIZE = 100u;\n    using SerializationString_t = cxx::string&lt;SERIALIZATION_STRING_SIZE&gt;;\n\n    static_assert(COMMIT_ID_STRING_SIZE &lt;= SERIALIZATION_STRING_SIZE, \"CommitId needs to transfered completely.\");\n    static_assert(COMMIT_ID_STRING_SIZE &lt;= BUILD_DATE_STRING_SIZE, \"BuildDate needs to transfered completely.\");\n    static_assert(cxx::strlen2(ICEORYX_BUILDDATE) &lt; BUILD_DATE_STRING_SIZE,\n                  \"COMMIT_BUILD_DATE_STRING_SIZE needs to be bigger.\");\n\n  protected:\n    bool m_valid{true};\n    uint16_t m_versionMajor{0u};\n    uint16_t m_versionMinor{0u};\n    uint16_t m_versionPatch{0u};\n    uint16_t m_versionTweak{0u};\n    BuildDateString_t m_buildDateString;\n    CommitIdString_t m_commitIdString;\n};\n\n} // namespace version\n} // namespace iox\n#endif // IOX_POSH_VERSION_VERSION_INFO_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Files/wait__set_8hpp/","text":"","title":"iceoryx_posh/popo/wait_set.hpp"},{"location":"API-reference/posh/Files/wait__set_8hpp/#namespaces","text":"Name     iox   iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/wait__set_8hpp/#classes","text":"Name     class iox::popo::WaitSet Logical disjunction of a certain number of Triggers.","title":"Classes"},{"location":"API-reference/posh/Files/wait__set_8hpp/#source-code","text":"<pre><code>// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved.\n// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// SPDX-License-Identifier: Apache-2.0\n#ifndef IOX_POSH_POPO_WAIT_SET_HPP\n#define IOX_POSH_POPO_WAIT_SET_HPP\n\n#include \"iceoryx_hoofs/cxx/algorithm.hpp\"\n#include \"iceoryx_hoofs/cxx/function_ref.hpp\"\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n#include \"iceoryx_hoofs/cxx/list.hpp\"\n#include \"iceoryx_hoofs/cxx/method_callback.hpp\"\n#include \"iceoryx_hoofs/cxx/stack.hpp\"\n#include \"iceoryx_hoofs/cxx/vector.hpp\"\n#include \"iceoryx_posh/iceoryx_posh_types.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\"\n#include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\"\n#include \"iceoryx_posh/popo/enum_trigger_type.hpp\"\n#include \"iceoryx_posh/popo/notification_attorney.hpp\"\n#include \"iceoryx_posh/popo/notification_callback.hpp\"\n#include \"iceoryx_posh/popo/notification_info.hpp\"\n#include \"iceoryx_posh/popo/trigger.hpp\"\n#include \"iceoryx_posh/popo/trigger_handle.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n\n#include &lt;typeinfo&gt;\n\nnamespace iox\n{\nnamespace popo\n{\nclass Condition;\n\nenum class WaitSetError : uint8_t\n{\n    WAIT_SET_FULL,\n    ALREADY_ATTACHED,\n};\n\n\ntemplate &lt;uint64_t Capacity = MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET&gt;\nclass WaitSet\n{\n  public:\n    static constexpr uint64_t CAPACITY = Capacity;\n    using TriggerArray = cxx::optional&lt;Trigger&gt;[Capacity];\n    using NotificationInfoVector = cxx::vector&lt;const NotificationInfo*, CAPACITY&gt;;\n\n    WaitSet() noexcept;\n    ~WaitSet() noexcept;\n\n    WaitSet(const WaitSet&amp; rhs) = delete;\n    WaitSet(WaitSet&amp;&amp; rhs) = delete;\n    WaitSet&amp; operator=(const WaitSet&amp; rhs) = delete;\n    WaitSet&amp; operator=(WaitSet&amp;&amp; rhs) = delete;\n\n    void markForDestruction() noexcept;\n\n    template &lt;typename T,\n              typename EventType,\n              typename ContextDataType = internal::NoType_t,\n              typename = std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value&gt;&gt;\n    cxx::expected&lt;WaitSetError&gt;\n    attachEvent(T&amp; eventOrigin,\n                const EventType eventType,\n                const uint64_t notificationId = 0U,\n                const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback = {}) noexcept;\n\n    template &lt;typename T,\n              typename EventType,\n              typename ContextDataType = internal::NoType_t,\n              typename = std::enable_if_t&lt;std::is_enum&lt;EventType&gt;::value, void&gt;&gt;\n    cxx::expected&lt;WaitSetError&gt; attachEvent(T&amp; eventOrigin,\n                                            const EventType eventType,\n                                            const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback) noexcept;\n\n    template &lt;typename T, typename ContextDataType = internal::NoType_t&gt;\n    cxx::expected&lt;WaitSetError&gt;\n    attachEvent(T&amp; eventOrigin,\n                const uint64_t notificationId = 0U,\n                const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback = {}) noexcept;\n\n    template &lt;typename T, typename ContextDataType = internal::NoType_t&gt;\n    cxx::expected&lt;WaitSetError&gt; attachEvent(T&amp; eventOrigin,\n                                            const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback) noexcept;\n\n    template &lt;typename T,\n              typename StateType,\n              typename ContextDataType = internal::NoType_t,\n              typename = std::enable_if_t&lt;std::is_enum&lt;StateType&gt;::value&gt;&gt;\n    cxx::expected&lt;WaitSetError&gt;\n    attachState(T&amp; stateOrigin,\n                const StateType stateType,\n                const uint64_t id = 0U,\n                const NotificationCallback&lt;T, ContextDataType&gt;&amp; stateCallback = {}) noexcept;\n\n    template &lt;typename T,\n              typename StateType,\n              typename ContextDataType = internal::NoType_t,\n              typename = std::enable_if_t&lt;std::is_enum&lt;StateType&gt;::value, void&gt;&gt;\n    cxx::expected&lt;WaitSetError&gt; attachState(T&amp; stateOrigin,\n                                            const StateType stateType,\n                                            const NotificationCallback&lt;T, ContextDataType&gt;&amp; stateCallback) noexcept;\n\n    template &lt;typename T, typename ContextDataType = internal::NoType_t&gt;\n    cxx::expected&lt;WaitSetError&gt;\n    attachState(T&amp; stateOrigin,\n                const uint64_t id = 0U,\n                const NotificationCallback&lt;T, ContextDataType&gt;&amp; stateCallback = {}) noexcept;\n\n    template &lt;typename T, typename ContextDataType = internal::NoType_t&gt;\n    cxx::expected&lt;WaitSetError&gt; attachState(T&amp; stateOrigin,\n                                            const NotificationCallback&lt;T, ContextDataType&gt;&amp; stateCallback) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    void detachEvent(T&amp; eventOrigin, const Targs&amp;... args) noexcept;\n\n    template &lt;typename T, typename... Targs&gt;\n    void detachState(T&amp; stateOrigin, const Targs&amp;... args) noexcept;\n\n    NotificationInfoVector timedWait(const units::Duration timeout) noexcept;\n\n    NotificationInfoVector wait() noexcept;\n\n    uint64_t size() const noexcept;\n\n    static constexpr uint64_t capacity() noexcept;\n\n  protected:\n    explicit WaitSet(ConditionVariableData&amp; condVarData) noexcept;\n\n  private:\n    enum class NoStateEnumUsed : StateEnumIdentifier\n    {\n        PLACEHOLDER\n    };\n\n    enum class NoEventEnumUsed : EventEnumIdentifier\n    {\n        PLACEHOLDER\n    };\n\n    using WaitFunction = cxx::function_ref&lt;ConditionListener::NotificationVector_t()&gt;;\n    template &lt;typename T, typename ContextDataType&gt;\n    cxx::expected&lt;uint64_t, WaitSetError&gt; attachImpl(T&amp; eventOrigin,\n                                                     const WaitSetIsConditionSatisfiedCallback&amp; hasTriggeredCallback,\n                                                     const uint64_t notificationId,\n                                                     const NotificationCallback&lt;T, ContextDataType&gt;&amp; eventCallback,\n                                                     const uint64_t originType,\n                                                     const uint64_t originTypeHash) noexcept;\n\n    NotificationInfoVector waitAndReturnTriggeredTriggers(const WaitFunction&amp; wait) noexcept;\n    NotificationInfoVector createVectorWithTriggeredTriggers() noexcept;\n\n    void removeTrigger(const uint64_t uniqueTriggerId) noexcept;\n    void removeAllTriggers() noexcept;\n    void acquireNotifications(const WaitFunction&amp; wait) noexcept;\n\n  private:\n    TriggerArray m_triggerArray;\n    ConditionVariableData* m_conditionVariableDataPtr{nullptr};\n    ConditionListener m_conditionListener;\n\n    cxx::stack&lt;uint64_t, Capacity&gt; m_indexRepository;\n    ConditionListener::NotificationVector_t m_activeNotifications;\n};\n\n} // namespace popo\n} // namespace iox\n\n#include \"iceoryx_posh/internal/popo/wait_set.inl\"\n\n#endif // IOX_POSH_POPO_WAIT_SET_HPP\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Source code"},{"location":"API-reference/posh/Namespaces/namespaceiox/","text":"","title":"iox"},{"location":"API-reference/posh/Namespaces/namespaceiox/#namespaces","text":"Name     iox::capro   iox::config   iox::gw   iox::helper   iox::mepoo   iox::popo   iox::roudi   iox::runtime   iox::version","title":"Namespaces"},{"location":"API-reference/posh/Namespaces/namespaceiox/#classes","text":"Name     struct iox::Config   struct iox::DefaultChunkDistributorConfig   struct iox::DefaultChunkQueueConfig","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox/#types","text":"Name     enum uint32_t SubscribeState   enum uint32_t ConnectionState   using Config&lt; mepoo::SegmentConfig, config::RouDiConfig &gt; RouDiConfig_t   using iox::popo::PublisherPortRouDi PublisherPortRouDiType   using iox::popo::PublisherPortUser PublisherPortUserType   using iox::popo::SubscriberPortRouDi SubscriberPortRouDiType   using iox::popo::SubscriberPortUser SubscriberPortUserType   using iox::build::CommunicationPolicy SubscriberPortType   using cxx::string&lt; MAX_RUNTIME_NAME_LENGTH &gt; RuntimeName_t   using cxx::string&lt; 100 &gt; NodeName_t   using cxx::string&lt; 128 &gt; ShmName_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox/#functions","text":"Name     constexpr const char * asStringLiteral(ConnectionState value)Converts the ConnectionState to a string literal.   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, ConnectionState value)Convenience stream operator to easily use the <code>asStringLiteral</code> function with std::ostream.   log::LogStream &amp; operator&lt;&lt;(log::LogStream &amp; stream, ConnectionState value)Convenience stream operator to easily use the <code>asStringLiteral</code> function with iox::log::LogStream.","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox/#attributes","text":"Name     constexpr uint32_t MAX_PUBLISHERS   constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER   constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY   constexpr uint64_t MAX_PUBLISHER_HISTORY   constexpr uint32_t MAX_SUBSCRIBERS   constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY   constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY   constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION   constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY   constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS   constexpr uint32_t MAX_INTERFACE_NUMBER   constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE   constexpr uint32_t MAX_CHANNEL_NUMBER   constexpr uint32_t MAX_GATEWAY_SERVICES   constexpr uint32_t MAX_CLIENTS   constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY   constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY   constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY   constexpr uint32_t MAX_SERVERS   constexpr uint32_t MAX_CLIENTS_PER_SERVER   constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY   constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY   constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY   constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES   constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS   constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET   constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER   constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS   constexpr uint32_t MAX_SHM_SEGMENTS   constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER   constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER   constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT   constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE   constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT   constexpr uint32_t ROUDI_MAX_MESSAGES   constexpr uint32_t ROUDI_MESSAGE_SIZE   constexpr uint32_t APP_MAX_MESSAGES   constexpr uint32_t APP_MESSAGE_SIZE   constexpr uint32_t MAX_PROCESS_NUMBER   constexpr uint32_t SERVICE_REGISTRY_CAPACITY   constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE   constexpr const char SERVICE_DISCOVERY_SERVICE_NAME   constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME   constexpr const char SERVICE_DISCOVERY_EVENT_NAME   constexpr uint32_t MAX_NODE_NUMBER   constexpr uint32_t MAX_NODE_PER_PROCESS   constexpr uint32_t MAX_RUNTIME_NAME_LENGTH","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#enum-subscribestate","text":"Enumerator Value Description     NOT_SUBSCRIBED 0    SUBSCRIBE_REQUESTED     SUBSCRIBED     UNSUBSCRIBE_REQUESTED     WAIT_FOR_OFFER","title":"enum SubscribeState"},{"location":"API-reference/posh/Namespaces/namespaceiox/#enum-connectionstate","text":"Enumerator Value Description     NOT_CONNECTED 0    CONNECT_REQUESTED     CONNECTED     DISCONNECT_REQUESTED     WAIT_FOR_OFFER","title":"enum ConnectionState"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-roudiconfig_t","text":"<pre><code>using iox::RouDiConfig_t = typedef Config&lt;mepoo::SegmentConfig, config::RouDiConfig&gt;;\n</code></pre>","title":"using RouDiConfig_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-publisherportrouditype","text":"<pre><code>using iox::PublisherPortRouDiType = typedef iox::popo::PublisherPortRouDi;\n</code></pre>","title":"using PublisherPortRouDiType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-publisherportusertype","text":"<pre><code>using iox::PublisherPortUserType = typedef iox::popo::PublisherPortUser;\n</code></pre>","title":"using PublisherPortUserType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberportrouditype","text":"<pre><code>using iox::SubscriberPortRouDiType = typedef iox::popo::SubscriberPortRouDi;\n</code></pre>","title":"using SubscriberPortRouDiType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberportusertype","text":"<pre><code>using iox::SubscriberPortUserType = typedef iox::popo::SubscriberPortUser;\n</code></pre>","title":"using SubscriberPortUserType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberporttype","text":"<pre><code>using iox::SubscriberPortType = typedef iox::build::CommunicationPolicy;\n</code></pre>","title":"using SubscriberPortType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-runtimename_t","text":"<pre><code>using iox::RuntimeName_t = typedef cxx::string&lt;MAX_RUNTIME_NAME_LENGTH&gt;;\n</code></pre>","title":"using RuntimeName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-nodename_t","text":"<pre><code>using iox::NodeName_t = typedef cxx::string&lt;100&gt;;\n</code></pre>","title":"using NodeName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-shmname_t","text":"<pre><code>using iox::ShmName_t = typedef cxx::string&lt;128&gt;;\n</code></pre>","title":"using ShmName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-asstringliteral","text":"<pre><code>inline constexpr const char * asStringLiteral(\n    ConnectionState value\n)\n</code></pre> <p>Converts the ConnectionState to a string literal. </p> <p>Parameters: </p> <ul> <li>value to convert to a string literal </li> </ul> <p>Return: pointer to a string literal </p>","title":"function asStringLiteral"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-operator","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n    ConnectionState value\n)\n</code></pre> <p>Convenience stream operator to easily use the <code>asStringLiteral</code> function with std::ostream. </p> <p>Parameters: </p> <ul> <li>stream sink to write the message to </li> <li>value to convert to a string literal </li> </ul> <p>Return: the reference to <code>stream</code> which was provided as input parameter </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-operator_1","text":"<pre><code>inline log::LogStream &amp; operator&lt;&lt;(\n    log::LogStream &amp; stream,\n    ConnectionState value\n)\n</code></pre> <p>Convenience stream operator to easily use the <code>asStringLiteral</code> function with iox::log::LogStream. </p> <p>Parameters: </p> <ul> <li>stream sink to write the message to </li> <li>value to convert to a string literal </li> </ul> <p>Return: the reference to <code>stream</code> which was provided as input parameter </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_publishers","text":"<pre><code>constexpr uint32_t MAX_PUBLISHERS = build::IOX_MAX_PUBLISHERS;\n</code></pre>","title":"variable MAX_PUBLISHERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscribers_per_publisher","text":"<pre><code>constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build::IOX_MAX_SUBSCRIBERS_PER_PUBLISHER;\n</code></pre>","title":"variable MAX_SUBSCRIBERS_PER_PUBLISHER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_chunks_allocated_per_publisher_simultaneously","text":"<pre><code>constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY =\n    build::IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY;\n</code></pre>","title":"variable MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_publisher_history","text":"<pre><code>constexpr uint64_t MAX_PUBLISHER_HISTORY = build::IOX_MAX_PUBLISHER_HISTORY;\n</code></pre>","title":"variable MAX_PUBLISHER_HISTORY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscribers","text":"<pre><code>constexpr uint32_t MAX_SUBSCRIBERS = build::IOX_MAX_SUBSCRIBERS;\n</code></pre>","title":"variable MAX_SUBSCRIBERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_chunks_held_per_subscriber_simultaneously","text":"<pre><code>constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY =\n    build::IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY;\n</code></pre>","title":"variable MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscriber_queue_capacity","text":"<pre><code>constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY;\n</code></pre>","title":"variable MAX_SUBSCRIBER_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-publishers_reserved_for_introspection","text":"<pre><code>constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5;\n</code></pre>","title":"variable PUBLISHERS_RESERVED_FOR_INTROSPECTION"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-publishers_reserved_for_service_registry","text":"<pre><code>constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1;\n</code></pre>","title":"variable PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-number_of_internal_publishers","text":"<pre><code>constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS =\n    PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY;\n</code></pre>","title":"variable NUMBER_OF_INTERNAL_PUBLISHERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_interface_number","text":"<pre><code>constexpr uint32_t MAX_INTERFACE_NUMBER = build::IOX_MAX_INTERFACE_NUMBER;\n</code></pre> <p>With MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY we couple the maximum number of chunks a user is allowed to hold with the maximum queue capacity. This allows that a polling user can replace all the held chunks in one execution with all new ones from a completely filled queue. Or the other way round, when we have a contract with the user regarding how many chunks they are allowed to hold, then the queue size needs not be bigger. We can provide this number of newest chunks, more the user would not be allowed to hold anyway </p>","title":"variable MAX_INTERFACE_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_interface_capro_fifo_size","text":"<pre><code>constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS;\n</code></pre>","title":"variable MAX_INTERFACE_CAPRO_FIFO_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_channel_number","text":"<pre><code>constexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS;\n</code></pre>","title":"variable MAX_CHANNEL_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_gateway_services","text":"<pre><code>constexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER;\n</code></pre>","title":"variable MAX_GATEWAY_SERVICES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_clients","text":"<pre><code>constexpr uint32_t MAX_CLIENTS = build::IOX_MAX_SUBSCRIBERS;\n</code></pre>","title":"variable MAX_CLIENTS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_requests_allocated_simultaneously","text":"<pre><code>constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U;\n</code></pre> <p>Todo: </p>","title":"variable MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_responses_processed_simultaneously","text":"<pre><code>constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U;\n</code></pre>","title":"variable MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_response_queue_capacity","text":"<pre><code>constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U;\n</code></pre>","title":"variable MAX_RESPONSE_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_servers","text":"<pre><code>constexpr uint32_t MAX_SERVERS = build::IOX_MAX_PUBLISHERS;\n</code></pre>","title":"variable MAX_SERVERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_clients_per_server","text":"<pre><code>constexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U;\n</code></pre> <p>Todo: </p>","title":"variable MAX_CLIENTS_PER_SERVER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_requests_processed_simultaneously","text":"<pre><code>constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U;\n</code></pre>","title":"variable MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_responses_allocated_simultaneously","text":"<pre><code>constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY;\n</code></pre>","title":"variable MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_request_queue_capacity","text":"<pre><code>constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024;\n</code></pre>","title":"variable MAX_REQUEST_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_condition_variables","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U;\n</code></pre>","title":"variable MAX_NUMBER_OF_CONDITION_VARIABLES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_notifiers","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build::IOX_MAX_NUMBER_OF_NOTIFIERS;\n</code></pre>","title":"variable MAX_NUMBER_OF_NOTIFIERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_attachments_per_waitset","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS;\n</code></pre> <p>Note: Waitset and Listener share both the max available notifiers, if one of them is running out of of notifiers the variable above must be increased </p>","title":"variable MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_events_per_listener","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS;\n</code></pre>","title":"variable MAX_NUMBER_OF_EVENTS_PER_LISTENER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_mempools","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U;\n</code></pre>","title":"variable MAX_NUMBER_OF_MEMPOOLS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_shm_segments","text":"<pre><code>constexpr uint32_t MAX_SHM_SEGMENTS = 100U;\n</code></pre>","title":"variable MAX_SHM_SEGMENTS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_memory_provider","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U;\n</code></pre>","title":"variable MAX_NUMBER_OF_MEMORY_PROVIDER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_memory_blocks_per_memory_provider","text":"<pre><code>constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U;\n</code></pre>","title":"variable MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_default_user_payload_alignment","text":"<pre><code>constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT {8U};\n</code></pre>","title":"variable CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_no_user_header_size","text":"<pre><code>constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE {0U};\n</code></pre>","title":"variable CHUNK_NO_USER_HEADER_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_no_user_header_alignment","text":"<pre><code>constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT {1U};\n</code></pre>","title":"variable CHUNK_NO_USER_HEADER_ALIGNMENT"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-roudi_max_messages","text":"<pre><code>constexpr uint32_t ROUDI_MAX_MESSAGES = 5U;\n</code></pre>","title":"variable ROUDI_MAX_MESSAGES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-roudi_message_size","text":"<pre><code>constexpr uint32_t ROUDI_MESSAGE_SIZE = 512U;\n</code></pre>","title":"variable ROUDI_MESSAGE_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-app_max_messages","text":"<pre><code>constexpr uint32_t APP_MAX_MESSAGES = 5U;\n</code></pre>","title":"variable APP_MAX_MESSAGES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-app_message_size","text":"<pre><code>constexpr uint32_t APP_MESSAGE_SIZE = 512U;\n</code></pre>","title":"variable APP_MESSAGE_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_process_number","text":"<pre><code>constexpr uint32_t MAX_PROCESS_NUMBER = 300U;\n</code></pre>","title":"variable MAX_PROCESS_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_registry_capacity","text":"<pre><code>constexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS;\n</code></pre>","title":"variable SERVICE_REGISTRY_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_findservice_result_size","text":"<pre><code>constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY;\n</code></pre>","title":"variable MAX_FINDSERVICE_RESULT_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_service_name","text":"<pre><code>constexpr const char SERVICE_DISCOVERY_SERVICE_NAME = \"ServiceDiscovery\";\n</code></pre>","title":"variable SERVICE_DISCOVERY_SERVICE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_instance_name","text":"<pre><code>constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME = \"RouDi_ID\";\n</code></pre>","title":"variable SERVICE_DISCOVERY_INSTANCE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_event_name","text":"<pre><code>constexpr const char SERVICE_DISCOVERY_EVENT_NAME = \"ServiceRegistry\";\n</code></pre>","title":"variable SERVICE_DISCOVERY_EVENT_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_node_number","text":"<pre><code>constexpr uint32_t MAX_NODE_NUMBER = 1000U;\n</code></pre>","title":"variable MAX_NODE_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_node_per_process","text":"<pre><code>constexpr uint32_t MAX_NODE_PER_PROCESS = 50U;\n</code></pre>","title":"variable MAX_NODE_PER_PROCESS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_runtime_name_length","text":"<pre><code>constexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable MAX_RUNTIME_NAME_LENGTH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/","text":"","title":"iox::capro"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#classes","text":"Name     class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#types","text":"Name     enum uint16_t Interfaces { INTERNAL = 0, ESOC, SOMEIP, AMQP, MQTT, DDS, SIGNAL, MTA, ROS1, INTERFACE_END}Describes from which interface the service is coming from.   enum uint16_t Scope { WORLDWIDE, LOCAL, INVALID}Scope of a service description.   using iox::cxx::nullopt_t Wildcard_t Used to search for any string.   using cxx::string&lt; 100 &gt; IdString_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#functions","text":"Name     bool serviceMatch(const ServiceDescription &amp; first, const ServiceDescription &amp; second)Compare two service descriptions via their values in member variables and return bool if match.   std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const ServiceDescription &amp; service)Convenience stream operator to easily use the <code>[ServiceDescription]()</code> with std::ostream.   log::LogStream &amp; operator&lt;&lt;(log::LogStream &amp; stream, const ServiceDescription &amp; service)Convenience stream operator to easily use the <code>[ServiceDescription]()</code> with log::LogStream.","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#attributes","text":"Name     constexpr Wildcard_t Wildcard   constexpr int32_t MAX_NUMBER_OF_CHARS   constexpr size_t CLASS_HASH_ELEMENT_COUNT   constexpr const char * INTERFACE_NAMES   constexpr char ScopeTypeString","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#enum-interfaces","text":"Enumerator Value Description     INTERNAL 0 Used for services, which are locally on this system and not coming over a gateway.   ESOC  Canonical protocol for CAN Bus.   SOMEIP  SOME/IP.   AMQP  Advanced Message Queuing Protocol.   MQTT  Message Queuing Telemetry Transport.   DDS  Data Distribution Service.   SIGNAL  Universal Measurement and Calibration Protocol (XCP)   MTA  Measurement technology adapter.   ROS1  Robot Operating System 1.   INTERFACE_END  End of enum.    <p>Describes from which interface the service is coming from. </p>","title":"enum Interfaces"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#enum-scope","text":"Enumerator Value Description     WORLDWIDE     LOCAL     INVALID      <p>Scope of a service description. </p>","title":"enum Scope"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#using-wildcard_t","text":"<pre><code>using iox::capro::Wildcard_t = typedef iox::cxx::nullopt_t;\n</code></pre> <p>Used to search for any string. </p>","title":"using Wildcard_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#using-idstring_t","text":"<pre><code>using iox::capro::IdString_t = typedef cxx::string&lt;100&gt;;\n</code></pre>","title":"using IdString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-servicematch","text":"<pre><code>bool serviceMatch(\n    const ServiceDescription &amp; first,\n    const ServiceDescription &amp; second\n)\n</code></pre> <p>Compare two service descriptions via their values in member variables and return bool if match. </p> <p>Parameters: </p> <ul> <li>ServiceDescription &amp;first Servicedescription to compare </li> <li>ServiceDescription &amp;second Servicedescription to compare </li> </ul> <p>Return: Bool if comparison match or not </p>","title":"function serviceMatch"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-operator","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n    const ServiceDescription &amp; service\n)\n</code></pre> <p>Convenience stream operator to easily use the <code>[ServiceDescription]()</code> with std::ostream. </p> <p>Parameters: </p> <ul> <li>stream output stream to write the message to </li> <li>service ServiceDescription that shall be converted </li> </ul> <p>Return: the reference to <code>stream</code> which was provided as input parameter </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-operator_1","text":"<pre><code>log::LogStream &amp; operator&lt;&lt;(\n    log::LogStream &amp; stream,\n    const ServiceDescription &amp; service\n)\n</code></pre> <p>Convenience stream operator to easily use the <code>[ServiceDescription]()</code> with log::LogStream. </p> <p>Parameters: </p> <ul> <li>stream output LogStream to write the message to </li> <li>service ServiceDescription that shall be converted </li> </ul> <p>Return: the reference to <code>stream</code> which was provided as input parameter </p>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-wildcard","text":"<pre><code>constexpr Wildcard_t Wildcard;\n</code></pre>","title":"variable Wildcard"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-max_number_of_chars","text":"<pre><code>static constexpr int32_t MAX_NUMBER_OF_CHARS = 64;\n</code></pre>","title":"variable MAX_NUMBER_OF_CHARS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-class_hash_element_count","text":"<pre><code>static constexpr size_t CLASS_HASH_ELEMENT_COUNT {4U};\n</code></pre>","title":"variable CLASS_HASH_ELEMENT_COUNT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-interface_names","text":"<pre><code>constexpr const char * INTERFACE_NAMES = {\"INTERNAL\", \"ESOC\", \"SOMEIP\", \"AMQP\", \"DDS\", \"SIGNAL\", \"MTA\", \"ROS1\", \"END\"};\n</code></pre>","title":"variable INTERFACE_NAMES"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-scopetypestring","text":"<pre><code>constexpr char ScopeTypeString = {\"WORLDWIDE\", \"INTERNAL\", \"INVALID\"};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable ScopeTypeString"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/","text":"","title":"iox::config"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#classes","text":"Name     struct iox::config::GatewayConfig Generic configuration for gateways.   class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files.   struct iox::config::CmdLineArgs_t   class iox::config::CmdLineParser   class iox::config::CmdLineParserConfigFileOption   struct iox::config::RouDiConfig   class iox::config::TomlRouDiConfigFileProvider","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#types","text":"Name     enum TomlGatewayConfigParseError   enum CmdLineParserResult","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#functions","text":"Name     iox::log::LogStream &amp; operator&lt;&lt;(iox::log::LogStream &amp; logstream, const CmdLineArgs_t &amp; cmdLineArgs)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#attributes","text":"Name     constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS   constexpr const char REGEX_VALID_CHARACTERS   constexpr const char DEFAULT_CONFIG_FILE_PATH   constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME   constexpr const char GATEWAY_CONFIG_SERVICE_NAME   constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME   constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME   constexpr char defaultConfigFilePath","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#enum-tomlgatewayconfigparseerror","text":"Enumerator Value Description     FILE_NOT_FOUND     INCOMPLETE_CONFIGURATION     INCOMPLETE_SERVICE_DESCRIPTION     INVALID_SERVICE_DESCRIPTION     EXCEPTION_IN_PARSER     MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED","title":"enum TomlGatewayConfigParseError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#enum-cmdlineparserresult","text":"Enumerator Value Description     UNKNOWN_OPTION_USED     INFO_OUTPUT_ONLY","title":"enum CmdLineParserResult"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#function-operator","text":"<pre><code>inline iox::log::LogStream &amp; operator&lt;&lt;(\n    iox::log::LogStream &amp; logstream,\n    const CmdLineArgs_t &amp; cmdLineArgs\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-toml_gateway_config_file_parse_error_strings","text":"<pre><code>constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS = {\"FILE_NOT_FOUND\",\n                                                                        \"INCOMPLETE_CONFIGURATION\",\n                                                                        \"INCOMPLETE_SERVICE_DESCRIPTION\",\n                                                                        \"INVALID_SERVICE_DESCRIPTION\",\n                                                                        \"EXCEPTION_IN_PARSER\",\n                                                                        \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\"};\n</code></pre>","title":"variable TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-regex_valid_characters","text":"<pre><code>static constexpr const char REGEX_VALID_CHARACTERS = \"^[a-zA-Z_][a-zA-Z0-9_]*$\";\n</code></pre>","title":"variable REGEX_VALID_CHARACTERS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-default_config_file_path","text":"<pre><code>static constexpr const char DEFAULT_CONFIG_FILE_PATH = \"/etc/iceoryx/gateway_config.toml\";\n</code></pre>","title":"variable DEFAULT_CONFIG_FILE_PATH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_table_name","text":"<pre><code>static constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME = \"services\";\n</code></pre>","title":"variable GATEWAY_CONFIG_SERVICE_TABLE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_name","text":"<pre><code>static constexpr const char GATEWAY_CONFIG_SERVICE_NAME = \"service\";\n</code></pre>","title":"variable GATEWAY_CONFIG_SERVICE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_instance_name","text":"<pre><code>static constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME = \"instance\";\n</code></pre>","title":"variable GATEWAY_CONFIG_SERVICE_INSTANCE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_event_name","text":"<pre><code>static constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME = \"event\";\n</code></pre>","title":"variable GATEWAY_CONFIG_SERVICE_EVENT_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-defaultconfigfilepath","text":"<pre><code>static constexpr char defaultConfigFilePath = \"/etc/iceoryx/roudi_config.toml\";\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable defaultConfigFilePath"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/","text":"","title":"iox::gw"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#classes","text":"Name     class iox::Channel A data structure representing a channel between Iceoryx and an external system.   class iox::GatewayBase Generic gateway for communication events.   class iox::GatewayDiscovery Discover the gateway.   class iox::GatewayGeneric A reference generic gateway implementation.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#types","text":"Name     enum uint8_t ChannelError   enum uint8_t GatewayError","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#enum-channelerror","text":"Enumerator Value Description     OBJECT_POOL_FULL","title":"enum ChannelError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#enum-gatewayerror","text":"Enumerator Value Description     UNSUPPORTED_SERVICE_TYPE     UNSUCCESSFUL_CHANNEL_CREATION     NONEXISTANT_CHANNEL       <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"enum GatewayError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1helper/","text":"","title":"iox::helper"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1helper/#classes","text":"Name     struct iox::helper::SetDefaults   struct iox::helper::SetDefaults&lt; FirstArg, RemainderArgs... &gt;   struct iox::helper::SetDefaults&lt; FinalArg &gt;   struct iox::helper::Optimize   struct iox::helper::Optimize&lt; FirstArg, RemainderArgs... &gt;   struct iox::helper::Optimize&lt; FinalArg &gt;     <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/","text":"","title":"iox::mepoo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#classes","text":"Name     struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used.   struct iox::mepoo::ChunkHeader   class iox::mepoo::ChunkSettings   struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics.   struct iox::mepoo::MePooConfig   struct iox::mepoo::SegmentConfig","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#types","text":"Name     using std::uint64_t SequenceNumber_t   using std::chrono::steady_clock BaseClock_t   using std::chrono::duration&lt; std::int64_t, std::nano &gt; DurationNs_t   using std::chrono::time_point&lt; BaseClock_t, DurationNs_t &gt; TimePointNs_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-sequencenumber_t","text":"<pre><code>using iox::mepoo::SequenceNumber_t = typedef std::uint64_t;\n</code></pre>","title":"using SequenceNumber_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-baseclock_t","text":"<pre><code>using iox::mepoo::BaseClock_t = typedef std::chrono::steady_clock;\n</code></pre>","title":"using BaseClock_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-durationns_t","text":"<pre><code>using iox::mepoo::DurationNs_t = typedef std::chrono::duration&lt;std::int64_t, std::nano&gt;;\n</code></pre>","title":"using DurationNs_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-timepointns_t","text":"<pre><code>using iox::mepoo::TimePointNs_t = typedef std::chrono::time_point&lt;BaseClock_t, DurationNs_t&gt;;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using TimePointNs_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/","text":"","title":"iox::popo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#namespaces","text":"Name     iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#classes","text":"Name     class iox::popo::ChunkSender   class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx.   struct iox::popo::ClientOptions This struct is used to configure the client.   class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class.   class iox::popo::Listener   class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney. Used for example by the WaitSet. Implements the Client-Attorney Pattern.   struct iox::popo::EventCallback   struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener   class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback.   class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx.   struct iox::popo::PublisherOptions This struct is used to configure the publisher.   class iox::popo::RpcInterface   class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system.   class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system.   class iox::popo::RpcBaseHeader   class iox::popo::RequestHeader   class iox::popo::ResponseHeader   class iox::popo::PublisherInterface   class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system.   class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx.   struct iox::popo::ServerOptions This struct is used to configure the server.   class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx.   struct iox::popo::SubscriberOptions This struct is used to configure the subscriber.   struct iox::popo::StateBasedTrigger_t   struct iox::popo::EventBasedTrigger_t   class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance.   class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable.   class iox::popo::UntypedClient   class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx.   class iox::popo::UntypedServer   class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx.   class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class.   class iox::popo::WaitSet Logical disjunction of a certain number of Triggers.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#types","text":"Name     enum ListenerError   enum uint8_t ConsumerTooSlowPolicy { WAIT_FOR_CONSUMER, DISCARD_OLDEST_DATA}Used by producers how to adjust to slow consumer.   enum uint8_t QueueFullPolicy { BLOCK_PRODUCER, DISCARD_OLDEST_DATA}Used by consumers to request a specific behavior from the producer.   enum TriggerType   enum uint8_t WaitSetError   enum MessagingPattern   using cxx::ConstMethodCallback&lt; bool &gt; WaitSetIsConditionSatisfiedCallback   using uint64_t StateEnumIdentifier used as underlying type it identifies an enum as a state based enum   using int64_t EventEnumIdentifier used as underlying type it identifies an enum as an event based enum","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#functions","text":"Name     template &lt;typename OriginType ,typename ContextDataType  =internal::NoType_t&gt; NotificationCallback&lt; OriginType, ContextDataType &gt; createNotificationCallback(void(&amp;)(OriginType *const) callback)creates an NotificationCallback   template &lt;typename OriginType ,typename ContextDataType &gt; NotificationCallback&lt; OriginType, ContextDataType &gt; createNotificationCallback(void(&amp;)(OriginType const, ContextDataType const) callback, ContextDataType &amp; userValue)creates an NotificationCallback with a user defined value","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#attributes","text":"Name     constexpr bool IS_EVENT_ENUM contains true when T is an event based enum, otherwise false   constexpr bool IS_STATE_ENUM contains true when T is a state based enum, otherwise false   constexpr StateBasedTrigger_t StateBasedTrigger   constexpr EventBasedTrigger_t EventBasedTrigger","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-listenererror","text":"Enumerator Value Description     LISTENER_FULL     EVENT_ALREADY_ATTACHED     EMPTY_EVENT_CALLBACK     EMPTY_INVALIDATION_CALLBACK","title":"enum ListenerError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-consumertooslowpolicy","text":"Enumerator Value Description     WAIT_FOR_CONSUMER  Waits for the consumer it it's queue is full.   DISCARD_OLDEST_DATA  Discards the oldest data and pushes the newest one into the queue.    <p>Used by producers how to adjust to slow consumer. </p>","title":"enum ConsumerTooSlowPolicy"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-queuefullpolicy","text":"Enumerator Value Description     BLOCK_PRODUCER  Requests the producer to block when the consumer queue is full.   DISCARD_OLDEST_DATA  Request to discard the oldest data and push the newest one into the queue.    <p>Used by consumers to request a specific behavior from the producer. </p>","title":"enum QueueFullPolicy"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-triggertype","text":"Enumerator Value Description     STATE_BASED     EVENT_BASED     INVALID","title":"enum TriggerType"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-waitseterror","text":"Enumerator Value Description     WAIT_SET_FULL     ALREADY_ATTACHED","title":"enum WaitSetError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-messagingpattern","text":"Enumerator Value Description     PUB_SUB     REQ_RES","title":"enum MessagingPattern"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-waitsetisconditionsatisfiedcallback","text":"<pre><code>using iox::popo::WaitSetIsConditionSatisfiedCallback = typedef cxx::ConstMethodCallback&lt;bool&gt;;\n</code></pre>","title":"using WaitSetIsConditionSatisfiedCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-stateenumidentifier","text":"<pre><code>using iox::popo::StateEnumIdentifier = typedef uint64_t;\n</code></pre> <p>used as underlying type it identifies an enum as a state based enum </p>","title":"using StateEnumIdentifier"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-eventenumidentifier","text":"<pre><code>using iox::popo::EventEnumIdentifier = typedef int64_t;\n</code></pre> <p>used as underlying type it identifies an enum as an event based enum </p>","title":"using EventEnumIdentifier"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#function-createnotificationcallback","text":"<pre><code>template &lt;typename OriginType ,\ntypename ContextDataType  =internal::NoType_t&gt;\nNotificationCallback&lt; OriginType, ContextDataType &gt; createNotificationCallback(\n    void(&amp;)(OriginType *const) callback\n)\n</code></pre> <p>creates an NotificationCallback</p> <p>Parameters: </p> <ul> <li>callback reference to a callback with the signature void(OriginType*) </li> </ul> <p>Return: the callback stored inside of an NotificationCallback</p>","title":"function createNotificationCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#function-createnotificationcallback_1","text":"<pre><code>template &lt;typename OriginType ,\ntypename ContextDataType &gt;\nNotificationCallback&lt; OriginType, ContextDataType &gt; createNotificationCallback(\n    void(&amp;)(OriginType *const, ContextDataType *const) callback,\n    ContextDataType &amp; userValue\n)\n</code></pre> <p>creates an NotificationCallback with a user defined value </p> <p>Parameters: </p> <ul> <li>callback reference to a callback with the signature void(OriginType, ContextDataType) </li> <li>userValue reference to a user defined value </li> </ul> <p>Return: the callback and user value stored inside of an NotificationCallback</p>","title":"function createNotificationCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-is_event_enum","text":"<pre><code>constexpr bool IS_EVENT_ENUM =\n    std::is_enum&lt;T&gt;::value&amp;&amp; std::is_same&lt;std::underlying_type_t&lt;T&gt;, EventEnumIdentifier&gt;::value;\n</code></pre> <p>contains true when T is an event based enum, otherwise false </p>","title":"variable IS_EVENT_ENUM"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-is_state_enum","text":"<pre><code>constexpr bool IS_STATE_ENUM =\n    std::is_enum&lt;T&gt;::value&amp;&amp; std::is_same&lt;std::underlying_type_t&lt;T&gt;, StateEnumIdentifier&gt;::value;\n</code></pre> <p>contains true when T is a state based enum, otherwise false </p>","title":"variable IS_STATE_ENUM"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-statebasedtrigger","text":"<pre><code>constexpr StateBasedTrigger_t StateBasedTrigger {};\n</code></pre>","title":"variable StateBasedTrigger"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-eventbasedtrigger","text":"<pre><code>constexpr EventBasedTrigger_t EventBasedTrigger {};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable EventBasedTrigger"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/","text":"","title":"iox::popo::internal"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#types","text":"Name     using void(*)() GenericCallbackPtr_t   using void(&amp;)() GenericCallbackRef_t   using void(&amp;)(void const, void const, GenericCallbackPtr_t const) TranslationCallbackRef_t   using void()(void const, void *const, GenericCallbackPtr_t const) TranslationCallbackPtr_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-genericcallbackptr_t","text":"<pre><code>using iox::popo::internal::GenericCallbackPtr_t = typedef void (*)();\n</code></pre>","title":"using GenericCallbackPtr_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-genericcallbackref_t","text":"<pre><code>using iox::popo::internal::GenericCallbackRef_t = typedef void (&amp;)();\n</code></pre>","title":"using GenericCallbackRef_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-translationcallbackref_t","text":"<pre><code>using iox::popo::internal::TranslationCallbackRef_t = typedef void (&amp;)(void* const, void* const, GenericCallbackPtr_t const);\n</code></pre>","title":"using TranslationCallbackRef_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-translationcallbackptr_t","text":"<pre><code>using iox::popo::internal::TranslationCallbackPtr_t = typedef void (*)(void* const, void* const, GenericCallbackPtr_t const);\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"using TranslationCallbackPtr_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/","text":"<p>More...</p>","title":"iox::roudi"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#classes","text":"Name     class iox::roudi::IceOryxRouDiApp   struct iox::roudi::IceOryxRouDiComponents   struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools.   struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to   struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port   struct iox::roudi::PublisherPortData container for publisher port introspection data.   struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to   struct iox::roudi::PortThroughputData   struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to   struct iox::roudi::SubscriberPortChangingData   struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic   struct iox::roudi::ProcessIntrospectionData   struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to   struct iox::roudi::DefaultRouDiMemory   class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case.   class iox::roudi::IceOryxRouDiMemoryManager   class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider, which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case.   class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider.   class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration.   class iox::roudi::RouDiMemoryInterface   class iox::roudi::RouDiMemoryManager   class iox::roudi::PortPool   class iox::roudi::RouDiApp base class for RouDi daemons   class iox::roudi::RouDiConfigFileProvider Base class for a config file provider.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#types","text":"Name     enum MonitoringMode { ON, OFF}Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored.   enum MemoryProviderError   enum RouDiMemoryManagerError   enum uint8_t PortPoolError   enum RouDiConfigFileParseError { NO_GENERAL_SECTION, INVALID_CONFIG_FILE_VERSION, NO_SEGMENTS, MAX_NUMBER_OF_SEGMENTS_EXCEEDED, SEGMENT_WITHOUT_MEMPOOL, MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED, MEMPOOL_WITHOUT_CHUNK_SIZE, MEMPOOL_WITHOUT_CHUNK_COUNT, EXCEPTION_IN_PARSER}This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool.   using cxx::string&lt; 1024 &gt; ConfigFilePathString_t   using cxx::vector&lt; MemPoolInfo, MAX_NUMBER_OF_MEMPOOLS &gt; MemPoolInfoContainer container for MemPoolInfo structs of all available mempools.   using cxx::vector&lt; MemPoolIntrospectionInfo, MAX_SHM_SEGMENTS+1 &gt; MemPoolIntrospectionInfoContainer container for MemPoolInfo structs of all available mempools.   using PortData SubscriberPortData","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#functions","text":"Name     iox::log::LogStream &amp; operator&lt;&lt;(iox::log::LogStream &amp; logstream, const MonitoringMode &amp; mode)   iox::log::LogStream &amp; operator&lt;&lt;(iox::log::LogStream &amp; logstream, const RouDiMemoryManagerError &amp; error)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#attributes","text":"Name     constexpr const char ROUDI_LOCK_NAME   constexpr const char IPC_CHANNEL_ROUDI_NAME   constexpr const char SHM_NAME shared memory segment for the iceoryx management data   constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID   constexpr units::Duration PROCESS_DEFAULT_KILL_DELAY   constexpr units::Duration PROCESS_TERMINATED_CHECK_INTERVAL   constexpr units::Duration DISCOVERY_INTERVAL   constexpr const char INTROSPECTION_SERVICE_ID   constexpr const char INTROSPECTION_APP_NAME   constexpr const char INTROSPECTION_NODE_NAME   const capro::ServiceDescription IntrospectionMempoolService   constexpr int MAX_GROUP_NAME_LENGTH   const capro::ServiceDescription IntrospectionPortService publisher/subscriber port information consisting of a process name,a capro service description string and a node name   const capro::ServiceDescription IntrospectionPortThroughputService   const capro::ServiceDescription IntrospectionSubscriberPortChangingDataService   const capro::ServiceDescription IntrospectionProcessService   constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#detailed-description","text":"<p>Todo: Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target </p>","title":"Detailed Description"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-monitoringmode","text":"Enumerator Value Description     ON     OFF      <p>Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored. </p>","title":"enum MonitoringMode"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-memoryprovidererror","text":"Enumerator Value Description     MEMORY_BLOCKS_EXHAUSTED  attempt to add more memory blocks than the capacity allows   NO_MEMORY_BLOCKS_PRESENT  an action was performed which requires memory blocks   MEMORY_ALREADY_CREATED  attempt to create memory although it already was created   MEMORY_CREATION_FAILED  generic error if memory creation failed   MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE  attempt to create memory with an alignment bigger than the page size   MEMORY_ALLOCATION_FAILED  memory creation failed at allocating memory   MEMORY_MAPPING_FAILED  memory creation failed at mapping memory   MEMORY_NOT_AVAILABLE  an action was performed which requires memory   MEMORY_DESTRUCTION_FAILED  generic error if memory destruction failed   MEMORY_DEALLOCATION_FAILED  memory destruction failed at deallocating memory   MEMORY_UNMAPPING_FAILED  memory destruction failed at unmapping memory   SIGACTION_CALL_FAILED  Setup or teardown of SIGBUS failed.","title":"enum MemoryProviderError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-roudimemorymanagererror","text":"Enumerator Value Description     MEMORY_PROVIDER_EXHAUSTED  attempt to add more memory provider than the capacity allows   NO_MEMORY_PROVIDER_PRESENT  an action was performed which requires memory provider   MEMORY_CREATION_FAILED  generic error if memory creation failed   MEMORY_DESTRUCTION_FAILED  generic error if memory destruction failed","title":"enum RouDiMemoryManagerError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-portpoolerror","text":"Enumerator Value Description     UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS     INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN     PUBLISHER_PORT_LIST_FULL     SUBSCRIBER_PORT_LIST_FULL     INTERFACE_PORT_LIST_FULL     CLIENT_PORT_LIST_FULL     UNIQUE_SERVER_PORT_ALREADY_EXISTS     SERVER_PORT_LIST_FULL     NODE_DATA_LIST_FULL     CONDITION_VARIABLE_LIST_FULL     EVENT_VARIABLE_LIST_FULL","title":"enum PortPoolError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-roudiconfigfileparseerror","text":"Enumerator Value Description     NO_GENERAL_SECTION     INVALID_CONFIG_FILE_VERSION     NO_SEGMENTS     MAX_NUMBER_OF_SEGMENTS_EXCEEDED     SEGMENT_WITHOUT_MEMPOOL     MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED     MEMPOOL_WITHOUT_CHUNK_SIZE     MEMPOOL_WITHOUT_CHUNK_COUNT     EXCEPTION_IN_PARSER      <p>This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool. </p>","title":"enum RouDiConfigFileParseError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-configfilepathstring_t","text":"<pre><code>using iox::roudi::ConfigFilePathString_t = typedef cxx::string&lt;1024&gt;;\n</code></pre>","title":"using ConfigFilePathString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-mempoolinfocontainer","text":"<pre><code>using iox::roudi::MemPoolInfoContainer = typedef cxx::vector&lt;MemPoolInfo, MAX_NUMBER_OF_MEMPOOLS&gt;;\n</code></pre> <p>container for MemPoolInfo structs of all available mempools. </p>","title":"using MemPoolInfoContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-mempoolintrospectioninfocontainer","text":"<pre><code>using iox::roudi::MemPoolIntrospectionInfoContainer = typedef cxx::vector&lt;MemPoolIntrospectionInfo, MAX_SHM_SEGMENTS + 1&gt;;\n</code></pre> <p>container for MemPoolInfo structs of all available mempools. </p>","title":"using MemPoolIntrospectionInfoContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-subscriberportdata","text":"<pre><code>using iox::roudi::SubscriberPortData = typedef PortData;\n</code></pre>","title":"using SubscriberPortData"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#function-operator","text":"<pre><code>inline iox::log::LogStream &amp; operator&lt;&lt;(\n    iox::log::LogStream &amp; logstream,\n    const MonitoringMode &amp; mode\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#function-operator_1","text":"<pre><code>iox::log::LogStream &amp; operator&lt;&lt;(\n    iox::log::LogStream &amp; logstream,\n    const RouDiMemoryManagerError &amp; error\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-roudi_lock_name","text":"<pre><code>constexpr const char ROUDI_LOCK_NAME = \"iox-unique-roudi\";\n</code></pre>","title":"variable ROUDI_LOCK_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-ipc_channel_roudi_name","text":"<pre><code>constexpr const char IPC_CHANNEL_ROUDI_NAME = \"roudi\";\n</code></pre>","title":"variable IPC_CHANNEL_ROUDI_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-shm_name","text":"<pre><code>constexpr const char SHM_NAME = \"iceoryx_mgmt\";\n</code></pre> <p>shared memory segment for the iceoryx management data </p>","title":"variable SHM_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-default_unique_roudi_id","text":"<pre><code>constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID {0U};\n</code></pre>","title":"variable DEFAULT_UNIQUE_ROUDI_ID"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-process_default_kill_delay","text":"<pre><code>constexpr units::Duration PROCESS_DEFAULT_KILL_DELAY = 45_s;\n</code></pre>","title":"variable PROCESS_DEFAULT_KILL_DELAY"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-process_terminated_check_interval","text":"<pre><code>constexpr units::Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250_ms;\n</code></pre>","title":"variable PROCESS_TERMINATED_CHECK_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-discovery_interval","text":"<pre><code>constexpr units::Duration DISCOVERY_INTERVAL = 100_ms;\n</code></pre>","title":"variable DISCOVERY_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_service_id","text":"<pre><code>constexpr const char INTROSPECTION_SERVICE_ID = \"Introspection\";\n</code></pre>","title":"variable INTROSPECTION_SERVICE_ID"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_app_name","text":"<pre><code>constexpr const char INTROSPECTION_APP_NAME = \"introspection\";\n</code></pre>","title":"variable INTROSPECTION_APP_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_node_name","text":"<pre><code>constexpr const char INTROSPECTION_NODE_NAME = \"introspection\";\n</code></pre>","title":"variable INTROSPECTION_NODE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionmempoolservice","text":"<pre><code>const capro::ServiceDescription IntrospectionMempoolService;\n</code></pre>","title":"variable IntrospectionMempoolService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-max_group_name_length","text":"<pre><code>constexpr int MAX_GROUP_NAME_LENGTH = 32;\n</code></pre>","title":"variable MAX_GROUP_NAME_LENGTH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionportservice","text":"<pre><code>const capro::ServiceDescription IntrospectionPortService;\n</code></pre> <p>publisher/subscriber port information consisting of a process name,a capro service description string and a node name </p>","title":"variable IntrospectionPortService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionportthroughputservice","text":"<pre><code>const capro::ServiceDescription IntrospectionPortThroughputService;\n</code></pre>","title":"variable IntrospectionPortThroughputService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionsubscriberportchangingdataservice","text":"<pre><code>const capro::ServiceDescription IntrospectionSubscriberPortChangingDataService;\n</code></pre>","title":"variable IntrospectionSubscriberPortChangingDataService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionprocessservice","text":"<pre><code>const capro::ServiceDescription IntrospectionProcessService;\n</code></pre>","title":"variable IntrospectionProcessService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-roudi_config_file_parse_error_strings","text":"<pre><code>constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS = {\"NO_GENERAL_SECTION\",\n                                                                 \"INVALID_CONFIG_FILE_VERSION\",\n                                                                 \"NO_SEGMENTS\",\n                                                                 \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\",\n                                                                 \"SEGMENT_WITHOUT_MEMPOOL\",\n                                                                 \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\",\n                                                                 \"MEMPOOL_WITHOUT_CHUNK_SIZE\",\n                                                                 \"MEMPOOL_WITHOUT_CHUNK_COUNT\",\n                                                                 \"EXCEPTION_IN_PARSER\"};\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/","text":"","title":"iox::runtime"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#classes","text":"Name     class iox::runtime::Node class which represents a node   struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU).   class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon.   class iox::runtime::PoshRuntimeSingleProcess   class iox::runtime::ServiceDiscovery","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#types","text":"Name     enum popo::EventEnumIdentifier ServiceDiscoveryEvent   using iox::cxx::vector&lt; capro::ServiceDescription, MAX_FINDSERVICE_RESULT_SIZE &gt; ServiceContainer","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#attributes","text":"Name     constexpr units::Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT   constexpr units::Duration PROCESS_KEEP_ALIVE_INTERVAL   constexpr units::Duration PROCESS_KEEP_ALIVE_TIMEOUT","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#enum-servicediscoveryevent","text":"Enumerator Value Description     SERVICE_REGISTRY_CHANGED","title":"enum ServiceDiscoveryEvent"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#using-servicecontainer","text":"<pre><code>using iox::runtime::ServiceContainer = typedef iox::cxx::vector&lt;capro::ServiceDescription, MAX_FINDSERVICE_RESULT_SIZE&gt;;\n</code></pre>","title":"using ServiceContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_waiting_for_roudi_timeout","text":"<pre><code>constexpr units::Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60_s;\n</code></pre>","title":"variable PROCESS_WAITING_FOR_ROUDI_TIMEOUT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_keep_alive_interval","text":"<pre><code>constexpr units::Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi::DISCOVERY_INTERVAL;\n</code></pre>","title":"variable PROCESS_KEEP_ALIVE_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_keep_alive_timeout","text":"<pre><code>constexpr units::Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable PROCESS_KEEP_ALIVE_TIMEOUT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1units_1_1duration__literals/","text":"<p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"iox::units::duration_literals"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/","text":"","title":"iox::version"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#types","text":"Name     enum CompatibilityCheckLevel   using cxx::string&lt; COMMIT_ID_STRING_SIZE &gt; CommitIdString_t   using cxx::string&lt; BUILD_DATE_STRING_SIZE &gt; BuildDateString_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#functions","text":"Name     iox::log::LogStream &amp; operator&lt;&lt;(iox::log::LogStream &amp; logstream, const version::CompatibilityCheckLevel &amp; level)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#attributes","text":"Name     const uint64_t COMMIT_ID_STRING_SIZE   const uint64_t BUILD_DATE_STRING_SIZE","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#enum-compatibilitychecklevel","text":"Enumerator Value Description     OFF     MAJOR     MINOR     PATCH     COMMIT_ID     BUILD_DATE","title":"enum CompatibilityCheckLevel"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#using-commitidstring_t","text":"<pre><code>using iox::version::CommitIdString_t = typedef cxx::string&lt;COMMIT_ID_STRING_SIZE&gt;;\n</code></pre>","title":"using CommitIdString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#using-builddatestring_t","text":"<pre><code>using iox::version::BuildDateString_t = typedef cxx::string&lt;BUILD_DATE_STRING_SIZE&gt;;\n</code></pre>","title":"using BuildDateString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#function-operator","text":"<pre><code>inline iox::log::LogStream &amp; operator&lt;&lt;(\n    iox::log::LogStream &amp; logstream,\n    const version::CompatibilityCheckLevel &amp; level\n)\n</code></pre>","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#variable-commit_id_string_size","text":"<pre><code>static const uint64_t COMMIT_ID_STRING_SIZE = 12U;\n</code></pre>","title":"variable COMMIT_ID_STRING_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#variable-build_date_string_size","text":"<pre><code>static const uint64_t BUILD_DATE_STRING_SIZE = 36U;\n</code></pre>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"variable BUILD_DATE_STRING_SIZE"},{"location":"API-reference/posh/Pages/todo/","text":"<p>Namespace iox::roudi</p> <ul> <li>Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target  </li> </ul> <p>Member iox::roudi::PortPool::getPublisherPortDataList  () noexcept</p> <ul> <li>don't create the vector with each call but only when the data really change there could be a member \"cxx::vector&lt;popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed </li> </ul>  <p>Updated on 17 March 2022 at 12:15:57 CET</p>","title":"Todo List"},{"location":"advanced/configuration-guide/","text":"","title":"Configuration guide"},{"location":"advanced/configuration-guide/#cmake-switches-for-configuring-iceoryx_posh-build","text":"<p>When building iceoryx_posh, there are several configuration options set by default. These options adjust the limits of Publisher and Subscriber Ports for resource management. These limits are used to create management structures in the shared memory segment called <code>iceoryx_mgmt</code> when starting up RouDi.</p>    switch description     <code>IOX_MAX_PUBLISHERS</code> Maximum number of publishers which can be managed by one <code>RouDi</code> instance   <code>IOX_MAX_SUBSCRIBERS_PER_PUBLISHER</code> Maximum number of connected subscriber ports per publisher port   <code>IOX_MAX_PUBLISHER_HISTORY</code> Maximum number of chunks available for the publisher history   <code>IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY</code> Maximum number of chunks a publisher can allocate at a given time   <code>IOX_MAX_SUBSCRIBERS</code> Maximum number of subscribers which can be managed by one <code>RouDi</code> instance   <code>IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY</code> Maximum number of chunks a subscriber can hold at a given time (subscriber history size)   <code>IOX_MAX_INTERFACE_NUMBER</code> Maximum number of interface ports which are used for gateways    <p>Have a look at IceoryxPoshDeployment.cmake for the default values of the constants.</p>  <p>Hint</p> <p>With the default values set, the size of <code>iceoryx_mgmt</code> is ~64.5 MByte. You can reduce the size by decreasing the values from the table via the CMake options. The current values are printed in the CMake stage when building iceoryx.</p>  <p>Example:</p> <pre><code>cmake -Bbuild -Hiceoryx_meta -DIOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY=64\n</code></pre> <p>With that change, the footprint of the management segment is reduced to ~52.7 MBytes. For larger use cases you can increase the value to avoid that samples are dropped on the subscriber side (see also #615).</p>","title":"CMake switches for configuring iceoryx_posh build"},{"location":"advanced/configuration-guide/#configuring-mempools-for-roudi","text":"<p>RouDi supports several shared memory segments with different access rights, to limit the read and write access between different applications. Inside of these segments reside mempools where the user payload data for transfer is stored.</p>  <p>Note</p> <p>Actually only the chunk-payload size is configured and the size of the <code>ChunkHeader</code> will be added to the configured size. If a user-header or a user-payload alignment larger than 8 is used, the available size for the user-payload will be smaller than the configured chunk-payload since some space is needed for the other functionality. Please have a look at the <code>chunk_header.md</code> design document for a formula how to determine the necessary chunk-payload size with user-header and extended user-payload alignment.</p>  <p>For building RouDi, iceoryx ships a library named <code>iceoryx_posh_roudi</code>. This lib gives you an API for compiling your own RouDi application and is part of <code>iceoryx_posh</code>.</p>  <p>Note</p> <p>The chunk size for the mempool needs to follow these restrictions:</p> <ol> <li>Chunksize needs to be greater than the alignment</li> <li>Chunksize needs to be a multiple of the alignment</li> </ol>  <p>The value for the alignment is set to 8.</p>","title":"Configuring Mempools for RouDi"},{"location":"advanced/configuration-guide/#dynamic-configuration","text":"<p>One way is to read a configuration dynamically at RouDi runtime (startup). Using TOML Config in RouDi is not mandatory for configuring segments and mempools, but a comfortable alternative.</p> <p>To enable the TOML config in iceoryx, the CMake option <code>-DTOML_CONFIG=ON</code> must be used (enabled by default). The <code>iox-roudi</code> provided by iceoryx is with TOML support and can be used out of the box.</p> <p>If you create your own RouDi application you need to link against <code>iceoryx_posh_config</code>:</p> <pre><code>target_link_libraries(custom-roudi\n    PRIVATE\n    iceoryx_posh::iceoryx_posh_roudi\n    iceoryx_posh::iceoryx_posh_config\n)\n</code></pre> <p>The TOML config file can be passed to RouDi with the <code>-c</code> command-line option.</p> <pre><code>./iox-roudi -c /absolute/path/to/config/file.toml\n</code></pre> <p>This is a common config file with format version 1:</p> <pre><code>[general]\nversion = 1\n\n[[segment]]\n\n[[segment.mempool]]\nsize = 32\ncount = 10000\n\n[[segment.mempool]]\nsize = 128\ncount = 10000\n\n[[segment.mempool]]\nsize = 1024\ncount = 1000\n</code></pre> <p>With this configuration, one payload segment will be created. The access rights are set to the RouDi group id. There are three mempools within this segment. One with 10000 chunks of 32 byte payload size, one with 10000 chunks of 128 bytes, and one with 1000 chunks of 1024 bytes.</p> <p>To restrict the access, a reader and writer group can be set:</p> <pre><code>[general]\nversion = 1\n\n[[segment]]\nreader = \"foo\"\nwriter = \"bar\"\n\n[[segment.mempool]]\nsize = 32\ncount = 10000\n\n[[segment.mempool]]\nsize = 128\ncount = 10000\n\n[[segment.mempool]]\nsize = 1024\ncount = 1000\n</code></pre> <p>With this configuration, only applications from the <code>bar</code> group have write access and can allocate chunks. Applications from the <code>foo</code> group have only read access.</p> <p>This is an example with multiple segments:</p> <pre><code>[general]\nversion = 1\n\n[[segment]]\nreader = \"foo\"\nwriter = \"bar\"\n\n[[segment.mempool]]\nsize = 32\ncount = 10000\n\n[[segment]]\nreader = \"alice\"\nwriter = \"eve\"\n\n[[segment.mempool]]\nsize = 1024\ncount = 100\n</code></pre> <p>When no config file is specified, a hard-coded version similar to the default config will be used.</p>","title":"Dynamic configuration"},{"location":"advanced/configuration-guide/#static-configuration","text":"<p>Another way is to have a static config that is compile-time dependent, this means that you have to recompile your RouDi application if you want to change your config (not the iceoryx_posh_roudi lib). You can have your source file with <code>main()</code> method where you can create your custom configuration and pass it to a RouDi instantiation. In your CMake file for your custom RouDi you need to ensure that it is not linking against <code>iceoryx_posh_config</code> to have a static config.</p> <p>A good example of a static config can be found here.</p>","title":"Static configuration"},{"location":"advanced/iceoryx_hoofs/","text":"<p>The iceoryx hoofs (Handy Objects Optimised For Safety) are our basic building blocks - the foundation of iceoryx. There are a wide variety of building blocks grouped together in categories or namespace, depending on where or how they are used.</p>","title":"Eclipse iceoryx hoofs overview"},{"location":"advanced/iceoryx_hoofs/#categories","text":"Namespace Short Description     cxx Since we are not allowed to use C++17 as well as the heap or exceptions we implemented constructs like <code>optional</code>, <code>expected</code> or <code>variant</code> so that we can be as modern as possible. Furthermore, you can find here constructs which are mentioned in the C++ Core Guidelines as well as STL re-implementations of container like <code>vector</code> which are relocatable an can be placed into the shared memory.   concurrent You should never use concurrent constructs like <code>mutex</code>, <code>semaphores</code>, <code>atomic</code>, etc. directly in our codebase. At the moment we still have some exceptions to this guideline but the idea is that all classes which are using them are stored under concurrent and have to undergo more tests then the usual non concurrent class. For instance we try to provide stress tests for them. This module provides classes like <code>fifo</code>, <code>smart_lock</code>, <code>sofi</code>, <code>trigger_queue</code> and much more.   design_pattern Certain code patterns which are repeating themselves all over the code are abstracted and stored in here. At the moment we only have the creation pattern which will be removed in a future release.   error-handling The central error handler in iceoryx for cases when no sane further execution is possible, e.g. <code>nullptr</code> access.   log The logger used by iceoryx.   posix_wrapper Posix constructs like shared memory, threads or semaphores are not used directly in our code base. We abstracted them so that they are following the RAII (Resource Acquisition Is Initialization) idiom and other good practices from the C++ community.   units Time units for duration and string literals.   other There are even more namespaces inside the iceoryx hoofs but they will either become obsolete in the future, will be integrated into existing names or are established as another namespace and documented here. We are unsure where they will end up in the future.","title":"Categories"},{"location":"advanced/iceoryx_hoofs/#structure","text":"<p>The following sections have a column labeled <code>internal</code> to indicate that the API is not stable and can change anytime. You should never rely on it and there is no support if it is used and breaks your code after an update.</p> <p>The column <code>maybe obsolete</code> marks classes which can be removed anytime soon.</p>","title":"Structure"},{"location":"advanced/iceoryx_hoofs/#cxx","text":"<p>This contains STL constructs which are not part of the C++14 standard as well as convenience constructs like the <code>NewType</code>. Since the module re-implements some STL constructs, the C++ STL coding guidelines are used for all files in this module, to help the user to have a painless transition from the official STL types to ours. The API should also be identical to the corresponding STL types but we have to make exceptions here. For instance, we do not throw exceptions, try to avoid undefined behavior and we do not use dynamic memory. In these cases we adjusted the API to our use case.</p> <p>Most of the headers are providing some example code on how the class should be used.</p>    class/file internal maybe obsolete description     <code>algorithm</code>   Implements <code>min</code> and <code>max</code> for an arbitrary number of values of the same type. For instance <code>min(1,2,3,4,5);</code>   <code>attributes</code>   C++17 and C++20 attributes are sometimes available through compiler extensions. The attribute macros defined in here (like <code>IOX_FALLTHROUGH</code>, <code>IOX_MAYBE_UNUSED</code> ... ) make sure that we are able to use them if the compiler supports it.   <code>convert</code>   Converting a number into a string is easy, converting it back can be hard. You can use functions like <code>strtoll</code> but you still have to handle errors like under- and overflow, or converting invalid strings into number. Here we abstract all the error handling so that you can convert strings into numbers safely.   <code>DeadlineTimer</code>   Polling based timer to check for an elapsed deadline.   <code>expected</code>   Our base class used in error handling. Every function which can fail should return an expected. With this the user knows that this function can fail and that they have to do some kind of error handling. We got inspired by the C++ expected proposal and by the rust error handling concept.   <code>filesystem</code>   Implementation of C++17 filesystem features for instance <code>cxx::perms</code> to abstract file permissions   <code>forward_list</code>   Heap and exception free, relocatable implementation of <code>std::forward_list</code>   <code>function</code>   A stack-based <code>std::function</code> replacement based on <code>storable_function</code>   <code>function_ref</code>   C++11 implementation of the next-gen C++ feature <code>std::function_ref</code> see function_ref proposal. It behaves like <code>std::function</code> but does not own the callable.   <code>functional_interface</code>   Constructs to easily add functional interfaces like <code>and_then</code> to object container.   <code>GenericRAII</code>   This is an abstraction of the C++ RAII idiom. Sometimes you have constructs where you would like to perform a certain task on creation and then again when they are getting out of scope, this is where <code>GenericRAII</code> comes in. It is like a <code>std::lock_guard</code> or a <code>std::shared_ptr</code> but more generic.   <code>helplets</code>   Implementations of C++ Core Guideline concepts like <code>not_null</code> are contained here. Additionally, we are providing some types to verify preconditions at compile time. Think of an int which has to be always greater 5, here we provide types like <code>greater_or_equal&lt;int, 6&gt;</code>.   <code>list</code>   Heap and exception free, relocatable implementation of <code>std::list</code>   <code>MethodCallback</code>  X Constructs a callback from a pointer to a specific object and a pointer to a method of that object, also as <code>ConstMethodCallback</code> available   <code>NewType&lt;T, Policies&gt;</code>   C++11 implementation of Haskells NewType-pattern.   <code>optional</code>   C++11 implementation of the C++17 feature <code>std::optional</code>   <code>pair</code> i X Simplistic re-implementation of an <code>std::pair</code>.   <code>poor_mans_heap</code>   Acquires memory on the stack for placement new instantiations. All classes must inherit from a base class which has to be known at compile time but the class itself does not have to be known - only the size.   <code>ReferenceCounter</code> i  Basic building block for classes which are needing some kind of reference counting like a <code>std::shared_ptr</code>   <code>requires</code>   Base for <code>Expects</code>/<code>Ensures</code> from the C++ Core Guideline   <code>scoped_static</code>   Helper function to limit lifetime of static or global variables to a scope   <code>serialization</code>  X Implements a simple serialization concept for classes based on the idea presented here ISOCPP serialization.   <code>set</code> i X Templated helper functions to create a fake <code>std::set</code> from a vector.   <code>stack</code>   Stack implementation with simple push/pop interface.   <code>static_storage</code> i  Untyped aligned static storage.   <code>storable_function</code> i  A <code>std::function</code> alternative with configurable backend for memory storage.   <code>string</code>   Heap and exception free implementation of <code>std::string</code>. Attention, since the string is stack based, std::string or char array which are assigned to this string will be truncated and zero-terminated if they exceed the string capacity.   <code>type_traits</code>   Extended support for evaluating types on compile-time.   <code>types</code>   Declares essential building block types like <code>byte_t</code>.   <code>UniqueId</code> i  Monotonic increasing IDs within a process.   <code>unique_ptr</code>   Provides a heap-less unique ptr implementation, unlike the STL   <code>variant</code>   C++11 implementation of the C++17 feature <code>std::variant</code>   <code>variant_queue</code>   A queue which wraps multiple variants of Queues (FiFo, SoFi, ResizeableLockFreeQueue)   <code>vector</code>   Heap and exception free implementation of <code>std::vector</code>","title":"CXX"},{"location":"advanced/iceoryx_hoofs/#concurrent","text":"<p>If you have to write concurrent code, never use concurrency constructs like <code>mutex</code>, <code>atomic</code>, <code>thread</code>, <code>semaphore</code>, etc. directly. Most of the use cases can be solved by using an <code>ActiveObject</code> which uses as building block our <code>FiFo</code> or a queue which is thread-safe when combined with <code>smart_lock</code>. To learn more about active objects see Prefer Using Active Objects Instead Of Naked Threads.</p>    class internal maybe obsolete description     <code>ActiveObject</code> i X Active object base skeleton implementation inspired by Prefer Using Active Objects Instead Of Naked Threads   <code>FiFo</code> i  Single producer, single consumer lock-free FiFo   <code>LockfreeQueue</code>   Multi producer, multi consumer lock-free FiFo with ringbuffer like overflow handling   <code>LoFFLi</code> i  Lock-free LIFO based index manager (lock-free free list). One building block of our memory manager. After construction it contains the indices {0 ... n} which you can acquire and release.   <code>PeriodicTask</code> i  Periodically executes a callable specified by the template parameter in a configurable time interval.   <code>ResizeableLockFreeQueue</code>   Resizeable variant of the <code>LockfreeQueue</code>   <code>smart_lock</code> i  Creates arbitrary thread safe constructs which then can be used like smart pointers. If some STL type should be thread safe use the smart_lock to create the thread safe version in one line. Based on some ideas presented in Wrapping C++ Member Function Calls   <code>SoFi</code> i  Single producer, single consumer lock-free safely overflowing FiFo (SoFi).   <code>TACO</code> i  Thread Aware exChange Ownership (TACO). Solution if you would like to use <code>std::atomic</code> with data types larger than 64 bit. Wait free data synchronization mechanism between threads.   <code>TriggerQueue</code> i X Queue with a <code>push</code> - <code>pop</code> interface where <code>pop</code> is blocking as long as the queue is empty. Can be used as a building block for active objects.    <p>attribute overview of the available Queues:</p>    Data Structure Shared Memory usable Thread-Safe Lock-Free Concurrent Producers : Consumers Bounded Capacity Data Type Restriction Use Case     <code>FiFo</code> Yes Yes Yes 1:1 Yes Copyable FIFO Data transfer   <code>LockfreeQueue</code> Yes Yes Yes n:m Yes Copyable or Movable lock-free transfer of arbitrary data between multiple contexts in FIFO order with overflow handling (ringbuffer)   <code>LoFFLi</code> Yes Yes Yes n:m Yes int32 manage memory access, LIFO order   <code>smart_lock</code> Yes Yes No n/a n/a None Wrapper to make classes thread-safe (by using a lock)   <code>SoFi</code> Yes Yes Yes 1:1 Yes Trivially Copyable lock-free transfer of small data (e.g. pointers) between two contexts in FIFO order with overflow handling (ringbuffer)   <code>ResizeableLockFreeQueue</code> Yes Yes Yes n:m Yes Copyable or Movable Resizeable variant of the <code>LockfreeQueue</code>   <code>TACO</code> Yes Yes Yes n:m Yes Copyable or Movable fast lock-free exchange data between threads   <code>TriggerQueue</code> No Yes No n:m Yes Copyable Process events in a blocking way","title":"Concurrent"},{"location":"advanced/iceoryx_hoofs/#design-pattern","text":"class internal maybe obsolete description     <code>Creation</code>  X When implementing resource handling classes which follow the RAII idiom we may have to throw exceptions inside the constructor. As an alternative to exceptions we have the creation pattern, a specialized factory which returns the object inside of an <code>expected</code>.","title":"Design pattern"},{"location":"advanced/iceoryx_hoofs/#error-handling","text":"<p>The error handler is a central instance for collecting all errors and react to them. The <code>error-handling.hpp</code> contains a list of all error enum values. The error handler has different error levels, for more information see error-handling.md</p>    class internal maybe obsolete description     <code>errorHandler</code>   Free function to call the error handler with a defined error and an error level, see header file for practical example.   <code>ErrorHandler</code> i  error handler class only for testing purposes, should not be used directly","title":"Error handling"},{"location":"advanced/iceoryx_hoofs/#log","text":"<p>For information about how to use the logger API see error-handling.md</p>    class internal maybe obsolete description     <code>logger</code>","title":"Log"},{"location":"advanced/iceoryx_hoofs/#posix-wrapper","text":"<p>We abstract POSIX resources following the RAII idiom and by using our Creation pattern. Try to exclusively use these abstractions or add a new one when using POSIX resources like semaphores, shared memory, etc.</p>    class internal maybe obsolete description     <code>AccessController</code> i  Interface for Access Control Lists (ACL).   <code>FileLock</code>   File lock C++ wrapping class.   <code>NamedPipe</code>   Shared memory based ipc channel. Mainly a <code>UnixDomainSocket</code> replacement on Windows.   <code>IpcChannel</code> i  Helper types used by the <code>MessageQueue</code>and the <code>UnixDomainSocket</code>.   <code>MessageQueue</code> i  Interface for Message Queues, see ManPage mq_overview.   <code>mutex</code> i  Mutex interface, see ManPage pthread_mutex_lock.   <code>posix_access_rights</code>   Rights and user management interface.   <code>posixCall</code>   Wrapper around C and POSIX function calls which performs a full error handling. Additionally, this wrapper makes sure that <code>EINTR</code> handling is performed correctly by repeating the system call.   <code>SignalGuard</code>   Helper class for signal handler registration.   <code>SignalWatcher</code>   Batteries included signal handling with polling and optional blocking wait for <code>SIGINT</code> and <code>SIGTERM</code>.   <code>Semaphore</code>   Semaphore interface, see ManPage sem_overview   <code>shared_memory_object/Allocator</code> i  Helper class for the <code>SharedMemoryObject</code>.   <code>shared_memory_object/MemoryMap</code> i  Abstraction of <code>mmap</code>, <code>munmap</code> and helper class for the <code>SharedMemoryObject</code>.   <code>shared_memory_object/SharedMemory</code> i  Abstraction of shared memory, see ManPage shm_overview and helper class for the <code>SharedMemoryObject</code>.   <code>SharedMemoryObject</code> i  Creates and maps existing shared memory into the application.   <code>system_configuration</code> i  Collection of free functions which acquire system information like the page-size.   <code>thread</code>   Wrapper for pthread functions like <code>pthread_setname_np</code>.   <code>Timer</code>  X Interface for the posix timer, see ManPage timer_create.   <code>UnixDomainSocket</code> i  Interface for unix domain sockets.","title":"POSIX wrapper"},{"location":"advanced/iceoryx_hoofs/#units","text":"<p>Never use physical properties like speed or time directly as integer or float in your code. Otherwise you encounter problems like this function <code>void setTimeout(int timeout)</code>. What is the unit of the argument, seconds? minutes? If you use <code>Duration</code> you see it directly in the code.</p> <pre><code>void setTimeout(const Duration &amp; timeout);\n\nsetTimeout(11_s); // 11 seconds\nsetTimeout(5_ms); // 5 milliseconds\n</code></pre>    class internal maybe obsolete description     <code>Duration</code> i  Represents the unit time, is convertible to <code>timespec</code> and <code>timeval</code>. User defined literals are available for convenience and readability.","title":"Units"},{"location":"advanced/iceoryx_hoofs/#objectpool","text":"class internal maybe obsolete description     <code>ObjectPool</code> i  Container which stores raw objects without calling the ctor of the objects.","title":"objectpool"},{"location":"advanced/iceoryx_hoofs/#graphs","text":"class internal maybe obsolete description     <code>DirectedGraph</code> i  Creates and manages a directed graph.   <code>DirectedAcyclicGraph</code> i  Like the <code>DirectedGraph</code> but additional checks prohibit to create edges which have a cyclic dependency.","title":"graphs"},{"location":"advanced/iceoryx_hoofs/#file-reader","text":"class internal maybe obsolete description     <code>FileReader</code> i X Wrapper for opening files and reading them.    <p> Check out iceoryx_hoofs on GitHub  </p>","title":"file-reader"},{"location":"advanced/installation-guide-for-contributors/","text":"","title":"Installation guide for contributors"},{"location":"advanced/installation-guide-for-contributors/#build-and-run-tests","text":"<p>While developing on iceoryx, you may want to know if your changes will break existing functionality or if your newly written tests will pass. For that purpose, we generate CMake targets that execute the tests. First, we need to build them:</p> <pre><code>cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST=ON\ncmake --build build\n</code></pre> <p>CMake automatically installs GoogleTest as a local dependency and builds the tests against it. Please note that if you want to build tests for extensions like the DDS-Gateway you need to enable this extension as well in the CMake build. To build the tests for all extensions simply add <code>-DBUILD_ALL</code> to the CMake command.</p>  <p>Hint</p> <p>Before creating a Pull-Request, you should check your code for compiler warnings. The <code>-DBUILD_STRICT</code> CMake option is available for this purpose, which treats compiler warnings as errors. This flag is enabled on the GitHub CI for building Pull-Requests.</p>  <p>Now let's execute all tests:</p> <pre><code>cd iceoryx/build\nmake all_tests\n</code></pre> <p>Some of the tests are time-dependent and need a stable environment. These timing tests are available in separate targets:</p> <pre><code>make timing_module_tests\nmake timing_integration_tests\n</code></pre> <p>In iceoryx we distinguish between different test levels. The most important are: Module tests and Integration tests. Module or unit tests are basically black box tests that test the public interface of a class. In integration tests the interaction of several classes is tested. The source code of the tests is placed into the folder <code>test</code> within the different iceoryx components. You can find there at least a folder <code>moduletests</code> and sometimes <code>integrationtests</code>.</p> <p>If you now want to create a new test, you can place the source file directly into the right folder. CMake will automatically detect the new file when doing a clean build and will add it to the corresponding executable. There is no need to add a gtest main function because we already provide it. Executables are created for every test level, for example <code>posh_moduletests</code>. They are placed into the corresponding build folder (e.g. <code>iceoryx/build/posh/test/posh_moduletests</code>).</p> <p>If you want to execute only individual test cases, you can use these executables together with a filter command. Let's assume you want to execute only <code>ServiceDescription_test</code> from posh_moduletests:</p> <pre><code>./build/posh/test/posh_moduletests --gtest_filter=\"ServiceDescription_test*\"\n</code></pre>  <p>Hint</p> <p>While writing code on iceoryx you should use git hooks that automatically ensure that you follow the coding and style guidelines. See <code>git-hooks</code>.</p>","title":"Build and run tests"},{"location":"advanced/installation-guide-for-contributors/#use-sanitizer-scan","text":"<p>Due to the fact that iceoryx works a lot with system memory, it should be ensured that errors like memory leaks are not introduced. To prevent this, we use the clang toolchain which offers several tools for scanning the codebase. One of them is the AddressSanitizer which checks e.g. for dangling pointers.</p> <p>The below-listed sanitizers are enabled at the moment.</p> <ul> <li>AddressSanitizer (ASan) is a fast memory error detector.</li> </ul>  <p>Note</p> <p>AddressSanitizer exits on the first detected error, which means there could be more errors in the codebase when this error is reported.</p>  <ul> <li>LeakSanitizer (LSan) is a run-time memory leak detector. In iceoryx, it runs as part of the AddressSanitizer.</li> <li>UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. iceoryx uses default behavior i.e. <code>print a verbose error report and continue execution</code></li> </ul> <p>With the <code>iceoryx_build_test.sh</code> script you can run the scan yourself. Additionally, the scans are running on the CI in every Pull-Request. As a prerequisite, you need to install the clang compiler:</p> <pre><code>sudo apt install clang\n</code></pre> <p>Then you need to compile iceoryx with the sanitizer flags:</p> <pre><code>./tools/iceoryx_build_test.sh build-strict build-all sanitize clang clean\n</code></pre> <p>Now we can run the tests with enabled sanitizer options:</p> <pre><code>cd build &amp;&amp; ./tools/run_tests.sh\n</code></pre> <p>If errors occur, an error report is shown with a stack trace to find the place where the leak occurs. If the leak has its origin in an external dependency or shall be handled later then it is possible to set a function on a suppression list. This should be used only rarely and only in coordination with an iceoryx maintainer.</p>  <p>Note</p> <p>iceoryx needs to be built as a static library to work with sanitizer flags, which is automatically achieved when using the script. If you want to use the ${ICEORYX_WARNINGS} then you have to call <code>find_package(iceoryx_hoofs)</code> and <code>include(IceoryxPlatform)</code> to make use of the ${ICEORYX_SANITIZER_FLAGS}.</p>","title":"Use Sanitizer Scan"},{"location":"advanced/installation-guide-for-contributors/#iceoryx-library-build","text":"<p>The iceoryx build consists of several libraries which have dependencies on each other. The goal is to have encapsulated library packages available so that the end-user can easily find them with the CMake command <code>find_package(...)</code>. In the default case, the iceoryx libraries are installed by <code>make install</code> into <code>/usr/lib</code> which requires root access. As an alternative you can install the libs into a custom folder by setting <code>-DCMAKE_INSTALL_PREFIX=/custom/install/path</code> as build flag for the CMake file in iceoryx_meta.</p> <p>iceoryx_meta collects all libraries (hoofs, posh etc.) and extensions (binding_c, dds) and can be a starting point for the CMake build. The provided build script <code>tools/iceoryx_build_test.sh</code> uses iceoryx_meta.</p> <p>Per default, iceoryx is built as static lib for better usability. Additionally, we offer to build as shared library because it is a cleaner solution for resolving dependency issues and it reduces the linker time. This is done by the flag <code>BUILD_SHARED_LIBS</code> which is set to OFF per default in iceoryx_meta. If you want to have shared libraries, just pass <code>-DBUILD_SHARED_LIBS=ON</code> to CMake or use <code>build-shared</code> as a flag in the build script.</p>  <p>Note</p> <p>When building with <code>colcon</code> in ROS 2, the packages <code>iceoryx_hoofs</code>, <code>iceoryx_posh</code> and <code>iceoryx_binding_c</code> are built automatically as shared libraries.</p>  <p>If iceoryx builds shared libraries you have to copy them into a custom path and set the LD_LIBRARY_PATH to the custom path (e.g. build/install/prefix).</p> <pre><code>export LD_LIBRARY_PATH=/your/path/to/iceoryx/libs\n</code></pre> <p>or you can set it directly:</p> <pre><code>LD_LIBRARY_PATH=/your/path/to/lib iox-roudi\n</code></pre> <p>If you want to share iceoryx to other users, you can create a debian package. This can be done by using: <code>./tools/iceoryx_build_test.sh package</code> where it will be deployed into the <code>build_package</code> folder.</p>  <p>Note</p> <p>The CMake libraries export their dependencies for easier integration. This means that you do not need to do a <code>find_package()</code> for all the dependencies. For example, you don't need to call <code>find_package(iceoryx_hoofs)</code> when you already called <code>find_package(iceoryx_posh)</code> since iceoryx_posh includes iceoryx_hoofs.</p>","title":"iceoryx library build"},{"location":"advanced/installation-guide-for-contributors/#tips-tricks","text":"<p>Sometimes one can encounter a failing CI target which is not reproducible locally on the developer machine. With <code>./tools/scripts/ice_env.sh</code> one can create a docker container with preinstalled dependencies and a configuration similar to the CI target container.</p> <p>When for instance the target ubuntu 18.04 fails we can start the container with</p> <pre><code>./tools/scripts/ice_env.sh enter ubuntu:18.04\n</code></pre> <p>which enters the environment automatically and one can start debugging.</p>","title":"Tips &amp; Tricks"},{"location":"concepts/architecture/","text":"<p>This article provides an overview of the Eclipse iceoryx architecture and explains the rationale for it.</p>","title":"Architecture"},{"location":"concepts/architecture/#software-layers","text":"<p>The main packages which Eclipse iceoryx is composed of are depicted below.</p> <p></p> <p>The next sections briefly describe the components and their libraries one by one.</p>","title":"Software layers"},{"location":"concepts/architecture/#components-and-libraries","text":"<p>The different libraries and their namespaces are depicted below.</p> <p></p>","title":"Components and libraries"},{"location":"concepts/architecture/#iceoryx-hoofs","text":"<p>Handy Objects Optimized For Safety (hoofs) is a library and contains various building blocks like fixed size containers, concurrency classes and modern, next-gen C++ constructs from upcoming C++ standard releases.</p> <p>For more information about the components, refer to its detailed description.</p>","title":"iceoryx hoofs"},{"location":"concepts/architecture/#iceoryx-posh","text":"<p>The package <code>iceoryx_posh</code> (POSIX SHared memory) contains everything related to shared memory inter-process communication.</p>","title":"iceoryx posh"},{"location":"concepts/architecture/#core-library","text":"<p>This section describes the namespaces of the core library.</p> <ul> <li><code>popo</code>: The namespace posh ports contains the user-API classes which are used to transfer data.</li> <li><code>capro</code>: The namespace canonical protocol implements the canonical protocol pattern protocol, which is used by <code>iceoryx_posh</code> to connect and discover <code>popo::Publisher</code> and <code>popo::Server</code>.</li> <li><code>mepoo</code>: The namespace memory pool contains all memory-related classes. For example the <code>MemoryManager</code> or <code>SharedPointer</code>.</li> <li><code>version</code>: The namespace version contains ABI compatibilities checks.</li> <li><code>build</code>: The namespace build contains certain maximium values which can be changed before compilation.</li> </ul>","title":"Core library"},{"location":"concepts/architecture/#gatway-library","text":"<ul> <li>The gateway library and its namespace <code>gw</code> contain generic abstractions to create a gateway. They are used by <code>iceoryx_dds</code>.</li> </ul>","title":"Gatway library"},{"location":"concepts/architecture/#roudi-library","text":"<ul> <li>The library RouDi and its namespace <code>roudi</code> contains classes which are used by the RouDi middleware daemon.</li> </ul>","title":"RouDi library"},{"location":"concepts/architecture/#iceoryx-c-binding","text":"<p>The module <code>iceoryx_binding_c</code> makes the inter-process communication features of <code>iceoryx_posh</code> available in C.</p>","title":"iceoryx C binding"},{"location":"concepts/architecture/#iceoryx-dds","text":"<p>The package <code>iceoryx_dds</code> provides a bi-directional DDS gateway using Eclipse Cyclone DDS. The gateway can be used to send data over a network e.g. via Ethernet.</p> <p>For more information, refer to the Readme.</p>","title":"iceoryx DDS"},{"location":"concepts/architecture/#iceoryx-introspection","text":"<p>The introspection client can be used for live debugging and provides information of the current system like memory usage and established connections.</p> <p>For more information, refer to the icecrystal example.</p>","title":"iceoryx introspection"},{"location":"concepts/best-practice-for-testing/","text":"<p>This is a guide on how to write tests for iceoryx. It intends to cover the most common cases which will probably apply to 99% of tests. This shall not encourage to be more royalist than the king and common sense shall be applied when the guidelines don't make sense. But if half of the tests don't follow the guidelines, it's a clear indicator that they need to be refactored.</p> <p>The guide also expects some knowledge on <code>gtest</code>. At least the Googletest Primer document should be read before continuing with this guide.</p> <p>Don't write tests just for the sake of having a high coverage number. First and foremost, tests must be meaningful and verify the code to prevent bugs and regressions. New code shall be created with testability in mind. Legacy code shall be refactored if it is not testable.</p> <p>In general, the Arrange Act Assert pattern shall be used. This makes it trivial to isolate a test failure, since only one state transition is tested at a time. These two blog posts explain the AAA pattern in more detail.</p> <p>While the AAA pattern provides a sensible structure, ZOMBIES help you to find sensible test cases.</p> <pre><code>Z = Zero\nO = One\nM = Many (or More complex)\nB = Boundary Behaviors\nI = Interface Definition\nE = Exercise Exceptional Behavior\nS = Simple Scenarios, Simple Solutions\n</code></pre> <p>This can be separated into ZOM and BIE with S bridging them together. ZOM are often simple tests, like a vector with zero items is empty or a vector with one item is not empty or a vector with N items has a size of N. The BIE part takes care of edge cases like adding one to Number::max saturates or division by zero returns error. The latter overlaps with a case from the ZOM part, which illustrates that these are not always clearly separated.</p> <p>Exercise Exceptional Behavior means to not only test the happy path, but also the negative one. Basically, you should test silly inputs and check for a graceful behavior like the previous example with division by 0. The linked blog post explains negative testing in a more thorough way.</p> <p>The catchwords can be used to draw simple scenarios which nicely fits to the AAA pattern. A non-exhaustive list of these scenarios are</p> <ul> <li>overflow</li> <li>underflow</li> <li>wrap around</li> <li>empty</li> <li>full</li> <li>out of bounds</li> <li>timeouts</li> <li>copy</li> <li>are the objects equal</li> <li>is the copy origin unchanged</li> <li>etc.</li> <li>move</li> <li>is the move destination object cleaning up its resources</li> <li>is the move origin object in a defined but unspecified state</li> <li>etc.</li> <li>etc.</li> </ul> <p>Following Hyrum's Law loosely, given enough users, one will find ways to use the software in a way it was never imagined. Therefore, never underestimate the creativity of brilliancy/stupidity.</p> <p>In some cases it might be necessary to instantiate an object on the heap. While that's not allowed in production code, it is fine in test code. To avoid manual memory management with new/delete, smart pointers shall be used if possible. As a reminder, if a method takes a pointer to an object, this object can be instantiated on the stack and the address of this object can be passed to the method. A good reason to use the heap are large objects which might cause a stack overflow. Some operating systems have a rather small stack of only a few kB, so this limit might be closer one might think.</p> <p>In general, the tests should be written in a fashion to not crash the application in case of a faulty implementation. It must be assumed that the implementation is broken and only a successful test run can prove otherwise. The <code>sut</code> (system under test) might return a <code>nullptr</code> instead of the expected valid pointer, so <code>nullptr</code> check has to be done with an <code>ASSERT_*</code> to gracefully abort the current test. Just using an <code>EXPECT_*</code> for the check is not sufficient since the potential <code>nullptr</code> will be dereferenced later on and will crash the application. The same applies to other potential dangerous operations, like accessing the value of a <code>cxx::optional</code> or <code>cxx::expected</code> or an out of bounds access of a <code>cxx::vector</code>.</p> <p>Last but not least, apply the DRY principle (don't repeat yourself) and use typed and parameterized tests to check multiple implementations and variations without repeating much code.</p>","title":"Best practice for testing"},{"location":"concepts/best-practice-for-testing/#practical-example","text":"<p>Let's test the following class</p> <pre><code>class SingleDigitNumber\n{\n  public:\n    SingleDigitNumber() noexcept = default;\n\n    constexpr SingleDigitNumber(uint64_t number) noexcept\n        : m_number(number)\n    {\n    }\n\n    constexpr operator uint64_t() const noexcept\n    {\n        return m_number;\n    }\n\n    constexpr SingleDigitNumber operator+(const SingleDigitNumber rhs) const noexcept\n    {\n        return m_number + rhs.m_number;\n    }\n\n    constexpr SingleDigitNumber operator-(const SingleDigitNumber rhs) const noexcept\n    {\n        return m_number - rhs.m_number;\n    }\n\n  private:\n    uint64_t m_number;\n};\n</code></pre> <p>This test fixture will be used</p> <pre><code>class SingleDigitNumber_test : public Test\n{\n  public:\n    void SetUp() override{};\n    void TearDown() override{};\n};\n</code></pre>","title":"Practical Example"},{"location":"concepts/best-practice-for-testing/#first-attempt","text":"<p>Well, this is quite a simple class, so the tests must also be simple, right?</p> <pre><code>TEST_F(SingleDigitNumber_test, TestClass)\n{\n    SingleDigitNumber number1;\n    SingleDigitNumber number2(3U);\n    SingleDigitNumber number3(2U);\n\n    auto number4 = number2 + number3;\n    auto number5 = number2 - number3;\n\n    EXPECT_TRUE(number4 == 5U);\n    EXPECT_EQ(1U, static_cast&lt;uint64_t&gt;(number5));\n}\n</code></pre> <p>Done and we reached 100% coverage. We can clap ourselves on the shoulders and move on. Well, except that we can't.</p> <p>The test above has several major and minor flaws. The first thing that leaps to the eye, it doesn't follow the AAA pattern. When the test fails, we don't know why and have to look in the code to figure out what went wrong. But even if only one aspect of the class would have been tested, there would still be essentially just a <code>[  FAILED  ] SingleDigitNumber_test.TestClass</code> output and we would need to look at the code to know what exactly is broken. This test case checks too many state transitions and doesn't have a sensible name.</p> <p>Furthermore, the default constructor is called in the test, but it is never checked to do the right thing. If there was a check, it would have revealed that <code>m_number</code> is not correctly initialized.</p> <p>Then, <code>EXPECT_TRUE</code> is used to compare the values. While this works, when the test fails we just get the information of the failure, but not which values were compared. To get this information <code>EXPECT_EQ</code> or <code>EXPECT_THAT</code> should be used. Furthermore, it's important to easily distinguish between the actual and the expected value, therefore the ordering of the values should be the same as if <code>EXPECT_THAT</code> would be used. The first value should be the actual value and the second one the expected.</p> <p>While the coverage might be 100%, there are no tests for:</p> <ul> <li>invalid parameters, e.g. passing <code>10</code> to the constructor</li> <li>overflow with <code>operator+</code>, e.g. adding <code>7</code> and <code>8</code></li> <li>underflow with <code>operator-</code>, e.g. subtracting <code>8</code> from <code>7</code></li> </ul> <p>Here, ZOMBIES comes into play and gives us some guide to identify this cases.</p> <p>Some of this test might made it necessary to define the behavior of the class in the first place, e.g. defining that an <code>operator+</code> will saturate to the max value instead of overflowing.</p>","title":"First Attempt"},{"location":"concepts/best-practice-for-testing/#how-to-do-it-better","text":"<p>At first, the test is split into multiple test cases according to the AAA pattern</p> <pre><code>TEST_F(SingleDigitNumber_test, DefaultConstructedObjectIsCorrectlyInitialized)\n{\n    constexpr uint64_t EXPECTED_VALUE{0U};\n\n    SingleDigitNumber sut;\n\n    EXPECT_EQ(static_cast&lt;uint64_t&gt;(sut), EXPECTED_VALUE);\n}\n</code></pre> <p>The test also has a meaningful name. If this fails in the CI, it is immediately clear what is broken. Additionally, the tested object is called <code>sut</code>. This makes it easy to identify the actual test object. Lastly, a <code>constexpr</code> is used for the expected value. This removes a magic value and also makes the output of a failed test more readable, since it is immediately clear what's the actual tested value and what's the expected value.</p> <p>Now let's continue with further tests, applying the ZOMBIES principle</p> <pre><code>TEST_F(SingleDigitNumber_test, ConstructionWithValidValueCreatesNumberWithSameValue)\n{\n    constexpr uint64_t NUMBER_VALUE{7U};\n    constexpr uint64_t EXPECTED_VALUE{NUMBER_VALUE};\n\n    SingleDigitNumber sut{NUMBER_VALUE};\n\n    EXPECT_EQ(static_cast&lt;uint64_t&gt;(sut), EXPECTED_VALUE);\n}\n\nTEST_F(SingleDigitNumber_test, ConstructionWithInvalidValueResultsInSaturation)\n{\n    constexpr uint64_t NUMBER_VALUE{42U};\n    constexpr uint64_t EXPECTED_VALUE{9U};\n\n    SingleDigitNumber sut{NUMBER_VALUE};\n\n    EXPECT_EQ(static_cast&lt;uint64_t&gt;(sut), EXPECTED_VALUE);\n}\n\nTEST_F(SingleDigitNumber_test, AddingZeroDoesNotChangeTheNumber)\n{\n    constexpr SingleDigitNumber NUMBER{3U};\n    constexpr SingleDigitNumber ZERO{0U};\n    constexpr uint64_t EXPECTED_VALUE{3U};\n\n    auto sut = NUMBER + ZERO;\n\n    EXPECT_EQ(static_cast&lt;uint64_t&gt;(sut), EXPECTED_VALUE);\n}\n\nTEST_F(SingleDigitNumber_test, AddingOneIncreasesTheNumberByOne)\n{\n    constexpr SingleDigitNumber NUMBER{3U};\n    constexpr SingleDigitNumber ONE{1U};\n    constexpr uint64_t EXPECTED_VALUE{4U};\n\n    auto sut = NUMBER + ONE;\n\n    EXPECT_EQ(static_cast&lt;uint64_t&gt;(sut), EXPECTED_VALUE);\n}\n\n// and so on\n</code></pre> <p>These are some examples showing how to apply the ZOMBIES principle to find good test cases. They also exert all the good practices mentioned previously, like clear and distinct names or avoiding magic numbers.</p>","title":"How To Do It Better"},{"location":"concepts/best-practice-for-testing/#slightly-more-advanced-topics","text":"","title":"Slightly More Advanced Topics"},{"location":"concepts/best-practice-for-testing/#typed-tests","text":"<p>There are situations when test cases only vary in the type applied to the <code>sut</code>. In this case typed tests can be used to reduce repetition. The there is a section for typed tests in the advanced gtest documentation.</p> <p>A more thorough example is in the gtest github repository.</p>","title":"Typed Tests"},{"location":"concepts/best-practice-for-testing/#parameterized-tests","text":"<p>Similar to typed tests, there are cases where the same test case should run with multiple parameters. One example is the conversion of <code>enum</code> values to strings. While this can be done in a loop, parameterized testing is a better approach.</p> <p>This is quite a good blog post to get into parameterized tests. Additionally, there is a section in the advanced documentation for gtest.</p> <p>The block post mentions tuples to pass multiple parameters at once. Since tuples can become cumbersome to use, especially if parameters are rearranged, it is recommended to create a <code>struct</code> to wrap the parameters instead.</p>","title":"Parameterized Tests"},{"location":"concepts/best-practice-for-testing/#mocks","text":"<p>Some classes are hard to test or to reach a full coverage. This might be due to external access or interaction with the operating system. Mocks can help to have full control over the <code>sut</code> and reliably cause error conditions to test the negative code path. There is an extensive gmock documentation in the gtest github repository.</p>","title":"Mocks"},{"location":"concepts/best-practice-for-testing/#pitfalls","text":"<p>Some tests require creating dummy classes and it might be that the same name is chosen multiple times, e.g. \u201cclass DummyData {...};\u201d. Usually, at some time the compiler would complain about double definitions. But since the definitions are not in header but source files and therefore confined in a translation unit, this is not the case and the test binary gets created. There might still be issues though, since the binary contains multiple symbols with the same name. One of these issues may arise with the usage of sanitizers, e.g. the address or leak sanitizer. If there are multiple \u201cDummyData\u201d classes with different sizes and they are created on the heap, which is totally fine for tests, the address sanitizer might detect an error since something with a different size than expected will be freed. To prevent such issues, the tests should be placed within an anonymous namespace which makes all the symbols unique.</p> <pre><code>namespace\n{\nstruct DummyData {\n    uint32_t foo{0};\n};\n\nclass MyTest : public Test\n{\n    //...\n};\n\nTEST_F(MyTest, TestName)\n{\n    EXPECT_EQ(ANSWER, 42)\n}\n\n} // namespace\n</code></pre>","title":"Pitfalls"},{"location":"concepts/best-practice-for-testing/#conclusion","text":"<ul> <li>apply the AAA pattern to structure the test and check only one state transition per test case (all side effects of that transition must be checked, though)</li> <li>don't test previously tested behavior</li> <li>use the ZOMBIES principle to find sensible test cases</li> <li>use meaningful names for the tests to indicate what the test is supposed to do and the expected outcome, like <code>...IsSuccessful</code>, <code>...Fails</code>, <code>...ResultsIn...</code>, <code>...LeadsTo...</code>, etc.</li> <li>name the test object <code>sut</code> to make clear which object is tested</li> <li>don't use magic numbers</li> <li>instantiate objects on the stack or use smart pointers for large objects and avoid manual memory management with new/delete</li> <li>use <code>ASSERT_*</code> before doing a potential dangerous action which might crash the test application, like accessing a <code>nullptr</code> or a <code>cxx::optional</code> with a <code>nullopt</code></li> <li>use mocks to reduce the complexity of the test arrangement</li> <li>apply the DRY principle by using typed and parameterized tests</li> <li>wrap the tests in an anonymous namespace</li> </ul>","title":"Conclusion"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/","text":"<p>Many parts of the iceoryx C++ API follow a functional programming approach and allow the user to specify functions which handle the possible cases, e.g. what should happen when data is received.</p> <p>This is very flexible but requires using the monadic types <code>iox::cxx::expected</code> and <code>iox::cxx::optional</code>, which we introduce in the following sections.</p>","title":"How optional and error values are returned in iceoryx"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/#optional","text":"<p>The type <code>iox::cxx::optional&lt;T&gt;</code> is used to indicate that there may or may not be a value of a specific type <code>T</code> available. This is essentially the 'maybe monad' in functional programming. Assuming we have some optional (usually the result of some computation)</p> <pre><code>optional&lt;int&gt; result = someComputation();\n</code></pre> <p>we can check for its value using</p> <pre><code>if(result.has_value())\n{\n    auto value = result.value();\n    // do something with the value\n}\nelse\n{\n    // handle the case that there is no value\n}\n</code></pre> <p>A shorthand to get the value is</p> <pre><code>auto value = *result;\n</code></pre>  <p>Attention</p> <p>Accessing the value if there is no value terminates the application, so it must be checked beforehand.</p>  <p>We can achieve the same with the functional approach by providing a function for both cases.</p> <pre><code>result.and_then([](int&amp; value) { /*do something with the value*/ })\n    .or_else([]() { /*handle the case that there is no value*/ });\n</code></pre> <p>Notice that we get the value by reference, so if a copy is desired it has to be created explicitly in the lambda expression or function we pass.</p> <p>The optional can be initialized from a value directly</p> <pre><code>optional&lt;int&gt; result = 73;\nresult = 37;\n</code></pre> <p>If the optional is default initialized, it is automatically set to its null value of type <code>iox::cxx::nullopt_t</code>. This can be also done directly by using the constant <code>iox::cxx::nullopt</code></p> <pre><code>result = iox::cxx::nullopt;\n</code></pre> <p>For a complete list of available functions see <code>optional.hpp</code>. The <code>iox::cxx::optional</code> behaves like the <code>std::optional</code> except that it does not throw exceptions and has no undefined behavior.</p>","title":"Optional"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/#expected","text":"<p><code>iox::cxx::expected&lt;T, E&gt;</code> generalizes <code>iox::cxx::optional</code> by admitting a value of another type <code>E</code> instead of no value at all, i.e. it contains either a value of type <code>T</code> or <code>E</code>. In this way, <code>expected</code> is a special case of the 'either monad'. It is usually used to pass a value of type <code>T</code> or an error that may have occurred, i.e. <code>E</code> is the error type.</p> <p>For more information on how it is used for error handling see error-handling.md.</p> <p>Assume we have <code>E</code> as an error type, then we can create a value</p> <pre><code>iox::cxx::expected&lt;int, E&gt; result(iox::cxx::success&lt;int&gt;(73));\n</code></pre> <p>and use the value or handle a potential error</p> <pre><code>if (!result.has_error())\n{\n    auto value = result.value();\n    // do something with the value\n}\nelse\n{\n    auto error = result.get_error();\n    // handle the error\n}\n</code></pre> <p>If we need an error value, we set</p> <pre><code>result = iox::cxx::error&lt;E&gt;(errorCode);\n</code></pre> <p>which assumes that <code>E</code> can be constructed from an <code>errorCode</code>.</p> <p>We again can employ a functional approach like this:</p> <pre><code>auto handleValue = [](int&amp; value) { /*do something with the value*/ };\nauto handleError = [](E&amp; value) { /*handle the error*/ };\nresult.and_then(handleValue).or_else(handleError);\n</code></pre> <p>There are more convenience functions such as <code>value_or</code> which provides the value or an alternative specified by the user. These can be found in <code>expected.hpp</code>.</p> <p>Note that when we move an <code>expected</code>, the origin contains a moved <code>T</code> or <code>E</code>, depending on the content before the move. This reflects the behavior of moving the content out of the <code>iox::cxx::expected</code> as in <code>auto foo = std::move(bar.value());</code> with <code>bar</code> being an <code>iox::cxx::expected</code>. Like all objects, <code>T</code> and <code>E</code> must therefore be in a well defined state after the move.</p>","title":"Expected"},{"location":"concepts/qos-policies/","text":"<p>Unlike other middlewares, e.g. DDS used in ROS 2, iceoryx keeps things simple and offers basic Quality of Service (QoS) settings. The QoS settings are called options and can be used to optimize and tailor the communication.</p>","title":"QoS policies"},{"location":"concepts/qos-policies/#serveroptions-and-clientoptions","text":"<p>The two most important settings are:</p>    Option Explanation     <code>ServerOptions::requestQueueCapacity</code> This enables servers to store n requests at the users side   <code>ClientOptions::responseQueueCapacity</code> This enables clients to store n responses at the users side","title":"<code>ServerOptions</code> and <code>ClientOptions</code>"},{"location":"concepts/qos-policies/#compatible-policies","text":"<p>The <code>ConsumerTooSlowPolicy</code> and <code>QueueFullPolicy</code> are used to control the behavior for full queues. Since some combinations would be contradicting, not all of them match to connect producer and consumer.</p>    <code>ConsumerTooSlowPolicy</code> <code>QueueFullPolicy</code> Behavior Connection     <code>WAIT_FOR_CONSUMER</code> <code>BLOCK_PRODUCER</code> Producer blocks and waits for consumers    <code>WAIT_FOR_CONSUMER</code> <code>DISCARD_OLDEST_DATA</code> Non-blocking producer    <code>DISCARD_OLDEST_DATA</code> <code>DISCARD_OLDEST_DATA</code> Non-blocking producer    <code>DISCARD_OLDEST_DATA</code> <code>BLOCK_PRODUCER</code> Not compatible, no connection established","title":"Compatible policies"},{"location":"concepts/qos-policies/#server-and-client-matching-criteria","text":"<p>Two criteria have to be fulfilled in order for a server and a client to be connected.</p> <ol> <li>Same <code>capro::ServiceDescription</code></li> <li>Matching <code>ConsumerTooSlowPolicy</code> and <code>QueueFullPolicy</code> in <code>ServerOptions</code>/<code>ClientOptions</code></li> </ol>","title":"Server and client matching criteria"},{"location":"concepts/qos-policies/#publisheroptions-and-subscriberoptions","text":"<p>The three most important settings are:</p>    Option Explanation     <code>PublisherOptions::historyCapacity</code> This enables late-joining subscribers to request the n last samples   <code>SubscriberOptions::queueCapacity</code> Size of the subscriber queue where samples are stored at the user side   <code>SubscriberOptions::historyRequest</code> The number of samples a late-joining subscriber will request from every offered publisher, should be equal or smaller than <code>historyCapacity</code> otherwise capped     <p>Warning</p> <p>In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time!</p> <p>The following two scenarios are examples of issues when using n:m together with the history feature:</p> <ol> <li> <p>Multiple publishers The last n samples of every publisher are received. This means for m publishers in the worst case m * n samples in random order, not in the order they were published on the topic.</p> </li> <li> <p>Multiple publishers after the publisher called <code>stopOffer()</code> or is removed The last n samples will never be received since they vanished. An arbitrary number of samples or nothing is received.</p> </li> </ol> <p>For more information about the options see the corresponding example <code>iceoptions</code>.</p>   <p>Info</p> <p>If the <code>PublisherOptions::historyCapacity</code> is larger than <code>SubscriberOptions::queueCapacity</code> and blocking behaviour is active, late-joining subscribers will not receive the latest and greatest sample, effectively loosing some.</p>","title":"<code>PublisherOptions</code> and <code>SubscriberOptions</code>"},{"location":"concepts/qos-policies/#publisher-and-subscriber-matching-criteria","text":"<p>If <code>requiresPublisherHistorySupport</code> is set, additionally to the matching criteria of server and client, there is a third one for publishers and subscribers:</p> <ol> <li>Same <code>capro::ServiceDescription</code></li> <li>Matching <code>ConsumerTooSlowPolicy</code> and <code>QueueFullPolicy</code> in <code>PublisherOptions</code>/<code>SubscriberOptions</code></li> <li><code>PublisherOptions::historyCapacity</code> &gt; 0</li> </ol>","title":"Publisher and subscriber matching criteria"},{"location":"design/design_article/","text":"","title":"Design article"},{"location":"examples/","text":"Example Description Level     icehello Sending data to another process    icedelivery Sending and receiving data using C++    icedelivery_in_c Sending and receiving data using C    icedocker Sending and receiving data across multiple docker instances    iceoptions Configuring pub/sub settings like history cache size or startup behaviour    complexdata Sending/receiving some of the iceoryx STL container surrogates    request_response Delivering data on demand (Client/Server) using C++    request_response_in_c Delivering data on demand (Client/Server) using C    callbacks Implementing event triggered callbacks using C++    callbacks_in_c Implementing event triggered callbacks using C    waitset Waiting for events like arrival of data using C++    waitset_in_c Waiting for events like arrival of data using C    iceensemble Using multiple publishers for one topic    singleprocess Communicating in a single process between threads    user_header Using a user-header for additional meta-information like timestamps    icediscovery Searching for currently available services    icediscovery_in_c Searching for currently available services using C    ice_access_control Configuring access rights for shared memory segments    iceperf Measuring the latency of different IPC mechanisms    icecrystal Using the introspection client for debugging","title":"List of examples"},{"location":"examples/callbacks/","text":"","title":"Listener (or how to use callbacks with iceoryx)"},{"location":"examples/callbacks/#thread-safety","text":"<p>The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a <code>std::mutex</code>.</p>","title":"Thread Safety"},{"location":"examples/callbacks/#introduction","text":"<p>For an introduction into the terminology please read the Glossary in the WaitSet C++ example.</p> <p>The Listener is a completely thread-safe construct that reacts to events by executing registered callbacks in a background thread. Events can be emitted by EventOrigins like a subscriber or a user trigger. Some of the EventOrigins like the subscriber can hereby emit more than one event type.</p> <p>The interface of a listener consists of two methods: <code>attachEvent</code> to attach a new event with a callback and <code>detachEvent</code>. These two methods can be called concurrently, even from inside a callback that was triggered by an event!</p>","title":"Introduction"},{"location":"examples/callbacks/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/callbacks/#code-walkthrough","text":"<p>Attention</p> <p>Please be aware of the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully.</p>  <p>Let's say we have an application that offers us two distinct services: <code>Radar.FrontLeft.Counter</code> and <code>Rader.FrontRight.Counter</code>. Every time we have received a sample from left and right we would like to calculate the sum with the newest values and print it out. If we have received only one of the samples, we store it until we received the other side.</p>","title":"Code Walkthrough"},{"location":"examples/callbacks/#ice_callbacks_publishercpp","text":"<p>The publisher of this example does not contain any new features but if you have some questions take a look at the icedelivery example.</p>","title":"ice_callbacks_publisher.cpp"},{"location":"examples/callbacks/#ice_callbacks_subscribercpp","text":"","title":"ice_callbacks_subscriber.cpp"},{"location":"examples/callbacks/#int-main","text":"<p>The subscriber main function starts as usual and after registering the runtime we create the listener that starts a background thread.</p>  <pre><code>iox::popo::Listener listener;\n</code></pre> <p>Because it is fun, we also create a heartbeat trigger that will be triggered every 4 seconds so that <code>heartbeat received</code> can be printed to the console. Furthermore, we have to create two subscribers to receive samples for the two services.</p>  <pre><code>iox::popo::UserTrigger heartbeat;\niox::popo::Subscriber&lt;CounterTopic&gt; subscriberLeft({\"Radar\", \"FrontLeft\", \"Counter\"});\niox::popo::Subscriber&lt;CounterTopic&gt; subscriberRight({\"Radar\", \"FrontRight\", \"Counter\"});\n</code></pre> <p>Next thing is a <code>heartbeatThread</code> which will trigger our heartbeat trigger every 4 seconds.</p>  <pre><code>std::thread heartbeatThread([&amp;] {\n    while (!iox::posix::hasTerminationRequested())\n    {\n        heartbeat.trigger();\n        std::this_thread::sleep_for(std::chrono::seconds(4));\n    }\n});\n</code></pre> <p>Now that everything is set up, we can attach the subscribers to the listener so that every time a new sample (<code>iox::popo::SubscriberEvent::DATA_RECEIVED</code>) is received our callback (<code>onSampleReceivedCallback</code>) will be called. We also attach our <code>heartbeat</code> user trigger to print the heartbeat message to the console via another callback (<code>heartbeatCallback</code>).</p>  <pre><code>listener.attachEvent(heartbeat, iox::popo::createNotificationCallback(heartbeatCallback)).or_else([](auto) {\n    std::cerr &lt;&lt; \"unable to attach heartbeat event\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n\n// It is possible to attach any c function here with a signature of void(iox::popo::Subscriber&lt;CounterTopic&gt; *).\n// But please be aware that the listener does not take ownership of the callback, therefore it has to exist as\n// long as the event is attached. Furthermore, it excludes lambdas which are capturing data since they are not\n// convertable to a c function pointer.\n// to simplify the example we attach the same callback onSampleReceivedCallback again\nlistener\n    .attachEvent(subscriberLeft,\n                 iox::popo::SubscriberEvent::DATA_RECEIVED,\n                 iox::popo::createNotificationCallback(onSampleReceivedCallback))\n    .or_else([](auto) {\n        std::cerr &lt;&lt; \"unable to attach subscriberLeft\" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    });\nlistener\n    .attachEvent(subscriberRight,\n                 iox::popo::SubscriberEvent::DATA_RECEIVED,\n                 iox::popo::createNotificationCallback(onSampleReceivedCallback))\n    .or_else([](auto) {\n        std::cerr &lt;&lt; \"unable to attach subscriberRight\" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    });\n</code></pre> <p>Since a user trigger has only one event, we do not have to specify an event when we attach it to the listener. <code>attachEvent</code> returns a <code>cxx::expected</code> to inform us if the attachment succeeded. When this is not the case the error handling is performed in the <code>.or_else([](auto){</code> part after each <code>attachEvent</code> call. In this example, we choose to attach the same callback twice to make things easier but you are free to attach any callback with the signature <code>void(iox::popo::Subscriber&lt;CounterTopic&gt; *)</code>.</p> <p>The setup is complete, but it would terminate right away since we have no blocker which waits until <code>SIGINT</code> or <code>SIGTERM</code> was send. In the other examples, we had not that problem since we pulled all the events in a while true loop but working only with callbacks requires something like our <code>SignalWatcher</code> which waits until <code>SIGINT</code> or <code>SIGTERM</code> was signaled.</p>  <pre><code>iox::posix::waitForTerminationRequest();\n</code></pre> <p>When <code>waitForTerminationRequest</code> unblocks we clean up all resources and terminate the process gracefully.</p>  <pre><code>listener.detachEvent(heartbeat);\nlistener.detachEvent(subscriberLeft, iox::popo::SubscriberEvent::DATA_RECEIVED);\nlistener.detachEvent(subscriberRight, iox::popo::SubscriberEvent::DATA_RECEIVED);\n\nheartbeatThread.join();\n</code></pre> <p>Hint: You do not have to detach an EventOrigin like a subscriber or user trigger before it goes out of scope. This also goes for the Listener, the implemented RAII-based design takes care of the resource cleanup.</p>","title":"int main()"},{"location":"examples/callbacks/#the-callbacks","text":"<p>The callbacks must have a signature like <code>void(PointerToEventOrigin*)</code>. Our <code>heartbeatCallback</code> for instance, just prints the message <code>heartbeat received</code>.</p>  <pre><code>void heartbeatCallback(iox::popo::UserTrigger*)\n{\n    std::cout &lt;&lt; \"heartbeat received \" &lt;&lt; std::endl;\n}\n</code></pre> <p>The <code>onSampleReceivedCallback</code> is more complex. We first acquire the received sample and check which subscriber signaled the event by acquiring the subscriber's service description. If the instance is equal to <code>FrontLeft</code> we store the sample in the <code>leftCache</code> otherwise in the <code>rightCache</code>.</p>  <pre><code>void onSampleReceivedCallback(iox::popo::Subscriber&lt;CounterTopic&gt;* subscriber)\n{\n    subscriber-&gt;take().and_then([subscriber](auto&amp; sample) {\n        auto instanceString = subscriber-&gt;getServiceDescription().getInstanceIDString();\n\n        // store the sample in the corresponding cache\n        if (instanceString == iox::capro::IdString_t(\"FrontLeft\"))\n        {\n            leftCache.emplace(*sample);\n        }\n        else if (instanceString == iox::capro::IdString_t(\"FrontRight\"))\n        {\n            rightCache.emplace(*sample);\n        }\n\n        std::cout &lt;&lt; \"received: \" &lt;&lt; sample-&gt;counter &lt;&lt; std::endl;\n    });\n    // ...\n}\n</code></pre> <p>In the next step, we check if both caches are filled. If this is the case, we print an extra message which states the result of the sum of both received values. Afterward, we reset both caches to start fresh again.</p>  <pre><code>void onSampleReceivedCallback(iox::popo::Subscriber&lt;CounterTopic&gt;* subscriber)\n{\n    // ...\n    // if both caches are filled we can process them\n    if (leftCache &amp;&amp; rightCache)\n    {\n        std::cout &lt;&lt; \"Received samples from FrontLeft and FrontRight. Sum of \" &lt;&lt; leftCache-&gt;counter &lt;&lt; \" + \"\n                  &lt;&lt; rightCache-&gt;counter &lt;&lt; \" = \" &lt;&lt; leftCache-&gt;counter + rightCache-&gt;counter &lt;&lt; std::endl;\n        leftCache.reset();\n        rightCache.reset();\n    }\n}\n</code></pre>","title":"The Callbacks"},{"location":"examples/callbacks/#additional-context-data-for-callbacks-ice_callbacks_listener_as_class_membercpp","text":"<p>Here we demonstrate how you can provide virtually everything as an additional argument to the callbacks. You just have to provide a reference to a value as additional argument in the <code>attachEvent</code> method which is then provided as argument in your callback. One of the use cases is to get access to members and methods of an object inside a static method which we demonstrate here.</p> <p>This example is identical to the ice_callbacks_subscriber.cpp one, except that we left out the cyclic heartbeat trigger. The key difference is that the listener is now a class member and in every callback we would like to change some member variables. For this we require an additional pointer to the object since the listener requires c function references which do not allow the usage of lambda expressions with capturing. Here we can use the userType feature which allows us to provide the this pointer as additional argument to the callback.</p> <p>The main function is now pretty short, we instantiate our object of type <code>CounterService</code> and call <code>waitForTerminationRequest</code> like in the previous example to wait for the control c event from the user.</p>  <pre><code>iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n\nCounterService counterService;\n\niox::posix::waitForTerminationRequest();\n</code></pre> <p>Our <code>CounterService</code> has the following members:</p>  <pre><code>iox::popo::Subscriber&lt;CounterTopic&gt; m_subscriberLeft;\niox::popo::Subscriber&lt;CounterTopic&gt; m_subscriberRight;\niox::cxx::optional&lt;CounterTopic&gt; m_leftCache;\niox::cxx::optional&lt;CounterTopic&gt; m_rightCache;\niox::popo::Listener m_listener;\n</code></pre> <p>And their purposes are the same as in the previous example. In the constructor we initialize the two subscribers and attach them to our listener. But now we add an additional parameter in the <code>iox::popo::createNotificationCallback</code>, the dereferenced <code>this</code> pointer. It has to be dereferenced since we require a reference as argument.</p>  <p>Attention</p> <p>The user has to ensure that the contextData (<code>*this</code>) in <code>attachEvent</code> lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling.</p>   <pre><code>CounterService()\n    : m_subscriberLeft({\"Radar\", \"FrontLeft\", \"Counter\"})\n    , m_subscriberRight({\"Radar\", \"FrontRight\", \"Counter\"})\n{\n    /// Attach the static method onSampleReceivedCallback and provide this as additional argument\n    /// to the callback to gain access to the object whenever the callback is called.\n    /// It is not possible to use a lambda with capturing here since they are not convertable to\n    /// a C function pointer.\n    /// important: the user has to ensure that the contextData (*this) lives as long as\n    ///            the subscriber with its callback is attached to the listener\n    m_listener\n        .attachEvent(m_subscriberLeft,\n                     iox::popo::SubscriberEvent::DATA_RECEIVED,\n                     iox::popo::createNotificationCallback(onSampleReceivedCallback, *this))\n        .or_else([](auto) {\n            std::cerr &lt;&lt; \"unable to attach subscriberLeft\" &lt;&lt; std::endl;\n            std::exit(EXIT_FAILURE);\n        });\n    m_listener\n        .attachEvent(m_subscriberRight,\n                     iox::popo::SubscriberEvent::DATA_RECEIVED,\n                     iox::popo::createNotificationCallback(onSampleReceivedCallback, *this))\n        .or_else([](auto) {\n            std::cerr &lt;&lt; \"unable to attach subscriberRight\" &lt;&lt; std::endl;\n            std::exit(EXIT_FAILURE);\n        });\n}\n</code></pre> <p>The <code>onSampleReceivedCallback</code> is now a static method instead of a free function. It has to be static since we require a C function reference as callback argument and a static method can be converted into such a type. But in a static method we do not have access to the members of an object, therefore we have to add an additional argument, the pointer to the object itself, called <code>self</code>.</p>  <pre><code>static void onSampleReceivedCallback(iox::popo::Subscriber&lt;CounterTopic&gt;* subscriber, CounterService* self)\n{\n    subscriber-&gt;take().and_then([subscriber, self](auto&amp; sample) {\n        auto instanceString = subscriber-&gt;getServiceDescription().getInstanceIDString();\n\n        // store the sample in the corresponding cache\n        if (instanceString == iox::capro::IdString_t(\"FrontLeft\"))\n        {\n            self-&gt;m_leftCache.emplace(*sample);\n        }\n        else if (instanceString == iox::capro::IdString_t(\"FrontRight\"))\n        {\n            self-&gt;m_rightCache.emplace(*sample);\n        }\n\n        std::cout &lt;&lt; \"received: \" &lt;&lt; sample-&gt;counter &lt;&lt; std::endl;\n    });\n\n    // if both caches are filled we can process them\n    if (self-&gt;m_leftCache &amp;&amp; self-&gt;m_rightCache)\n    {\n        std::cout &lt;&lt; \"Received samples from FrontLeft and FrontRight. Sum of \" &lt;&lt; self-&gt;m_leftCache-&gt;counter\n                  &lt;&lt; \" + \" &lt;&lt; self-&gt;m_rightCache-&gt;counter &lt;&lt; \" = \"\n                  &lt;&lt; self-&gt;m_leftCache-&gt;counter + self-&gt;m_rightCache-&gt;counter &lt;&lt; std::endl;\n        self-&gt;m_leftCache.reset();\n        self-&gt;m_rightCache.reset();\n    }\n}\n</code></pre> <p> Check out callbacks on GitHub  </p>","title":"Additional context data for callbacks (ice_callbacks_listener_as_class_member.cpp)"},{"location":"examples/callbacks_in_c/","text":"","title":"Listener in C (or how to use callbacks with iceoryx)"},{"location":"examples/callbacks_in_c/#thread-safety","text":"<p>The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a <code>mutex</code>.</p>","title":"Thread Safety"},{"location":"examples/callbacks_in_c/#introduction","text":"<p>For a general introduction into the Listener concept please take a look at the first part of the Listener C++ example and at the Glossary of the WaitSet C++ example.</p>","title":"Introduction"},{"location":"examples/callbacks_in_c/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/callbacks_in_c/#code-walkthrough","text":"<p>Attention</p> <p>Please be aware about the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully.</p>  <p>The C version of the callbacks example performs the identical tasks as the C++ version. We have again an application which offers two services called <code>Radar.FrontLeft.Counter</code> and <code>Radar.FrontRight.Counter</code>. Every time we have received a sample from each service we calculate the sum of it.</p>","title":"Code Walkthrough"},{"location":"examples/callbacks_in_c/#ice_c_callbacks_publisherc","text":"<p>The publisher contains only already known iceoryx features. If some of them are not known to you please take a look at the icedelivery in C example.</p>","title":"ice_c_callbacks_publisher.c"},{"location":"examples/callbacks_in_c/#ice_c_callbacks_subscriberc","text":"","title":"ice_c_callbacks_subscriber.c"},{"location":"examples/callbacks_in_c/#int-main","text":"<p>The subscriber starts as usual by registering the process at the runtime. In the next step, we set up some <code>listenerStorage</code> and initialize the listener which will start a background thread for the upcoming event-triggered callbacks.</p>  <pre><code>iox_listener_storage_t listenerStorage;\niox_listener_t listener = iox_listener_init(&amp;listenerStorage);\n</code></pre> <p>Besides the subscribers we also would like to have an event that will be triggered by our self - the <code>heartbeat</code>.</p>  <pre><code>iox_user_trigger_storage_t heartbeatStorage;\nheartbeat = iox_user_trigger_init(&amp;heartbeatStorage);\n</code></pre> <p>Both subscribers use the same options which we set up with:</p>  <pre><code>iox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.historyRequest = 10U;\noptions.queueCapacity = 50U;\noptions.nodeName = \"iox-c-callback-subscriber-node\";\n</code></pre> <p>and then we can construct the two subscribers <code>subscriberLeft</code> and <code>subscriberRight</code>.</p>  <pre><code>iox_sub_t subscriberLeft = iox_sub_init(&amp;subscriberLeftStorage, \"Radar\", \"FrontLeft\", \"Counter\", &amp;options);\niox_sub_t subscriberRight = iox_sub_init(&amp;subscriberRightStorage, \"Radar\", \"FrontRight\", \"Counter\", &amp;options);\n</code></pre> <p>Now that everything is initialized, we start our <code>heartbeatTriggerThread</code> which triggers our <code>heartbeat</code> every 4 seconds.</p>  <pre><code>pthread_t heartbeatTriggerThread;\nif (pthread_create(&amp;heartbeatTriggerThread, NULL, cyclicHeartbeatTrigger, NULL))\n{\n    printf(\"failed to create thread\\n\");\n    return -1;\n}\n</code></pre> <p>Attaching the subscribers and the heartbeat allows the Listener to call the callbacks whenever the event is signaled by the EventOrigin.</p>  <pre><code>// from here on the callbacks are called when an event occurs\niox_listener_attach_user_trigger_event(listener, heartbeat, &amp;heartbeatCallback);\niox_listener_attach_subscriber_event(\n    listener, subscriberLeft, SubscriberEvent_DATA_RECEIVED, &amp;onSampleReceivedCallback);\niox_listener_attach_subscriber_event(\n    listener, subscriberRight, SubscriberEvent_DATA_RECEIVED, &amp;onSampleReceivedCallback);\n</code></pre> <p>A user trigger can emit only one event therefore we do not provide the event type as an argument in the user trigger attach call.</p> <p>Since we are following a push-based approach, i.e. without an event loop that is pulling the events and processing them, we require a blocking call that waits until the process is signaled to terminate.</p>  <pre><code>while (keepRunning)\n{\n    sleep_for(100);\n}\n</code></pre> <p>When <code>keepRunning</code> is set to false, we clean up all the resources. First, we detach the events from the Listener. This is an optional step since the Listener detaches all events by itself when it is deinitialized. This applies also for all the EventOrigins, if you for instance deinitialize an attached subscriber it will automatically detach itself from the Listener.</p>  <pre><code>iox_listener_detach_user_trigger_event(listener, heartbeat);\niox_listener_detach_subscriber_event(listener, subscriberLeft, SubscriberEvent_DATA_RECEIVED);\niox_listener_detach_subscriber_event(listener, subscriberRight, SubscriberEvent_DATA_RECEIVED);\n</code></pre> <p>In a last step we have to release all acquired resources</p>  <pre><code>iox_user_trigger_deinit(heartbeat);\niox_sub_deinit(subscriberLeft);\niox_sub_deinit(subscriberRight);\niox_listener_deinit(listener);\n</code></pre>","title":"int main()"},{"location":"examples/callbacks_in_c/#the-callbacks","text":"<p>Every callback must have a signature like <code>void (iox_event_origin_t)</code>. Our <code>heartbeatCallback</code> just prints the message <code>heartbeat received</code> onto the console.</p>  <pre><code>void heartbeatCallback(iox_user_trigger_t userTrigger)\n{\n    (void)userTrigger;\n    printf(\"heartbeat received\\n\");\n    fflush(stdout);\n}\n</code></pre> <p>The <code>onSampleReceivedCallback</code> is a little bit more complex. First we acquire the chunk and then we have to find out which subscriber received the chunk. For that we acquire the service description of the subscriber and if its instance equals <code>FrontLeft</code> we store the chunk value in the <code>leftCache</code> otherwise in the <code>rightCache</code>.</p>  <pre><code>void onSampleReceivedCallback(iox_sub_t subscriber)\n{\n    const struct CounterTopic* userPayload;\n    if (iox_sub_take_chunk(subscriber, (const void**)&amp;userPayload) == ChunkReceiveResult_SUCCESS)\n    {\n        iox_service_description_t serviceDescription = iox_sub_get_service_description(subscriber);\n        if (strcmp(serviceDescription.instanceString, \"FrontLeft\") == 0)\n        {\n            leftCache.value = *userPayload;\n            leftCache.isSet = true;\n        }\n        else if (strcmp(serviceDescription.instanceString, \"FrontRight\") == 0)\n        {\n            rightCache.value = *userPayload;\n            rightCache.isSet = true;\n        }\n        printf(\"received: %d\\n\", userPayload-&gt;counter);\n        fflush(stdout);\n    }\n    // ...\n}\n</code></pre> <p>If both caches are set, we can calculate the sum of both chunks and print them to the console. To start fresh in the next cycle, we reset the <code>leftCache</code> and the <code>rightCache</code> afterward.</p>  <pre><code>void onSampleReceivedCallback(iox_sub_t subscriber)\n{\n    // ...\n    if (leftCache.isSet &amp;&amp; rightCache.isSet)\n    {\n        printf(\"Received samples from FrontLeft and FrontRight. Sum of %d + %d = %d\\n\",\n               leftCache.value.counter,\n               rightCache.value.counter,\n               leftCache.value.counter + rightCache.value.counter);\n        fflush(stdout);\n        leftCache.isSet = false;\n        rightCache.isSet = false;\n    }\n}\n</code></pre>","title":"The callbacks"},{"location":"examples/callbacks_in_c/#additional-context-data-for-callbacks-ice_c_callbacks_with_context_datac","text":"<p>Sometimes we would like to modify data structures which are not globally available within the callback. To facilitate this we provide the functions called <code>iox_listener_attach_***_event_with_context_data</code> which allow to provide an additional void pointer for the callback as second argument.</p> <p>The following example is a simplified version of the ice_c_callbacks_subscriber.c example where we removed the cyclic heartbeat trigger. The key difference is that we have a local variable called <code>counterService</code> in which we store the <code>leftCache</code> and <code>rightCache</code> and we let the callback update that variable directly.</p>  <pre><code>CounterService counterService;\ncounterService.leftCache.isSet = false;\ncounterService.rightCache.isSet = false;\n</code></pre> <p>The callback takes an additional void pointer argument which we cast then to our CounterService to perform the same tasks as in the previous example but now on <code>CounterService * self</code>.</p>  <pre><code>void onSampleReceivedCallback(iox_sub_t subscriber, void* contextData)\n{\n    if (contextData == NULL)\n    {\n        fprintf(stderr, \"aborting onSampleReceivedCallback since contextData is a null pointer\\n\");\n        return;\n    }\n\n    CounterService* self = (CounterService*)contextData;\n    // ...\n}\n</code></pre> <p>Finally, we have to attach both subscribers and provide the pointer to <code>counterService</code> as additional argument so that we can access it in the callback.</p>  <p>Attention</p> <p>The user has to ensure that the contextData (<code>&amp;counterService</code>) in <code>iox_listener_attach_subscriber_event_with_context_data</code> lives as long as the attachment with its callback is attached, otherwise the callback context data pointer is dangling.</p>   <pre><code>iox_listener_attach_subscriber_event_with_context_data(\n    listener, subscriberLeft, SubscriberEvent_DATA_RECEIVED, &amp;onSampleReceivedCallback, &amp;counterService);\niox_listener_attach_subscriber_event_with_context_data(\n    listener, subscriberRight, SubscriberEvent_DATA_RECEIVED, &amp;onSampleReceivedCallback, &amp;counterService);\n</code></pre> <p> Check out callbacks_in_c on GitHub  </p>","title":"Additional context data for callbacks (ice_c_callbacks_with_context_data.c)"},{"location":"examples/complexdata/","text":"","title":"complexdata"},{"location":"examples/complexdata/#introduction","text":"<p>To implement zero-copy data transfer we use a shared memory approach. This requires that every data structure needs to be entirely contained in the shared memory and must not internally use pointers or references. The complete list of restrictions can be found here. Therefore, most of the STL types cannot be used, but we reimplemented some constructs. This example shows how to send/receive a iox::cxx::vector and how to send/receive a complex data structure containing some of our STL container surrogates.</p>","title":"Introduction"},{"location":"examples/complexdata/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/complexdata/#code-walkthrough","text":"<p>The following examples demonstrate how to send/receive the STL containers that were reimplemented in iceoryx so that they meet our requirements.</p>","title":"Code Walkthrough"},{"location":"examples/complexdata/#publisher-application-sending-a-ioxcxxvector","text":"<p>In this example we want our publisher to send a vector containing double. Since we cannot use dynamic memory, we use the <code>iox::cxx::vector</code> with a capacity of 5.</p>  <pre><code>iox::popo::Publisher&lt;iox::cxx::vector&lt;double, 5&gt;&gt; publisher({\"Radar\", \"FrontRight\", \"VectorData\"});\n</code></pre> <p>We use a while-loop similar to the one described in the icedelivery example to send the vector to the subscriber. After successfully loaning memory we append elements to the vector until it's full.</p>  <pre><code>for (uint64_t i = 0U; i &lt; sample-&gt;capacity(); ++i)\n{\n    // we can omit the check of the return value since the loop doesn't exceed the capacity of the\n    // vector\n    sample-&gt;emplace_back(static_cast&lt;double&gt;(ct + i));\n}\n</code></pre> <p>The only difference here to the <code>std::vector</code> is that <code>emplace_back</code> returns a bool - true if the appending was successful, false otherwise. <code>emplace_back</code> fails when the vector is already full. In our case, we can omit the check of the return value since the for-loop doesn't exceed the capacity of the vector.</p>","title":"Publisher application sending a <code>iox::cxx::vector</code>"},{"location":"examples/complexdata/#subscriber-application-receiving-a-ioxcxxvector","text":"<p>Our subscriber application iterates over the received vector to print its entries to the console. Note that the <code>separator</code> is only used for a easy to read output.</p>  <pre><code>for (const auto&amp; entry : *sample)\n{\n    s &lt;&lt; separator &lt;&lt; entry;\n    separator = \", \";\n}\n</code></pre>","title":"Subscriber application receiving a <code>iox::cxx::vector</code>"},{"location":"examples/complexdata/#publisher-application-sending-a-complex-data-structure","text":"<p>In this example our publisher will send a more complex data structure. It contains some of the STL containers that are reimplemented in iceoryx. A list of all reimplemented containers can be found here.</p>  <pre><code>struct ComplexDataType\n{\n    forward_list&lt;string&lt;10&gt;, 5&gt; stringForwardList;\n    list&lt;uint64_t, 10&gt; integerList;\n    list&lt;optional&lt;int32_t&gt;, 15&gt; optionalList;\n    stack&lt;float, 5&gt; floatStack;\n    string&lt;20&gt; someString;\n    vector&lt;double, 5&gt; doubleVector;\n    vector&lt;variant&lt;string&lt;10&gt;, double&gt;, 10&gt; variantVector;\n};\n</code></pre> <p>Contrary to the STL containers, the iceoryx containers have a static size, i.e. you have to provide the capacity (= max. size).</p> <p>We use again a while-loop to loan memory, add data to our containers and send it to the subscriber. Since we must not throw exceptions all used insertion methods return a bool that indicates whether the insertion was successful. It will fail when a container is already full. To handle the return value we introduce a helper function.</p>  <pre><code>void handleInsertionReturnVal(const bool success)\n{\n    if (!success)\n    {\n        std::cerr &lt;&lt; \"Failed to insert element.\" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n}\n</code></pre> <p>Now let's add some data to our containers. For the lists we use the <code>push_front</code> methods which can be used similar to the corresponding STL methods.</p>  <pre><code>// forward_list&lt;string&lt;10&gt;, 5&gt;\nhandleInsertionReturnVal(sample-&gt;stringForwardList.push_front(\"world\"));\nhandleInsertionReturnVal(sample-&gt;stringForwardList.push_front(\"hello\"));\n// list&lt;uint64_t, 10&gt;;\nhandleInsertionReturnVal(sample-&gt;integerList.push_front(ct));\nhandleInsertionReturnVal(sample-&gt;integerList.push_front(ct * 2));\nhandleInsertionReturnVal(sample-&gt;integerList.push_front(ct + 4));\n// list&lt;optional&lt;int32_t&gt;, 15&gt;\nhandleInsertionReturnVal(sample-&gt;optionalList.push_front(42));\nhandleInsertionReturnVal(sample-&gt;optionalList.push_front(nullopt));\n</code></pre>  <p>Note</p> <p>If you're not familiar with <code>optional</code>, please have a look at How optional and error values are returned in iceoryx.</p>  <p>Now we fill the stack</p>  <pre><code>for (uint64_t i = 0U; i &lt; sample-&gt;floatStack.capacity(); ++i)\n{\n    handleInsertionReturnVal(sample-&gt;floatStack.push(static_cast&lt;float&gt;(ct * i)));\n}\n</code></pre> <p>and assign a greeting to the string.</p>  <pre><code>sample-&gt;someString = \"hello iceoryx\";\n</code></pre> <p>For the vectors we use the <code>emplace_back</code> method, which can be used similar to the corresponding <code>std::vector</code> method.</p>  <pre><code>for (uint64_t i = 0U; i &lt; sample-&gt;doubleVector.capacity(); ++i)\n{\n    handleInsertionReturnVal(sample-&gt;doubleVector.emplace_back(static_cast&lt;double&gt;(ct + i)));\n}\n// vector&lt;variant&lt;string&lt;10&gt;, double&gt;, 10&gt;;\nhandleInsertionReturnVal(sample-&gt;variantVector.emplace_back(in_place_index&lt;0&gt;(), \"seven\"));\nhandleInsertionReturnVal(sample-&gt;variantVector.emplace_back(in_place_index&lt;1&gt;(), 8.0));\nhandleInsertionReturnVal(sample-&gt;variantVector.emplace_back(in_place_index&lt;0&gt;(), \"nine\"));\n</code></pre> <p>With <code>in_place_index</code> the passed object is constructed in-place at the given index.</p>","title":"Publisher application sending a complex data structure"},{"location":"examples/complexdata/#subscriber-application-receiving-a-complex-data-structure","text":"<p>The subscriber application just prints the received data to the console. For the <code>optionalList</code> we have to check whether the <code>optional</code> contains a value. As in the first example, the <code>separator</code> is used for a clear output.</p>  <pre><code>for (const auto&amp; entry : sample-&gt;optionalList)\n{\n    (entry.has_value()) ? s &lt;&lt; separator &lt;&lt; entry.value() : s &lt;&lt; separator &lt;&lt; \"optional is empty\";\n    separator = \", \";\n}\n</code></pre> <p>To print the elements of the <code>floatStack</code>, we pop elements until the stack is empty.</p>  <pre><code>auto stackCopy = sample-&gt;floatStack;\nwhile (stackCopy.size() &gt; 0U)\n{\n    auto result = stackCopy.pop();\n    s &lt;&lt; separator &lt;&lt; result.value();\n    separator = \", \";\n}\n</code></pre> <p>Please note that <code>pop</code> returns a <code>iox::cxx::optional</code> which contains the last pushed element or a <code>nullopt</code> if the stack is empty. Here, we don't have to check whether the <code>optional</code> contains a value since the loop ensures that we only pop elements when the stack contains some.</p> <p>To print the elements of the <code>variantVector</code> we iterate over the vector entries and access the alternative that is held by the variant via its index. We use the not STL compliant <code>get_at_index</code> method which returns a pointer to the type stored at the index. If the variant does not contain any type, <code>index()</code> will return an <code>INVALID_VARIANT_INDEX</code>.</p>  <pre><code>for (const auto&amp; i : sample-&gt;variantVector)\n{\n    switch (i.index())\n    {\n    case 0:\n        s &lt;&lt; separator &lt;&lt; *i.template get_at_index&lt;0&gt;();\n        break;\n    case 1:\n        s &lt;&lt; separator &lt;&lt; *i.template get_at_index&lt;1&gt;();\n        break;\n    case INVALID_VARIANT_INDEX:\n        s &lt;&lt; separator &lt;&lt; \"variant does not contain a type\";\n        break;\n    default:\n        s &lt;&lt; separator &lt;&lt; \"this is a new type\";\n    }\n    separator = \", \";\n}\n</code></pre> <p> Check out complexdata on GitHub  </p>","title":"Subscriber application receiving a complex data structure"},{"location":"examples/ice_access_control/","text":"","title":"ice_access_control"},{"location":"examples/ice_access_control/#introduction","text":"<p>This example demonstrates how access rights can be applied to shared memory segments on Linux-based operating systems. It provides a custom RouDi, a radar and a display application.</p>  <p>Hint</p> <p>The access right feature is only supported on Linux and QNX</p>","title":"Introduction"},{"location":"examples/ice_access_control/#expected-output","text":"<p></p>","title":"Expected output"},{"location":"examples/ice_access_control/#code-walkthrough","text":"<p>RouDi needs to be able to send a SIGKILL signal to the apps in case RouDi shuts down. Hence, RouDi needs CAP_KILL capability or similar rights on other POSIX operating systems. However, the user roudi does not need root access rights.</p> <p>The system user can be member of multiple system groups. This examples uses the following users and groups:</p>    Users privileged group unprivileged group infotainment group iceoryx group     perception X   X   infotainment  X X X   roudi    X   notallowed    X     <p>Hint</p> <p>In order to be able to use iceoryx communication, all apps have to be in the group iceoryx.</p>","title":"Code walkthrough"},{"location":"examples/ice_access_control/#overview-over-the-apps-and-shared-memory-segments","text":"<p>RouDi is built with two shared memory segments infotainment and privileged. On startup, it creates these two shared memory segments in the operating system. The privileged segment requires the app to be started with the group privileged if it publishes data or with the unprivileged group when data should only be received. The infotainment segment on the other hand requires only one group for reading and writing called infotainment. See the next chapter for a detailed description on how to configure the shared memory segments.</p> <pre><code>                                 +-----------------------+\n+--------------------+           |                       |           +---------------------+\n|  Radar App         |           | Privileged Shared     |           |  Cheeky App         |\n|  user: perception  |           | Memory Segment        |           |  user: notallowed   |\n|                    |  publish  |                       |           |      #     #        |\n|            #       |  -------&gt; | r group: unprivileged |           |       #   #         |\n|           #        |           | w group: privileged   |           |        # #          |\n|          #         |           |                       |           |        # #          |\n|     #   #          |           |                       |           |       #   #         |\n|      # #           |           |                       |           |      #     #        |\n+--------------------+           |                       |           +---------------------+\n                                 +-----------------------+\n                                                 |\n                                                 |          subscribe\n                                                 +---------------------------+\n                                                                             |\n                                                                             |\n                                                                             |\n                                                                            \\ /\n                                 +-----------------------+\n                                 |                       |           +---------------------+\n                                 | Infotainment Shared   |           |  Display App        |\n                                 | Memory Segment        |  publish  |  user: infotainment |\n                                 |                       |  &lt;------  |                     |\n                                 | r group: infotainment |           |            #        |\n                                 | w group: infotainment |           |           #         |\n                                 |                       |           |          #          |\n                                 |                       |           |     #   #           |\n                                 |                       |           |      # #            |\n                                 |                       |           +---------------------+\n                                 +-----------------------+\n</code></pre>","title":"Overview over the Apps and Shared Memory Segments"},{"location":"examples/ice_access_control/#roudi-and-apps","text":"","title":"RouDi and Apps"},{"location":"examples/ice_access_control/#working-setup","text":"<p>Do the following to configure shared memory segments when building a custom RouDi:</p>  <pre><code>iox::RouDiConfig_t roudiConfig;\n\n// Create Mempool Config\niox::mepoo::MePooConfig mepooConfig;\n\n// We only send very small data, just one mempool per segment\nmepooConfig.addMemPool({128, 1000});\n\n// Create an entry for a new shared memory segment from the mempooConfig and add it to the roudiConfig\n// Parameters are {\"ReaderGroup\", \"WriterGroup\", MemoryPoolConfig}\nroudiConfig.m_sharedMemorySegments.push_back({\"unprivileged\", \"privileged\", mepooConfig});\nroudiConfig.m_sharedMemorySegments.push_back({\"infotainment\", \"infotainment\", mepooConfig});\n</code></pre> <p>The <code>roudiConfig</code> is composed of a memory pool config called <code>mepooConfig</code>. When the segment is created, one needs to specify the reader group (first string), writer group (second string) as well as the <code>mepooConfig</code> (last parameter). The access rights are solely based on user groups and not on users itself. All users in the reader group are allowed to read, but don't have write access. Users in the writer group have both read and write access.</p>  <p>Tip</p> <p>Shared memory segment can also be configured via a TOML config file.</p>  <p>The radar app is started with the user perception, which is in the group privileged. Therefore it has write access to the privileged segment and is sending data into the privileged shared memory segment.</p> <p>The display app is started with the user infotainment, which is in the group infotainment and unprivileged. Therefore it has read access to the privileged segment. It reads the topic <code>{\"Radar\", \"FrontLeft\", \"Object\"}</code> from the privileged segment and forwards it as a slighty modified topic <code>{\"Radar\", \"HMI-Display\", \"Object\"}</code>. Because the user infotainment is only in the infotainment and unprivileged group, it only has write access to the infotainment segment. Hence, the data is written to this segment.</p>  <p>Hint</p> <p>It's advised to create only one shared memory segment per writer group (e.g. not two segments with <code>w: infotainment</code>). In this case it wouldn't be possible to control which segment will be used.</p>  <p>The shared memory segments can be found under <code>/dev/shm</code></p> <pre><code>moss@reynholm:$ getfacl /dev/shm/*\n# file: dev/shm/iceoryx_mgmt\n# owner: roudi\n# group: iceoryx\nuser::rw-\ngroup::rw-\nother::---\n\n# file: dev/shm/infotainment\n# owner: roudi\n# group: iceoryx\nuser::rw-\ngroup::rw-\ngroup:infotainment:rw-\nmask::rw-\nother::---\n\n# file: dev/shm/privileged\n# owner: roudi\n# group: iceoryx\nuser::rw-\ngroup::rw-\ngroup:privileged:rw-\ngroup:unprivileged:r--\nmask::rw-\nother::--\n</code></pre>  <p>Note</p> <p>Note the shared memory managment segment (<code>iceoryx_mgmt</code>) is always available for everyone in the group <code>iceoryx</code> to read and write.</p>","title":"Working setup"},{"location":"examples/ice_access_control/#not-working-setup","text":"<p>The cheeky app is started with the user notallowed. This user is not in any group that allow either read or write access to any of the shared memory segments. Hence, RouDi will print a warning in this case.</p> <p>Despite having no read access, subscribers can still be created. </p>  <pre><code>iox::popo::Subscriber&lt;RadarObject&gt; subscriber({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>When creating and requesting a publisher, RouDi will answer with an error, as there is no write access. Hence, an error will be printed and the cheeky app will stop.</p>  <pre><code>iox::popo::Publisher&lt;RadarObject&gt; publisher({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p> Check out ice_access_control on GitHub  </p>","title":"Not-working setup"},{"location":"examples/icecrystal/","text":"","title":"icecrystal"},{"location":"examples/icecrystal/#introduction","text":"<p>This example shows you how to use the introspection for debugging purposes. With the introspection you can look into the machine room of RouDi. It shows live information about the memory usage and all registered processes. Additionally, it shows the publisher and subscriber ports that are created inside the shared memory.</p>","title":"Introduction"},{"location":"examples/icecrystal/#expected-output","text":"<p>We re-use the binaries from icedelivery.</p> <p></p>","title":"Expected Output"},{"location":"examples/icecrystal/#feature-walkthrough","text":"<p>This example does not contain any additional code. The code of the <code>iceoryx_introspection_client</code> can be found under tools/introspection/.</p> <p>The introspection can be started with several command line arguments.</p> <pre><code>--mempool         Subscribe to mempool introspection data.\n</code></pre> <p>The memory pool view will show all available shared memory segments and their respective owner. Additionally, the maximum number of available chunks, the number of currently used chunks as well as the minimal value of free chunks are visible. This can be handy for stress tests to find out if your memory configuration is valid.</p> <pre><code>--process         Subscribe to process introspection data.\n</code></pre> <p>The process view will show you the processes (incl. PID), which are currently registered with RouDi.</p> <pre><code>--port            Subscribe to port introspection data.\n</code></pre> <p>The port view shows both publisher and subscriber ports that are created by RouDi in the shared memory. Their respective service description (service, instance, event) is shown to identify them uniquely. The columns <code>Process</code> and <code>Node</code> display to which process and node the ports belong. The service discovery protocol allows you to define the <code>Propagation scope</code> of the data. This can enable data forwarding to other machines e.g. over network or just consume them internally.</p> <pre><code>--all             Subscribe to all available introspection data.\n</code></pre> <p><code>--all</code> will enable all three views at once.</p> <pre><code>-v, --version     Display latest official iceoryx release version and exit.\n</code></pre> <p>Make sure that the version number of the introspection exactly matches the version number of RouDi. Currently, we don't guarantee binary compatibility between different versions. With different version numbers things might break.</p>","title":"Feature walkthrough"},{"location":"examples/icedelivery/","text":"","title":"icedelivery"},{"location":"examples/icedelivery/#introduction","text":"<p>This example showcases a data transmission setup with zero-copy inter-process communication (IPC) on iceoryx. It provides publisher and subscriber applications. They come in two C++ API flavors (untyped and typed).</p>","title":"Introduction"},{"location":"examples/icedelivery/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/icedelivery/#code-walkthrough","text":"<p>This example makes use of two kinds of API flavors. With the untyped API, you have the most flexibility. It enables you to define higher level APIs with a different look and feel on top of iceoryx, e.g. the ara::com API of AUTOSAR Adaptive or the ROS 2 API. It is not meant to be used by developers in daily life, the assumption is that there will always be a higher abstraction. A simple example how such an abstraction could look like is given in the second step with the typed example. The typed API provides type safety combined with RAII.</p>","title":"Code walkthrough"},{"location":"examples/icedelivery/#publisher-application-untyped","text":"<p>First off, let's include the publisher, the runtime and the signal handler:</p>  <pre><code>#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/untyped_publisher.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>You might be wondering what the publisher application is sending? It's this struct.</p>  <pre><code>struct RadarObject\n{\n    RadarObject() noexcept\n    {\n    }\n    RadarObject(double x, double y, double z) noexcept\n        : x(x)\n        , y(y)\n        , z(z)\n    {\n    }\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n};\n</code></pre> <p>It is included by:</p>  <pre><code>#include \"topic_data.hpp\"\n</code></pre> <p>For the communication with RouDi a runtime object is created. The parameter of the method <code>initRuntime()</code> contains a unique string identifier for this publisher.</p>  <pre><code>constexpr char APP_NAME[] = \"iox-cpp-publisher-untyped\";\niox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>Now that RouDi knows our publisher application is existing, let's create a publisher instance for sending our charming struct to everyone:</p>  <pre><code>iox::popo::UntypedPublisher publisher({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>Now comes the work mode. Data needs to be created. But hang on.. we need memory first! Let's reserve a memory chunk which fits our RadarObject struct.</p>  <pre><code>publisher.loan(sizeof(RadarObject))\n    .and_then([&amp;](auto&amp; userPayload) {\n        // ...\n    })\n    .or_else([&amp;](auto&amp; error) {\n        // ...\n    });\n</code></pre> <p>The call to <code>loan()</code> returns a <code>cxx::expected</code>. By concatenating <code>and_then</code> and <code>or_else</code> branches are implicitly taken and your code becomes less error-prone compared to using <code>if() { .. } else { .. }</code>. Well, it's a bit of a lambda jungle. Read it like a story in a book: \"Loan memory and then if it succeeds, fill it with some data or else if it fails, handle the error\".</p> <p>Remember, the untyped API will always be bare-metal!</p> <p>Hence, the <code>RadarObject</code> needs to be constructed with a placement new:</p>  <pre><code>RadarObject* data = new (userPayload) RadarObject(ct, ct, ct);\n</code></pre> <p>Then, we can write some values:</p>  <pre><code>data-&gt;x = ct;\ndata-&gt;y = ct;\ndata-&gt;z = ct;\n</code></pre> <p>Finally, the value is made available to any subscriber with</p>  <pre><code>publisher.publish(userPayload);\n</code></pre> <p>Incrementing the counter and sending the data happens in a loop every second until the user presses <code>Ctrl-C</code>. It is captured with the signal handler and stops the loop.</p>","title":"Publisher application (untyped)"},{"location":"examples/icedelivery/#subscriber-application-untyped","text":"<p>How can the subscriber application receive the data the publisher application just transmitted?</p> <p>Similar to the publisher, we include the topic data, the subscriber, the runtime as well as the signal handler header:</p>  <pre><code>#include \"topic_data.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/untyped_subscriber.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>To make RouDi aware of the subscriber a runtime object is created, once again with a unique identifier string:</p>  <pre><code>constexpr char APP_NAME[] = \"iox-cpp-subscriber-untyped\";\niox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>In the next step a subscriber object is created, matching exactly the <code>capro::ServiceDescription</code> that the publisher offered:</p>  <pre><code>iox::popo::UntypedSubscriber subscriber({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>Again in a while-loop we do the following:</p>  <pre><code>while (!iox::posix::hasTerminationRequested())\n{\n    subscriber\n        .take()\n        .and_then([&amp;](const void* userPayload) {\n            // ...\n        })\n        .or_else([](auto&amp; result) {\n            if (result != iox::popo::ChunkReceiveResult::NO_CHUNK_AVAILABLE)\n            {\n                std::cout &lt;&lt; \"Error receiving chunk.\" &lt;&lt; std::endl;\n            }\n        });\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n</code></pre> <p>The program execution is stopped when the user presses <code>Ctrl-C</code>.</p> <p>Let's translate it into a story again: \"Take the data and then if this succeeds, work with the sample, or else if an error other than <code>NO_CHUNK_AVAILABLE</code> occurred, print the string 'Error receiving chunk.'\". Of course, you don't need to take care of all cases, but we advise doing so.</p> <p>In the <code>and_then</code> case the content of the sample is printed to the command line:</p>  <pre><code>auto object = static_cast&lt;const RadarObject*&gt;(userPayload);\nstd::cout &lt;&lt; APP_NAME &lt;&lt; \" got value: \" &lt;&lt; object-&gt;x &lt;&lt; std::endl;\n</code></pre> <p>Please note the <code>static_cast</code> before reading out the data. It is necessary because the untyped subscriber is unaware of the type of the transmitted data.</p> <p>After accessing the value, the chunk of memory needs to be explicitly released by calling:</p>  <pre><code>// note that we explicitly have to release the sample\n// and afterwards the pointer access is undefined behavior\nsubscriber.release(userPayload);\n</code></pre> <p>The subscriber runs 10x times faster than the publisher, to make sure that all data samples are received.</p>","title":"Subscriber application (untyped)"},{"location":"examples/icedelivery/#publisher-application-typed","text":"<p>The typed publisher application is an example for a high-level user API and does the same thing as the untyped publisher described before. In this summary, just the differences to the prior publisher application are described.</p> <p>Starting again with the includes, there is now a different one:</p>  <pre><code>#include \"iceoryx_posh/popo/publisher.hpp\"\n</code></pre> <p>When it comes to the runtime, things are the same as in the untyped publisher. However, a typed publisher object is created and the transmitted data type is provided as template parameter:</p>  <pre><code>iox::popo::Publisher&lt;RadarObject&gt; publisher({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>A similar while-loop is used to send the data to the subscriber. In contrast to the untyped publisher the typed one offers three additional possibilities.</p>","title":"Publisher application (typed)"},{"location":"examples/icedelivery/#1-loan-and-publish","text":"<p>Usage #1 default constructs the data type in-place:</p>  <pre><code>//  * Retrieve a typed sample from shared memory.\n//  * Sample can be held until ready to publish.\n//  * Data is default constructed during loan\npublisher.loan()\n    .and_then([&amp;](auto&amp; sample) {\n        sample-&gt;x = sampleValue1;\n        sample-&gt;y = sampleValue1;\n        sample-&gt;z = sampleValue1;\n        sample.publish();\n    })\n    .or_else([](auto&amp; error) {\n        // Do something with error\n        std::cerr &lt;&lt; \"Unable to loan sample, error: \" &lt;&lt; error &lt;&lt; std::endl;\n    });\n</code></pre>","title":"#1 Loan and publish"},{"location":"examples/icedelivery/#2-loan-construct-in-place-and-publish","text":"<p>Usage #2 constructs the data type with the values provided in loan:</p>  <pre><code>//  * Retrieve a typed sample from shared memory and construct data in-place\n//  * Sample can be held until ready to publish.\n//  * Data is constructed with the arguments provided.\npublisher.loan(sampleValue2, sampleValue2, sampleValue2)\n    .and_then([](auto&amp; sample) { sample.publish(); })\n    .or_else([](auto&amp; error) {\n        // Do something with error\n        std::cerr &lt;&lt; \"Unable to loan sample, error: \" &lt;&lt; error &lt;&lt; std::endl;\n    });\n</code></pre> <p>One might wonder what the type of the variable <code>sample</code> is? It is <code>iox::popo::Sample&lt;RadarObject&gt;</code>. This class behaves similar to a <code>std::unique_ptr</code> and makes sure that the ownership handling is done automatically and memory is freed when going out of scope on subscriber side.</p>","title":"#2 Loan, construct in-place and publish"},{"location":"examples/icedelivery/#3-publish-by-copy","text":"<p>Usage #3 does a copy-and-publish in one call. This should only be used for small data types, as otherwise copies can lead to a larger runtime.</p>  <pre><code>//  * Basic copy-and-publish. Useful for smaller data types.\nauto object = RadarObject(sampleValue3, sampleValue3, sampleValue3);\npublisher.publishCopyOf(object).or_else([](auto&amp; error) {\n    // Do something with error.\n    std::cerr &lt;&lt; \"Unable to publishCopyOf, error: \" &lt;&lt; error &lt;&lt; std::endl;\n});\n</code></pre>","title":"#3 Publish by copy"},{"location":"examples/icedelivery/#4-publish-the-result-of-a-computation","text":"<p>Usage #4 can be useful if you have a callable, e.g. a function or functor that should always be called. The callable needs to have the signature <code>void(SampleType*, ...)</code>.  The semantics are as follows: The publisher loans a sample from shared memory and if loaning was successful the callable is called with a pointer to the <code>SampleType</code> as first argument. If loaning was unsuccessful, the callable is not called, but instead the <code>or_else</code> branch is taken.</p>  <pre><code>//  * Provide a callable that will be used to populate the loaned sample.\n//  * The first argument of the callable must be T* and is the location that the callable should\n//      write its result to.\npublisher.publishResultOf(getRadarObject, ct).or_else([](auto&amp; error) {\n    // Do something with error.\n    std::cerr &lt;&lt; \"Unable to publishResultOf, error: \" &lt;&lt; error &lt;&lt; std::endl;\n});\npublisher\n    .publishResultOf([&amp;sampleValue4](RadarObject* object) {\n        *object = RadarObject(sampleValue4, sampleValue4, sampleValue4);\n    })\n    .or_else([](auto&amp; error) {\n        // Do something with error.\n        std::cerr &lt;&lt; \"Unable to publishResultOf, error: \" &lt;&lt; error &lt;&lt; std::endl;\n    });\n</code></pre>","title":"#4 Publish the result of a computation"},{"location":"examples/icedelivery/#subscriber-application-typed","text":"<p>As with the typed publisher application there is a different include compared to the untyped subscriber:</p>  <pre><code>#include \"iceoryx_posh/popo/subscriber.hpp\"\n</code></pre> <p>An instance of <code>Subscriber</code> is created:</p>  <pre><code>iox::popo::Subscriber&lt;RadarObject&gt; subscriber({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>Everything else is nearly the same. However, there is one crucial difference which makes the <code>Subscriber</code> typed.</p> <p>Compare this line from the <code>UntypedSubscriber</code></p>  <pre><code>.and_then([&amp;](const void* userPayload) {\n    // ...\n})\n</code></pre> <p>with</p>  <pre><code>.and_then([](auto&amp; sample) {\n    // ...\n})\n</code></pre> <p>In case of the typed <code>Subscriber</code>, <code>auto</code> is deduced to <code>iox::popo::Sample&lt;const RadarObject&gt;</code>. With the <code>UntypedSubscriber</code> the parameter is <code>const void*</code> as no type information is available.</p> <p> Check out icedelivery on GitHub  </p>","title":"Subscriber application (typed)"},{"location":"examples/icedelivery_in_c/","text":"<p>You can find a more detailed description of the C API in the iceoryx_binding_c README.md.</p>","title":"icedelivery in C"},{"location":"examples/icedelivery_in_c/#introduction","text":"<p>The behavior and structure is identical to the icedelivery C++ example so that we explain here only the C API differences and not the underlying mechanisms.</p>","title":"Introduction"},{"location":"examples/icedelivery_in_c/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/icedelivery_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icedelivery_in_c/#subscriber","text":"<p>As in the icedelivery C++ example, we perform the following steps:</p> <ol> <li>Create a runtime instance.</li> <li>Create a subscriber with some options.</li> <li>Receive data.</li> <li>C API: Additionally, we have to remove the previously allocated subscriber         port!</li> </ol> <p>Let's take a look at the <code>receiving</code> function that comes with the <code>ice_c_subscriber.c</code> example.</p> <ol> <li>We register our process at RouDi with the name <code>iox-c-subscriber</code></li> </ol>  <pre><code>const char APP_NAME[] = \"iox-c-subscriber\";\niox_runtime_init(APP_NAME);\n</code></pre> <ol> <li>We create a subscriber with the service description     {\"Radar\", \"FrontLeft\", \"Object\" }. We also set subscriber options. The     <code>historyRequest</code> tells the subscriber how many previously sent samples it     shall request from all offered and matching publishers and the     <code>queueCapacity</code> how many unread samples the subscriber can queue. The     <code>nodeName</code> is the name of the node the subscriber is associated with.     The <code>subscriberStorage</code> is the place where the subscriber is stored in     memory and <code>subscriber</code> is actually a pointer to that location.</li> </ol>  <pre><code>iox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.historyRequest = 10U;\noptions.queueCapacity = 50U;\noptions.nodeName = \"iox-c-subscriber-node\";\niox_sub_storage_t subscriberStorage;\n\niox_sub_t subscriber = iox_sub_init(&amp;subscriberStorage, \"Radar\", \"FrontLeft\", \"Object\", &amp;options);\n</code></pre> <ol> <li>We receive samples in a loop and print the received data on the console as     long as the <code>killswitch</code> is not set to <code>true</code> by an external signal.</li> </ol>  <pre><code>while (!killswitch)\n{\n    if (SubscribeState_SUBSCRIBED == iox_sub_get_subscription_state(subscriber))\n    {\n        const void* userPayload = NULL;\n        // we will receive more than one sample here since the publisher is sending a\n        // new sample every 400 ms and we check for new samples only every second\n        while (ChunkReceiveResult_SUCCESS == iox_sub_take_chunk(subscriber, &amp;userPayload))\n        {\n            const struct RadarObject* sample = (const struct RadarObject*)(userPayload);\n            printf(\"%s got value: %.0f\\n\", APP_NAME, sample-&gt;x);\n            fflush(stdout);\n            iox_sub_release_chunk(subscriber, userPayload);\n        }\n        printf(\"\\n\");\n    }\n    else\n    {\n        printf(\"Not subscribed!\\n\");\n    }\n\n    sleep_for(1000);\n}\n</code></pre> <ol> <li>When using the C API we have to clean up the subscriber after     its usage.</li> </ol>  <pre><code>iox_sub_deinit(subscriber);\n</code></pre>","title":"Subscriber"},{"location":"examples/icedelivery_in_c/#publisher","text":"<p>The publisher is implemented in a similar way like in the icedelivery C++ example:</p> <ol> <li>Create a runtime instance.</li> <li>Create a publisher with some options.</li> <li>Send data.</li> <li>C API: Additionally, we have to remove the previously allocated publisher         port!</li> </ol> <p>Let's take a look at the <code>sending</code> function that comes with the <code>ice_c_publisher.c</code> example.</p> <ol> <li>We register our process at RouDi with the name <code>iox-c-publisher</code></li> </ol>  <pre><code>const char APP_NAME[] = \"iox-c-publisher\";\niox_runtime_init(APP_NAME);\n</code></pre> <ol> <li>We create a publisher with the service description</li> </ol>  <pre><code>iox_pub_options_t options;\niox_pub_options_init(&amp;options);\noptions.historyCapacity = 10U;\noptions.nodeName = \"iox-c-publisher-node\";\niox_pub_storage_t publisherStorage;\niox_pub_t publisher = iox_pub_init(&amp;publisherStorage, \"Radar\", \"FrontLeft\", \"Object\", &amp;options);\n</code></pre> <ol> <li>Until an external signal sets <code>killswitch</code> to <code>true</code>, we will send an     incrementing number to all subscribers in every iteration and print the     value of that number to the console.</li> </ol>  <pre><code>double ct = 0.0;\n\nwhile (!killswitch)\n{\n    void* userPayload = NULL;\n    if (AllocationResult_SUCCESS == iox_pub_loan_chunk(publisher, &amp;userPayload, sizeof(struct RadarObject)))\n    {\n        struct RadarObject* sample = (struct RadarObject*)userPayload;\n\n        sample-&gt;x = ct;\n        sample-&gt;y = ct;\n        sample-&gt;z = ct;\n\n        printf(\"%s sent value: %.0f\\n\", APP_NAME, ct);\n        fflush(stdout);\n\n        iox_pub_publish_chunk(publisher, userPayload);\n\n        ++ct;\n\n        sleep_for(400);\n    }\n    else\n    {\n        printf(\"Failed to allocate chunk!\");\n    }\n}\n</code></pre> <ol> <li>And we clean up our publisher port.</li> </ol>  <pre><code>iox_pub_deinit(publisher);\n</code></pre> <p> Check out icedelivery_in_c on GitHub  </p>","title":"Publisher"},{"location":"examples/icediscovery/","text":"","title":"icediscovery"},{"location":"examples/icediscovery/#introduction","text":"<p>This example demonstrates how to search for specific services using iceoryx's <code>ServiceDiscovery</code>. It provides two applications - one offering different services and one searching for these making different search queries. A <code>service</code> in iceoryx is defined by a <code>ServiceDescription</code> that represents a topic under which publisher/server and subscriber/client can exchange data.</p> <p>In addition the applications <code>iox-wait-for-service</code> and <code>iox-discovery-monitor</code> demonstrate how to write custom discovery functionality to wait for specific services or monitor the availability of services respectively.</p>","title":"Introduction"},{"location":"examples/icediscovery/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/icediscovery/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icediscovery/#offer-services","text":"<p>We create several publishers which offer their services on construction by default. For more dynamism the <code>cameraPublishers</code> offer/stop their services periodically. If you want more information on how to create a publisher, have a look at the icehello, icedelivery, and iceoptions examples.</p>","title":"Offer services"},{"location":"examples/icediscovery/#find-services","text":"<p>To be able to search for services, we have to create a <code>ServiceDiscovery</code> object:</p>  <pre><code>iox::runtime::ServiceDiscovery serviceDiscovery;\n</code></pre> <p>It is included via:</p>  <pre><code>#include \"iceoryx_posh/runtime/service_discovery.hpp\"\n</code></pre> <p>On that object we can call the method <code>findService</code> which expects the three service string identifiers and a callable which will be applied to all matching services. In addition we have to specify whether we want to search for publishers (<code>MessagingPattern::PUB_SUB</code>) used in publish-subscribe communication or servers (<code>MessagingPattern::REQ_RES</code>) used in request-response communication.</p> <p>In this example we pass a function that prints the found services on the console:</p>  <pre><code>void printSearchResult(const iox::capro::ServiceDescription&amp; service)\n{\n    std::cout &lt;&lt; \"- \" &lt;&lt; service &lt;&lt; std::endl;\n}\n</code></pre> <p>We can search for exactly matching services:</p>  <pre><code>serviceDiscovery.findService(iox::capro::IdString_t{\"Radar\"},\n                             iox::capro::IdString_t{\"FrontLeft\"},\n                             iox::capro::IdString_t{\"Image\"},\n                             printSearchResult,\n                             iox::popo::MessagingPattern::PUB_SUB);\n</code></pre> <p>or add wildcards to our search query:</p>  <pre><code>serviceDiscovery.findService(iox::capro::IdString_t{\"Camera\"},\n                             iox::capro::Wildcard,\n                             iox::capro::Wildcard,\n                             printSearchResult,\n                             iox::popo::MessagingPattern::PUB_SUB);\n</code></pre> <p>With the above <code>findService</code> call we look for every <code>Camera</code> service with any instance and any event. Since the <code>cameraPublishers</code> periodically offer/stop their services, you should see sometimes 5 <code>Camera</code> services and sometimes none.</p>","title":"Find services"},{"location":"examples/icediscovery/#wait-for-services","text":"<p>Start the applications <code>iox-wait-for-service</code> and <code>iox-offer-service</code>. This can be done in any order, but for demonstration purposes <code>iox-offer-service</code> should be started last.</p> <p><code>iox-wait-for-service</code> uses a customized service discovery Discovery which supports to wait for services by including</p>  <pre><code>#include \"discovery_blocking.hpp\"\n</code></pre> <p>We then can use our custom discovery class</p>  <pre><code>// requires the runtime to be created first\nDiscovery discovery;\n</code></pre> <p>which provides a function <code>waitUntil</code> to wait for some discovery-related search query condition.</p> <p>We define the search query</p>  <pre><code>auto query = [&amp;]() {\n    auto result = discovery.findService(service, instance, event);\n    return !result.empty();\n};\n</code></pre> <p>This is essentially any callable with <code>bool(void)</code> signature, but it should depend on the discovery somehow (by capture), as it is only checked when the service availability changes in some way. Here we require some specific service to be found before we proceed.</p>  <pre><code>iox::capro::IdString_t service{\"Camera\"};\niox::capro::IdString_t instance{\"FrontLeft\"};\niox::capro::IdString_t event{\"Image\"};\n</code></pre> <p>Now we can wait until the service discovery changes and the service becomes available.</p>  <pre><code>bool serviceWasAvailable = discovery.waitUntil(query);\n</code></pre> <p>This wait is blocking until the service was available. If it already is available we do not block and proceed. It is important that due to the nature of concurrent systems we cannot know that the service is still available once we return from <code>waitUntil</code>, as the application offering the service may have stopped doing so in the meantime.</p> <p>Usually we will assume that the service is available and may continue, e.g. by creating subscribers and running application specific code.</p> <p>We can also block until any unspecified change in the service availability occurs</p>  <pre><code>discovery.waitUntilChange();\n</code></pre> <p>This change is relative to the last <code>findService</code> call we issued, i.e. if something changed compared to the available services at this point, we wake up and continue.</p> <p>We then can check any condition we like, but usually it will be most useful to again check discovery-related conditions. Here we check whether a particular service becomes unavailable (essentially the negation of our query before)</p>  <pre><code>if (discovery.findService(service, instance, event).empty())\n{\n    break;\n}\n</code></pre> <p>Note that we use a customized <code>findService</code> version which returns a result container which can easily be build using the version which takes a function to be applied to all services in the search result.</p> <p>Once the service becomes unavailable, the application exits.</p> <p>Should the service we wait for never become available we can unblock any of the wait calls with</p>  <pre><code>if (discoveryPtr)\n{\n    discoveryPtr-&gt;unblockWait();\n}\n</code></pre>","title":"Wait for services"},{"location":"examples/icediscovery/#monitor-service-availability","text":"<p>If we want to continously monitor the availability of some service or check some discovery condition we can do so by using e.g. a listener to conditionally execute callbacks.</p> <p>To do so, we start the applications <code>iox-discovery-monitor</code> and <code>iox-offer-service</code> (again in any order, but for demonstration purposes <code>iox-offer-service</code> should be started last).</p> <p>Again we can use a Discovery customized for this purpose by including</p>  <pre><code>#include \"discovery_monitor.hpp\"\n</code></pre> <p>and creating it like so</p>  <pre><code>// requires the runtime to be created first\nDiscovery discovery;\n</code></pre> <p>Afterwards we create a callback to be called whenever the service availability changes.</p>  <pre><code>auto callback = [&amp;](Discovery&amp; discovery) -&gt; void {\n    auto result = discovery.findService(service, instance, event);\n\n    if (!result.empty())\n    {\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" &lt;\" &lt;&lt; service &lt;&lt; \", \" &lt;&lt; instance &lt;&lt; \", \" &lt;&lt; event &lt;&lt; \"&gt; available\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" &lt;\" &lt;&lt; service &lt;&lt; \", \" &lt;&lt; instance &lt;&lt; \", \" &lt;&lt; event &lt;&lt; \"&gt; unavailable\"\n                  &lt;&lt; std::endl;\n    }\n    printSearchResult(result);\n};\n</code></pre> <p>This callback essentially checks whether a specific service is available or unavailable and generates output accordingly. Other reactions are possible as well, such as changing the processing logic of an pplication.</p> <p>To start the monitoring, we register the callback</p>  <pre><code>discovery.registerCallback(callback);\n</code></pre> <p>Monitoring happens in a background thread implicitly created by the <code>Discovery</code>, i.e. the callback is executed in this thread.</p> <p>When we want to stop monitoring we have to deregister the callback</p>  <pre><code>discovery.deregisterCallback();\n</code></pre> <p>Here this is done at the very end where it is technically not required, but in a more complex application it could be done while the application is processing data. The main processing loop of the application is deliberately left empty for simplicty. Usually it would interact with the callback by e.g. changing application behavior whenever the availability of some service changes.</p> <p>While we only can attach one callback to the general event that the service availability changes in some way, we can generalize the mechanism here to check for multiple conditions and react to each of them by e.g. calling a specific function. These conditions would still need to be checked in the callback we defined though.</p>","title":"Monitor service availability"},{"location":"examples/icediscovery/#implementation-of-discovery-with-blocking-wait","text":"<p>We build our custom discovery on top of the <code>iox::runtime::ServiceDiscovery</code> by composition. While inheritance is an option, composition has the advantage that we can use <code>ServiceDiscovery</code> as a singleton (to save memory) but our custom <code>Discovery</code> class can be fairly lightweight and does not need to be a singleton.</p>  <pre><code>ServiceDiscovery&amp; serviceDiscovery()\n{\n    static ServiceDiscovery instance;\n    return instance;\n}\n</code></pre> <p>This is useful as the <code>ServiceDiscovery</code> may be fairly large and in general there is no point in having multiple <code>ServiceDiscovery</code> objects that all have the same purpose and (if updated) same view of the available services.</p> <p>The key idea is to use a waitset and attach to the event that the service availability changes</p>  <pre><code>m_waitset.attachEvent(*m_discovery, iox::runtime::ServiceDiscoveryEvent::SERVICE_REGISTRY_CHANGED)\n    .or_else(errorHandler);\n</code></pre> <p>Waiting for any availability change is now as simple as waiting on the waitset</p>  <pre><code>void Discovery::waitUntilChange()\n{\n    do\n    {\n        auto notificationVector = m_waitset.wait();\n        for (auto&amp; notification : notificationVector)\n        {\n            if (notification-&gt;doesOriginateFrom(m_discovery))\n            {\n                return;\n            }\n        }\n    } while (m_blocking);\n}\n</code></pre> <p>If we want to wait for a specific condition, we can do so with</p>  <pre><code>template &lt;typename Condition&gt;\nbool Discovery::waitUntil(const Condition&amp; condition)\n{\n    do\n    {\n        // 1) does the condition hold?\n        bool result = condition();\n        if (result)\n        {\n            // 2) condition held and we return (without mutex to protect condition changes\n            // there is no way to guarantee it still holds)\n            return true;\n        }\n        else\n        {\n            if (!m_blocking)\n            {\n                return false;\n            }\n        }\n        // 3) condition did not hold but it may hold if we use the latest discovery data\n        //    which may have arrived in the meantime\n\n        // 4) this does not wait if there is new discovery data (and hence we try again immediately)\n        waitUntilChange();\n        // 5) discovery data changed, check condition again (even if unblocked)\n    } while (true);\n\n    return false;\n}\n</code></pre> <p>The  condition needs to be evaluable to <code>bool</code> and takes no arguments. While this can be generalized to any variadic arguments, it is not needed as we can use capturing lambda expressions. The wait simply checks for the condition, and if true returns immediately. Otherwise it waits until the available services change using <code>waitUntilChange</code> before checking the condition again.</p> <p>It is also possible to unblock any of the waits even if nothing changes or the condition does not hold</p>  <pre><code>void Discovery::unblockWait()\n{\n    m_blocking = false;\n    // could also unblock with a dedicated condition to unblock the wait but that requires more code\n    // (additional trigger) and is not necessary if it is only supposed to happen once\n    m_waitset.markForDestruction();\n}\n</code></pre> <p>This is can only be called once and makes all future wait calls non-blocking. It is useful to unblock any wait calls to be able to stop the application.</p> <p>Finally we provide a custom implementation of <code>findService</code> which returns a container of our choice, in this case a <code>std::vector</code>.</p>  <pre><code>ServiceContainer Discovery::findService(const iox::cxx::optional&lt;iox::capro::IdString_t&gt;&amp; service,\n                                        const iox::cxx::optional&lt;iox::capro::IdString_t&gt;&amp; instance,\n                                        const iox::cxx::optional&lt;iox::capro::IdString_t&gt;&amp; event)\n{\n    ServiceContainer result;\n    auto filter = [&amp;](const iox::capro::ServiceDescription&amp; s) { result.emplace_back(s); };\n    m_discovery-&gt;findService(service, instance, event, filter, iox::popo::MessagingPattern::PUB_SUB);\n    return result;\n}\n</code></pre> <p>It is implemenented by using the native <code>findService</code> call of the <code>ServiceDiscovery</code> with an appropriate filter function. The benefit is that this way we can choose containers which do not necessrily reside on the stack.</p>","title":"Implementation of Discovery with blocking wait"},{"location":"examples/icediscovery/#implementation-of-discovery-monitoring","text":"<p>To implement a <code>Discovery</code> where we actively monitor availability of services we employ a listener. Contrary to the blocking solution this does not block the user threads and executes any callback in a background thread created by the listener. The callback will be executed on any change of the available services.</p> <p>To register the callback we call</p>  <pre><code>template &lt;typename Callback&gt;\nbool Discovery::registerCallback(const Callback&amp; callback)\n</code></pre> <p>which attaches the callback to the listener.</p>  <pre><code>auto invoker = iox::popo::createNotificationCallback(invokeCallback, *this);\nm_listener.attachEvent(*m_discovery, iox::runtime::ServiceDiscoveryEvent::SERVICE_REGISTRY_CHANGED, invoker)\n    .or_else(errorHandler);\n</code></pre> <p>The callback is stored as a <code>cxx::function</code> which does not require dynamic memory (but limits the size of the stored function, which is relvant e.g. for capturing lambdas). If dynamic memory is no concern we can also use a <code>std::function</code>. The callback can be any callable with a <code>(void)(discovery::Discovery&amp;)</code> signature. Again the callback signature can be generalized somewhat but there are constraints to use it with the listener. Since the listener can only call static or free functions, we use an additional indirection to call the actual callback</p>  <pre><code>void Discovery::invokeCallback(ServiceDiscovery*, Discovery* self)\n{\n    // discarded discovery argument is required by the listener\n    self-&gt;m_callback(*self);\n}\n</code></pre> <p>As soon as the callback is registered, the listener thread will invoke it on any service availability change. There is a small caveat though that while callback is called on any change, we can only access the latest discovery information by e.g. calling <code>findService</code>. This means all intermediate changes cannot be detected, in particular we may encounter an ABA problem of service availabilty: the service is availalable, becomes unavailable and available again in quick succession. If the callback issues a <code>findService</code>, it will not observe any change in this case. As one is usually mainly interested in the available services this can be considered a minor limitation.</p> <p>To stop monitoring changes in the availability of services we simply call</p>  <pre><code>void Discovery::deregisterCallback()\n{\n    if (m_callback)\n    {\n        m_listener.detachEvent(*m_discovery, iox::runtime::ServiceDiscoveryEvent::SERVICE_REGISTRY_CHANGED);\n    }\n    m_callback = nullptr;\n}\n</code></pre> <p>which detaches the callback from the listener.</p> <p>As before we built on an <code>iox::runtime::ServiceDiscovery</code> by composition and define a custom<code>findService</code> function which returns a <code>std::vector</code>.</p> <p> Check out icediscovery on GitHub  </p>","title":"Implementation of Discovery monitoring"},{"location":"examples/icediscovery_in_c/","text":"","title":"icediscovery in C"},{"location":"examples/icediscovery_in_c/#introduction","text":"<p>This example demonstrates how to search for specific services using iceoryx's service discovery. It provides two applications - one offering different services and one searching for those with different search queries. The behavior and structure is quite similar to the icediscovery C++ example.</p>","title":"Introduction"},{"location":"examples/icediscovery_in_c/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/icediscovery_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icediscovery_in_c/#offer-services","text":"<p>We create several publishers which offer their services on construction by default. For more dynamism the <code>cameraPublishers</code> offer/stop their services periodically. If you want more information on how to create publishers, have a look at the icedelivery C example.</p>","title":"Offer services"},{"location":"examples/icediscovery_in_c/#find-services","text":"<p>To be able to search for services, we need to include:</p>  <pre><code>#include \"iceoryx_binding_c/service_discovery.h\"\n</code></pre> <p>We create some storage for the service discovery and initialize it.</p>  <pre><code>iox_service_discovery_storage_t storage;\niox_service_discovery_t serviceDiscovery = iox_service_discovery_init(&amp;storage);\n</code></pre> <p>We can now call three different find service functions. Let's start with</p>  <pre><code>iox_service_discovery_find_service_apply_callable(\n    serviceDiscovery, \"Radar\", \"FrontLeft\", \"Image\", printSearchResult, MessagingPattern_PUB_SUB);\n</code></pre> <p>which searches for all <code>{Radar, FrontLeft, Image}</code> services offered by publishers and applies the provided function <code>printSearchResult</code> on each of them. The function must have the signature <code>void(const iox_service_description_t)</code>. Here we pass a function that prints the found services on the console:</p>  <pre><code>void printSearchResult(const iox_service_description_t service)\n{\n    printf(\n        \"- Service: %s, Instance: %s, Event: %s\\n\", service.serviceString, service.instanceString, service.eventString);\n}\n</code></pre> <p>We cannot only search for exact matching services. In combination with wildcards (<code>NULL</code>) we can also search for all instances and events with the service <code>Radar</code>:</p>  <pre><code>iox_service_discovery_find_service_apply_callable(\n    serviceDiscovery, \"Radar\", NULL, NULL, printSearchResult, MessagingPattern_PUB_SUB);\n</code></pre> <p>The wildcard can be used for all strings which describe a service, i.e. service, instance and event.</p> <p>Let's now search for all <code>Camera</code> services and store the results in an array:</p>  <pre><code>numberFoundServices = iox_service_discovery_find_service(serviceDiscovery,\n                                                         \"Camera\",\n                                                         NULL,\n                                                         NULL,\n                                                         searchResult,\n                                                         SEARCH_RESULT_CAPACITY,\n                                                         &amp;missedServices,\n                                                         MessagingPattern_PUB_SUB);\n</code></pre> <p><code>searchResult</code> is a <code>iox_service_description_t</code> array of size <code>SEARCH_RESULT_CAPACITY</code>. The matching services are written into this array, up to a maximum of <code>SEARCH_RESULT_CAPACITY</code>. If the number of found services exceeds the array's capacity, the number of services that could not be stored is written to <code>missedServices</code>. The number of stored services is returned. Since the <code>cameraPublishers</code> periodically offer/stop their services, you should see sometimes 5 <code>Camera</code> services and sometimes none.</p> <p>Finally, let's try out the third find service function. We search again for all <code>Camera</code> services but additionally count the front camera services:</p>  <pre><code>iox_service_discovery_find_service_apply_callable_with_context_data(\n    serviceDiscovery, \"Camera\", NULL, NULL, searchFrontDevices, &amp;numberFrontCameras, MessagingPattern_PUB_SUB);\n</code></pre> <p>This function is quite similar to the first find service function, but we pass an additional argument <code>numberFrontCameras</code>:</p>  <pre><code>uint32_t numberFrontCameras = 0U;\n</code></pre> <p>We use this variable to store the number of front cameras and provide it as second argument <code>count</code> to the function <code>searchFrontDevices</code> which is applied to all found services:</p>  <pre><code>void searchFrontDevices(const iox_service_description_t service, void* count)\n{\n    if (strncmp(service.instanceString, \"FrontLeft\", IOX_CONFIG_SERVICE_STRING_SIZE) == 0\n        || strncmp(service.instanceString, \"FrontRight\", IOX_CONFIG_SERVICE_STRING_SIZE) == 0)\n    {\n        ++*(uint32_t*)count;\n    }\n}\n</code></pre> <p> Check out icediscovery on GitHub  </p>","title":"Find services"},{"location":"examples/icedocker/","text":"","title":"Use Iceoryx In A Docker Environment"},{"location":"examples/icedocker/#introduction","text":"<p>Let's assume we are working on a system in which <code>iox-roudi</code> runs in a docker environment and it should orchestrate two applications which are running again in two different docker containers so that we end up with a system of 3 different docker containers.</p> <p>To demonstrate the setup we use the icedelivery C++ example.</p> <pre><code>                         +-----------+\n                         | docker 1  |\n                         |           |\n                         | iox-roudi |\n                         +-----------+\n\n       +-------------------+        +--------------------+\n       | docker 2          | send   | docker 3           |\n       |                   |-------&gt;|                    |\n       | iox-cpp-publisher | data   | iox-cpp-subscriber |\n       +-------------------+        +--------------------+\n</code></pre>","title":"Introduction"},{"location":"examples/icedocker/#requirements","text":"","title":"Requirements"},{"location":"examples/icedocker/#shared-access-to-unix-domain-sockets","text":"<p>Every iceoryx application registers itself at our central broker RouDi by sending a message to the unix domain socket located at <code>IOX_UDS_SOCKET_PATH_PREFIX/roudi</code> which is defined in the corresponding platform settings file <code>platform_settings.hpp</code>. In linux the socket file handle can be found at <code>/tmp/roudi</code>. When the application registers at RouDi it announces its unix domain socket as well to receive responses of requests which will be sent during runtime to RouDi. This socket is stored as well in <code>/tmp/IOX_RUNTIME_NAME</code>. The <code>iox-cpp-publisher</code> runtime has the same name as the binary which leads to the socket <code>/tmp/iox-cpp-publisher</code>.</p>","title":"Shared Access to Unix Domain Sockets"},{"location":"examples/icedocker/#shared-access-to-file-locks","text":"<p>Iceoryx applications ensure that every runtime name is unique in the system by creating a file lock before creating the runtime. This is stored in <code>IOX_LOCK_FILE_PATH_PREFIX/IOX_RUNTIME_NAME.lock</code> whereby <code>IOX_LOCK_FILE_PATH_PREFIX</code> is defined in the platform settings file <code>platform_settings.hpp</code>. When running the icedelivery example in a linux environment one can observe the lock files <code>/tmp/roudi.lock</code>, <code>/tmp/iox-cpp-subscriber.lock</code> and <code>/tmp/iox-cpp-publisher.lock</code>.</p>","title":"Shared Access to File Locks"},{"location":"examples/icedocker/#shared-access-to-semaphores-and-shared-memory","text":"<p>One of the tasks of the central broker RouDi is to create and distribute shared memory. When the <code>iox-cpp-publisher</code> would like to send data it acquires a pointer to this shared memory, writes the data into it and sends the pointer to the <code>iox-cpp-subscriber</code> which reads the memory at the received memory position. Additionally, it is possible to signal events across process boundaries via semaphores. For instance to signal a subscriber that data has arrived.</p>","title":"Shared Access to Semaphores and Shared Memory"},{"location":"examples/icedocker/#implementation","text":"<p>To have shared access to the required resources we have to bind the host filesystem:</p> <ul> <li><code>/tmp</code></li> <li><code>/dev</code></li> </ul> <p>into every docker container.</p>","title":"Implementation"},{"location":"examples/icedocker/#terminal-example","text":"<p>We start in 3 separate terminals 3 docker instances. In this example we use <code>archlinux:latest</code> but one is free to choose any other linux distribution. The iceoryx repository which contains an already built iceoryx can be found at <code>/home/user/iceoryx</code> which is bound to <code>/iceoryx</code>. The usage is explained in detail in the icedelivery C++ example.</p>","title":"Terminal Example"},{"location":"examples/icedocker/#terminal-1-iox-roudi","text":"<pre><code>docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest\n\ncd /iceoryx\n./build/iox-roudi\n</code></pre>","title":"Terminal 1 (iox-roudi)"},{"location":"examples/icedocker/#terminal-2-iox-cpp-publisher","text":"<pre><code>docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest\n\ncd /iceoryx\n./build/iceoryx_examples/icedelivery/iox-cpp-publisher\n</code></pre>","title":"Terminal 2 (iox-cpp-publisher)"},{"location":"examples/icedocker/#terminal-3-iox-cpp-subscriber","text":"<pre><code>docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest\n\ncd /iceoryx\n./build/iceoryx_examples/icedelivery/iox-cpp-subscriber\n</code></pre>","title":"Terminal 3 (iox-cpp-subscriber)"},{"location":"examples/icedocker/#docker-compose-example","text":"<p>We can also use <code>docker-compose</code> to start our test setup. Our example is coming with a configuration file <code>docker-compose.yml</code> which can be used from the iceoryx root path with the following command:</p> <pre><code>docker-compose -f iceoryx_examples/icedocker/docker-compose.yml --project-directory . up\n</code></pre> <p>We have to set the project directory explicitly so that the mapping of the iceoryx root path is working as intended.</p>","title":"docker-compose Example"},{"location":"examples/iceensemble/","text":"","title":"iceensemble"},{"location":"examples/iceensemble/#introduction","text":"<p>A common use case is that multiple sensors are sending data of the same type, e.g. LIDAR data, and a subscriber is interested in the data of all those sensors.</p> <p>This example demonstrates</p> <ol> <li>how you can run multiple publisher applications publishing on the same topic (n:m communication)</li> <li>how to communicate between C and C++</li> </ol>  <p>Info</p> <p>The default communication policy is many to many. If you have built iceoryx with the CMake flag <code>-DONE_TO_MANY_ONLY</code> this example will not run.</p>","title":"Introduction"},{"location":"examples/iceensemble/#run-iceensemble","text":"<p>The easiest way is to build all examples via <code>./tools/iceoryx_build_test.sh</code>. Then, create eight terminals and run one command in each of them.</p> <pre><code>./build/iox-roudi\n\n./build/iceoryx_examples/icehello/iox-cpp-publisher-helloworld\n./build/iceoryx_examples/icedelivery/iox-cpp-publisher\n./build/iceoryx_examples/icedelivery/iox-cpp-publisher-untyped\n./build/iceoryx_examples/iceoptions/iox-cpp-publisher-with-options\n./build/iceoryx_examples/icedelivery_in_c/iox-c-publisher\n\n./build/iceoryx_examples/icedelivery/iox-cpp-subscriber\n./build/iceoryx_examples/iceoptions/iox-subscriber-with-options\n</code></pre> <p>Alternatively, you can use the provided tmux script.</p> <pre><code>./iceoryx_examples/iceensemble/run_iceensemble.sh\n</code></pre>  <p>Info</p> <p>As <code>iox-subscriber-with-options</code> requests the blocking publisher feature, although having the same <code>capro::ServiceDescription</code> <code>{\"Radar\", \"FrontLeft\", \"Object\"}</code> it is only connected to <code>iox-publisher-with-options</code></p>","title":"Run iceensemble"},{"location":"examples/iceensemble/#expected-output","text":"<p></p> <p> Check out iceensemble on GitHub  </p>","title":"Expected Output"},{"location":"examples/icehello/","text":"","title":"icehello"},{"location":"examples/icehello/#introduction","text":"<p>This example demonstrates a basic data transmission with zero-copy inter-process communication (IPC). It provides a publisher and a subscriber application.</p>","title":"Introduction"},{"location":"examples/icehello/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/icehello/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icehello/#publisher","text":"<p>At first, we need to define what kind of data type the publisher and subscriber application will exchange:</p>  <pre><code>struct RadarObject\n{\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n};\n</code></pre> <p>It is included via:</p>  <pre><code>#include \"topic_data.hpp\"\n</code></pre> <p>Next, we include the publisher and the runtime:</p>  <pre><code>#include \"iceoryx_posh/popo/publisher.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>We create a runtime object to communicate with the RouDi daemon. We use a unique string for identifying our application:</p>  <pre><code>constexpr char APP_NAME[] = \"iox-cpp-publisher-helloworld\";\niox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>Now we create a publisher instance for our charming struct. Notice that the topic type is passed as a template parameter:</p>  <pre><code>iox::popo::Publisher&lt;RadarObject&gt; publisher({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>The three strings which are passed as parameter to the constructor of <code>iox::popo::Publisher</code> define our <code>capro::ServiceDescription</code>. <code>capro</code> stands for canionical protocol and is used to abstract different SoA protocols. <code>Radar</code> is the service name, <code>FrontLeft</code> an instance of the service <code>Radar</code> and the third string the specific event <code>Object</code> of the instance. In iceoryx, a publisher and a subscriber are connected only if all three IDs match.</p> <p>For exiting on Ctrl+C, we use the <code>SignalWatcher</code></p>  <pre><code>#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n</code></pre> <p>and loop in our <code>while</code> loop until it states that <code>SIGINT</code> or <code>SIGTERM</code> was sent via the function <code>hasTerminationRequested</code>.</p>  <pre><code>while (!iox::posix::hasTerminationRequested())\n</code></pre> <p>In order to send our sample, we loan some shared memory inside the <code>while</code> loop:</p>  <pre><code>auto loanResult = publisher.loan();\n</code></pre> <p>If loaning was successful, we assign the incremented counter to all three values in <code>RadarObject</code> and <code>publish()</code> to the subscriber application:</p>  <pre><code>if (!loanResult.has_error())\n{\n    auto&amp; sample = loanResult.value();\n    // Sample can be held until ready to publish\n    sample-&gt;x = ct;\n    sample-&gt;y = ct;\n    sample-&gt;z = ct;\n    sample.publish();\n}\n</code></pre> <p>In case an error occurred during loaning, we need to handle it:</p>  <pre><code>else\n{\n    auto error = loanResult.get_error();\n    // Do something with error\n    std::cerr &lt;&lt; \"Unable to loan sample, error code: \" &lt;&lt; error &lt;&lt; std::endl;\n}\n</code></pre> <p>Topics are printed and published every second:</p>  <pre><code>std::cout &lt;&lt; APP_NAME &lt;&lt; \" sent value: \" &lt;&lt; ct &lt;&lt; std::endl;\nstd::this_thread::sleep_for(std::chrono::seconds(1));\n</code></pre>","title":"Publisher"},{"location":"examples/icehello/#subscriber","text":"<p>The subscriber needs to have similar includes, but unlike the publisher <code>subscriber.hpp</code> is included:</p>  <pre><code>#include \"topic_data.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/subscriber.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>As well as the publisher, the subscriber needs to register with the daemon RouDi:</p>  <pre><code>constexpr char APP_NAME[] = \"iox-cpp-subscriber-helloworld\";\niox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>Next, the subscriber object is created, again passing the topic type <code>RadarObject</code> as template parameter:</p>  <pre><code>iox::popo::Subscriber&lt;RadarObject&gt; subscriber({\"Radar\", \"FrontLeft\", \"Object\"});\n</code></pre> <p>Publisher and subscriber will only be connected if they both use exactly these same three strings, our <code>capro::ServiceDescription</code>.</p> <p>Inside the <code>while</code> loop, we take the sample from shared memory and print it if we acquired it successfully.</p>  <pre><code>auto takeResult = subscriber.take();\nif (!takeResult.has_error())\n{\n    std::cout &lt;&lt; APP_NAME &lt;&lt; \" got value: \" &lt;&lt; takeResult.value()-&gt;x &lt;&lt; std::endl;\n}\n</code></pre> <p>In case an error occurred during taking, we need to handle it:</p>  <pre><code>if (takeResult.get_error() == iox::popo::ChunkReceiveResult::NO_CHUNK_AVAILABLE)\n{\n    std::cout &lt;&lt; \"No chunk available.\" &lt;&lt; std::endl;\n}\nelse\n{\n    std::cout &lt;&lt; \"Error receiving chunk.\" &lt;&lt; std::endl;\n}\n</code></pre> <p>The subscriber application polls for the sample ten times faster than the publisher is sending it. Therefore no samples should be missed, but not every time the subscriber tries to take a sample, it will get some. In this case, we print \"No chunk available.\".</p>  <pre><code>std::this_thread::sleep_for(std::chrono::milliseconds(100));\n</code></pre> <p>Increasing the polling rate is just one approach for reliable communication. iceoptions explains how to configure the history size of a subscriber. In the WaitSet example you learn how to avoid polling altogether.</p> <p> Check out icehello on GitHub  </p>","title":"Subscriber"},{"location":"examples/iceoptions/","text":"","title":"iceoptions"},{"location":"examples/iceoptions/#introduction","text":"<p>This example demonstrates what kind of quality of service options can be configured on the publisher and subscriber side. The options can be used for the typed and untyped C++ API flavors as well as the C API.</p>","title":"Introduction"},{"location":"examples/iceoptions/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/iceoptions/#code-walkthrough","text":"<p>Info</p> <p>This example describes a single publisher scenario.</p>","title":"Code walkthrough"},{"location":"examples/iceoptions/#publisher","text":"<p>In order to configure a publisher, we have to supply a struct of the type <code>iox::popo::PublisherOptions</code> as a second parameter.</p>  <pre><code>iox::popo::Publisher&lt;RadarObject&gt; publisher({\"Radar\", \"FrontLeft\", \"Object\"}, publisherOptions);\n</code></pre> <p><code>historyCapacity</code> will enable subscribers to read the last n samples e.g. in case they are started later than the publisher:</p>  <pre><code>publisherOptions.historyCapacity = 10U;\n</code></pre> <p>Topics are automatically offered on creation of a publisher, if you want to disable that feature and control the offering yourself, do:</p>  <pre><code>publisherOptions.offerOnCreate = false;\n</code></pre> <p>Due to the disabled <code>offerOnCreate</code> feature, don't forget to offer our topic:</p>  <pre><code>publisher.offer();\n</code></pre> <p>To organize publishers inside an application, they can be associated and grouped by providing a node name. Some frameworks call nodes runnables.</p>  <pre><code>publisherOptions.nodeName = \"Pub_Node_With_Options\";\n</code></pre> <p>To ensure that samples are never lost, you have the possibility to busy-wait for the subscriber when publishing. Both publisher and subscriber have to request compatible policies (<code>ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER</code> and <code>QueueFullPolicy::BLOCK_PRODUCER</code>).</p>  <pre><code>publisherOptions.subscriberTooSlowPolicy = iox::popo::ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER;\n</code></pre> <p>With this option set, it is possible that a slow subscriber blocks a publisher indefinitely due to the busy waiting loop. In order to be able to gracefully shut down the application with <code>Ctrl+C</code>, the publisher needs to be unblocked. To achieve this, we publish the data in a background thread so that we can initiate the shutdown of the runtime:</p>  <pre><code>iox::runtime::PoshRuntime::getInstance().shutdown();\n</code></pre>","title":"Publisher"},{"location":"examples/iceoptions/#subscriber","text":"<p>To configure a subscriber, we have to supply a struct of the type <code>iox::popo::SubscriberOptions</code> as a second parameter.</p>  <pre><code>iox::popo::Subscriber&lt;RadarObject&gt; subscriber({\"Radar\", \"FrontLeft\", \"Object\"}, subscriberOptions);\n</code></pre> <p>The <code>queueCapacity</code> parameter specifies how many samples the queue of the subscriber object can hold. If the queue would encounter an overflow, the oldest sample is released to create space for the newest one, which is then stored. The queue behaves like a circular buffer.</p>  <pre><code>subscriberOptions.queueCapacity = 10U;\n</code></pre> <p><code>historyRequest</code> will enable a subscriber to receive the last n samples of matching publishers on subscription e.g. in case it was started later than the publisher. If the publisher does not have a sufficient <code>historyCapacity</code> (smaller than <code>historyRequest</code>), it will still be connected but we will not be able to receive the requested amount of historical data (if it was available). Instead we will receive the largest amount of historical sample the publisher has available, i.e. best-effort. In particular we will be connected to a publisher with <code>historyCapacity</code> = 0.</p> <p>If we want to enforce the contract that the publisher needs to support a <code>historyCapacity</code>, we can do so by setting <code>requirePublisherHistorySupport</code> to <code>true</code>. In this case, the subscriber will only connect if the publisher history support is at least 1, i.e. <code>historyCapacity</code> &gt; 0. By default this is set to <code>false</code> and best-effort behavior is used.</p>  <p>Warning</p> <p>In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time! For more information about this limitation see the QoS article.</p>   <pre><code>subscriberOptions.historyRequest = 5U;\n\nsubscriberOptions.requiresPublisherHistorySupport = false;\n</code></pre> <p>Topics are automatically subscribed on creation. If you want to disable that feature and control the subscription yourself, set <code>subscribeOnCreate</code> appropriately:</p>  <pre><code>subscriberOptions.subscribeOnCreate = false;\n</code></pre> <p>Due to the disabled <code>subscribeOnCreate</code> feature, don't forget to subscribe to our topic:</p>  <pre><code>subscriber.subscribe();\n</code></pre> <p>Again, for organising subscribers inside an application, a <code>nodeName</code> can be applied:</p>  <pre><code>subscriberOptions.nodeName = \"Sub_Node_With_Options\";\n</code></pre> <p>To ensure that samples are never lost, we request the publisher to busy-wait, in case of a full queue:</p>  <pre><code>subscriberOptions.queueFullPolicy = iox::popo::QueueFullPolicy::BLOCK_PRODUCER;\n</code></pre> <p> Check out iceoptions on GitHub  </p>","title":"Subscriber"},{"location":"examples/iceperf/","text":"","title":"iceperf"},{"location":"examples/iceperf/#introduction","text":"<p>Note</p> <p>Since not all IPC mechanisms are supported on all platforms the IPC benchmark only runs fully on QNX and Linux. The iceoryx C or C++ API related benchmark is supported on all platforms.</p>  <p>This example measures the latency of IPC transmissions between two applications. We compare the latency of iceoryx with message queues and unix domain sockets.</p> <p>The measurement is carried out with several payload sizes. Round trips are performed for each payload size, using either the default setting or the provided command line parameter for the number of round trips to do. The time measurement only considers the time to allocate/release memory and the time to send the data. The construction and initialization of the payload is not part of the measurement.</p> <p>At the end of the benchmark, the average latency for each payload size is printed.</p>","title":"Introduction"},{"location":"examples/iceperf/#run-iceperf","text":"<p>Create three terminals and run one command in each of them. In this setup the leader is doing the ping pong measurements with the follower. You can set the number of measurement iterations (number of round trips) with a command line parameter of iceperf-bench-leader (e.g. <code>./iceperf-bench-leader -n 100000</code>). There are further options which can be printed by calling <code>./iceperf-bench-leader -h</code>.</p> <pre><code>    # If installed and available in PATH environment variable\n    iox-roudi\n    # If build from scratch with script in tools\n    $ICEORYX_ROOT/build/install/prefix/bin/iox-roudi\n\n    build/iceoryx_examples/iceperf/iceperf-bench-follower\n\n    build/iceoryx_examples/iceperf/iceperf-bench-leader\n</code></pre> <p>If you would like to test only the C++ API or the C API you can start <code>iceperf-bench-leader</code> with the parameter <code>-t iceoryx-cpp-api</code> or <code>-t iceoryx-c-api</code>.</p> <pre><code>    build/iceoryx_examples/iceperf/iceperf-bench-follower\n\n    build/iceoryx_examples/iceperf/iceperf-bench-leader -n 100000 -t iceoryx-cpp-api\n</code></pre>","title":"Run iceperf"},{"location":"examples/iceperf/#expected-output","text":"<p>The measured transmission modes depend on the operating system (e.g. no message queue on MacOS). The measurements depend on the benchmark parameters and the hardware.</p> <p>The following shows an example output with Ubuntu 18.04 on Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz.</p>","title":"Expected Output"},{"location":"examples/iceperf/#iceperf-bench-leader-application","text":"<pre><code>******   MESSAGE QUEUE    ********\nWaiting for: subscription, subscriber [ success ]\nMeasurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB,\n512 kB, 1024 kB, 2048 kB, 4096 kB\nWaiting for: unsubscribe  [ finished ]\n\n#### Measurement Result ####\n100000 round trips for each payload.\n\n| Payload Size [kB] | Average Latency [\u00b5s] |\n|------------------:|---------------------:|\n|                 1 |                  3.1 |\n|                 2 |                  3.2 |\n|                 4 |                  3.8 |\n|                 8 |                  5.2 |\n|                16 |                  7.7 |\n|                32 |                   13 |\n|                64 |                   23 |\n|               128 |                   43 |\n|               256 |                   81 |\n|               512 |              1.6e+02 |\n|              1024 |                3e+02 |\n|              2048 |              5.9e+02 |\n|              4096 |              1.2e+03 |\n\nFinished!\n\n****** UNIX DOMAIN SOCKET ********\nWaiting for: subscription, subscriber [ success ]\nMeasurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB,\n512 kB, 1024 kB, 2048 kB, 4096 kB\nWaiting for: unsubscribe  [ finished ]\n\n#### Measurement Result ####\n100000 round trips for each payload.\n\n| Payload Size [kB] | Average Latency [\u00b5s] |\n|------------------:|---------------------:|\n|                 1 |                  4.3 |\n|                 2 |                  4.3 |\n|                 4 |                  4.6 |\n|                 8 |                    6 |\n|                16 |                  8.7 |\n|                32 |                   14 |\n|                64 |                   27 |\n|               128 |                   53 |\n|               256 |              1.1e+02 |\n|               512 |              2.1e+02 |\n|              1024 |              4.2e+02 |\n|              2048 |              8.4e+02 |\n|              4096 |              1.7e+03 |\n\nFinished!\n\n******      ICEORYX       ********\nWaiting for: subscription, subscriber [ success ]\nMeasurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB,\n512 kB, 1024 kB, 2048 kB, 4096 kB\nWaiting for: unsubscribe  [ finished ]\n\n#### Measurement Result ####\n100000 round trips for each payload.\n\n| Payload Size [kB] | Average Latency [\u00b5s] |\n|------------------:|---------------------:|\n|                 1 |                 0.73 |\n|                 2 |                 0.58 |\n|                 4 |                 0.61 |\n|                 8 |                 0.61 |\n|                16 |                 0.59 |\n|                32 |                 0.62 |\n|                64 |                  0.6 |\n|               128 |                 0.58 |\n|               256 |                 0.61 |\n|               512 |                 0.61 |\n|              1024 |                 0.58 |\n|              2048 |                 0.61 |\n|              4096 |                 0.61 |\n\nFinished!\n\n******   ICEORYX C API    ********\nWaiting for: subscription, subscriber [ success ]\nMeasurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB,\n512 kB, 1024 kB, 2048 kB, 4096 kB\nWaiting for: unsubscribe  [ finished ]\n\n#### Measurement Result ####\n100000 round trips for each payload.\n\n| Payload Size [kB] | Average Latency [\u00b5s] |\n|------------------:|---------------------:|\n|                 1 |                 0.73 |\n|                 2 |                 0.58 |\n|                 4 |                 0.61 |\n|                 8 |                 0.61 |\n|                16 |                 0.59 |\n|                32 |                 0.62 |\n|                64 |                  0.6 |\n|               128 |                 0.58 |\n|               256 |                 0.61 |\n|               512 |                 0.61 |\n|              1024 |                 0.58 |\n|              2048 |                 0.61 |\n|              4096 |                 0.61 |\n\nFinished!\n</code></pre>","title":"iceperf-bench-leader Application"},{"location":"examples/iceperf/#iceperf-bench-follower-application","text":"<pre><code>******   MESSAGE QUEUE    ********\nregistering with the leader\n\n****** UNIX DOMAIN SOCKET ********\nregistering with the leader\n\n******      ICEORYX       ********\nWaiting for: subscription, subscriber [ success ]\nWaiting for: unsubscribe  [ finished ]\n\n******   ICEORYX C API    ********\nWaiting for: subscription, subscriber [ success ]\nWaiting for: unsubscribe  [ finished ]\n</code></pre>","title":"iceperf-bench-follower Application"},{"location":"examples/iceperf/#code-walkthrough","text":"<p>Here we briefly describe the setup for performing the measurements in <code>iceperf_bench_leader.hpp/cpp</code> and <code>iceperf_bench_follower.hpp/cpp</code>. Things like initialization, sending and receiving of data are technology specific and can be found in the respective files (e.g. uds.cpp for unix domain socket). Our focus here is on the top-most abstraction layer which allows us to add new IPC technologies to extend and compare them.</p>","title":"Code Walkthrough"},{"location":"examples/iceperf/#iceperf-bench-leader-application-code","text":"<p>Apart from headers for the different IPC technologies, the <code>topic_data.hpp</code> file is included which contains the <code>PerSettings</code> and <code>PerTopic</code> structs. These are used to transfer some information between the applications. The <code>PerTopic</code> struct is used as some kind of header in each transferred sample and is independent of the payload size.</p>  <pre><code>struct PerfSettings\n{\n    Benchmark benchmark{Benchmark::ALL};\n    Technology technology{Technology::ALL};\n    uint64_t numberOfSamples{10000U};\n};\n\nstruct PerfTopic\n{\n    uint32_t payloadSize{0};\n    uint32_t subPackets{0};\n    RunFlag runFlag{RunFlag::RUN};\n};\n</code></pre> <p>The <code>PerfSettings</code> struct is used to synchronize the settings between the leader and the follower application.</p> <p>The <code>PerfTopic</code> struct is used to share some information during the measurement. It contains <code>payloadSize</code> to specify the payload size used for the current measurement. If it is not possible to transmit the <code>payloadSize</code> with a single data transfer (e.g. OS limit for the payload of a single socket send), the payload is divided into several sub-packets. This is indicated with <code>subPackets</code>. The <code>runFlag</code> is used to shut down the iceperf-bench follower at the end of the benchmark.</p> <p>Let's use some constants to prevent magic values and set and names for the communication resources that are used.</p>  <pre><code>constexpr const char APP_NAME[]{\"iceperf-bench-leader\"};\nconstexpr const char PUBLISHER[]{\"Leader\"};\nconstexpr const char SUBSCRIBER[]{\"Follower\"};\n</code></pre> <p>The <code>IcePerfLeader</code> c'tor does a cleanup of potentially outdated resources of technologies which might have left some resources in the file system after an abnormal terminations.</p>  <pre><code>#ifndef __APPLE__\nMQ::cleanupOutdatedResources(PUBLISHER, SUBSCRIBER);\n#endif\nUDS::cleanupOutdatedResources(PUBLISHER, SUBSCRIBER);\n</code></pre> <p>The <code>doMeasurement()</code> method executes a measurement for the provided IPC technology and number of round trips. To be able to always perform the same steps and avoiding code duplications, we use a base class with technology independent functionality and the technology has to implement the technology dependent part.</p>  <pre><code>void IcePerfLeader::doMeasurement(IcePerfBase&amp; ipcTechnology) noexcept\n{\n    ipcTechnology.initLeader();\n\n    std::vector&lt;std::tuple&lt;uint32_t, iox::units::Duration&gt;&gt; latencyMeasurements;\n    const std::vector&lt;uint32_t&gt; payloadSizesInKB{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096};\n    std::cout &lt;&lt; \"Measurement for:\";\n    const char* separator = \" \";\n    for (const auto payloadSizeInKB : payloadSizesInKB)\n    {\n        std::cout &lt;&lt; separator &lt;&lt; payloadSizeInKB &lt;&lt; \" kB\" &lt;&lt; std::flush;\n        separator = \", \";\n        auto payloadSizeInBytes = payloadSizeInKB * IcePerfBase::ONE_KILOBYTE;\n\n        ipcTechnology.preLatencyPerfTestLeader(payloadSizeInBytes);\n\n        auto latency = ipcTechnology.latencyPerfTestLeader(m_settings.numberOfSamples);\n\n        latencyMeasurements.push_back(std::make_tuple(payloadSizeInKB, latency));\n\n        ipcTechnology.postLatencyPerfTestLeader();\n    }\n    std::cout &lt;&lt; std::endl;\n\n    ipcTechnology.releaseFollower();\n\n    ipcTechnology.shutdown();\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"#### Measurement Result ####\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; m_settings.numberOfSamples &lt;&lt; \" round trips for each payload.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"| Payload Size [kB] | Average Latency [\u00b5s] |\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"|------------------:|---------------------:|\" &lt;&lt; std::endl;\n    for (const auto&amp; latencyMeasuement : latencyMeasurements)\n    {\n        auto payloadSizeInKB = std::get&lt;0&gt;(latencyMeasuement);\n        auto latencyInMicroseconds = static_cast&lt;double&gt;(std::get&lt;1&gt;(latencyMeasuement).toNanoseconds()) / 1000.0;\n        std::cout &lt;&lt; \"| \" &lt;&lt; std::setw(17) &lt;&lt; payloadSizeInKB &lt;&lt; \" | \" &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(2)\n                  &lt;&lt; latencyInMicroseconds &lt;&lt; \" |\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Finished!\" &lt;&lt; std::endl;\n}\n</code></pre> <p>Initialization is different for each IPC technology. Here we have to create sockets, message queues or iceoryx publisher and subscriber. With <code>ipcTechnology.initLeader()</code> we set up these resources on the leader side. After the definition of the different payload sizes to use, we execute a single round trip measurement for each individual payload size. The leader has to orchestrate the whole process and has a pre- and post-step for each round trip measurement. <code>ipcTechnology.preLatencyPerfTestLeader(...)</code> sets the payload size for the upcoming measurement. <code>ipcTechnology.latencyPerfTestLeader(m_settings.numberOfSamples)</code> performs the data exchange between leader and follower and returns the time it took to transmit the number of samples in a round trip. After the measurements are taken for each payload size, <code>ipcTechnology.releaseFollower()</code> releases the follower. This is required since the follower is not aware of the benchmark settings, e.g. how many payload sizes are considered and hence we need to issue a shutdown. We clean up the communication resources with <code>ipcTechnology.shutdown()</code> before we print the results.</p> <p>In the <code>run()</code> method we create instances for the different IPC technologies we want to compare. Each technology is implemented in its own class and implements the pure virtual functions provided with the <code>IcePerfBase</code> class. Before this is done, we send the <code>PerfSettings</code> to the follower application.</p>  <pre><code>int IcePerfLeader::run() noexcept\n{\n    iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n\n    iox::capro::ServiceDescription serviceDescription{\"IcePerf\", \"Settings\", \"Generic\"};\n    iox::popo::PublisherOptions options;\n    options.historyCapacity = 1U;\n    iox::popo::Publisher&lt;PerfSettings&gt; settingsPublisher{serviceDescription, options};\n    if (!settingsPublisher.publishCopyOf(m_settings))\n    {\n        std::cerr &lt;&lt; \"Could not send settings to follower!\" &lt;&lt; std::endl;\n        return EXIT_FAILURE;\n    }\n    // ...\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Now we can create an object for each IPC technology that we want to evaluate and call the <code>doMeasurement()</code> method.</p>  <pre><code>int IcePerfLeader::run() noexcept\n{\n    iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n    // ...\n    if (m_settings.technology == Technology::ALL || m_settings.technology == Technology::POSIX_MESSAGE_QUEUE)\n    {\n#ifndef __APPLE__\n        std::cout &lt;&lt; std::endl &lt;&lt; \"******   MESSAGE QUEUE    ********\" &lt;&lt; std::endl;\n        MQ mq(PUBLISHER, SUBSCRIBER);\n        doMeasurement(mq);\n#else\n        if (m_settings.technology == Technology::POSIX_MESSAGE_QUEUE)\n        {\n            std::cout &lt;&lt; \"The message queue is not supported on macOS and will be skipped!\" &lt;&lt; std::endl;\n        }\n#endif\n    }\n\n    if (m_settings.technology == Technology::ALL || m_settings.technology == Technology::UNIX_DOMAIN_SOCKET)\n    {\n        std::cout &lt;&lt; std::endl &lt;&lt; \"****** UNIX DOMAIN SOCKET ********\" &lt;&lt; std::endl;\n        UDS uds(PUBLISHER, SUBSCRIBER);\n        doMeasurement(uds);\n    }\n\n    if (m_settings.technology == Technology::ALL || m_settings.technology == Technology::ICEORYX_CPP_API)\n    {\n        std::cout &lt;&lt; std::endl &lt;&lt; \"******      ICEORYX       ********\" &lt;&lt; std::endl;\n        Iceoryx iceoryx(PUBLISHER, SUBSCRIBER);\n        doMeasurement(iceoryx);\n    }\n\n    if (m_settings.technology == Technology::ALL || m_settings.technology == Technology::ICEORYX_C_API)\n    {\n        std::cout &lt;&lt; std::endl &lt;&lt; \"******   ICEORYX C API    ********\" &lt;&lt; std::endl;\n        IceoryxC iceoryxc(PUBLISHER, SUBSCRIBER);\n        doMeasurement(iceoryxc);\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre>","title":"iceperf-bench-leader Application Code"},{"location":"examples/iceperf/#iceperf_bench_follower-application","text":"<p>The <code>iceperf-bench-follower</code> application is similar to <code>iceperf-bench-leader</code>. The first change is that the <code>SUBSCRIBER</code> and <code>PUBLISHER</code> switch their names.</p>  <pre><code>constexpr const char APP_NAME[]{\"iceperf-bench-follower\"};\nconstexpr const char PUBLISHER[]{\"Follower\"};\nconstexpr const char SUBSCRIBER[]{\"Leader\"};\n</code></pre> <p>While the <code>run()</code> method of the leader publishes the <code>PerfSettings</code>, the follower is subscribed to those settings and waits for them before the technologies are created, which is done similarly as for the leader.</p>  <pre><code>int IcePerfFollower::run() noexcept\n{\n    iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n\n    iox::capro::ServiceDescription serviceDescription{\"IcePerf\", \"Settings\", \"Generic\"};\n    iox::popo::SubscriberOptions options;\n    options.historyRequest = 1U;\n    iox::popo::Subscriber&lt;PerfSettings&gt; settingsSubscriber{serviceDescription, options};\n\n    m_settings = getSettings(settingsSubscriber);\n    // ...\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>The <code>doMeasurement()</code> method is much simpler than the one from the leader, since it only has to react on incoming data. Apart from <code>ipcTechnology.initFollower()</code> and <code>ipcTechnology.shutdown()</code> all the functionality to perform the round trip for different payload sizes is contained in <code>ipcTechnology.latencyPerfTestFollower()</code></p>  <pre><code>void IcePerfFollower::doMeasurement(IcePerfBase&amp; ipcTechnology) noexcept\n{\n    ipcTechnology.initFollower();\n\n    ipcTechnology.latencyPerfTestFollower();\n\n    ipcTechnology.shutdown();\n}\n</code></pre> <p> Check out iceperf on GitHub  </p>","title":"iceperf_bench_follower Application"},{"location":"examples/request_response/","text":"","title":"Request response"},{"location":"examples/request_response/#introduction","text":"<p>This example demonstrates how to use iceoryx in a client-server architecture using the request-response communication pattern. The client sends a request with two consecutive fibonacci numbers and the server responds with the next number in the sequence.</p> <p>We provide three examples, the very basic typed and untyped examples and the most natural setup combining a server with a Listener and a client using a WaitSet. Since you can find the general setup and functionality of the client and the server also in the Listener/WaitSet example, we will describe only this one.</p>","title":"Introduction"},{"location":"examples/request_response/#expected-output","text":"<p></p>","title":"Expected output"},{"location":"examples/request_response/#code-walkthrough","text":"<p>In the following scenario the client (client_cxx_waitset.cpp) uses the WaitSet to wait for a response from the server (server_cxx_listener.cpp). The server uses the Listener API to take and process the requests from the client.</p> <p>The client is inspired by the <code>iox-cpp-waitset-basic</code> example from the WaitSet example and the server from the <code>iox-cpp-callbacks-subscriber</code> in the Listener example.</p> <p>This is the most recommended way to create an efficient client-server combination with iceoryx.</p>","title":"Code walkthrough"},{"location":"examples/request_response/#client-using-waitset","text":"<p>At first, the includes for the client port, request-response types, WaitSet, and runtime are needed.</p>  <pre><code>#include \"request_and_response_types.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/client.hpp\"\n#include \"iceoryx_posh/popo/wait_set.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>Afterwards we prepare some <code>ContextData</code> where we can store the Fibonacci numbers and the sequence ids that we use to ensure the correct ordering of the responses.</p>  <pre><code>struct ContextData\n{\n    uint64_t fibonacciLast = 0;\n    uint64_t fibonacciCurrent = 1;\n    int64_t requestSequenceId = 0;\n    int64_t expectedResponseSequenceId = requestSequenceId;\n};\n</code></pre> <p>Next, the iceoryx runtime is initialized. With this call, the application will be registered at <code>RouDi</code>, the routing and discovery daemon.</p>  <pre><code>iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>After creating the runtime, the client is created and attached to the WaitSet. The options can be used to alter the behavior of the client, like setting the response queue capacity or blocking behavior when the response queue is full or the server is too slow. The <code>ClientOptions</code> are similar to <code>PublisherOptions</code>/<code>SubscriberOptions</code>.</p>  <pre><code>iox::popo::WaitSet&lt;&gt; waitset;\n\niox::popo::ClientOptions options;\noptions.responseQueueCapacity = 2U;\niox::popo::Client&lt;AddRequest, AddResponse&gt; client({\"Example\", \"Request-Response\", \"Add\"}, options);\n\n// attach client to waitset\nwaitset.attachState(client, iox::popo::ClientState::HAS_RESPONSE).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach client\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>Since the client requests the sum of two numbers from the server, we provide the structs <code>AddRequest</code> and <code>AddResponse</code> as template parameters. When the sum is received, it is re-used as the <code>addend</code> of the next request to send. This calculates a Fibonacci sequence.</p>  <pre><code>struct AddRequest\n{\n    uint64_t augend{0};\n    uint64_t addend{0};\n};\n</code></pre>  <pre><code>struct AddResponse\n{\n    uint64_t sum{0};\n};\n</code></pre> <p>In the main loop, the client prepares first a request using the <code>loan()</code> API. The request is a sample consisting of the two numbers <code>augend</code> and <code>addend</code> that the server shall sum up. Additionally, the sample is marked with a sequence id that is incremented before every send cycle to ensure a correct ordering of the messages. The request is transmitted to the server via the <code>send()</code> API.</p>  <pre><code>client.loan()\n    .and_then([&amp;](auto&amp; request) {\n        request.getRequestHeader().setSequenceId(ctx.requestSequenceId);\n        ctx.expectedResponseSequenceId = ctx.requestSequenceId;\n        ctx.requestSequenceId += 1;\n        request-&gt;augend = ctx.fibonacciLast;\n        request-&gt;addend = ctx.fibonacciCurrent;\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" Send Request: \" &lt;&lt; ctx.fibonacciLast &lt;&lt; \" + \" &lt;&lt; ctx.fibonacciCurrent\n                  &lt;&lt; std::endl;\n        request.send().or_else(\n            [&amp;](auto&amp; error) { std::cout &lt;&lt; \"Could not send Request! Error: \" &lt;&lt; error &lt;&lt; std::endl; });\n    })\n    .or_else([](auto&amp; error) { std::cout &lt;&lt; \"Could not allocate Request! Error: \" &lt;&lt; error &lt;&lt; std::endl; });\n</code></pre> <p>Once the request has been sent, we block and wait for samples to arrive. Then we iterate over the notification vector to check if we were triggered from our client:</p>  <pre><code>auto notificationVector = waitset.timedWait(iox::units::Duration::fromSeconds(5));\n\nfor (auto&amp; notification : notificationVector)\n{\n    if (notification-&gt;doesOriginateFrom(&amp;client))\n    {\n        // ...\n    }\n}\n</code></pre> <p>The client receives the responses from the server using <code>take()</code> and extracts the sequence id with <code>response.getResponseHeader().getSequenceId()</code>. When the server response comes in the correct order, the received sum is stored in the <code>ContextData</code> struct <code>ctx</code> for usage in the next request.</p>  <pre><code>while (client.take().and_then([&amp;](const auto&amp; response) {\n    auto receivedSequenceId = response.getResponseHeader().getSequenceId();\n    if (receivedSequenceId == ctx.expectedResponseSequenceId)\n    {\n        ctx.fibonacciLast = ctx.fibonacciCurrent;\n        ctx.fibonacciCurrent = response-&gt;sum;\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" Got Response : \" &lt;&lt; ctx.fibonacciCurrent &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"Got Response with outdated sequence ID! Expected = \"\n                  &lt;&lt; ctx.expectedResponseSequenceId &lt;&lt; \"; Actual = \" &lt;&lt; receivedSequenceId\n                  &lt;&lt; \"! -&gt; skip\" &lt;&lt; std::endl;\n    }\n}))\n{\n}\n</code></pre>","title":"Client using WaitSet"},{"location":"examples/request_response/#server-using-listener","text":"<p>At first, the includes for the server port, Listener, request-response types and runtime are needed.</p>  <pre><code>#include \"request_and_response_types.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/listener.hpp\"\n#include \"iceoryx_posh/popo/server.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>Then a callback is created that shall be called when the server receives a request. In this case the calculation and the sending of the response is done in the Listener callback. If there are more resource-consuming tasks, this could also be outsourced with a thread pool to handle the requests.</p>  <pre><code>void onRequestReceived(iox::popo::Server&lt;AddRequest, AddResponse&gt;* server)\n{\n    while (server-&gt;take().and_then([&amp;](const auto&amp; request) {\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" Got Request: \" &lt;&lt; request-&gt;augend &lt;&lt; \" + \" &lt;&lt; request-&gt;addend &lt;&lt; std::endl;\n\n        server-&gt;loan(request)\n            .and_then([&amp;](auto&amp; response) {\n                response-&gt;sum = request-&gt;augend + request-&gt;addend;\n                std::cout &lt;&lt; APP_NAME &lt;&lt; \" Send Response: \" &lt;&lt; response-&gt;sum &lt;&lt; std::endl;\n                response.send().or_else(\n                    [&amp;](auto&amp; error) { std::cout &lt;&lt; \"Could not send Response! Error: \" &lt;&lt; error &lt;&lt; std::endl; });\n            })\n            .or_else([](auto&amp; error) { std::cout &lt;&lt; \"Could not allocate Response! Error: \" &lt;&lt; error &lt;&lt; std::endl; });\n    }))\n    {\n    }\n}\n</code></pre> <p>The server provides the <code>take()</code> method for receiving requests and the <code>loan()</code> and <code>send()</code> methods for sending the responses with the sum of the two numbers.</p> <p>Next, the iceoryx runtime is initialized.</p>  <pre><code>iox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>After creating the runtime, the server port is created based on a <code>ServiceDescription</code>. Similar to the client, the <code>options</code> are used to alter the behavior of the server, like setting the request queue capacity or blocking behavior when the request queue is full or the client is too slow.</p>  <pre><code>iox::popo::ServerOptions options;\noptions.requestQueueCapacity = 10U;\niox::popo::Server&lt;AddRequest, AddResponse&gt; server({\"Example\", \"Request-Response\", \"Add\"}, options);\n</code></pre> <p>Now we want to listen to an incoming server event and call the previously created callback whenever a request has been received. This is done with the following call:</p>  <pre><code>listener\n    .attachEvent(\n        server, iox::popo::ServerEvent::REQUEST_RECEIVED, iox::popo::createNotificationCallback(onRequestReceived))\n    .or_else([](auto) {\n        std::cerr &lt;&lt; \"unable to attach server\" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    });\n</code></pre> <p>With that the preparation is done and the main thread can just sleep or do other things:</p>  <pre><code>iox::posix::waitForTerminationRequest();\n</code></pre> <p>Once the user wants to shutdown the server, the server event is detached from the listener:</p>  <pre><code>listener.detachEvent(server, iox::popo::ServerEvent::REQUEST_RECEIVED);\n</code></pre> <p> Check out request_response on GitHub  </p>","title":"Server using Listener"},{"location":"examples/request_response_in_c/","text":"<p>You can find a more detailed description of the C API in the iceoryx_binding_c README.md.</p>","title":"Request response in C"},{"location":"examples/request_response_in_c/#introduction","text":"<p>The behavior and structure is very close to the request response C++ example so that we explain here only the C API differences and not the underlying mechanisms.</p> <p>The rough idea is that the client sends two fibonacci numbers to the server which then sends the sum of those numbers back.</p>","title":"Introduction"},{"location":"examples/request_response_in_c/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/request_response_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/request_response_in_c/#client-basic","text":"<p>Like with most iceoryx C applications we start with:</p> <ul> <li>Registering a signal handler</li> <li>Initialize the runtime</li> </ul>  <pre><code>signal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n\niox_runtime_init(APP_NAME);\n</code></pre> <p>We continue with initializing our <code>client</code> to send requests to the server. First of all, we need some memory in which the client can be stored called <code>clientStorage</code>. <code>iox_client_init</code> will create an object in this memory location, sets the service description and uses the default client options which is indicated by the <code>NULL</code> argument at the end.</p>  <pre><code>iox_client_storage_t clientStorage;\niox_client_t client = iox_client_init(&amp;clientStorage, \"Example\", \"Request-Response\", \"Add\", NULL);\n</code></pre> <p>Like in the C++ version of our example we implement a client/server based fibonacci algorithm and store the first two fibonacci numbers in <code>fibonacciLast</code> and <code>fibonacciCurrent</code>. <code>requestSequenceId</code> and <code>expectedResponseSequenceId</code> are helping us to keep track of the sequence number which we increase with every sent request and then verify it again in the server's response.</p>  <pre><code>uint64_t fibonacciLast = 0U;\nuint64_t fibonacciCurrent = 1U;\nint64_t requestSequenceId = 0;\nint64_t expectedResponseSequenceId = requestSequenceId;\n</code></pre> <p>We enter our main loop and continue sending requests as long as <code>keepRunning</code> is <code>true</code>. When the users presses Control+C the term signal is emitted and <code>keepRunning</code> is set to <code>false</code> via the signal handler callback.</p> <p>We start by loaning memory to send out our <code>request</code>.</p>  <pre><code>struct AddRequest* request = NULL;\nenum iox_AllocationResult loanResult =\n    iox_client_loan_request(client, (void**)&amp;request, sizeof(struct AddRequest));\n</code></pre> <p>To set the sequence id we have to acquire the request header first from the payload. Additionally, we set <code>expectedResponseSequenceId</code> so that we can verify the response later and increment the <code>requestSequenceId</code> for the next run.</p>  <pre><code>iox_request_header_t requestHeader = iox_request_header_from_payload(request);\niox_request_header_set_sequence_id(requestHeader, requestSequenceId);\nexpectedResponseSequenceId = requestSequenceId;\nrequestSequenceId += 1;\n</code></pre> <p>Before we can send out the <code>request</code> we have to set the two fibonacci numbers.</p>  <pre><code>request-&gt;augend = fibonacciLast;\nrequest-&gt;addend = fibonacciCurrent;\nprintf(\"%s Send Request: %lu + %lu\\n\",\n       APP_NAME,\n       (unsigned long)fibonacciLast,\n       (unsigned long)fibonacciCurrent);\nenum iox_ClientSendResult sendResult = iox_client_send(client, request);\nif (sendResult != ClientSendResult_SUCCESS)\n{\n    printf(\"Error sending Request! Error code: %d\\n\", sendResult);\n}\n</code></pre> <p>Now we give the server a little time to process the <code>request</code>.</p>  <pre><code>const uint32_t DELAY_TIME_IN_MS = 150U;\nsleep_for(DELAY_TIME_IN_MS);\n</code></pre> <p>We process the <code>response</code> by acquiring it first with <code>iox_client_take_response</code>. If this is successful we verify the sequence number, adjust our fibonacci numbers and print our response to the console. When the sequence number does not fulfill our expectation we print an error message.</p>  <pre><code>const struct AddResponse* response = NULL;\nwhile (iox_client_take_response(client, (const void**)&amp;response) == ChunkReceiveResult_SUCCESS)\n{\n    iox_const_response_header_t responseHeader = iox_response_header_from_payload_const(response);\n    int64_t receivedSequenceId = iox_response_header_get_sequence_id_const(responseHeader);\n    if (receivedSequenceId == expectedResponseSequenceId)\n    {\n        fibonacciLast = fibonacciCurrent;\n        fibonacciCurrent = response-&gt;sum;\n        printf(\"%s Got Response: %lu\\n\", APP_NAME, (unsigned long)fibonacciCurrent);\n    }\n    else\n    {\n        printf(\"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -&gt; skip\\n\",\n               (unsigned long)expectedResponseSequenceId,\n               (unsigned long)receivedSequenceId);\n    }\n\n    iox_client_release_response(client, response);\n}\n</code></pre> <p>Please do not forget to call <code>iox_client_release_response</code> to release the <code>response</code> again. If you forget this you won't be able to receive <code>response</code>s anymore after a certain time since you hold to many responses in parallel.</p> <p>As final step we cleanup the used resources and deinitialize the client.</p>  <pre><code>iox_client_deinit(client);\n</code></pre>","title":"Client Basic"},{"location":"examples/request_response_in_c/#client-waitset","text":"<p>The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the client basic example with a waitset. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example.</p> <p>The startup phase is identical to the client basic version, we register the signal handlers, initialize the runtime, create a client and initialize our variables. Afterwards we create our waitset and attach the client state <code>ClientState_HAS_RESPONSE</code> to it.</p>  <pre><code>iox_ws_storage_t waitsetStorage;\niox_ws_t waitset = iox_ws_init(&amp;waitsetStorage);\n\nif (iox_ws_attach_client_state(waitset, client, ClientState_HAS_RESPONSE, 0U, NULL) != WaitSetResult_SUCCESS)\n{\n    printf(\"failed to attach client\\n\");\n    _exit(-1);\n}\n</code></pre> <p>Again we perform the same task like in the client basic example. We enter our main loop, loan a request and set it up. But after we sent the request to our server we do not sleep for some time, we wait on the waitset until the request was received. We use <code>iox_ws_timed_wait</code> to wait for at most 2 seconds.</p>  <pre><code>iox_notification_info_t notificationArray[NUMBER_OF_NOTIFICATIONS];\nuint64_t missedNotifications = 0U;\nstruct timespec timeout;\ntimeout.tv_sec = 2;\ntimeout.tv_nsec = 0;\n\nuint64_t numberOfNotifications =\n    iox_ws_timed_wait(waitset, timeout, notificationArray, NUMBER_OF_NOTIFICATIONS, &amp;missedNotifications);\n</code></pre> <p>When this blocking call returns we iterate over the <code>notificationArray</code> and when one triggered originated from our <code>client</code> we acquire all responses in a while loop and print them to the console.</p>  <pre><code>for (uint64_t i = 0; i &lt; numberOfNotifications; ++i)\n{\n    if (iox_notification_info_does_originate_from_client(notificationArray[i], client))\n    {\n        const struct AddResponse* response = NULL;\n        while (iox_client_take_response(client, (const void**)&amp;response) == ChunkReceiveResult_SUCCESS)\n        {\n            iox_const_response_header_t responseHeader = iox_response_header_from_payload_const(response);\n            int64_t receivedSequenceId = iox_response_header_get_sequence_id_const(responseHeader);\n            if (receivedSequenceId == expectedResponseSequenceId)\n            {\n                fibonacciLast = fibonacciCurrent;\n                fibonacciCurrent = response-&gt;sum;\n                printf(\"%s Got Response: %lu\\n\", APP_NAME, (unsigned long)fibonacciCurrent);\n            }\n            else\n            {\n                printf(\"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -&gt; skip\\n\",\n                       (unsigned long)expectedResponseSequenceId,\n                       (unsigned long)receivedSequenceId);\n            }\n            iox_client_release_response(client, response);\n        }\n    }\n}\n</code></pre> <p>The cleanup is done when we exit our mainloop. We detach the client state from the waitset first and then deinitialize the waitset and the client.</p>  <pre><code>iox_ws_detach_client_state(waitset, client, ClientState_HAS_RESPONSE);\niox_ws_deinit(waitset);\niox_client_deinit(client);\n</code></pre>","title":"Client WaitSet"},{"location":"examples/request_response_in_c/#server-basic","text":"<p>We again start with registering the signal handler and the runtime.</p>  <pre><code>signal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n\niox_runtime_init(APP_NAME);\n</code></pre> <p>As next step we initialize the <code>server</code>. Like the client the <code>server</code> requires some memory where it can be stored, the <code>serverStorage</code>. The <code>server</code> is also initialized with the default options which is indicated via the last <code>NULL</code> argument.</p>  <pre><code>iox_server_storage_t serverStorage;\niox_server_t server = iox_server_init(&amp;serverStorage, \"Example\", \"Request-Response\", \"Add\", NULL);\n</code></pre> <p>We enter the main loop and start it by taking a <code>request</code>. If it was taken successfully, we print an info message to the console and loan a <code>response</code>. We require the <code>request</code> for the loan so that the <code>response</code> can be delivered to the corresponding client. When the <code>iox_server_loan_response</code> was successful we calculate the sum of the two received fibonacci numbers and send it.</p>  <pre><code>const struct AddRequest* request = NULL;\nif (iox_server_take_request(server, (const void**)&amp;request) == ServerRequestResult_SUCCESS)\n{\n    printf(\"%s Got Request: %lu + %lu\\n\",\n           APP_NAME,\n           (unsigned long)request-&gt;augend,\n           (unsigned long)request-&gt;addend);\n\n    struct AddResponse* response = NULL;\n    enum iox_AllocationResult loanResult =\n        iox_server_loan_response(server, request, (void**)&amp;response, sizeof(struct AddResponse));\n    if (loanResult == AllocationResult_SUCCESS)\n    {\n        response-&gt;sum = request-&gt;augend + request-&gt;addend;\n        printf(\"%s Send Response: %lu\\n\", APP_NAME, (unsigned long)response-&gt;sum);\n        enum iox_ServerSendResult sendResult = iox_server_send(server, response);\n        if (sendResult != ServerSendResult_SUCCESS)\n        {\n            printf(\"Error sending Response! Error code: %d\\n\", sendResult);\n        }\n    }\n    else\n    {\n        printf(\"%s Could not allocate Response! Error code: %d\\n\", APP_NAME, loanResult);\n    }\n\n    iox_server_release_request(server, request);\n}\n</code></pre> <p>Again, it is important that one releases the <code>request</code> with <code>iox_server_release_request</code> otherwise <code>iox_server_take_request</code> will fail since one holds to many requests in parallel.</p> <p>The final step is again the resource cleanup where we deinitialize the server.</p>  <pre><code>iox_server_deinit(server);\n</code></pre>","title":"Server Basic"},{"location":"examples/request_response_in_c/#server-listener","text":"<p>The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the server basic example with a listener. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example.</p> <p>The listener example starts like the basic example by registering the signal handler, initializing the runtime and creating a server.</p> <p>In the next step we create a listener and attach the server event <code>ServerEvent_REQUEST_RECEIVED</code> with <code>iox_listener_attach_server_event</code>. One parameter of that call is <code>onRequestReceived</code> a pointer to a function which handles the logic whenever we receive a request.</p>  <pre><code>iox_server_storage_t serverStorage;\niox_server_t server = iox_server_init(&amp;serverStorage, \"Example\", \"Request-Response\", \"Add\", NULL);\n\niox_listener_storage_t listenerStorage;\niox_listener_t listener = iox_listener_init(&amp;listenerStorage);\n\nif (iox_listener_attach_server_event(listener, server, ServerEvent_REQUEST_RECEIVED, onRequestReceived)\n    != ListenerResult_SUCCESS)\n{\n    printf(\"unable to attach server\\n\");\n    _exit(-1);\n}\n</code></pre> <p>In the next step we run into our main loop which waits until the user terminates the process.</p>  <pre><code>while (keepRunning)\n{\n    const uint32_t SLEEP_TIME_IN_MS = 500U;\n    sleep_for(SLEEP_TIME_IN_MS);\n}\n</code></pre> <p>The actual logic behind processing a request is handled in the function <code>onRequestReceived</code> which is called in a thread inside the listener whenever our server receives a request. The code again looks identical to the server basic example. We take the request with <code>iox_server_take_request</code>, print a message to the console and then loan a response with <code>iox_server_loan_response</code> which is populated and send to the client with <code>iox_server_send</code>.</p>  <pre><code>void onRequestReceived(iox_server_t server)\n{\n    const struct AddRequest* request = NULL;\n    while (iox_server_take_request(server, (const void**)&amp;request) == ServerRequestResult_SUCCESS)\n    {\n        printf(\"%s Got Request: %lu + %lu\\n\", APP_NAME, (unsigned long)request-&gt;augend, (unsigned long)request-&gt;addend);\n\n        struct AddResponse* response = NULL;\n        enum iox_AllocationResult loanResult =\n            iox_server_loan_response(server, request, (void**)&amp;response, sizeof(struct AddResponse));\n        if (loanResult == AllocationResult_SUCCESS)\n        {\n            response-&gt;sum = request-&gt;augend + request-&gt;addend;\n            printf(\"%s Send Response: %lu\\n\", APP_NAME, (unsigned long)response-&gt;sum);\n            enum iox_ServerSendResult sendResult = iox_server_send(server, response);\n            if (sendResult != ServerSendResult_SUCCESS)\n            {\n                printf(\"Error sending Response! Error code: %d\\n\", sendResult);\n            }\n        }\n        else\n        {\n            printf(\"Could not allocate Response! Error code: %d\\n\", loanResult);\n        }\n        iox_server_release_request(server, request);\n    }\n}\n</code></pre> <p>The resource cleanup is done after our mainloop has ended. We detach the server event from the listener first and then deinitialize the listener and server.</p>  <pre><code>iox_listener_detach_server_event(listener, server, ServerEvent_REQUEST_RECEIVED);\niox_listener_deinit(listener);\niox_server_deinit(server);\n</code></pre> <p> Check out request response in c on GitHub  </p>","title":"Server Listener"},{"location":"examples/singleprocess/","text":"","title":"Single process"},{"location":"examples/singleprocess/#introduction","text":"<p>This example demonstrates how iceoryx can be used in a single process for inter-thread communication. This is for instance helpful if you would like to establish a simple communication API in a 3D engine with a multitude of threads that are interacting without starting RouDi every time separately.</p>","title":"Introduction"},{"location":"examples/singleprocess/#run-singleprocess","text":"<p></p> <p>The first lines until <code>RouDi is ready for clients</code> are coming from the RouDi startup in which the shared memory management segment and user data segment are created.</p> <p>Afterward, the publisher and subscriber thread are started and are beginning to transmit and receive data.</p>","title":"Run singleprocess"},{"location":"examples/singleprocess/#code-walkthrough","text":"","title":"Code Walkthrough"},{"location":"examples/singleprocess/#creating-a-single-process-roudi-publisher-and-subscriber","text":"<ol> <li>We start by setting the log level to error since we do not want to see all the     debug messages.</li> </ol>  <pre><code>iox::log::LogManager::GetLogManager().SetDefaultLogLevel(iox::log::LogLevel::kError);\n</code></pre> <ol> <li>To start RouDi we have to create a configuration for him. We are choosing the     default config. Additionally, RouDi needs some other components like a memory     management unit which handles how the memory is created in which the transmission     data is stored. The <code>IceOryxRouDiComponents</code> class is handling them for us</li> </ol>  <pre><code>iox::RouDiConfig_t defaultRouDiConfig = iox::RouDiConfig_t().setDefaults();\niox::roudi::IceOryxRouDiComponents roudiComponents(defaultRouDiConfig);\n</code></pre> <ol> <li>We are starting RouDi, provide the required components and     disable monitoring. The last bool parameter <code>TERMINATE_APP_IN_ROUDI_DTOR_FLAG</code>     states that RouDi does not     terminate all registered processes when RouDi goes out of scope. If we would set it     to <code>true</code>, our application would self terminate in the destructor of <code>roudi</code>.</li> </ol>  <pre><code>constexpr bool TERMINATE_APP_IN_ROUDI_DTOR_FLAG = false;\niox::roudi::RouDi roudi(\n    roudiComponents.rouDiMemoryManager,\n    roudiComponents.portManager,\n    iox::roudi::RouDi::RoudiStartupParameters{iox::roudi::MonitoringMode::OFF, TERMINATE_APP_IN_ROUDI_DTOR_FLAG});\n</code></pre> <ol> <li>Here comes a key difference to an inter-process application. If you would like     to communicate within one process, you have to use <code>PoshRuntimeSingleProcess</code>.     You can create only one runtime at a time!</li> </ol>  <pre><code>iox::runtime::PoshRuntimeSingleProcess runtime(\"singleProcessDemo\");\n</code></pre> <ol> <li>Now that everything is up and running, we can start the publisher and subscriber     thread and wait until the user terminates the application.</li> </ol>  <pre><code>std::thread publisherThread(publisher), subscriberThread(subscriber);\n\niox::posix::waitForTerminationRequest();\n\npublisherThread.join();\nsubscriberThread.join();\n\nstd::cout &lt;&lt; \"Finished\" &lt;&lt; std::endl;\n</code></pre>","title":"Creating a Single Process RouDi, Publisher and Subscriber"},{"location":"examples/singleprocess/#implementation-of-publisher-and-subscriber","text":"<p>Since there are no differences to the inter-process ports you can take a look at the icedelivery example for a detailed documentation. We only provide here a short overview.</p>","title":"Implementation of Publisher and Subscriber"},{"location":"examples/singleprocess/#publisher","text":"<p>We create a typed publisher with the following service description (Service = <code>Single</code>, Instance = <code>Process</code>, Event = <code>Demo</code>) and a <code>historyCapacity</code> of 10.</p>  <pre><code>iox::popo::PublisherOptions publisherOptions;\npublisherOptions.historyCapacity = 10U;\niox::popo::Publisher&lt;TransmissionData_t&gt; publisher({\"Single\", \"Process\", \"Demo\"}, publisherOptions);\n</code></pre> <p>After that, we are sending numbers in ascending order with a 100ms interval in a <code>while</code> loop.</p>  <pre><code>uint64_t counter{0};\nconstexpr const char GREEN_RIGHT_ARROW[] = \"\\033[32m-&gt;\\033[m \";\nwhile (!iox::posix::hasTerminationRequested())\n{\n    publisher.loan().and_then([&amp;](auto&amp; sample) {\n        sample-&gt;counter = counter++;\n        consoleOutput(\"Sending   \", GREEN_RIGHT_ARROW, sample-&gt;counter);\n        sample.publish();\n    });\n\n    std::this_thread::sleep_for(CYCLE_TIME);\n}\n</code></pre>","title":"Publisher"},{"location":"examples/singleprocess/#subscriber","text":"<p>We create a subscriber port with the same service description, a <code>queueCapacity</code> of 10 and request to get the last 5 samples when we connect (<code>historyRequest</code>).</p>  <pre><code>iox::popo::SubscriberOptions options;\noptions.queueCapacity = 10U;\noptions.historyRequest = 5U;\niox::popo::Subscriber&lt;TransmissionData_t&gt; subscriber({\"Single\", \"Process\", \"Demo\"}, options);\n</code></pre> <p>Now we can receive the data in a while loop when our <code>SubscribeState</code> is <code>SUBSCRIBED</code> until someone terminates the application.</p>  <pre><code>constexpr const char ORANGE_LEFT_ARROW[] = \"\\033[33m&lt;-\\033[m \";\nwhile (!iox::posix::hasTerminationRequested())\n{\n    if (iox::SubscribeState::SUBSCRIBED == subscriber.getSubscriptionState())\n    {\n        bool hasMoreSamples{true};\n\n        do\n        {\n            subscriber.take()\n                .and_then([&amp;](auto&amp; sample) { consoleOutput(\"Receiving \", ORANGE_LEFT_ARROW, sample-&gt;counter); })\n                .or_else([&amp;](auto&amp; result) {\n                    hasMoreSamples = false;\n                    if (result != iox::popo::ChunkReceiveResult::NO_CHUNK_AVAILABLE)\n                    {\n                        std::cout &lt;&lt; \"Error receiving chunk.\" &lt;&lt; std::endl;\n                    }\n                });\n        } while (hasMoreSamples);\n    }\n\n    std::this_thread::sleep_for(CYCLE_TIME);\n}\n</code></pre> <p> Check out singleprocess on GitHub  </p>","title":"Subscriber"},{"location":"examples/user_header/","text":"","title":"user-header"},{"location":"examples/user_header/#introduction","text":"<p>This example demonstrates how to leverage the user-header to send custom meta-information with each sample. Specifically, we want to send a timestamp alongside the sample. The example contains code for the typed and untyped C++ API as well as for the C language binding.</p>","title":"Introduction"},{"location":"examples/user_header/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/user_header/#code-walkthrough","text":"<p>The examples uses the user-header and user-payload which is defined in <code>user_header_and_payload_types.hpp</code> for the C++ API and in <code>user_header_and_payload_types.h</code> for the C API. The user-header consists of a simple <code>uint64_t</code> which is used to transmit a timestamp and the user-payload is a Fibonacci number.</p> <p>This are the definitions for the C++ API:</p>  <pre><code>struct Header\n{\n    uint64_t publisherTimestamp{0};\n};\n</code></pre>  <pre><code>struct Data\n{\n    uint64_t fibonacci{0};\n};\n</code></pre> <p>This are the definitions for the C API:</p>  <pre><code>typedef struct\n{\n    uint64_t publisherTimestamp;\n} Header;\n</code></pre>  <pre><code>typedef struct\n{\n    uint64_t fibonacci;\n} Data;\n</code></pre>","title":"Code walkthrough"},{"location":"examples/user_header/#publisher-typed-c-api","text":"<p>At first, there are includes for the user-header and user-payload types and the iceoryx includes for publisher and runtime.</p>  <pre><code>#include \"user_header_and_payload_types.hpp\"\n\n#include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\"\n#include \"iceoryx_posh/popo/publisher.hpp\"\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n</code></pre> <p>Next, the iceoryx runtime is initialized. With this call, the application will be registered at <code>RouDi</code>, the routing and discovery daemon.</p>  <pre><code>constexpr char APP_NAME[] = \"iox-cpp-user-header-publisher\";\niox::runtime::PoshRuntime::initRuntime(APP_NAME);\n</code></pre> <p>Now, we create the publisher. Unlike the other examples, this uses the second template parameter to define the user-header. This is the only change compared to the other examples with the typed C++ API.</p>  <pre><code>iox::popo::Publisher&lt;Data, Header&gt; publisher({\"Example\", \"User-Header\", \"Timestamp\"});\n</code></pre> <p>In the main loop, a Fibonacci sequence is created and every second a number is published. The Fibonacci number is passed to the <code>loan</code> method which construct the <code>Data</code> object if the loaning was successful. This example uses the functional approach with <code>and_then</code> and <code>or_else</code>. Please have a look at the <code>icehello</code> example if you prefer a more traditional approach.</p>  <pre><code>uint64_t timestamp = 42;\nuint64_t fibonacciLast = 0;\nuint64_t fibonacciCurrent = 1;\nwhile (!iox::posix::hasTerminationRequested())\n{\n    auto fibonacciNext = fibonacciCurrent + fibonacciLast;\n    fibonacciLast = fibonacciCurrent;\n    fibonacciCurrent = fibonacciNext;\n\n    publisher.loan(Data{fibonacciCurrent})\n        .and_then([&amp;](auto&amp; sample) {\n            // ...\n        })\n        .or_else([&amp;](auto&amp; error) {\n            // ...\n        });\n\n    constexpr uint64_t MILLISECONDS_SLEEP{1000U};\n    std::this_thread::sleep_for(std::chrono::milliseconds(MILLISECONDS_SLEEP));\n    timestamp += MILLISECONDS_SLEEP;\n}\n</code></pre> <p>When the loaning was successful, we get a sample and can access it in the <code>and_then</code> branch. The sample has a <code>getUserHeader</code> method which returns a reference to the user-header we specified with the template parameter. In this case it's the <code>Header</code> struct and we set the <code>publisherTimestamp</code>.</p>  <pre><code>sample.getUserHeader().publisherTimestamp = timestamp;\nsample.publish();\n\nstd::cout &lt;&lt; APP_NAME &lt;&lt; \" sent data: \" &lt;&lt; fibonacciCurrent &lt;&lt; \" with timestamp \" &lt;&lt; timestamp &lt;&lt; \"ms\"\n          &lt;&lt; std::endl;\n</code></pre> <p>If the loaning fails, the <code>or_else</code> branch is executed, which prints an error message</p>  <pre><code>std::cout &lt;&lt; APP_NAME &lt;&lt; \" could not loan sample! Error code: \" &lt;&lt; error &lt;&lt; std::endl;\n</code></pre>","title":"Publisher Typed C++ API"},{"location":"examples/user_header/#publisher-untyped-c-api","text":"<p>The example with the untyped C++ publisher is quite similar to the one with the typed publisher. The few differences will be discussed in this section.</p> <p>At first there is a different include</p>  <pre><code>#include \"iceoryx_posh/popo/untyped_publisher.hpp\"\n</code></pre> <p>When the publisher is created, there is also no notion of a user-header and it looks exactly the same like already shown in other examples.</p>  <pre><code>iox::popo::UntypedPublisher publisher({\"Example\", \"User-Header\", \"Timestamp\"});\n</code></pre> <p>Variations come again into play when the chunk is loaned. Since the API is untyped, the parameter for the user-header have to be provided with the <code>loan</code> call. These are optional parameter and are set to values indicating no user-header by default.</p>  <pre><code>publisher.loan(sizeof(Data), alignof(Data), sizeof(Header), alignof(Header))\n    .and_then([&amp;](auto&amp; userPayload) {\n        // ...\n    })\n    .or_else([&amp;](auto&amp; error) {\n        // ...\n    });\n</code></pre> <p>Lastly, since the untyped C++ API returns a <code>void</code> pointer to the user-payload, there is an intermediate step to access the user-header by obtaining a <code>ChunkHeader</code> first, which provides a method to get the user-header. This also return a <code>void</code> pointer, which makes a cast to the actual type necessary.</p>  <pre><code>auto header = static_cast&lt;Header*&gt;(iox::mepoo::ChunkHeader::fromUserPayload(userPayload)-&gt;userHeader());\nheader-&gt;publisherTimestamp = timestamp;\n\nauto data = static_cast&lt;Data*&gt;(userPayload);\ndata-&gt;fibonacci = fibonacciCurrent;\n\npublisher.publish(userPayload);\n\nstd::cout &lt;&lt; APP_NAME &lt;&lt; \" sent data: \" &lt;&lt; fibonacciCurrent &lt;&lt; \" with timestamp \" &lt;&lt; timestamp &lt;&lt; \"ms\"\n          &lt;&lt; std::endl;\n</code></pre>","title":"Publisher Untyped C++ API"},{"location":"examples/user_header/#publisher-c-api","text":"<p>The example for the C API is similar to the one in <code>icedelivery_in_c</code> and therefore only the user-header related parts are looked into. The overall structure is the same like in the typed and untyped C++ API counterparts.</p> <p>The functions to access the user-header are located in the following include</p>  <pre><code>#include \"iceoryx_binding_c/chunk.h\"\n</code></pre> <p>Similar to the untyped C++ API, the user-header parameter are specified with the loan function. Since C does not have overloading, this is done by a different function</p>  <pre><code>void* userPayload;\nconst uint32_t ALIGNMENT = 8;\nenum iox_AllocationResult res = iox_pub_loan_aligned_chunk_with_user_header(\n    publisher, &amp;userPayload, sizeof(Data), ALIGNMENT, sizeof(Header), ALIGNMENT);\n</code></pre> <p>Like with the untyped C++ API, the path to the user-header needs an intermediate step with the <code>iox_chunk_header_t</code> and explicit casting to since the functions return <code>void</code> pointer.</p>  <pre><code>iox_chunk_header_t* chunkHeader = iox_chunk_header_from_user_payload(userPayload);\nHeader* header = (Header*)iox_chunk_header_to_user_header(chunkHeader);\nheader-&gt;publisherTimestamp = timestamp;\n\nData* data = (Data*)userPayload;\ndata-&gt;fibonacci = fibonacciCurrent;\n\niox_pub_publish_chunk(publisher, userPayload);\n\n// explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux\nprintf(\"%s sent data: %lu with timestamp %ldms\\n\",\n       APP_NAME,\n       (unsigned long)fibonacciCurrent,\n       (unsigned long)timestamp);\nfflush(stdout);\n</code></pre>","title":"Publisher C API"},{"location":"examples/user_header/#subscriber-typed-c-api","text":"<p>The boilerplate code for the subscriber is the same like for the publisher, therefore only the specific subscriber code is discussed in this section.</p> <p>To use the subscriber, <code>subscriber.hpp</code> needs to be included. Similar to the publisher, the subscriber requires the same additional template parameter when it is used with a user header.</p>  <pre><code>iox::popo::Subscriber&lt;Data, Header&gt; subscriber({\"Example\", \"User-Header\", \"Timestamp\"});\n</code></pre> <p>The main loop is quite simple. The publisher is periodically polled and the data of the received sample is printed. Again, the user-header is accessed by the <code>getUserHeader</code> method of the sample.</p>  <pre><code>while (!iox::posix::hasTerminationRequested())\n{\n    subscriber.take().and_then([&amp;](auto&amp; sample) {\n        std::cout &lt;&lt; APP_NAME &lt;&lt; \" got value: \" &lt;&lt; sample-&gt;fibonacci &lt;&lt; \" with timestamp \"\n                  &lt;&lt; sample.getUserHeader().publisherTimestamp &lt;&lt; \"ms\" &lt;&lt; std::endl;\n    });\n\n    constexpr std::chrono::milliseconds SLEEP_TIME{100U};\n    std::this_thread::sleep_for(SLEEP_TIME);\n}\n</code></pre>","title":"Subscriber Typed C++ API"},{"location":"examples/user_header/#subscriber-untyped-c-api","text":"<p>On the subscriber side, the typed and untyped examples are even closer in similarity than the publisher example. The notable difference is the <code>take</code> method, which returns a <code>void</code> pointer to the user-payload. Like with the untyped publisher, in order to get the user-header the <code>ChunkHeader</code> must be obtained. Contrary to the untyped publisher, we must cast to a <code>const T*</code> type, like <code>const Header*</code> since we are not allowed to mutate the header from a subscriber. At the end, the chunk must be released to prevent chunk leaks. This is done by calling the <code>release</code> method with user-payload pointer.</p>  <pre><code>subscriber.take().and_then([&amp;](auto&amp; userPayload) {\n    auto header =\n        static_cast&lt;const Header*&gt;(iox::mepoo::ChunkHeader::fromUserPayload(userPayload)-&gt;userHeader());\n\n    auto data = static_cast&lt;const Data*&gt;(userPayload);\n\n    std::cout &lt;&lt; APP_NAME &lt;&lt; \" got value: \" &lt;&lt; data-&gt;fibonacci &lt;&lt; \" with timestamp \"\n              &lt;&lt; header-&gt;publisherTimestamp &lt;&lt; \"ms\" &lt;&lt; std::endl;\n\n    subscriber.release(userPayload);\n});\n</code></pre>","title":"Subscriber Untyped C++ API"},{"location":"examples/user_header/#subscriber-c-api","text":"<p>Finally there is the C API example. Like with the publisher example for the C API we just take a look at the user-header specific parts. The overall structure is the same like in the typed and untyped C++ API counterparts.</p> <p>As we already have seen with the untyped C++ example, the call to take the sample is independent of the usage of a user-header. Likewise, the access to the user-header is done by the intermediate step of getting an <code>iox_chunk_header_t</code> first. Since we are not allowed to mutate the user-header from a subscriber, the respective functions with a <code>_const</code> suffix must be used. At last, the chunk is released in order to prevent chunk leaks.</p>  <p><pre><code>const void* userPayload;\nif (iox_sub_take_chunk(subscriber, &amp;userPayload) == ChunkReceiveResult_SUCCESS)\n{\n    const iox_chunk_header_t* chunkHeader = iox_chunk_header_from_user_payload_const(userPayload);\n    const Header* header = (const Header*)(iox_chunk_header_to_user_header_const(chunkHeader));\n\n    const Data* data = (const Data*)userPayload;\n\n    // explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux\n    printf(\"%s got value: %lu with timestamp %ldms\\n\",\n           APP_NAME,\n           (unsigned long)data-&gt;fibonacci,\n           (unsigned long)header-&gt;publisherTimestamp);\n    fflush(stdout);\n\n    iox_sub_release_chunk(subscriber, userPayload);\n}\n</code></pre>  Check out User-Header on GitHub  </p>","title":"Subscriber C API"},{"location":"examples/waitset/","text":"","title":"WaitSet"},{"location":"examples/waitset/#thread-safety","text":"<p>The WaitSet is not thread-safe!</p> <ul> <li>It is not allowed to attach or detach Triggerable    classes with <code>attachEvent</code> or <code>detachEvent</code> when another thread is currently    waiting for notifications with <code>wait</code> or <code>timedWait</code>.</li> <li>Do not call any of the WaitSet methods concurrently.</li> </ul> <p>The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle.</p>","title":"Thread Safety"},{"location":"examples/waitset/#introduction","text":"<p>The WaitSet is a set to which you can attach objects so that they can signal a wide variety of events to one single notifiable. The typical approach is that one creates a WaitSet, attaches multiple subscribers, user triggers or other Triggerables to it and then wait until one or many of the attached entities signal an event. If that happens one receives a list of NotificationInfos which is corresponding to all occurred events.</p>","title":"Introduction"},{"location":"examples/waitset/#events-and-states","text":"<p>In this context, we define the state of an object as a specified set of values to which the members of that object are set. An event on the other hand is defined as a state change. Usually, an event changes the state of the corresponding object but this is not mandatory.</p> <p>States and events can be attached to a WaitSet. The user will be informed only once by the WaitSet for every event which occurred. If the event occurred multiple times before the user has requested an event update from the WaitSet the user will still be informed only once. State changes are induced by events and the user will be informed about a specific state as long as the state persists.</p> <p>The subscriber for instance has the state <code>SubscriberState::HAS_DATA</code> and the event <code>SubscriberEvent::DATA_RECEIVED</code>. If you attach the subscriber event <code>SubscriberEvent::DATA_RECEIVED</code> to a WaitSet you will be notified about every new incoming sample whenever you call <code>WaitSet::wait</code> or <code>WaitSet::timedWait</code>. If multiple samples were sent before you called those methods you will still receive only one notification.</p> <p>If you attach the state <code>SubscriberState::HAS_DATA</code> you will be notified by <code>WaitSet::wait</code> or <code>WaitSet::timedWait</code> as long as there are received samples present in the subscriber queue.</p>","title":"Events and States"},{"location":"examples/waitset/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/waitset/#glossary","text":"<ul> <li>Event a state change of an object; a Triggerable will signal an event via a TriggerHandle to      a Notifyable. For instance one can attach the subscriber event <code>DATA_RECEIVED</code> to WaitSet.      This will cause the subscriber to notify the WaitSet via the TriggerHandle everytime a      sample was received.</li> <li>NotificationCallback a callback attached to a NotificationInfo. It must have the     following signature <code>void ( NotificationOrigin )</code>. Any free function, static     class method and non capturing lambda expression is allowed. You have to ensure the lifetime of that callback.     This can become important when you would like to use lambda expressions.</li> <li>NotificationId an id which is tagged to an event. It does not need to be unique      or follow any restrictions. The user can choose any arbitrary <code>uint64_t</code>. Assigning      the same NotificationId to multiple Events can be useful when you would like to      group Events.</li> <li>NotificationInfo a class that corresponds to Triggers and is used to inform      the user which Event occurred. You can use the NotificationInfo to acquire      the NotificationId, call the NotificationCallback or acquire the NotificationOrigin.</li> <li>NotificationOrigin the pointer to the class where the Event originated from, short      pointer to the Triggerable.</li> <li>Notifyable is a class which listens to events. A TriggerHandle which corresponds to a Trigger      is used to notify the Notifyable that an event occurred. The WaitSet is a Notifyable.</li> <li>State a specified set of values to which the members of an object are set.</li> <li>Trigger a class which is used by the Notifyable to acquire the information which events were      signalled. It corresponds to a TriggerHandle. If the Notifyable goes out of scope the corresponding      TriggerHandle will be invalidated and if the Triggerable goes out of scope the corresponding      Trigger will be invalidated.</li> <li>Triggerable a class which has attached a TriggerHandle to itself to signal      certain Events to a Notifyable.</li> <li>TriggerHandle a thread-safe class which can be used to trigger a Notifyable.      If a TriggerHandle goes out of scope it will detach itself from the Notifyable. A TriggerHandle is      logical equal to another Trigger if they:</li> <li>are attached to the same Notifyable (or in other words they are using the        same <code>ConditionVariable</code>)</li> <li>they have the same NotificationOrigin</li> <li>they have the same callback to verify that they were triggered        (<code>hasNotificationCallback</code>)</li> <li>they have the same NotificationId</li> <li>WaitSet a Notifyable which manages a set of Triggers which are corresponding to Events.      A user may attach or detach events. The Waitset is listening      to the whole set of Triggers and if one or more Triggers are triggered by an event it will notify      the user. If a WaitSet goes out of scope all attached Triggers will be      invalidated.</li> </ul>","title":"Glossary"},{"location":"examples/waitset/#quick-overview","text":"<p>Events or States can be attached to a Notifyable like the WaitSet. The WaitSet will listen on Triggers for a signal that an Event has occurred and it hands out TriggerHandles to Triggerable objects. The TriggerHandle is used to inform the WaitSet about the occurrence of an Event. When returning from <code>WaitSet::wait()</code> the user is provided with a vector of NotificationInfos associated with Events which had occurred and States which persists. The NotificationOrigin, NotificationId and NotificationCallback are stored inside of the NotificationInfo and can be acquired by the user.</p>  <p>Warning</p> <p>Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully.</p>","title":"Quick Overview"},{"location":"examples/waitset/#reference","text":"task call     attach subscriber event to a WaitSet <code>waitset.attachEvent(subscriber, iox::popo::SubscriberEvent::DATA_RECEIVED, 123, &amp;mySubscriberCallback)</code>   attach subscriber state to a WaitSet <code>waitset.attachState(subscriber, iox::popo::SubscriberState::HAS_DATA, 123, &amp;mySubscriberCallback)</code>   attach user trigger to a WaitSet <code>waitset.attachEvent(userTrigger, 456, &amp;myUserTriggerCallback)</code>   wait for triggers <code>auto triggerVector = myWaitSet.wait();</code>   wait for triggers with timeout <code>auto triggerVector = myWaitSet.timedWait(1_s);</code>   check if event/state originated from some object <code>notification-&gt;doesOriginateFrom(ptrToSomeObject)</code>   get id of the event/state <code>notification-&gt;getNotificationId()</code>   call eventCallback <code>(*notification)()</code>   acquire NotificationOrigin <code>notification-&gt;getOrigin&lt;OriginType&gt;();</code>","title":"Reference"},{"location":"examples/waitset/#use-cases","text":"<p>This example consists of 6 use cases.</p> <ol> <li> <p><code>ice_waitset_basic</code>: A single subscriber is notified by the WaitSet if data arrives.</p> </li> <li> <p><code>ice_waitset_gateway.cpp</code>: We build a gateway to forward data     to another network. A list of subscriber events are handled in an uniform way     by defining a callback which is executed for every subscriber who     has received data.</p> </li> <li> <p><code>ice_waitset_grouping</code>: We would like to group multiple subscribers into 2 distinct     groups and handle them whenever they have a specified state according to their group membership.</p> </li> <li> <p><code>ice_waitset_individual</code>: A list of subscribers where every subscriber is     handled differently.</p> </li> <li> <p><code>ice_waitset_timer_driven_execution</code>: We use the WaitSet to trigger a cyclic call which should     execute an algorithm every 1 s.</p> </li> <li> <p><code>ice_waitset_trigger</code>: We create our own class which can be attached to a     WaitSet to signal states and events.</p> </li> </ol>","title":"Use Cases"},{"location":"examples/waitset/#examples","text":"<p>All our examples require a running <code>iox-roudi</code> and some data to receive which will be send by <code>iox-cpp-waitset-publisher</code>. The publisher does not contain any WaitSet specific logic and is explained in detail in the icedelivery example.</p>","title":"Examples"},{"location":"examples/waitset/#basic","text":"<p>We create one subscriber and attach it to the WaitSet. Afterwards we wait for data in a loop and process it on arrival. To leave the loop and exit the application we have to register a signal handler that calls <code>waitset.markForDestruction()</code> which wakes up the blocking <code>waitset-&gt;wait()</code> whenever Ctrl+C is pressed.</p>  <pre><code>std::atomic_bool keepRunning{true};\niox::cxx::optional&lt;iox::popo::WaitSet&lt;&gt;&gt; waitset;\n\nstatic void sigHandler(int sig IOX_MAYBE_UNUSED)\n{\n    keepRunning = false;\n    if (waitset)\n    {\n        waitset-&gt;markForDestruction();\n    }\n}\n</code></pre> <p>In the beginning we create the WaitSet. It is important to construct it only after the runtime has already been initialized since it internally depends on facilities set up by the runtime.</p> <p>Afterwards we register our signal handler which will unblock the WaitSet. Finally we attach the subscriber to the WaitSet stating that we want to be notified when it has data (indicated by <code>iox::popo::SubscriberState::HAS_DATA</code>).</p> <p>It is good practice to handle potential failure while attaching, otherwise warnings will emerge since the return value <code>cxx::expected</code> is marked to require handling. In our case no errors should occur since the WaitSet can accomodate the two triggers we want to attach.</p>  <pre><code>waitset.emplace();\n\n// register signal handler to handle termination of the loop\nauto signalGuard = iox::posix::registerSignalHandler(iox::posix::Signal::INT, sigHandler);\nauto signalTermGuard = iox::posix::registerSignalHandler(iox::posix::Signal::TERM, sigHandler);\n\n// create subscriber\niox::popo::Subscriber&lt;CounterTopic&gt; subscriber({\"Radar\", \"FrontLeft\", \"Counter\"});\n\n// attach subscriber to waitset\nwaitset-&gt;attachState(subscriber, iox::popo::SubscriberState::HAS_DATA).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach subscriber\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>We create a loop which we will exit as soon as someone presses CTRL+C and our signal handler sets <code>keepRunning</code> to false. If this happens <code>markForDestruction</code> turns the <code>waitset-&gt;wait()</code> into an empty non-blocking method and makes sure that we do not wait indefinitely.</p>  <pre><code>while (keepRunning)\n{\n    // We block and wait for samples to arrive.\n    auto notificationVector = waitset-&gt;wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        // We woke up and hence there must be at least one sample. When the sigHandler has called\n        // markForDestruction the notificationVector is empty otherwise we know which subscriber received samples\n        // since we only attached one.\n        // Best practice is to always acquire the notificationVector and iterate over all elements and then react\n        // accordingly. When this is not done and more elements are attached to the WaitSet it can cause\n        // problems since we either miss events or handle events for objects which never occurred.\n        if (notification-&gt;doesOriginateFrom(&amp;subscriber))\n        {\n            // Consume a sample\n            subscriber.take()\n                .and_then([](auto&amp; sample) { std::cout &lt;&lt; \" got value: \" &lt;&lt; sample-&gt;counter &lt;&lt; std::endl; })\n                .or_else([](auto&amp; reason) {\n                    std::cout &lt;&lt; \"got no data, return code: \" &lt;&lt; static_cast&lt;uint64_t&gt;(reason) &lt;&lt; std::endl;\n                });\n            // We could consume all samples but do not need to.\n            // If there is more than one sample we will wake up again since the state of the subscriber is still\n            // iox::popo::SubscriberState::HAS_DATA in this case.\n        }\n    }\n}\n</code></pre> <p>Processing just one sample even if more might have arrived will cause <code>wait</code> to unblock again immediately to process the next sample (or shut down if requested). Due to the overhead of the <code>wait</code> call it may still be more efficient to process all samples in a loop until there are none left before waiting again, but it is not required. It would be required if we attach via <code>attachEvent</code> instead of <code>attachState</code>, since we might wake up due to the arrival of a second sample, only process the first and will not receive a wake up until a third sample arrives (which could be much later or never).</p>","title":"Basic"},{"location":"examples/waitset/#gateway","text":"<p>We have a list of subscribers which can be subscribed to any arbitrary topic and everytime we receive a sample we would like to send the bytestream to a socket, write it into a file or print it to the console. But whatever we choose to do we perform the same task for all the subscribers. And since we process all incoming data right away we attach the <code>SubscriberEvent::DATA_RECEIVED</code> which notifies us only once.</p> <p>Let's start by implementing our callback which prints the subscriber pointer, the payload size and the payload pointer to the console. We have to process all samples as long as there are samples in the subscriber queue since we attached an event that notifies us only once. But it is impossible to miss samples since the notification is reset right after <code>wait</code> or <code>timedWait</code> is returned - this means if a sample arrives after those calls we will be notified again. Additionally, since we would like to count the sum of all processed samples, we add a second argument called <code>sumOfAllSamples</code> to the user defined context data.</p>  <pre><code>void subscriberCallback(iox::popo::UntypedSubscriber* const subscriber, uint64_t* const sumOfAllSamples)\n{\n    while (subscriber-&gt;hasData())\n    {\n        subscriber-&gt;take().and_then([&amp;](auto&amp; userPayload) {\n            auto chunkHeader = iox::mepoo::ChunkHeader::fromUserPayload(userPayload);\n            auto flags = std::cout.flags();\n            std::cout &lt;&lt; \"subscriber: \" &lt;&lt; std::hex &lt;&lt; subscriber &lt;&lt; \" length: \" &lt;&lt; std::dec\n                      &lt;&lt; chunkHeader-&gt;userPayloadSize() &lt;&lt; \" ptr: \" &lt;&lt; std::hex &lt;&lt; chunkHeader-&gt;userPayload()\n                      &lt;&lt; std::dec &lt;&lt; std::endl;\n            std::cout.setf(flags);\n        });\n        // no nullptr check required since it is guaranteed != nullptr\n        ++(*sumOfAllSamples);\n    }\n}\n</code></pre> <p>The Event callback requires a signature of either <code>void (NotificationOrigin)</code> or <code>void(NotificationOrigin, ContextDataType *)</code> when one would like to provide an additional data pointer to the callback. In our example the NotificationOrigin is a <code>iox::popo::UntypedSubscriber</code> pointer which we use to acquire the latest sample by calling <code>take()</code> and the <code>ContextDataType</code> is an <code>uint64_t</code> used to count the processed samples. When <code>take()</code> was successful we print our message to the console inside of the <code>and_then</code> lambda.</p> <p>The <code>shutdownTrigger</code> uses a simpler callback which just informs us that we are exiting the program. Therefore we do not need an additional <code>ContextDataType</code> pointer.</p>  <pre><code>void shutdownCallback(iox::popo::UserTrigger*)\n{\n    std::cout &lt;&lt; \"CTRL+C pressed - exiting now\" &lt;&lt; std::endl;\n}\n</code></pre> <p>In our <code>main</code> function we create a WaitSet which has storage capacity for 3 events, 2 subscribers and one shutdown trigger, after we registered us at our central broker RouDi. Then we attach our <code>shutdownTrigger</code> to handle <code>CTRL+C</code> events.</p>  <pre><code>iox::popo::WaitSet&lt;NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER&gt; waitset;\n\n// attach shutdownTrigger to handle CTRL+C\nwaitset.attachEvent(shutdownTrigger, iox::popo::createNotificationCallback(shutdownCallback)).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach shutdown trigger\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>After that we define our <code>sumOfAllSamples</code> variable and create a vector to hold our subscribers. We create and then attach the subscribers to our WaitSet with the <code>SubscriberEvent::DATA_RECEIVED</code> event and the <code>subscriberCallback</code>. Everytime one of the subscribers is receiving a new sample it will trigger the WaitSet.</p>  <p>Attention</p> <p>The user has to ensure that the contextData (<code>sumOfAllSamples</code>) in <code>attachEvent</code> lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling.</p>   <pre><code>uint64_t sumOfAllSamples = 0U;\n\n// create subscribers and subscribe them to our service\niox::cxx::vector&lt;iox::popo::UntypedSubscriber, NUMBER_OF_SUBSCRIBERS&gt; subscriberVector;\nfor (auto i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    subscriberVector.emplace_back(iox::capro::ServiceDescription{\"Radar\", \"FrontLeft\", \"Counter\"});\n    auto&amp; subscriber = subscriberVector.back();\n\n    /// important: the user has to ensure that the contextData (sumOfAllSamples) lives as long as\n    ///            the subscriber with its callback is attached to the listener\n    waitset\n        .attachEvent(subscriber,\n                     iox::popo::SubscriberEvent::DATA_RECEIVED,\n                     0,\n                     createNotificationCallback(subscriberCallback, sumOfAllSamples))\n        .or_else([&amp;](auto) {\n            std::cerr &lt;&lt; \"failed to attach subscriber\" &lt;&lt; i &lt;&lt; std::endl;\n            std::exit(EXIT_FAILURE);\n        });\n}\n</code></pre> <p><code>attachEvent</code> is returning a <code>cxx::expected</code> which informs us if attaching the event succeeded. In the <code>.or_else([&amp;](auto){/*...*/})</code> part we perform the error handling whenever <code>attachEvent</code> fails.</p> <p>Now our system is prepared and ready to work. We enter the event loop which starts with a call to our WaitSet (<code>waitset.wait()</code>). This call will block until one or more events triggered the WaitSet. After the call returned we get a vector filled with NotificationInfos which are corresponding to all the events which triggered the WaitSet.</p> <p>We iterate through this vector. If an Event originated from the <code>shutdownTrigger</code> we exit the program, otherwise we just call the assigned callback by calling the trigger. This will then call the <code>subscriberCallback</code> with the NotificationOrigin (the pointer to the untyped subscriber) and the contextData (<code>sumOfAllSamples</code>) as parameters.</p>  <pre><code>while (keepRunning)\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        if (notification-&gt;doesOriginateFrom(&amp;shutdownTrigger))\n        {\n            (*notification)();\n            keepRunning = false;\n        }\n        else\n        {\n            // call the callback which was assigned to the notification\n            (*notification)();\n        }\n    }\n\n    auto flags = std::cout.flags();\n    std::cout &lt;&lt; \"sum of all samples: \" &lt;&lt; std::dec &lt;&lt; sumOfAllSamples &lt;&lt; std::endl;\n    std::cout.setf(flags);\n}\n</code></pre>","title":"Gateway"},{"location":"examples/waitset/#grouping","text":"<p>In our next use case we would like to divide the subscribers into two groups and we do not want to attach a callback to them. Instead we perform the calls on the subscribers directly. Additionally, we would like to be notified as long as there are samples in the subscriber queue therefore we have to attach the <code>SubscriberState::HAS_DATA</code>.</p> <p>We again start by creating a WaitSet with a capacity of 5 (4 subscribers and 1 shutdownTrigger), and attach the <code>shutdownTrigger</code> to handle <code>CTRL+C</code>.</p>  <pre><code>iox::popo::WaitSet&lt;NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER&gt; waitset;\n\n// attach shutdownTrigger to handle CTRL+C\nwaitset.attachEvent(shutdownTrigger).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach shutdown trigger\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>Now we create a vector of 4 subscribers.</p>  <pre><code>iox::cxx::vector&lt;iox::popo::UntypedSubscriber, NUMBER_OF_SUBSCRIBERS&gt; subscriberVector;\nfor (auto i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    subscriberVector.emplace_back(iox::capro::ServiceDescription{\"Radar\", \"FrontLeft\", \"Counter\"});\n}\n</code></pre> <p>After that, we define our two groups with the ids <code>FIRST_GROUP_ID</code> and <code>SECOND_GROUP_ID</code> and attach the first two subscribers with the state <code>SubscriberState::HAS_DATA</code> to the first group and the remaining subscribers to the second group.</p>  <pre><code>// attach the first two subscribers to waitset with a id of FIRST_GROUP_ID\nfor (auto i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS / 2; ++i)\n{\n    waitset.attachState(subscriberVector[i], iox::popo::SubscriberState::HAS_DATA, FIRST_GROUP_ID)\n        .or_else([&amp;](auto) {\n            std::cerr &lt;&lt; \"failed to attach subscriber\" &lt;&lt; i &lt;&lt; std::endl;\n            std::exit(EXIT_FAILURE);\n        });\n}\n\n// attach the remaining subscribers to waitset with a id of SECOND_GROUP_ID\nfor (auto i = NUMBER_OF_SUBSCRIBERS / 2; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    waitset.attachState(subscriberVector[i], iox::popo::SubscriberState::HAS_DATA, SECOND_GROUP_ID)\n        .or_else([&amp;](auto) {\n            std::cerr &lt;&lt; \"failed to attach subscriber\" &lt;&lt; i &lt;&lt; std::endl;\n            std::exit(EXIT_FAILURE);\n        });\n}\n</code></pre> <p>The event loop calls <code>auto notificationVector = waitset.wait()</code> in a blocking call to receive a vector of all the NotificationInfos which are corresponding to the occurred events. If the Event originated from the <code>shutdownTrigger</code> we terminate the program.</p>  <pre><code>while (keepRunning)\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        if (notification-&gt;doesOriginateFrom(&amp;shutdownTrigger))\n        {\n            keepRunning = false;\n        }\n        // ...\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>The remaining part of the loop is handling the subscribers. In the first group we would like to print the received data to the console and in the second group we just dismiss the received data.</p>  <pre><code>// we print the received data for the first group\nelse if (notification-&gt;getNotificationId() == FIRST_GROUP_ID)\n{\n    auto subscriber = notification-&gt;getOrigin&lt;iox::popo::UntypedSubscriber&gt;();\n    subscriber-&gt;take().and_then([&amp;](auto&amp; userPayload) {\n        const CounterTopic* data = static_cast&lt;const CounterTopic*&gt;(userPayload);\n        auto flags = std::cout.flags();\n        std::cout &lt;&lt; \"received: \" &lt;&lt; std::dec &lt;&lt; data-&gt;counter &lt;&lt; std::endl;\n        std::cout.setf(flags);\n        subscriber-&gt;release(userPayload);\n    });\n}\n// dismiss the received data for the second group\nelse if (notification-&gt;getNotificationId() == SECOND_GROUP_ID)\n{\n    std::cout &lt;&lt; \"dismiss data\\n\";\n    auto subscriber = notification-&gt;getOrigin&lt;iox::popo::UntypedSubscriber&gt;();\n    // We need to release the data to reset the trigger hasData\n    // otherwise the WaitSet would notify us in `waitset.wait()` again\n    // instantly.\n    subscriber-&gt;releaseQueuedData();\n}\n</code></pre>  <p>Attention</p> <p>For the second group we have to call <code>releaseQueuedData</code> to release the unread data. Otherwise we would be notified by the WaitSet immediately again since the subscriber has still the state <code>HAS_DATA</code>.</p>","title":"Grouping"},{"location":"examples/waitset/#individual","text":"<p>When every Triggerable requires a different reaction we need to know the origin of an Event. We can call <code>event.doesOriginateFrom(NotificationOrigin)</code> which will return true if the event originated from NotificationOrigin and otherwise false.</p> <p>We start this example by creating a WaitSet with the default capacity and attaching the <code>shutdownTrigger</code> to handle <code>CTRL+C</code>.</p>  <pre><code>iox::popo::WaitSet&lt;&gt; waitset;\n\n// attach shutdownTrigger to handle CTRL+C\nwaitset.attachEvent(shutdownTrigger).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach shutdown trigger\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>Additionally, we create two subscribers and attach them with the state <code>SubscriberState::HAS_DATA</code> to the WaitSet to let them inform us whenever they have samples in their queue.</p>  <pre><code>iox::popo::Subscriber&lt;CounterTopic&gt; subscriber1({\"Radar\", \"FrontLeft\", \"Counter\"});\niox::popo::Subscriber&lt;CounterTopic&gt; subscriber2({\"Radar\", \"FrontLeft\", \"Counter\"});\n\nwaitset.attachState(subscriber1, iox::popo::SubscriberState::HAS_DATA).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach subscriber1\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\nwaitset.attachState(subscriber2, iox::popo::SubscriberState::HAS_DATA).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach subscriber2\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>With that set up we enter the event loop and handle the program termination first.</p>  <pre><code>while (keepRunning)\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        if (notification-&gt;doesOriginateFrom(&amp;shutdownTrigger))\n        {\n            keepRunning = false;\n        }\n        // ...\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>When the origin is <code>subscriber1</code> we would like to print the received data to the console. But for <code>subscriber2</code> we just dismiss the received samples. We accomplish this by asking the <code>event</code> if it originated from the corresponding subscriber. If so, we act.</p>  <pre><code>while (keepRunning)\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        // ...\n        // process sample received by subscriber1\n        else if (notification-&gt;doesOriginateFrom(&amp;subscriber1))\n        {\n            subscriber1.take().and_then(\n                [&amp;](auto&amp; sample) { std::cout &lt;&lt; \"subscriber 1 received: \" &lt;&lt; sample-&gt;counter &lt;&lt; std::endl; });\n        }\n        // dismiss sample received by subscriber2\n        if (notification-&gt;doesOriginateFrom(&amp;subscriber2))\n        {\n            // We need to release the samples to reset the trigger hasSamples\n            // otherwise the WaitSet would notify us in `waitset.wait()` again\n            // instantly.\n            subscriber2.releaseQueuedData();\n            std::cout &lt;&lt; \"subscriber 2 received something - dont care\\n\";\n        }\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>","title":"Individual"},{"location":"examples/waitset/#timer-driven-execution","text":"<p>Let's say we have <code>SomeClass</code> and would like to execute a cyclic static method <code>cyclicRun</code> every second. We could execute any arbitrary algorithm in there but for now we just print <code>activation callback</code>. The class could look like</p>  <pre><code>class SomeClass\n{\n  public:\n    static void cyclicRun(iox::popo::UserTrigger*)\n    {\n        std::cout &lt;&lt; \"activation callback\\n\";\n    }\n};\n</code></pre>  <p>Attention</p> <p>The user trigger is event based and always reset after the WaitSet has acquired all triggered objects.</p>  <p>As always, we begin by creating a WaitSet with the default capacity and by attaching the <code>shutdownTrigger</code> to it. In this case we do not set an event id when calling <code>attachEvent</code> which means the default event id  <code>NotificationInfo::INVALID_ID</code> is set.</p>  <pre><code>iox::popo::WaitSet&lt;&gt; waitset;\n\n// attach shutdownTrigger to handle CTRL+C\nwaitset.attachEvent(shutdownTrigger).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach shutdown trigger\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>After that we require a <code>cyclicTrigger</code> to trigger our <code>cyclicRun</code> every second. Therefore, we attach it to the <code>waitset</code> with eventId <code>0</code> and the callback <code>SomeClass::cyclicRun</code></p>  <pre><code>iox::popo::UserTrigger cyclicTrigger;\nwaitset.attachEvent(cyclicTrigger, 0U, createNotificationCallback(SomeClass::cyclicRun)).or_else([](auto) {\n    std::cerr &lt;&lt; \"failed to attach cyclic trigger\" &lt;&lt; std::endl;\n    std::exit(EXIT_FAILURE);\n});\n</code></pre> <p>The next thing we need is something which will trigger our <code>cyclicTrigger</code> every second. We use an infinite loop packed inside of a thread.</p>  <pre><code>std::thread cyclicTriggerThread([&amp;] {\n    while (keepRunning.load())\n    {\n        cyclicTrigger.trigger();\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n});\n</code></pre> <p>Everything is set up and we can implement the event loop. As usual we handle <code>CTRL+C</code> which is indicated by the <code>shutdownTrigger</code>.</p>  <pre><code>while (keepRunning.load())\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        if (notification-&gt;doesOriginateFrom(&amp;shutdownTrigger))\n        {\n            // CTRL+C was pressed -&gt; exit\n            keepRunning.store(false);\n        }\n        // ...\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> <p>The <code>cyclicTrigger</code> callback is called in the else part.</p>  <pre><code>while (keepRunning.load())\n{\n    auto notificationVector = waitset.wait();\n\n    for (auto&amp; notification : notificationVector)\n    {\n        // ...\n        else\n        {\n            // call SomeClass::cyclicRun\n            (*notification)();\n        }\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>","title":"Timer Driven Execution"},{"location":"examples/waitset/#trigger","text":"<p>In this example we describe how you would implement a Triggerable class which can be attached to a WaitSet or a Listener. Our class in this example will be called <code>MyTriggerClass</code> and it can signal the WaitSet the two states <code>HAS_PERFORMED_ACTION</code> and <code>IS_ACTIVATED</code>. Furthermore, we can also attach the two corresponding events <code>PERFORM_ACTION_CALLED</code> and <code>ACTIVATE_CALLED</code>. The <code>PERFORM_ACTION_CALLED</code> event is triggered whenever the method <code>performAction</code> is called and the state <code>HAS_PERFORMED_ACTION</code> persists until someone resets the state with the method <code>reset()</code>. The same applies to the event <code>ACTIVATE_CALLED</code> which is triggered by an <code>activate()</code> call and the corresponding state <code>IS_ACTIVATED</code> which stays until someone resets it with <code>reset()</code>.</p>","title":"Trigger"},{"location":"examples/waitset/#mytriggerclass","text":"","title":"MyTriggerClass"},{"location":"examples/waitset/#attaching-states","text":"<p>A class that would like to attach states to a WaitSet has to implement the following methods.</p> <ol> <li> <p><code>void enableState(iox::popo::TriggerHandle&amp;&amp;, const UserDefinedStateEnum )</code></p> <p>Used by the WaitSet to attach a trigger handle to the object so that the object can notify the WaitSet that it entered a certain state.</p> </li> <li> <p><code>void disableState(const UserDefinedStateEnum)</code></p> <p>Called whenever the user detaches the state from the WaitSet.</p> </li> <li> <p><code>void invalidateTrigger(const uint64_t uniqueTriggerId)</code></p> <p>If the WaitSet goes out of scope it calls this method to invalidate the loan trigger.</p> </li> <li> <p><code>iox::popo::WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied(const UserDefinedStateEnum)</code></p> <p>With every iteration the WaitSet has to ask the object if the attached state still persists. This is done with the <code>isStateConditionSatisfied</code> callback which will be returned here.</p> </li> </ol> <p>The <code>UserDefinedStateEnum</code> can be some arbitrary enum class which requires <code>iox::popo::StateEnumIdentifier</code> as underlying type so that it can be identified as an enum which describes certain states. In our example it is called <code>MyTriggerClassStates</code>.</p>  <pre><code>enum class MyTriggerClassStates : iox::popo::StateEnumIdentifier\n{\n    HAS_PERFORMED_ACTION,\n    IS_ACTIVATED\n};\n</code></pre>","title":"Attaching States"},{"location":"examples/waitset/#attaching-events","text":"<p>Events can be attached to WaitSets and Listeners. For this to work the class has to implement the following methods.</p> <ol> <li> <p><code>void enableEvent(iox::popo::TriggerHandle&amp;&amp;, const UserDefinedEventEnum)</code></p> <p>Used by the WaitSet or the Listener to attach a trigger handle which signals certain events to them.</p> </li> <li> <p><code>void disableEvent(const UserDefinedEventEnum)</code></p> <p>Called whenever the user detaches the event from the WaitSet or the Listener.</p> </li> <li> <p><code>void invalidateTrigger(const uint64_t uniqueTriggerId)</code></p> <p>Used to clean up all loan trigger handles when the WaitSet or Listener goes out of scope.</p> </li> </ol> <p>Like with the state enum the event enum can be also any arbitrary enum class which has <code>iox::popo::EventEnumIdentifier</code> as an underlying type. In our example it is called <code>MyTriggerClassEvents</code>.</p>  <pre><code>enum class MyTriggerClassEvents : iox::popo::EventEnumIdentifier\n{\n    PERFORM_ACTION_CALLED,\n    ACTIVATE_CALLED\n};\n</code></pre>","title":"Attaching Events"},{"location":"examples/waitset/#further-requirements","text":"<ol> <li> <p><code>friend iox::popo::NotificationAttorney</code></p> <p>Methods like <code>enableEvent</code>, <code>disableEvent</code> etc. should never be accessible via the public API and should be therefore private. To avoid that every class has to befriend the WaitSet, Listener and other internal structures we implemented the client attorney pattern and the class has only to befriend the <code>iox::popo::NotificationAttorney</code>.</p> </li> <li> <p>Deleted move and copy operations</p> </li> </ol> <p>At the moment the WaitSet does not support Triggerable classes which are movable or copyable. This is caused by the <code>resetCallback</code> and the <code>isStateConditionSatisfied</code> callback which are pointing to the Triggerable. After a move the callbacks inside of the WaitSet would point to the wrong memory location and a copy could lead to an unattached object if there is no more space left in the WaitSet. Therefore we have to delete the move and copy operations for now.</p>  <pre><code>MyTriggerClass(const MyTriggerClass&amp;) = delete;\nMyTriggerClass(MyTriggerClass&amp;&amp;) = delete;\nMyTriggerClass&amp; operator=(const MyTriggerClass&amp;) = delete;\nMyTriggerClass&amp; operator=(MyTriggerClass&amp;&amp;) = delete;\n</code></pre>","title":"Further Requirements"},{"location":"examples/waitset/#implementation","text":"<p>The method implementation of the two actions <code>activate</code> and <code>performAction</code> which trigger an event and causing a state change look like the following.</p>  <pre><code>// When you call this method you will trigger the ACTIVATE event\nvoid activate(const uint64_t activationCode) noexcept\n{\n    m_activationCode = activationCode;\n    m_isActivated = true;\n    m_activateTrigger.trigger();\n}\n\n// Calling this method will trigger the PERFORMED_ACTION event\nvoid performAction() noexcept\n{\n    m_hasPerformedAction = true;\n    m_onActionTrigger.trigger();\n}\n</code></pre> <p>As you can see we perform some internal action and when they are finished we signal the corresponding Trigger via our stored TriggerHandle that we performed the task. Internally we just set a boolean to signal that the method was called.</p> <p>Every state based Trigger requires a corresponding class method which returns a boolean stating if the state which led to the trigger still persists. In our case these are the two const methods <code>hasPerformedAction</code> and <code>isActivated</code>.</p>  <pre><code>// required by the m_onActionTrigger to ask the class if it was triggered\nbool hasPerformedAction() const noexcept\n{\n    return m_hasPerformedAction;\n}\n\n// required by the m_activateTrigger to ask the class if it was triggered\nbool isActivated() const noexcept\n{\n    return m_isActivated;\n}\n</code></pre> <p>Since the following methods should not be accessible by the public but must be accessible by any Notifyable like the WaitSet and to avoid that we have to befriend every possible Notifyable we created the <code>NotificationAttorney</code>. Every Triggerable has to befriend the <code>NotificationAttorney</code> which provides access to the private methods <code>enableEvent</code>/<code>enableState</code>, <code>disableEvent</code>/<code>disableState</code>, <code>invalidateTrigger</code> and <code>getCallbackForIsStateConditionSatisfied</code> to all Notifyables.</p>  <pre><code>friend iox::popo::NotificationAttorney;\n</code></pre> <p>The method <code>enableEvent</code> is called by the WaitSet when a <code>MyTriggerClass</code> event is being attached to it. During that process the WaitSet creates a <code>triggerHandle</code> and forwards the <code>event</code> to which this handle belongs.</p> <p>In the switch case statement we assign the <code>triggerHandle</code> to the corresponding internal trigger handle.</p>  <pre><code>void enableEvent(iox::popo::TriggerHandle&amp;&amp; triggerHandle, const MyTriggerClassEvents event) noexcept\n{\n    switch (event)\n    {\n    case MyTriggerClassEvents::PERFORM_ACTION_CALLED:\n        m_onActionTrigger = std::move(triggerHandle);\n        break;\n    case MyTriggerClassEvents::ACTIVATE_CALLED:\n        m_activateTrigger = std::move(triggerHandle);\n        break;\n    }\n}\n</code></pre> <p>Attaching a state works in a similar way.</p>  <pre><code>void enableState(iox::popo::TriggerHandle&amp;&amp; triggerHandle, const MyTriggerClassStates state) noexcept\n{\n    switch (state)\n    {\n    case MyTriggerClassStates::HAS_PERFORMED_ACTION:\n        m_onActionTrigger = std::move(triggerHandle);\n        break;\n    case MyTriggerClassStates::IS_ACTIVATED:\n        m_activateTrigger = std::move(triggerHandle);\n        break;\n    }\n}\n</code></pre> <p>It is possible to use the same trigger for either a state or an event attachment but then we loose the ability to attach the state and the corresponding event at the same time to a WaitSet. In most cases it is not a problem and when you attach an event when the corresponding state is already attached you will get a warning message on the terminal and the already attached event is detached so that the state can be attached. This is realized via the RAII idiom.</p> <p>The next thing on our checklist is the <code>invalidateTrigger</code> method used by the WaitSet to reset the Trigger when it goes out of scope. Therefore we look up the correct unique trigger id first and then <code>invalidate</code> it to make them unusable in the future.</p>  <pre><code>void invalidateTrigger(const uint64_t uniqueTriggerId)\n{\n    if (m_onActionTrigger.getUniqueId() == uniqueTriggerId)\n    {\n        m_onActionTrigger.invalidate();\n    }\n    else if (m_activateTrigger.getUniqueId() == uniqueTriggerId)\n    {\n        m_activateTrigger.invalidate();\n    }\n}\n</code></pre> <p>Detaching an event in the WaitSet will lead to a call to <code>disableEvent</code> in our class. In this case we have to <code>reset</code> the corresponding trigger to invalidate and release it from the WaitSet. Like before we use a switch case statement to find the trigger corresponding to the event.</p>  <pre><code>void disableEvent(const MyTriggerClassEvents event) noexcept\n{\n    switch (event)\n    {\n    case MyTriggerClassEvents::PERFORM_ACTION_CALLED:\n        m_onActionTrigger.reset();\n        break;\n    case MyTriggerClassEvents::ACTIVATE_CALLED:\n        m_activateTrigger.reset();\n        break;\n    }\n}\n</code></pre> <p>The same idea is used when detaching a state.</p>  <pre><code>void disableState(const MyTriggerClassStates state) noexcept\n{\n    switch (state)\n    {\n    case MyTriggerClassStates::HAS_PERFORMED_ACTION:\n        m_onActionTrigger.reset();\n        break;\n    case MyTriggerClassStates::IS_ACTIVATED:\n        m_activateTrigger.reset();\n        break;\n    }\n}\n</code></pre> <p>The last method we have to implement is <code>getCallbackForIsStateConditionSatisfied</code>. The WaitSet can handle state based attachments and therefore it requires, beside the condition variable which only states that something has happened, a callback to find the object where it happened. This is the <code>isStateConditionSatisfied</code> callback. In our case we either return the method pointer to <code>hasPerformedAction</code> or <code>isActivated</code> depending on which state was requested.</p>  <pre><code>iox::popo::WaitSetIsConditionSatisfiedCallback\ngetCallbackForIsStateConditionSatisfied(const MyTriggerClassStates event) const noexcept\n{\n    switch (event)\n    {\n    case MyTriggerClassStates::HAS_PERFORMED_ACTION:\n        return {*this, &amp;MyTriggerClass::hasPerformedAction};\n    case MyTriggerClassStates::IS_ACTIVATED:\n        return {*this, &amp;MyTriggerClass::isActivated};\n    }\n    return {};\n}\n</code></pre>","title":"Implementation"},{"location":"examples/waitset/#using-mytriggerclass","text":"<p>The next thing we define is a free function, our <code>eventLoop</code>, which will handle all events of our WaitSet. Since we would like to attach the <code>IS_ACTIVATED</code> state we have to reset the state whenever it occurs otherwise the WaitSet will notify us right away since the state still persists. The second attachment will be an event attachment and the WaitSet informs us just once that the event has occurred which makes the <code>reset</code> call obsolete.</p>  <pre><code>void eventLoop()\n{\n    while (keepRunning)\n    {\n        auto notificationVector = waitset-&gt;wait();\n        for (auto&amp; notification : notificationVector)\n        {\n            if (notification-&gt;getNotificationId() == ACTIVATE_ID)\n            {\n                // reset MyTriggerClass instance state\n                notification-&gt;getOrigin&lt;MyTriggerClass&gt;()-&gt;reset(MyTriggerClassStates::IS_ACTIVATED);\n                // call the callback attached to the trigger\n                (*notification)();\n            }\n            else if (notification-&gt;getNotificationId() == ACTION_ID)\n            {\n                // reset is not required since we attached an notification here. we will be notified once\n                (*notification)();\n            }\n        }\n    }\n}\n</code></pre> <p>We start like in every other example by creating the <code>waitset</code> first. In this case the <code>waitset</code> and the <code>triggerClass</code> are stored inside of two global <code>optional</code>'s and have to be created with an <code>emplace</code> call.</p>  <pre><code>waitset.emplace();\ntriggerClass.emplace();\n</code></pre> <p>After that we can attach the <code>IS_ACTIVATED</code> state and <code>PERFORM_ACTION_CALLED</code> event to the waitset and provide a callback for them.</p>  <pre><code>// attach the IS_ACTIVATED state to the waitset and assign a callback\nwaitset\n    -&gt;attachState(*triggerClass,\n                  MyTriggerClassStates::IS_ACTIVATED,\n                  ACTIVATE_ID,\n                  iox::popo::createNotificationCallback(callOnActivate))\n    .or_else([](auto) {\n        std::cerr &lt;&lt; \"failed to attach MyTriggerClassStates::IS_ACTIVATED state \" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    });\n// attach the PERFORM_ACTION_CALLED event to the waitset and assign a callback\nwaitset\n    -&gt;attachEvent(*triggerClass,\n                  MyTriggerClassEvents::PERFORM_ACTION_CALLED,\n                  ACTION_ID,\n                  iox::popo::createNotificationCallback(MyTriggerClass::callOnAction))\n    .or_else([](auto) {\n        std::cerr &lt;&lt; \"failed to attach MyTriggerClassEvents::PERFORM_ACTION_CALLED event \" &lt;&lt; std::endl;\n        std::exit(EXIT_FAILURE);\n    });\n</code></pre> <p>Now that everything is set up we can start our <code>eventLoop</code> in a new thread.</p>  <pre><code>std::thread eventLoopThread(eventLoop);\n</code></pre> <p>A thread which will trigger an event every second is started with the following lines.</p>  <pre><code>std::thread triggerThread([&amp;] {\n    uint64_t activationCode = 1U;\n    for (auto i = 0U; i &lt; 10; ++i)\n    {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        triggerClass-&gt;activate(activationCode++);\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        triggerClass-&gt;performAction();\n    }\n\n    std::cout &lt;&lt; \"Sending final trigger\" &lt;&lt; std::endl;\n    keepRunning = false;\n    triggerClass-&gt;activate(activationCode++);\n    triggerClass-&gt;performAction();\n});\n</code></pre> <p> Check out waitset on GitHub  </p>","title":"Using MyTriggerClass"},{"location":"examples/waitset_in_c/","text":"","title":"WaitSet in C"},{"location":"examples/waitset_in_c/#thread-safety","text":"<p>The WaitSet is not thread-safe!</p> <ul> <li>It is not allowed to attach or detach Triggerable    classes with <code>iox_ws_attach_**</code> or <code>iox_ws_detach_**</code> when another thread is currently    waiting for notifications with <code>iox_ws_wait</code> or <code>iox_ws_timed_wait</code>.</li> <li>Do not call any of the <code>iox_ws_</code> functions concurrently.</li> </ul> <p>The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle.</p>","title":"Thread Safety"},{"location":"examples/waitset_in_c/#introduction","text":"<p>A detailed introduction into the WaitSet nomenclature and topic can be found in the waitset C++ example. Here we will only introduce the C API and not the WaitSet in general. For this, we will take a look at the same use case as the waitset C++ example. The examples are structured in the same way as the C++ ones.</p>","title":"Introduction"},{"location":"examples/waitset_in_c/#expected-output","text":"<p></p>","title":"Expected Output"},{"location":"examples/waitset_in_c/#code-walkthrough","text":"<p>Warning</p> <p>Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully.</p>  <p>To run an example you need a running <code>iox-roudi</code> and the waitset publisher <code>iox-c-waitset-publisher</code>. They are identical to the ones introduced in the icedelivery C example.</p>","title":"Code Walkthrough"},{"location":"examples/waitset_in_c/#gateway","text":"<p>Let's say we would like to write a gateway and would like to forward every incoming message from a subscriber with the same callback. For instance we could perform a memcopy of the received data into a specific struct. Additionally, we would like to count all processed samples. Therefore we provide an extra void pointer argument called <code>contextData</code> which is a pointer to an <code>uint64_t</code>.</p> <p>This could be performed by a function that we attach to an event as a callback. In our case, we have the function <code>subscriberCallback</code> that prints out the subscriber pointer and the content of the received sample.</p>  <pre><code>void subscriberCallback(iox_sub_t const subscriber, void* const contextData)\n{\n    if (contextData == NULL)\n    {\n        fprintf(stderr, \"aborting subscriberCallback since contextData is a null pointer\\n\");\n        return;\n    }\n\n    uint64_t* sumOfAllSamples = (uint64_t*)contextData;\n    const void* userPayload = NULL;\n    while (iox_sub_take_chunk(subscriber, &amp;userPayload) == ChunkReceiveResult_SUCCESS)\n    {\n        printf(\"subscriber: %p received %u\\n\", (void*)subscriber, ((struct CounterTopic*)userPayload)-&gt;counter);\n        fflush(stdout);\n\n        iox_sub_release_chunk(subscriber, userPayload);\n        ++(*sumOfAllSamples);\n    }\n}\n</code></pre> <p>The <code>shutdownTrigger</code> gets a simplified callback where it just states that the program will be terminated. For this we do not need any context data.</p>  <pre><code>void shutdownCallback(iox_user_trigger_t userTrigger)\n{\n    (void)userTrigger;\n    printf(\"CTRL+C pressed - exiting now\\n\");\n    fflush(stdout);\n}\n</code></pre> <p>Since we attach the <code>SubscriberEvent_DATA_RECEIVED</code> event to the WaitSet that notifies us just once when data was received we have to gather and process all chunks. One will never miss chunks since the event notification is reset after a call to <code>iox_ws_wait</code> or <code>iox_ws_timed_wait</code> which we introduce below.</p> <p>After we registered our runtime we set up some <code>waitSetStorage</code>, initialize the WaitSet and attach a <code>shutdownTrigger</code> to handle <code>CTRL+C</code>.</p>  <pre><code>iox_runtime_init(\"iox-c-waitset-gateway\");\n\niox_ws_storage_t waitSetStorage;\niox_ws_t waitSet = iox_ws_init(&amp;waitSetStorage);\nshutdownTrigger = iox_user_trigger_init(&amp;shutdownTriggerStorage);\n\n// attach shutdownTrigger with no callback to handle CTRL+C\niox_ws_attach_user_trigger_event(waitSet, shutdownTrigger, 0U, shutdownCallback);\n\n// register signal after shutdownTrigger since we are using it in the handler\nsignal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n</code></pre> <p>In the next steps, we define <code>sumOfAllSamples</code>, create two subscribers with <code>iox_sub_init</code>, subscribe them to our topic and attach the event <code>SubscriberEvent_DATA_RECEIVED</code> to the WaitSet with the <code>subscriberCallback</code>, an event id <code>1U</code> and a pointer to our user defined context data <code>sumOfAllSamples</code> which is then provided as argument for the callback.</p>  <p>Attention</p> <p>The user has to ensure that the contextData (<code>sumOfAllSamples</code>) in <code>iox_ws_attach_subscriber_event_with_context_data</code> lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling.</p>   <pre><code>uint64_t sumOfAllSamples = 0U;\n\n// array where the subscriber are stored\niox_sub_storage_t subscriberStorage[NUMBER_OF_SUBSCRIBERS];\niox_sub_t subscriber[NUMBER_OF_SUBSCRIBERS];\n\n// create subscriber and subscribe them to our service\niox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.historyRequest = 1U;\noptions.queueCapacity = 256U;\noptions.nodeName = \"iox-c-waitSet-gateway-node\";\nfor (uint64_t i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    subscriber[i] = iox_sub_init(&amp;(subscriberStorage[i]), \"Radar\", \"FrontLeft\", \"Counter\", &amp;options);\n\n    iox_ws_attach_subscriber_event_with_context_data(\n        waitSet, subscriber[i], SubscriberEvent_DATA_RECEIVED, 1U, subscriberCallback, &amp;sumOfAllSamples);\n}\n</code></pre> <p>Now that everything is set up we enter the event loop. It always starts with a call to <code>iox_ws_wait</code>, a blocking call which returns us the number of occurred notifications.</p>  <pre><code>uint64_t missedElements = 0U;\nuint64_t numberOfNotifications = 0U;\n\n// array where all notification infos from iox_ws_wait will be stored\niox_notification_info_t notificationArray[NUMBER_OF_NOTIFICATIONS];\n\nbool keepRunning = true;\nwhile (keepRunning)\n{\n    numberOfNotifications = iox_ws_wait(waitSet, notificationArray, NUMBER_OF_NOTIFICATIONS, &amp;missedElements);\n    // ...\n}\n</code></pre> <p>The events which have occurred are stored in the <code>notificationArray</code>. We iterate through it, if the <code>shutdownTrigger</code> was triggered we terminate the program otherwise we call the callback with <code>iox_notification_info_call(notification)</code>.</p>  <pre><code>for (uint64_t i = 0U; i &lt; numberOfNotifications; ++i)\n{\n    iox_notification_info_t notification = notificationArray[i];\n\n    if (iox_notification_info_does_originate_from_user_trigger(notification, shutdownTrigger))\n    {\n        // CTRL+C was pressed -&gt; exit\n        keepRunning = false;\n    }\n    else\n    {\n        // call the callback which was assigned to the event\n        iox_notification_info_call(notification);\n\n        printf(\"sum of all samples: %lu\\n\", (unsigned long)sumOfAllSamples);\n        fflush(stdout);\n    }\n}\n</code></pre> <p>Before we can close the program, we cleanup all resources.</p>  <pre><code>for (uint64_t i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    // not mandatory since iox_sub_deinit will detach the subscriber automatically\n    // only added to present the full API\n    iox_ws_detach_subscriber_event(waitSet, subscriber[i], SubscriberEvent_DATA_RECEIVED);\n    iox_sub_deinit(subscriber[i]);\n}\n\niox_ws_deinit(waitSet);\niox_user_trigger_deinit(shutdownTrigger);\n</code></pre>","title":"Gateway"},{"location":"examples/waitset_in_c/#grouping","text":"<p>In this scenario, we have two groups of subscribers. We are interested in the data of the first group and would like to print them onto the console and the data of the second group should be discarded.</p> <p>We start like in every example with creating the WaitSet and attaching the <code>shutdownTrigger</code>.</p>  <pre><code>iox_runtime_init(\"iox-c-waitset-grouping\");\n\niox_ws_storage_t waitSetStorage;\niox_ws_t waitSet = iox_ws_init(&amp;waitSetStorage);\nshutdownTrigger = iox_user_trigger_init(&amp;shutdownTriggerStorage);\n\n// attach shutdownTrigger with no callback to handle CTRL+C\niox_ws_attach_user_trigger_event(waitSet, shutdownTrigger, 0U, NULL);\n\n// register signal after shutdownTrigger since we are using it in the handler\nsignal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n</code></pre> <p>After that we can create a list of subscribers and subscribe them to our topic.</p>  <pre><code>// array where the subscribers are stored\niox_sub_storage_t subscriberStorage[NUMBER_OF_SUBSCRIBERS];\niox_sub_t subscriber[NUMBER_OF_SUBSCRIBERS];\n\n// create subscriber and subscribe them to our service\niox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.historyRequest = 1U;\noptions.queueCapacity = 256U;\noptions.nodeName = \"iox-c-waitset-grouping-node\";\nfor (uint64_t i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    subscriber[i] = iox_sub_init(&amp;(subscriberStorage[i]), \"Radar\", \"FrontLeft\", \"Counter\", &amp;options);\n}\n</code></pre> <p>To distinct our two groups we set the eventId of the first group to <code>123</code> and of the second group to <code>456</code>. The first two subscribers are attached with the <code>SubscriberState_HAS_DATA</code> state and the event id of the first group to our waitset. The third and forth subscriber are attached to the same waitset under the second group id.</p>  <pre><code>const uint64_t FIRST_GROUP_ID = 123U;\nconst uint64_t SECOND_GROUP_ID = 456U;\n\n// attach the first two subscribers to the waitset with a triggerid of FIRST_GROUP_ID\nfor (uint64_t i = 0U; i &lt; 2U; ++i)\n{\n    iox_ws_attach_subscriber_state(waitSet, subscriber[i], SubscriberState_HAS_DATA, FIRST_GROUP_ID, NULL);\n}\n\n// attach the remaining subscribers to the waitset with a triggerid of SECOND_GROUP_ID\nfor (uint64_t i = 2U; i &lt; 4U; ++i)\n{\n    iox_ws_attach_subscriber_state(waitSet, subscriber[i], SubscriberState_HAS_DATA, SECOND_GROUP_ID, NULL);\n}\n</code></pre> <p>We are again ready for our event loop. We start as usual by setting the array of notifications by calling <code>iox_ws_wait</code>.</p>  <pre><code>bool keepRunning = true;\nwhile (keepRunning)\n{\n    numberOfNotifications = iox_ws_wait(waitSet, notificationArray, NUMBER_OF_NOTIFICATIONS, &amp;missedElements);\n    // ...\n}\n</code></pre> <p>When we iterate through the array we handle the <code>shutdownTrigger</code> first. We check if an event is from the first group by calling <code>iox_notification_info_get_event_id</code> and compare the result with <code>FIRST_GROUP_ID</code>. If that is the case we acquire the subscriber handle with <code>iox_notification_info_get_subscriber_origin</code>. This allows us to receive the new sample and to print the result to the console. The second group is handled in the same way. But we do not print the new samples to screen, we just discard them.</p>  <pre><code>for (uint64_t i = 0U; i &lt; numberOfNotifications; ++i)\n{\n    iox_notification_info_t notification = notificationArray[i];\n\n    if (iox_notification_info_does_originate_from_user_trigger(notification, shutdownTrigger))\n    {\n        // CTRL+C was pressed -&gt; exit\n        keepRunning = false;\n    }\n    // we print the received data for the first group\n    else if (iox_notification_info_get_notification_id(notification) == FIRST_GROUP_ID)\n    {\n        iox_sub_t subscriber = iox_notification_info_get_subscriber_origin(notification);\n        const void* userPayload;\n        if (iox_sub_take_chunk(subscriber, &amp;userPayload))\n        {\n            printf(\"received: %u\\n\", ((struct CounterTopic*)userPayload)-&gt;counter);\n            fflush(stdout);\n\n            iox_sub_release_chunk(subscriber, userPayload);\n        }\n    }\n    // dismiss the received data for the second group\n    else if (iox_notification_info_get_notification_id(notification) == SECOND_GROUP_ID)\n    {\n        printf(\"dismiss data\\n\");\n        iox_sub_t subscriber = iox_notification_info_get_subscriber_origin(notification);\n        // We need to release the samples to reset the event hasSamples\n        // otherwise the WaitSet would notify us in `iox_ws_wait()` again\n        // instantly.\n        iox_sub_release_queued_chunks(subscriber);\n    }\n}\n</code></pre> <p>In the case of the <code>SECOND_GROUP_ID</code> we have to release all queued chunks otherwise the WaitSet would notify us right away since the <code>SubscriberState_HAS_DATA</code> still persists.</p> <p>The last thing we have to do is to cleanup all the acquired resources.</p>  <pre><code>for (uint64_t i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    iox_sub_deinit(subscriber[i]);\n}\n\niox_ws_deinit(waitSet);\niox_user_trigger_deinit(shutdownTrigger);\n</code></pre>","title":"Grouping"},{"location":"examples/waitset_in_c/#individual","text":"<p>We also can handle every event individually, for instance when you would like to have a different reaction for every subscriber which has received a sample. One way would be to assign every subscriber a different callback, here we look at a different approach. We check if the event originated from a specific subscriber and then perform the calls on that subscriber directly.</p> <p>We start as usual by creating a WaitSet and attach the <code>shutdownTrigger</code> to it.</p>  <pre><code>iox_runtime_init(\"iox-c-waitset-individual\");\n\niox_ws_storage_t waitSetStorage;\niox_ws_t waitSet = iox_ws_init(&amp;waitSetStorage);\nshutdownTrigger = iox_user_trigger_init(&amp;shutdownTriggerStorage);\n\n// attach shutdownTrigger with no callback to handle CTRL+C\niox_ws_attach_user_trigger_event(waitSet, shutdownTrigger, 0U, NULL);\n\n// register signal after shutdownTrigger since we are using it in the handler\nsignal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n</code></pre> <p>Now we create two subscribers, subscribe them to our topic and attach them to the waitset without a callback and with the same trigger id.</p>  <pre><code>// array where the subscriber are stored\niox_sub_storage_t subscriberStorage[NUMBER_OF_SUBSCRIBERS];\niox_sub_t subscriber[NUMBER_OF_SUBSCRIBERS];\n\n// create two subscribers, subscribe to the service and attach them to the waitset\niox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.historyRequest = 1U;\noptions.queueCapacity = 256U;\noptions.nodeName = \"iox-c-waitset-individual-node1\";\n\nsubscriber[0] = iox_sub_init(&amp;(subscriberStorage[0]), \"Radar\", \"FrontLeft\", \"Counter\", &amp;options);\n\noptions.nodeName = \"iox-c-waitset-individual-node2\";\nsubscriber[1] = iox_sub_init(&amp;(subscriberStorage[1]), \"Radar\", \"FrontLeft\", \"Counter\", &amp;options);\n\niox_ws_attach_subscriber_state(waitSet, subscriber[0U], SubscriberState_HAS_DATA, 0U, NULL);\niox_ws_attach_subscriber_state(waitSet, subscriber[1U], SubscriberState_HAS_DATA, 0U, NULL);\n</code></pre> <p>We are ready to start the event loop. We begin by acquiring the array of all the triggered triggers.</p>  <pre><code>uint64_t missedElements = 0U;\nuint64_t numberOfNotifications = 0U;\n\n// array where all notification infos from iox_ws_wait will be stored\niox_notification_info_t notificationArray[NUMBER_OF_NOTIFICATIONS];\n\nbool keepRunning = true;\nwhile (keepRunning)\n{\n    numberOfNotifications = iox_ws_wait(waitSet, notificationArray, NUMBER_OF_NOTIFICATIONS, &amp;missedElements);\n    // ...\n}\n</code></pre> <p>The <code>shutdownTrigger</code> is handled as usual and we use <code>iox_notification_info_does_originate_from_subscriber</code> to identify the event that originated from a specific subscriber. If it originated from the first subscriber we print the received data to the console, if it originated from the second subscriber we discard the data.</p>  <pre><code>for (uint64_t i = 0U; i &lt; numberOfNotifications; ++i)\n{\n    iox_notification_info_t notification = notificationArray[i];\n\n    if (iox_notification_info_does_originate_from_user_trigger(notification, shutdownTrigger))\n    {\n        // CTRL+C was pressed -&gt; exit\n        keepRunning = false;\n    }\n    // process sample received by subscriber1\n    else if (iox_notification_info_does_originate_from_subscriber(notification, subscriber[0U]))\n    {\n        const void* userPayload;\n        if (iox_sub_take_chunk(subscriber[0U], &amp;userPayload))\n        {\n            printf(\"subscriber 1 received: %u\\n\", ((struct CounterTopic*)userPayload)-&gt;counter);\n            fflush(stdout);\n\n            iox_sub_release_chunk(subscriber[0U], userPayload);\n        }\n    }\n    // dismiss sample received by subscriber2\n    else if (iox_notification_info_does_originate_from_subscriber(notification, subscriber[1]))\n    {\n        // We need to release the samples to reset the event hasSamples\n        // otherwise the WaitSet would notify us in `iox_ws_wait()` again\n        // instantly.\n        iox_sub_release_queued_chunks(subscriber[1U]);\n        printf(\"subscriber 2 received something - dont care\\n\");\n        fflush(stdout);\n    }\n}\n</code></pre> <p>We conclude the example as always, by cleaning up the resources.</p>  <pre><code>for (uint64_t i = 0U; i &lt; NUMBER_OF_SUBSCRIBERS; ++i)\n{\n    iox_sub_deinit(subscriber[i]);\n}\n\niox_ws_deinit(waitSet);\niox_user_trigger_deinit(shutdownTrigger);\n</code></pre>","title":"Individual"},{"location":"examples/waitset_in_c/#timer-driven-execution","text":"<p>In this example, we demonstrate how you can use the WaitSet to trigger a cyclic call every second. We use a user trigger which will be triggered in a separate thread every second to signal the WaitSet that it's time for the next run. Additionally, we attach a callback (<code>cyclicRun</code>) to this user trigger so that the event can directly call the cyclic call.</p>  <p>Note</p> <p>This example does not run on Windows due to direct usage of the <code>pthread</code> API.</p>  <p>We begin by creating the WaitSet and attach the <code>shutdownTrigger</code>.</p>  <pre><code>iox_runtime_init(\"iox-c-waitset-timer-driven-execution\");\n\niox_ws_storage_t waitSetStorage;\niox_ws_t waitSet = iox_ws_init(&amp;waitSetStorage);\nshutdownTrigger = iox_user_trigger_init(&amp;shutdownTriggerStorage);\n\n// attach shutdownTrigger with no callback to handle CTRL+C\niox_ws_attach_user_trigger_event(waitSet, shutdownTrigger, 0, NULL);\n\n// register signal after shutdownTrigger since we are using it in the handler\nsignal(SIGINT, sigHandler);\nsignal(SIGTERM, sigHandler);\n</code></pre> <p>Now we create our cyclic trigger and attach it to our waitset with an eventId of <code>0</code> and the callback <code>cyclicRun</code>.</p>  <pre><code>cyclicTrigger = iox_user_trigger_init(&amp;cyclicTriggerStorage);\niox_ws_attach_user_trigger_event(waitSet, cyclicTrigger, 0, cyclicRun);\n</code></pre> <p>The thread which will trigger the <code>cyclicTrigger</code> every second is started in the next lines.</p>  <pre><code>pthread_t cyclicTriggerThread;\nif (createThread(&amp;cyclicTriggerThread, cyclicTriggerCallback))\n{\n    printf(\"failed to create thread\\n\");\n    return -1;\n}\n</code></pre> <p>Everything is prepared and we enter the event loop. We start by gathering all notifications in an array.</p>  <pre><code>uint64_t missedElements = 0U;\nuint64_t numberOfNotifications = 0U;\n\n// array where all notifications from iox_ws_wait will be stored\niox_notification_info_t notificationArray[NUMBER_OF_NOTIFICATIONS];\n\nwhile (keepRunning)\n{\n    numberOfNotifications = iox_ws_wait(waitSet, notificationArray, NUMBER_OF_NOTIFICATIONS, &amp;missedElements);\n    // ...\n}\n</code></pre> <p>The <code>shutdownTrigger</code> is handled as usual and the <code>cyclicTrigger</code> is handled by just calling the attached callback with <code>iox_notification_info_call(notification)</code>.</p>  <pre><code>for (uint64_t i = 0U; i &lt; numberOfNotifications; ++i)\n{\n    iox_notification_info_t notification = notificationArray[i];\n\n    if (iox_notification_info_does_originate_from_user_trigger(notification, shutdownTrigger))\n    {\n        // CTRL+C was pressed -&gt; exit\n        keepRunning = false;\n    }\n    else\n    {\n        // call myCyclicRun\n        iox_notification_info_call(notification);\n    }\n}\n</code></pre> <p>The last thing we have to do is to cleanup all the used resources.</p>  <pre><code>joinThread(cyclicTriggerThread);\niox_ws_deinit(waitSet);\niox_user_trigger_deinit(shutdownTrigger);\n</code></pre> <p> Check out waitset_in_c on GitHub  </p>","title":"Timer Driven Execution"},{"location":"getting-started/installation/","text":"<p>All iceoryx libraries are deployed as independent CMake packages. Posh is using functions from hoofs and is depending on it. You are able to build posh and hoofs and integrate them into existing CMake projects.</p>","title":"Installation"},{"location":"getting-started/installation/#prerequisites","text":"","title":"Prerequisites"},{"location":"getting-started/installation/#dependencies","text":"<ul> <li>64-bit hardware (e.g. x86_64 or aarch64; 32-bit hardware might work, but is not supported)</li> <li>CMake, 3.16 or later</li> <li>One of the following compilers:<ul> <li>GCC, 8.3 or later (5.4 currently supported too)</li> <li>Clang, 9.0 or later</li> <li>MSVC, part of Visual Studio 2019 or later</li> </ul> </li> <li>libacl, 2.2 or later. Only for Linux &amp; QNX.</li> <li>optional, ncurses, 6.2 or later. Required by introspection tool (only for Linux, QNX and MacOS).</li> </ul>","title":"Dependencies"},{"location":"getting-started/installation/#optional-cyclone-dds-gateway","text":"<p>The Cyclone DDS gateway depends currently on Cyclone DDS. When building it with the CMake option <code>-DDDS_GATEWAY=ON</code> it will be automatically installed as a dependency. Furthermore, you have to install:</p> <ul> <li>GNU Bison, 3.0.4 or later</li> </ul>","title":"Optional, Cyclone DDS Gateway"},{"location":"getting-started/installation/#mac-os","text":"<p>Before installing iceoryx you need to install XCode and git. Optionally, ncurses library is required for the introspection client. To install ncurses locally into your build folder follow these steps</p> <pre><code>cd iceoryx\nICEORYX_DIR=$PWD\nmkdir -p build\ncd build\ngit clone https://github.com/mirror/ncurses.git\ncd ncurses\ngit checkout v6.2\n./configure  --prefix=$ICEORYX_DIR/build/dependencies/ --exec-prefix=$ICEORYX_DIR/build/dependencies/ --with-termlib\nmake -j12\nmake install\n</code></pre>","title":"Mac OS"},{"location":"getting-started/installation/#linux","text":"<p>Although we strive to be fully POSIX-compliant, we recommend using Ubuntu 18.04 and at least GCC 7.5.0 for development.</p> <p>You will need to install the following packages:</p> <pre><code>sudo apt install gcc g++ cmake libacl1-dev libncurses5-dev pkg-config\n</code></pre> <p>Additionally, there is an optional dependency to the cpptoml library, which is used to parse the RouDi config file containing mempool configuration.</p>","title":"Linux"},{"location":"getting-started/installation/#qnx","text":"<p>QNX SDP 7.0 and 7.1 are supported (shipping with gcc 5.4 and gcc 8.3 respectively).</p> <p>The easiest way to build iceoryx on QNX is by using the build script and providing a toolchain file. We provide generic QNX SDP 7.0 toolchain files for ARM_64 and X86_64 in <code>./tools/toolchains/qnx</code> (Direct Link).</p> <p>ARM_64:</p> <pre><code>./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_aarch64le.cmake\n</code></pre> <p>X86_64:</p> <pre><code>./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_x86_64.cmake\n</code></pre>  <p>Attention</p> <p>Please ensure that the folder <code>/var/lock</code> exist and the filesystem supports file locking.</p>","title":"QNX"},{"location":"getting-started/installation/#windows","text":"<p>In case you do not have a Windows installation, Microsoft provides free developer images from here.</p> <p>Additionally, CMake and git are required. The option to add CMake to the system PATH for all users should be set when it is installed.</p> <p>If the developer image from Microsoft is used, Visual Studio Community 2019 is already installed, else it can be found here.</p> <p>To be able to compile iceoryx, the <code>Desktop development with C++</code> Workload must be installed. This is done by running <code>VisualStudioInstaller</code> and selecting the <code>Modify</code> button on <code>Visual Studio Community 2019</code>.</p> <p>Either <code>VS Code</code> or <code>Developer Command Prompt</code> can be used to build iceoryx with CMake. Maybe one or two restarts are required to let CMake find the compiler.</p> <p>Alternatively, <code>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat</code> can be executed in any shell to setup all the paths for compilation.</p>","title":"Windows"},{"location":"getting-started/installation/#build-with-cmake","text":"<p>Note</p> <p>Building with CMake is the preferred way, for more complex actions like a coverage scan is a script available (see chapter below).</p>  <p>The <code>CMakeLists.txt</code> from <code>iceoryx_meta</code> can be used to easily develop iceoryx with an IDE.</p> <ol> <li> <p>Clone the repository</p> <pre><code>git clone https://github.com/eclipse-iceoryx/iceoryx.git\n</code></pre> </li> <li> <p>Generate the necessary build files</p> <pre><code>cd iceoryx\ncmake -Bbuild -Hiceoryx_meta\n# when you have installed external dependencies like ncurses you have to add them\n# to your prefix path\ncmake -Bbuild -Hiceoryx_meta -DCMAKE_PREFIX_PATH=$(PWD)/build/dependencies/\n</code></pre>  <p>Tip</p> <p>To build all iceoryx components add <code>-DBUILD_ALL=ON</code> to the CMake command. For Windows it is currently recommended to use the <code>cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST=ON -DINTROSPECTION=OFF -DBINDING_C=ON -DEXAMPLES=ON</code> instead</p>  </li> <li> <p>Compile the source code</p> <pre><code>cmake --build build\n</code></pre>  <p>Tip</p> <p>You can speed up the build by appending <code>-j 4</code> where 4 stands for the number of parallel build processes. You can choose more or less depending on your available CPU cores on your machine.</p>  </li> <li> <p>Install to system</p> <p>Mac:</p> <pre><code>cmake --build build --target install\n</code></pre> <p>Linux:</p> <pre><code>sudo cmake --build build --target install\n</code></pre>  <p>Tip</p> <p>The installation directory is usually left at its default, which is <code>/usr/local</code></p>   <p>Note</p> <p>iceoryx is built in release mode as static library with <code>-O3</code> optimization by default. If you want to enable debug symbols please set <code>CMAKE_BUILD_TYPE=Deb</code>.</p>  </li> </ol>","title":"Build with CMake"},{"location":"getting-started/installation/#build-options","text":"<p>Please take a look at the CMake file build_options.cmake to get an overview of the available build options for enabling additional features.</p>","title":"Build options"},{"location":"getting-started/installation/#build-with-script","text":"<p>As an alternative, we provide a build-test script which we use to integrate iceoryx into our infrastructure. The intention of the script goes beyond building iceoryx, it is also used for the code coverage scan or the address-sanitizer runs on the CI. The script currently works for Linux and QNX only, it is planned to offer a multi-platform solution.</p> <ol> <li> <p>Clone the repository</p> <pre><code>git clone https://github.com/eclipse-iceoryx/iceoryx.git\n</code></pre> </li> <li> <p>Build everything</p> <pre><code>cd iceoryx\n./tools/iceoryx_build_test.sh build-all\n</code></pre>  <p>Note</p> <p>The build script is installing the header files and binaries into <code>build/install/prefix</code>.</p>  </li> </ol> <p>You can use the <code>help</code> argument for getting an overview of the available options:</p> <pre><code>./tools/iceoryx_build_test.sh help\n</code></pre>  <p>Tip</p> <p>The examples can be built with <code>-DEXAMPLES=ON</code> with iceoryx_meta or by providing the <code>examples</code> argument to the build script.</p>","title":"Build with script"},{"location":"getting-started/installation/#build-with-colcon","text":"<p>Alternatively, iceoryx can be built with colcon to provide a smooth integration for ROS 2 developers. To build the iceoryx_integrationtest package one requires a minimal ROS 2 installation.</p> <p>Install required ROS 2 packages:</p> <pre><code>sudo apt install ros-foxy-ros-testing ros-foxy-ros-base\nsource /opt/ros/foxy/setup.bash\n</code></pre> <p>build with colcon:</p> <pre><code>mkdir -p iceoryx_ws/src\ncd $_\ngit clone https://github.com/eclipse-iceoryx/iceoryx.git\ncd ..\ncolcon build\n</code></pre>  <p>Note</p> <p>If you don't want to install ROS 2, you can skip the iceoryx_integrationtest package by calling:</p> <pre><code>colcon build --packages-skip iceoryx_integrationtest\n</code></pre>  <p>This build method makes the most sense in combination with rmw_iceoryx</p>","title":"Build with colcon"},{"location":"getting-started/overview/","text":"<p>This document covers the core functionality of Eclipse iceoryx and is intended to provide a quick introduction to setting up iceoryx applications.</p>","title":"Overview"},{"location":"getting-started/overview/#general","text":"<p>To set up a collection of applications using iceoryx (an iceoryx system), the applications need to initialize a runtime and create communication participants like publishers and subscribers or clients and servers. Publishers send data of a specific topic which can be received by subscribers of the same topic. Servers wait on a topic for requests from clients and respond to these requests. To enable the operation of these participants, the middleware daemon, called <code>RouDi</code>, must be running.</p> <p>But before we get into more details, let's start with a simple publish-subscribe example.</p>","title":"General"},{"location":"getting-started/overview/#a-first-example","text":"<p>We need to create a runtime with a unique name along all applications for each application to enable communication with RouDi.</p> <pre><code>iox::runtime::PoshRuntime::initRuntime(\"some_unique_name\");\n</code></pre> <p>Now this application is ready to communicate with RouDi and we can define the data type we want to send.</p> <pre><code>struct CounterTopic\n{\n    uint32_t counter;\n};\n</code></pre> <p>Then we create a publisher that offers our CounterTopic.</p> <pre><code>iox::popo::Publisher&lt;CounterTopic&gt; publisher({\"Group\", \"Instance\", \"CounterTopic\"});\n</code></pre> <p>Now we can use the publisher to send the data.</p> <pre><code>auto result = publisher.loan();\nif(!result.has_error())\n{\n    auto&amp; sample = result.value();\n    sample-&gt;counter = 30;\n    sample.publish();\n}\nelse\n{\n    // handle the error\n}\n</code></pre> <p>Here <code>result</code> is an <code>expected</code> and hence we may get an error. This can happen if we try to loan too many samples and exhaust memory. We have to handle this potential error since the expected class has the <code>nodiscard</code> keyword attached. This means we get a warning (or an error when build in strict mode) when we don't handle it. We could also explicitly discard it with <code>IOX_DISCARD_RESULT</code> which is discouraged. If you want to know more about <code>expected</code>, take a look at How optional and error values are returned in iceoryx.</p> <p>Let's create a corresponding subscriber.</p> <pre><code>iox::popo::Subscriber&lt;CounterTopic&gt; subscriber({\"Group\", \"Instance\", \"CounterTopic\"});\n</code></pre> <p>Now we can use the subscriber to receive data. For simplicity, we assume that we periodically check for new data. It is also possible to explicitly wait for data using the WaitSet or the Listener. The code to receive the data is the same, the only difference is the way we wake up before checking for data.</p> <pre><code>while (keepRunning)\n{\n    // wait for new data (either sleep and wake up periodically or by notification from the waitset)\n\n    auto result = subscriber.take();\n\n    if(!result.has_error())\n    {\n        auto&amp; sample = result.value();\n        uint32_t counter = sample-&gt;counter;\n        //process the data\n    }\n    else\n    {\n        //handle the error\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n}\n</code></pre> <p>By calling <code>take</code> we get an <code>expected</code> and hence we have to handle the potential error.</p> <p>And that's it. We have created our first simple iceoryx example. Here you can find further examples which demonstrate how iceoryx can be used and describe our API in more detail.</p> <p>Now that we have applications capable of sending and receiving data, we can run the complete iceoryx system.</p>  <p>Note</p> <p>RouDi and all Apps have to be built with the same compiler and the same compiler flags.</p>  <p>First we need to start RouDi.</p> <pre><code># If installed and available in PATH environment variable\niox-roudi\n# If build from scratch with script in tools\n$ICEORYX_ROOT/build/iox-roudi\n</code></pre> <p>Afterwards, we can start the applications which immediately connect to the RouDi via their runtime.</p> <p>When the application terminates, the runtime cleans up all resources needed for communication with RouDi. This includes all memory chunks used for the data transmission which may still be held by the application.</p> <p>Before going into the details in the next sections, the following animation depicts the course of events.</p> <p></p> <p>We now briefly define the main entities of an iceoryx system which were partially already used in the example above.</p>","title":"A first example"},{"location":"getting-started/overview/#roudi","text":"<p>RouDi is an abbreviation for Routing and Discovery. RouDi takes care of the communication setup but does not actually participate in the communication between the publisher and the subscriber or the client and the server. RouDi can be thought of as the switchboard operator of iceoryx. One of its other major tasks is the setup of the shared memory, which the applications use for exchanging payload data. Sometimes referred to as daemon, RouDi manages the shared memory and is responsible for the service discovery, i.e. enabling subscribers/clients to find topics offered by publishers/servers. It also keeps track of all applications which have initialized a runtime and are hence able to create publishers, subscribers, servers or clients. It provides facilities for applications to query this information.</p> <p>When an application crashes, RouDi cleans up all resources. Due to our mostly lock-free inter-process mechanisms (only one last lock; we are working to remove it), iceoryx-based communication is much more reliable compared to traditional mechanism using locking.</p> <p>To view the available command line options for RouDi call <code>$ICEORYX_ROOT/build/iox-roudi --help</code>.</p>","title":"RouDi"},{"location":"getting-started/overview/#shared-memory","text":"<p>To enable zero-copy inter-process communication, iceoryx uses the shared memory approach, i.e. publishers and subscribers or clients and servers can communicate via shared memory resulting in zero-copy communication.</p> <p>Shared memory is physical memory that is made accessible to multiple processes via a mapping to a memory area in their virtual address spaces.</p> <p>For further information have a look at our shared memory concept article.</p>","title":"Shared memory"},{"location":"getting-started/overview/#runtime","text":"<p>Each application that wants to use iceoryx has to instantiate its runtime, which essentially enables communication with RouDi.</p> <p>To do so, the following lines of code are required</p> <pre><code>iox::runtime::PoshRuntime::initRuntime(\"some_unique_application_name\");\n</code></pre> <p>The runtime is an object inside the user application that maps the shared memory into the user application's address space.</p>  <p>Note</p> <p>Only one runtime object per user application is allowed.</p>","title":"Runtime"},{"location":"getting-started/overview/#creating-service-descriptions-for-topics","text":"<p>A <code>ServiceDescription</code> in iceoryx represents a topic under which publishers and subscribers or clients and servers can exchange data and is uniquely identified by three string identifiers.</p> <ol> <li><code>Group</code> name</li> <li><code>Instance</code> name</li> <li><code>Topic</code> name</li> </ol> <p>A triple consisting of such strings is called a <code>ServiceDescription</code>. Two <code>ServiceDescription</code>s are considered matching if all these three strings are element-wise equal, i.e. group, instance and topic names are the same for both of them. This means the group and instance identifier can be ignored to create different <code>ServiceDescription</code>s. They will be needed for advanced filtering functionality in the future.</p> <p>The service model of iceoryx is derived from AUTOSAR and is still used in the API with these names (<code>Service</code>, <code>Instance</code>, <code>Event</code>). The so called canonical protocol is implemented in the namespace <code>capro</code>.</p> <p>The following table gives an overview of the different terminologies and the current mapping:</p>     Group Instance Topic     rmw_iceoryx Type Namespace/Topic -   AUTOSAR Service Instance Event   DDS Gateway - - /Group/Instance/Topic   Cyclone DDS - Type Name Topic Name    <p>Service is related to instance like classes are related to objects in C++. A service describes an abstract topic and an instance is one instantiation of that abstraction, like an object is an instantiated class. Events are in this context like members of a class.</p> <p>Example:</p> <pre><code>class MyRadarService {\n   public:\n      bool hasObstacleDetected;\n      float distanceToObstacle;\n};\n\nMyRadarService frontLeftRadarInstance;\nstd::cout &lt;&lt; frontLeftRadarInstance.hasObstacleDetected &lt;&lt; std::endl;\n</code></pre> <p>In the iceoryx world, we would for instance subscribe to the service <code>(\"MyRadarService\", \"frontLeftRadarInstance\", \"hasObstacleDetected\")</code> and would receive a sample whenever an obstacle was detected. Or we would subscribe to <code>distanceToObstacle</code> and would receive a constant stream of data which presents the distance to the obstacle.</p>","title":"Creating service descriptions for topics"},{"location":"getting-started/overview/#restrictions","text":"<p>The data type of the transmitted data can be any C++ class, struct or plain old data type as long as it satisfies the following conditions:</p> <ul> <li>no heap is used</li> <li>the data structure is entirely contained in the shared memory - no pointers to process local memory, no references to process local constructs, no dynamic allocators</li> <li>the data structure has to be relocatable and therefore must not internally use pointers/references</li> <li>no virtual member functions</li> </ul>  <p>Note</p> <p>Most of the STL types cannot be used, but we reimplemented some of them so that they meet the conditions above. You can find an overview here.</p>","title":"Restrictions"},{"location":"getting-started/overview/#publisher","text":"<p>A publisher is tied to a topic and needs a service description to be constructed. If it is typed, one needs to additionally specify the data type as a template parameter. Otherwise, the publisher is only aware of raw memory and the user has to ensure that it is interpreted correctly.</p> <p>Once it has offered its topic, it is able to publish (send) data of the specific type. Note that the default is to have multiple publishers for the same topic (n:m communication). A compile-time option to restrict iceoryx to 1:n communication is available. Should 1:n communication be used, RouDi checks for multiple publishers on the same topics and raises an error if there is more than one publisher for a topic.</p>","title":"Publisher"},{"location":"getting-started/overview/#subscriber","text":"<p>Symmetrically a subscriber also corresponds to a topic and thus needs a service description to be constructed. As for publishers we distinguish between typed and untyped subscribers.</p> <p>Once a subscriber is subscribed to some topic, it is able to receive data of the type tied to this topic. In the untyped case this is raw memory and the user must take care that it is interpreted in a way that is compatible to the data that was actually sent.</p> <p>When multiple publishers have offered the same topic the subscriber will receive the data of all of them (but in indeterminate order between different publishers). Note that the subscriber will not receive data from servers or clients, even when they use the same topic.</p>","title":"Subscriber"},{"location":"getting-started/overview/#client","text":"<p>Similar to publishers and subscribers, clients are tied to a topic and need a service description to be constructed. If the client is typed, one needs to specify the request and response data types as template parameters. In the untyped case, the client is only aware of raw memory and the user has to take care of its correct interpretation.</p> <p>Once a client is connected to a server, it can send requests to and receive responses from the server. A sequence ID is used to match a response to a specific request. It must be set on request and checked on response by the user.</p>","title":"Client"},{"location":"getting-started/overview/#server","text":"<p>Like a client, a server needs a service description to be constructed and can be typed or untyped. In the typed case, the user has to provide the request and the response data types as template parameters. Otherwise, the server handles raw memory and the user has to ensure that it is interpreted correctly.</p> <p>Once connected, the server can receive requests from clients and send the corresponding responses.</p>","title":"Server"},{"location":"getting-started/overview/#avoid-polling","text":"<p>The easiest way to receive data is to periodically poll whether data is available as depicted on the left side of the picture below for the publish-subscribe messaging pattern. This is sufficient for simple use cases but inefficient in general, as it often leads to unnecessary latency and wake-ups without data. An alternative approach to receive data is to wait for user-defined events to occur. This is provided by our <code>WaitSet</code> and <code>Listener</code> which are introduced in the following sections.</p> <p></p>","title":"Avoid polling"},{"location":"getting-started/overview/#waitset","text":"<p>The WaitSet can be used to relinquish control by putting the thread to sleep with a non-busy wait and wait for user-defined events to occur. Usually, these events correspond to the availability of data at specific subscribers or clients. This way we can immediately wake up when data is available and avoid unnecessary wake-ups if no data is available.</p> <p>One typical use case is to create a WaitSet, attach multiple subscribers and/or clients and user triggers and then wait until one or many of the attached objects signal an event. If this happens one receives a list of all occured events called <code>notificationVector</code>. This makes it possible to collect data directly from the subscriber or client when it signals the WaitSet that new data or a new response is available.</p> <p>The WaitSet uses the reactor pattern and is informed with a push strategy that one of the attached events occured at which it informs the user.</p> <p>For more information on how to use the WaitSet see our WaitSet examples.</p>","title":"WaitSet"},{"location":"getting-started/overview/#listener","text":"<p>The Listener can be used to connect custom callbacks to user-defined events. Unlike the WaitSet, it reacts to those events by executing the connected custom callbacks in a background thread, that will be created by the Listener. As with the WaitSet the background thread waits non-busy on the reception of new data.</p>  <p>Note</p> <p>The Listener is completely thread-safe but please be aware that most of the objects which can be attached to the Listener are not thread-safe! This means either the object is handled solely by the Listener, which should be the most common use case, or the user has to ensure the thread safety with other means like encapsulating the object in a thread-safe class.</p>  <p>One use case could be that one creates a Listener and attaches multiple subscribers. Every time new data is available, the corresponding connected callback will be executed, e.g. print something to the console or calculate an algorithm. Another use case could be that a server is attached to the Listener and every time a request is received, the connected callback that creates and sends a response, is executed.</p> <p>Like the WaitSet, the Listener uses the reactor pattern.</p> <p>For more information about the Listener see our callbacks examples.</p>","title":"Listener"},{"location":"getting-started/overview/#api","text":"<p>The API is offered in two languages, C++ and C. Detailed information can be found in the C++ example and C example.</p> <p>Many parts of the C++ API follow a functional programming approach which is less error-prone. This requires using the monadic types <code>cxx::expected</code> and <code>cxx::optional</code> which are introduced here.</p> <p>With the C++ API, we distinguish between the <code>typed API</code> and the <code>untyped API</code>. In the typed API, the underlying data type is made apparent by typed pointers or references to some data type T (often a template parameter). This allows working with the data in a C++ idiomatic and type-safe way and should be preferred whenever possible. The typed API is mainly used when iceoryx is used stand-alone, i.e. not integrated into a third party framework.</p> <p>The untyped API provides opaque (i.e. void) pointers to data, which is flexible and efficient but also requires that the user takes care to interpret received data correctly, i.e. as a type compatible to what was actually sent. This is required for interaction with other lower level APIs and integration into third party frameworks such as ROS. For further information see the respective header files.</p>","title":"API"},{"location":"getting-started/what-is-iceoryx/","text":"<p>The technology behind Eclipse iceoryx originated in the automotive domain. With the introduction of video-based driver assistance, the amount of data to be exchanged between different threads of execution increased to GBytes/sec. The resources on these embedded systems were constrained and a solution was needed to use precious runtime for functional computations, not for shifting around bytes in memory.</p> <p>The simple answer was to avoid copying of messages inside the middleware that manages the data communication between the different software nodes. This can be done by using shared memory that can be accessed by the producers and consumers of messages. On its own, this is not a new innovation as the approach has been used since the 1970s. However, iceoryx takes the approach further, ending up in an inter-process-communication technology with a publish/subscribe and request/response architecture that is fast, flexible and dependable.</p>","title":"What is Eclipse iceoryx?"},{"location":"getting-started/what-is-iceoryx/#fast","text":"<p>With the iceoryx API, a publisher can write the message directly into a chunk of memory that was previously requested from the middleware. When the message is delivered, subscribers receive reference counted pointers to these memory chunks, which are stored in queues with configurable capacities. The same principle applies to clients and servers. With this iceoryx achieves what we refer to as true zero-copy \u2014 an end-to-end approach from producers to consumers without creating a single copy.</p> <p>Avoiding the copies on API level is crucial when GBytes of sensor data have to be processed per second on robotics and autonomous driving systems. Therefore the iceoryx team contributed to the standardization of true zero-copy capable APIs in ROS 2 and AUTOSAR Adaptive.</p> <p>On modern processors iceoryx has a latency of less than 1 \u00b5s for transferring a message. And the best message is that this latency is constant as size doesn't matter. Want to give it a try? Then have a look at our iceperf example after having made the first steps.</p>","title":"Fast"},{"location":"getting-started/what-is-iceoryx/#flexible","text":"<p>iceoryx already supports Linux, QNX and MacOS as operating systems as well as C and C++ as user APIs. Windows and Rust are the next ones on the list. The typed C++ API is the most comfortable when you want to directly use the iceoryx API on the user side. The untyped C++ API and the C API provide a data agnostic interface that is often preferred when integrating iceoryx as shared memory backbone into a bigger framework.</p> <p>The APIs support polling access and event-driven interactions with the WaitSet and Listener. Applications can be started and stopped flexibly as there is a service discovery behind the scenes that dynamically connects matching communication entities.</p> <p>That iceoryx has the right set of features can be seen from the already existing integrations in middleware and frameworks such as Eclipse Cyclone DDS,  eCAL from Continental,  RTA-VRTE from ETAS and  Apex.Middleware from Apex.AI.</p>","title":"Flexible"},{"location":"getting-started/what-is-iceoryx/#dependable","text":"<p>The predecessor of iceoryx is running in millions of vehicles worldwide. All iceoryx maintainers hail from the safety critical automotive domain. Hence, they know the necessary requirements and have these in mind for the design and implementation of features. The usage of heap, exceptions and any undefined behavior are to be avoided to increase the predictability. Instead a custom memory allocation is being used, based on static memory pools. Additionally, the handling of return values and error cases was inspired by upcoming C++ features and other languages like Rust (details can be found here).</p> <p>As different processes are operating on shared data structures, avoiding deadlocks is becoming all the more important. iceoryx uses lock-free data structures like the multi-producer multi-consumer (MPMC) queue that was written portably thanks to modern C++.</p> <p>The tools available for automotive-compliant software development are always one or two releases behind the latest C++ standard. This fact, combined with our already mentioned constraints, led to a bunch of STL like C++ classes that have the goal to combine modern C++ with the reliability needed for the domains iceoryx is used in. They can be found in the iceoryx hoofs which are introduced here.</p>","title":"Dependable"},{"location":"release-notes/iceoryx-unreleased/","text":"","title":"iceoryx vx.x.x"},{"location":"release-notes/iceoryx-unreleased/#vxxx-xxxx-xx-xx","text":"<p>Full Changelog</p> <p>Features:</p> <p>Bugfixes:</p> <ul> <li>Foo Bar #000</li> </ul> <p>Refactoring:</p> <p>New API features:</p> <p>API Breaking Changes:</p> <ol> <li> <p>Some API change.</p> <pre><code>// before\n#include \"old/include.hpp\"\n\n// after\n#include \"new/include.hpp\"\n</code></pre> </li> </ol>","title":"vx.x.x (xxxx-xx-xx)"},{"location":"release-notes/iceoryx-v1-0-0/","text":"","title":"iceoryx v1.0.0"},{"location":"release-notes/iceoryx-v1-0-0/#v100-2021-04-15","text":"<p>Full Changelog</p> <p>Description: This is the first major release for Eclipse iceoryx. That means it is the first release with long-term support and the adopters of iceoryx can rely on a stable API. The release called Almond allows for true zero-copy inter-process-communication on Linux, QNX and MacOS and provides C and modern C++ user APIs. This release is supported until 2022-04-01.</p> <p>Compared to the feature content of the initial contribution, the main new features are:</p> <p>Features:</p> <ul> <li>Introduction of a C API</li> <li>Refactoring of C++ API</li> <li>MacOS support</li> <li>Support for n:m communication</li> <li>Bridge to Eclipse Cyclone DDS</li> </ul> <p>See Eclipse iceoryx 1.0.0 (Almond) for more information.</p> <ul> <li>Reserved chunkinfo user payload header #14</li> <li>New chunk available callback for the new C++ and C APIs #350</li> <li>Add generic QNX toolchain files #609</li> <li>Introduction of Runnables/Nodes for the new APIs #349</li> <li>extend waitset and listener for member use case and waitset callback for user type #707</li> </ul> <p>Refactoring:</p> <ul> <li>Added tests to iceoryx_posh and iceoryx_utils #496,  #484, #454 , #240</li> <li>Add [[nodiscard]] keyword to cxx::expected class #624</li> <li>Refactor Relocatable Pointer #605</li> <li>Integration test with RouDi and new API elements #378</li> <li>Refactoring copyright headers #483</li> <li>Integration of Unix Domain Sockets #381</li> <li>Add how to install after build to guide #533</li> <li>Add maven and openjdk-14-jdk-headless as build prerequisites #525</li> <li>Refine modern pub/sub API #408</li> <li>Replace introspection threads with PeriodicTask #489</li> <li>Enable UndefinedBehaviorSanitizer #489</li> <li>Move iceoryx from eclipse to iceoryx-eclipse organization #467</li> </ul> <p>Fixed bugs:</p> <ul> <li>TOML parser exceptions will crash RouDi #622</li> <li>fail build on ubuntu 16.04 with g++ 5.4.0 #495</li> <li>Wrong handling of applications that are started multiple times in parallel #404</li> <li>Expected and_then/or_else calling callable without checking #599</li> <li>std::void_t used in code #591</li> <li>Fix resource leak caused by move ctor/assignment #542</li> <li>nanoseconds in units::Duration are truncated #190</li> <li>popo/user_trigger.hpp:33:5: error: exception specification of explicitly defaulted default constructor does not match the calculated one #494</li> <li>iceoryx libs should be build as static libs #509</li> <li>Build with gcov is broken #497</li> </ul>","title":"v1.0.0 (2021-04-15)"},{"location":"release-notes/iceoryx-v1-0-0/#v0997-2021-04-09","text":"<p>Full Changelog</p> <ul> <li>cleanup testing libraries; if used outside of iceoryx, include paths and link targets must be adjusted</li> <li>build iceoryx_utils, iceoryx_posh and iceoryx_binding_c as shared libraries in colcon</li> </ul>","title":"v0.99.7 (2021-04-09)"},{"location":"release-notes/iceoryx-v1-0-0/#v0996-2021-04-08","text":"<p>Full Changelog</p> <ul> <li>Add git to dependency list in iceoryx_posh for RHEL</li> </ul>","title":"v0.99.6 (2021-04-08)"},{"location":"release-notes/iceoryx-v1-0-0/#v0995-2021-04-08","text":"<p>Full Changelog</p> <ul> <li>Add libatomic to dependency list in iceoryx_utils for RHEL</li> </ul>","title":"v0.99.5 (2021-04-08)"},{"location":"release-notes/iceoryx-v1-0-0/#v0994-2021-04-06","text":"<p>Full Changelog</p> <ul> <li>Increase version number to trigger build again on ROS buildfarm</li> </ul>","title":"v0.99.4 (2021-04-06)"},{"location":"release-notes/iceoryx-v1-0-0/#v0993-2021-04-06","text":"<p>Full Changelog</p> <ul> <li>Increase version number to trigger build again on ROS buildfarm</li> </ul>","title":"v0.99.3 (2021-04-06)"},{"location":"release-notes/iceoryx-v1-0-0/#v0992-2021-04-03","text":"<p>Full Changelog</p> <ul> <li>Prepare package release for iceoryx 1.0 #670</li> </ul>","title":"v0.99.2 (2021-04-03)"},{"location":"release-notes/iceoryx-v1-0-0/#v0990-2021-04-01","text":"<p>Full Changelog</p> <p>Intermediate Milestone before the final 1.0.0 release, see v.1.0.0 above for the changes.</p>","title":"v0.99.0 (2021-04-01)"},{"location":"release-notes/iceoryx-v1-0-0/#v0900-2020-12-22","text":"<p>Full Changelog</p> <p>Pre-Release for new and stable APIs and n:m pub/sub communication</p> <p>This is a pre-release for our first long-term-support release that is coming soon (will be iceoryx_1.0.0).</p> <p>We had a major refactoring of the iceoryx communication infrastructure which allows to do n:m communication now and provides a flexible history functionality for late joining subscribers.</p> <p>This new infrastructure is also made to support request/response communication as a next step (#27). The C++ API has been completely reworked and a new C API has been added.</p> <p>We will give the API draft some weeks for finalizing the features and to incorporate feedback from the community. There's an issue in which we collect and discuss the final modifications (#408).</p> <p>Features:</p> <ul> <li>Complete refactoring of publishers and subscribers from shared memory data structures to user APIs, #252</li> <li>First versions of new APIs for C++ and C #252</li> <li>n:m publish/subscribe communication now possible #25</li> <li>First version of a DDS gateway. Cyclone DDS already integrated, FastDDS on it's way #64, #65</li> <li>New github actions for Mac OS and colcon build #175, #276, #328</li> <li>Adjustable capacity for the lockfree queue #216</li> <li>Check the files have a copyright header #346</li> </ul> <p>Refactoring:</p> <ul> <li>Refactoring of waitset #341</li> <li>create multi publisher example #394</li> <li>Full IceOryx Public API Cheat Sheet #283</li> <li>Rework build and test steps in iceoryx #433</li> <li>Extend iceperf example to C API #453</li> <li>Remove default parameter from PoshRuntime::getInstance() #382</li> <li>Enable Sanitizer in Debug Build and Unit Tests #141</li> <li>Minor RouDi cleanups #91</li> <li>C++14 #220</li> <li>Replace occurence of std::list by cxx::list #221</li> </ul> <p>Fixed bugs:</p> <ul> <li>SegFault in iox-roudi on startup #447</li> <li>Mocks can cause segfaults/undefined behavior #427</li> <li>Chunks are lost forever when having an overflow in a variant queue of type FIFO #456</li> <li>RouDi does not free shared memory properly on x86 Linux #324</li> <li>WaitSet behavior wrong in <code>waitAndReturnFulfilledConditions</code> #388</li> <li>Incorrect usage of strncpy #374</li> <li>Global Instantiation of Publisher/Subscriber created core dump #327</li> </ul>","title":"v0.90.0 (2020-12-22)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170-2020-08-27","text":"<p>Full Changelog\\ MacOS support and preparations for new API</p> <p>Packages:</p> <ul> <li>iceoryx_posh (Quality level 4)</li> <li>iceoryx_utils (Quality level 4)</li> <li>iceoryx_examples (Quality level 5)</li> </ul> <p>Features:</p> <ul> <li>MacOS support #32</li> <li>Major RouDi refactorings #70, #59, #78</li> <li>Preparations for new iceoryx API #25</li> <li>iceoryx to cyclonedds gateway #64</li> <li>Introduce cxx::function_ref #86</li> </ul> <p>Fixed bugs:</p> <ul> <li>POSIX timer improvements #120, #167</li> <li>Memory Synchronisation Issue in FiFo #119</li> <li>Roudi MessageQueue thread startup #171</li> <li>Destructor fix MessageQueue and UnixDomainSocket #150</li> <li>RouDi ressource clean-up #113</li> </ul>","title":"v0.17.0 (2020-08-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc6-2020-07-29","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Fixed bugs:</p> <ul> <li>Sporadic timing test failure #120</li> <li>Improvement: Merge Mempool Introspection data into one sample #210</li> </ul>","title":"v0.17.0_RC6 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc5-2020-07-29","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Fixed bugs:</p> <ul> <li>Callable can outrun periodicity of POSIX timer #161</li> </ul>","title":"v0.17.0_RC5 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc4-2020-07-29","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Fixed bugs:</p> <ul> <li>The destroy method of MessageQueue and UnixDomainSocket does not fully invalidate the object #150</li> <li>Roudi message queue thread startup #171</li> </ul>","title":"v0.17.0_RC4 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc3-2020-07-27","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Features:</p> <ul> <li>cmake options for deployment parameter #142</li> </ul>","title":"v0.17.0_RC3 (2020-07-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc2-2020-07-27","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Refactoring:</p> <ul> <li>Refactoring of logging #88</li> <li>Remove const_cast wherever possible #76</li> <li>Remove asynchronous service discovery feature #90</li> <li>qacpp-4.5.0-2427 #93</li> <li>Usage of github actions to build pull requests #89</li> <li>Reduce default memory consumption with config and mempools #78</li> </ul> <p>Fixed bugs:</p> <ul> <li>Sporadic timing test failure #120</li> <li>Make SOFI real size equal to the specified one #105</li> <li>increase padding in introspection #117</li> <li>Increase the process waiting for RouDi timeout to 60 seconds #110</li> </ul>","title":"v0.17.0_RC2 (2020-07-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc1-2020-03-24","text":"<p>Full Changelog\\ Release Candidate for 0.17.0 release</p> <p>Features:</p> <ul> <li>Memory abstraction, modularization of RouDi and fixes #59</li> <li>Memory abstraction and RouDi modularization step 2, fixed string improvements and other fixes #70</li> </ul> <p>Fixed bugs:</p> <ul> <li>Can't compile due to missing CPPTOML #67</li> </ul>","title":"v0.17.0_RC1 (2020-03-24)"},{"location":"release-notes/iceoryx-v1-0-0/#v0161-2020-03-02","text":"<p>Full Changelog\\ Support for rmw_iceoryx with ROS2 python API</p> <p>Packages:</p> <ul> <li>POSH (POSIX Shared Memory)</li> <li>Utils</li> <li>Iceoryx examples</li> </ul> <p>Features:</p> <ul> <li>Capability to cleanup shared memory resources during process lifetime #51</li> </ul> <p>Fixed bugs:</p> <ul> <li>compile error with clang #43</li> <li>CMqInterface unit tests are failing caused by unneeded move operations #56</li> </ul> <p>Known limitations:</p> <ul> <li><code>RouDi --version</code> shows 0.16.0.1 instead of 0.16.1</li> </ul>","title":"v0.16.1 (2020-03-02)"},{"location":"release-notes/iceoryx-v1-0-0/#v0160-2019-12-16","text":"<p>Introspection, performance test and flexible mapping of shared memory</p> <p>Packages:</p> <ul> <li>POSH (POSIX Shared Memory)</li> <li>Utils</li> <li>Iceoryx examples</li> </ul> <p>Features:</p> <ul> <li>Introspection client for live debugging of iceoryx #21</li> <li>Flexible mapping of shared memory in virtual address spaces #19</li> <li>Performance test to measure inter-process latency #17</li> <li>Docker build #15 (Thanks to @Mr-Slippery )</li> </ul> <p>Fixed bugs:</p> <ul> <li>Payload size not updated by allocateChunk #10</li> <li>Failure in runnable creation #23</li> </ul> <p>Command for generating git log for merge commits between two tags</p> <pre><code>**git log --merges --first-parent master --pretty=format:\"%h %&lt;(10,trunc)%aN %C(white)%&lt;(15)%aD%Creset %C(red bold)%&lt;(15)%D%Creset %s\" &lt;TAG_BASE&gt;...&lt;TAG_TARGET&gt; &gt; diff_merge_commit.log**\n</code></pre>","title":"v0.16.0 (2019-12-16)"},{"location":"release-notes/iceoryx-v1-0-1/","text":"","title":"iceoryx v.1.0.1"},{"location":"release-notes/iceoryx-v1-0-1/#v101-2021-06-15","text":"<p>Full Changelog</p> <p>Description: This is the first bugfix release for Eclipse iceoryx 1.0.0. We made minor changes in the documentation and added several patches.</p> <p>Compared to the feature content of the release 1.0.0, the following bug tickets where resolved:</p> <p>Bugfixes:</p> <ul> <li>Github CI Integrationtests failing #825</li> <li>Segmentation Fault in FileLock #808</li> <li>cpptoml cannot be build due to failing examples #791</li> <li>Missing template parameter for user-header in typed C++ API #768</li> <li>Fix issues with generating website documentation #743</li> <li>Starting an application after RouDi was terminated floods the cmd line with error messages #654</li> </ul>","title":"v1.0.1 (2021-06-15)"},{"location":"release-notes/iceoryx-v1-0-2/","text":"","title":"iceoryx v.1.0.2"},{"location":"release-notes/iceoryx-v1-0-2/#v102-2022-02-18","text":"<p>Full Changelog</p> <p>Bugfixes:</p> <ul> <li>Backporting Bugfixes for GCC 11 #1092</li> </ul>","title":"v1.0.2 (2022-02-18)"},{"location":"release-notes/iceoryx-v2-0-0/","text":"","title":"iceoryx v2.0.0"},{"location":"release-notes/iceoryx-v2-0-0/#v200-2022-03-14","text":"<p>Full Changelog</p> <p>Features:</p> <ul> <li>block publisher when subscriber queue full #615</li> <li>extend chunk header for gateways and recompute #711</li> <li>Basic Windows 10 support #33</li> <li>Common puml file for common settings #865</li> <li>Relocatable Pointers - Version 2.0 #926</li> <li>Implement <code>waitForTerminationRequest</code> #973</li> <li>Partial enable iceoryx building with msvc2015+clang #965</li> <li>C binding for posh configuration #930</li> <li>Enhance MacOS performance with timed{send,receive} functionality in unix domain socket#903</li> <li>Multi-Publisher support for DDS gateway and generic gateway class #900</li> <li>Replace <code>iox-gw-iceoryx2dds</code> and <code>iox-gw-dds2iceoryx</code> gateways with <code>iox-dds-gateway</code> #900</li> <li>Enhance <code>posixCall</code> #805</li> <li>Git Hooks on iceoryx #486</li> <li>static memory alternative for std::function #391</li> <li>Adding support for Helix QAC 2021.1 #755 thanks to @toniglandy1</li> <li>Axivion analysis on CI #409</li> <li>Cpptoml can be provided by an external source #951</li> <li>Extend <code>cxx::optional</code> constructor for in place construction so that copy/move for values inside the optional even could be deleted #967</li> <li>Add templated <code>from</code>/<code>into</code> free functions to formalize conversions from enums and other types #992</li> <li><code>UniqueId</code> class for unique IDs within a process #1010</li> <li>Add <code>requirePublisherHistorySupport</code> option at subscriber side (if set to true requires historyCapacity &gt; 0 to be eligible for connection) #1029, #1278</li> <li>Add <code>/tools/scripts/ice_env.sh</code> shell script to provide simple access to docker containers for CI debugging #1049</li> <li>Introduce <code>cxx::FunctionalInterface</code> to enrich nullable classes with <code>and_then</code>, <code>or_else</code>, <code>value_or</code>, <code>expect</code> #996</li> <li>Add C++17 <code>std::perms</code> as <code>cxx::perms</code> to <code>iceoryx_hoofs/cxx/filesystem.hpp</code>. #1059</li> <li>Support FreeBSD as a representative for the UNIX platforms #1054</li> <li>Add event parameter to <code>findService</code> method #415</li> <li>Implement stream operator for <code>ChunkReceiveResult</code> and <code>AllocationError</code> to be able to use it with ostream and LogStream #1062</li> <li>Replace IPC-channel-based <code>findService</code> with pub/sub-based on #415</li> <li>Add <code>findService</code> method to <code>ServiceDiscovery</code> which applies a callable to all matching services #1105</li> <li>Increase limits of <code>ServiceRegistry</code> to support the maximum number of publishers and servers that are configured in <code>iceoryx_posh_types.hpp</code> #1074</li> <li>C binding for service discovery #1142</li> <li>Introduce <code>iox::popo::MessagingPattern</code> to <code>findService</code> to allow separate searches for publishers (<code>MessagingPattern::PUB_SUB</code>) and servers (<code>iox::popo::MessagingPattern::REQ_RES</code>) #27</li> <li>Request/Response communication with iceoryx #27<ul> <li>For more details how this feature can be used please have a look at the <code>iceoryx_examples/request_response</code></li> <li>Limitations<ul> <li>The port introspection is not aware of the new <code>Client</code> and <code>Server</code> #1128</li> <li>The DDS gateway is not aware of the new <code>Server</code> #1145</li> </ul> </li> </ul> </li> <li>Set <code>MAX_NUMBER_OF_NOTIFIERS</code> to 256 and prepare configuration via CMake#1144</li> <li>Reorganize code in publisher.hpp/.inl and subscriber.hpp/inl #1173</li> <li>Install headers to <code>include/iceoryx/vX.Y.Z</code> by default and add CMake option <code>MAKE_UNIQUE_INCLUDEDIR</code> to control the behavior #1194</li> </ul> <p>Bugfixes:</p> <ul> <li>Analyse suppressed errors of AddressSanitizer, LeakSanitizer &amp; UndefinedBehaviorSanitizer #423</li> <li>CMake file duplicate option in build_options.cmake #709 thanks to @ZhenshengLee</li> <li>SharedChunk should internally store an absolute pointer #713</li> <li>loanPreviousChunk is broken #729</li> <li>Runtime Error in SubscriberImpl #714</li> <li>Wrong Values of iox-cpp-subscriber and iox-cpp-publisher #781</li> <li>CMake fails during googletest step with gcc 11.1.0 #798</li> <li>NewType Copy-Assign raises compiler warning on GCC 8.4.0 #282</li> <li>Apply noexcept all the things rule to posh, hoofs and binding_c #916</li> <li>Doxygen shows wrong include paths #922</li> <li><code>find_package(iceoryx_posh)</code> fails #944 thanks to @ijnek</li> <li>iox-roudi report error when running in docker #946</li> <li>compile error: duration.inl - duration literals are not found (Windows) #1078</li> <li><code>cxx::string</code> initialization with nullptr leads to segfault #1108</li> <li>Fix support for libc++ on clang #905</li> <li>Fix warnings for gcc-11.1 #838</li> <li>Incremental builds with the build script are broken #821</li> <li>Compile failed because of missing <code>&lt;limits&gt;</code> for GCC 11 #811 thanks to @homalozoa</li> <li>Unable to build cyclone dds <code>idlpp-cxx</code> #736</li> <li>Fix format string issues with introspection client #960 thanks to @roehling</li> <li>Add support for Multi-Arch install destinations #961 thanks to @roehling</li> <li>Fix a few misspellings in log messages #962 thanks to @roehling</li> <li>Fix typos in goals/non-goals document #968 thanks to @ fb913bf0de288ba84fe98f7a23d35edfdb22381</li> <li>Catch deserialization errors for enums in publisher and subscriber options #989</li> <li>Fix linker error on QNX #1013</li> <li>When posix mutex fails a correct error message is reported on the console #999</li> <li>Only use <code>std::result_of</code> for C++14 to be able to use iceoryx in C++20 projects #1076</li> <li>Set stack size for windows in <code>singleprocess</code> example and posh tests #1082</li> <li>Roudi console timestamps are out of date #1130</li> <li>Application can't create publisher repeatedly with previous one already destroyed #938</li> <li>Prevent creation of <code>popo::Publisher</code>'s with internal <code>ServiceDescription</code> #1120</li> <li>RelativePointer is now type safe, i.e. can only be constructed from pointers with a valid convertion to the raw pointer #1121</li> <li>Clamping <code>historyRequest</code> to <code>queueCapacity</code> #1192</li> <li>C binding storage sizes do not match for multiple OS's and architectures #1218</li> <li>Update cyclone dds version used by gateway to support aarch64 #1223</li> <li>The file lock posix wrapper unlocks and removes a file correctly #1216</li> <li>Minor fixes for the examples #743</li> <li>Fix race condition in Windows platform semaphore/mutex posix implementation #1271</li> <li>Fix race condition in Windows platform HandleTranslator #1264</li> <li>Fix race condition in Windows platform shared memory implementation #1269</li> </ul> <p>Refactoring:</p> <ul> <li>implement Module-Tests for smart_lock #588</li> <li>improve Helix QAC parsing coverage #759 thanks to @toniglandy1</li> <li>Write \"ROS 2\" with a space between \"ROS\" and \"2\" #762 thanks to @christophebedard</li> <li>Enforce unix line endings #794</li> <li>Rename utils to hoofs #790</li> <li>Cleanup MemoryProvider and MemoryBlock #842</li> <li>Remove #define private public from all tests #529</li> <li>Write example on how to use iceoryx in a docker environment #924</li> <li>Allow cpptoml to be provided externally and not vendored by CMake #950 thanks to @photex</li> <li>Reworked iceoryx examples #482</li> <li>Handle nullptr callbacks in waitset and listener #932</li> <li>Add CI job that checks formatting with clang-format #887</li> <li>Add clang-tidy rules for iceoryx_hoofs #889</li> <li>Consolidate CI jobs in one workflow #891</li> <li>Move all tests into an anonymous namespace #563</li> <li>Refactor <code>smart_c</code> to use contract by design and expected #418</li> <li><code>PoshRuntime</code> Mock #449</li> <li>Clean-up Doxygen for dds #583</li> <li>Rename utils to hoofs #790</li> <li>plantuml in design documentation #787</li> <li>Refine quality levels #425</li> <li>Clean-up std::terminate usage #261</li> <li>Add Quality Declaration Document #910</li> <li>Make <code>cxx::string::capacity</code> a <code>static</code> method #979</li> <li>Restructure iceoryx tools #471</li> <li>Use cxx::expected for MemoryManager::getChunk #954</li> <li>Upgrade GTest/GMock to v1.10 #841</li> <li>Remove the requirement for INVALID_STATE for the cxx::expected #987</li> <li>Add unique test identifers #988</li> <li>Remove <code>ApplicationPort</code> and <code>ApplicationPortData</code> classes #415</li> <li>Remove creation pattern from <code>MemoryMap</code> and replace it with <code>MemoryMapBuilder</code> #1036</li> <li>Fix error handling of <code>TypedUniqueId</code> and refactor it to <code>UniquePortId</code> #861</li> <li>Updating Codecov API and enforce CMake version 3.16 for building iceoryx #774 and #1031</li> <li>Remove <code>InvalidIdString</code> and <code>isValid()</code> from <code>ServiceDescription</code>, replace Wildcard string with <code>iox::cxx::nullopt</code> #415</li> <li>Remove creation pattern from <code>SharedMemory</code> and replace it with <code>SharedMemoryBuilder</code> #1036</li> <li>Remove the leading slash requirement from the name of a shared memory in <code>SharedMemory</code> and <code>SharedMemoryObject</code> #439</li> </ul> <p>New API features:</p> <ol> <li> <p>Introduce <code>iceoryx_hoofs/cxx/filesystem.hpp</code> which implements <code>std::perms</code> as <code>cxx::perms</code>.</p> <pre><code>#include \"iceoryx_hoofs/cxx/filesystem.hpp\"\n\n// ...\ncxx::perms filePermissions;\nfilePermissions = cxx::perms::owner_read | cxx::perms::group_write;\nstd::cout &lt;&lt; filePermissions &lt;&lt; std::endl;\n</code></pre> </li> </ol> <p>API Breaking Changes:</p> <ol> <li> <p>The CMake files in iceoryx expect to have CMake version 3.16 or greater installed, otherwise the build fails.    (Hint: Ubuntu 18 users can install <code>cmake-mozilla</code> from the universe repository provided by Canonical)</p> </li> <li> <p>Dependency for building the <code>iceoryx_dds</code> gateway changed from <code>openjdk</code> (Java) to <code>bison</code></p> </li> <li> <p>Change include from <code>iceoryx_hoofs/cxx/helplets.hpp</code> to <code>iceoryx_hoofs/cxx/requires.hpp</code>    when using <code>cxx::Expects</code> or <code>cxx::Ensures</code></p> <pre><code>// before\n#include \"iceoryx_hoofs/cxx/helplets.hpp\"\n\niox::cxx::Expects(someCondition);\niox::cxx::Ensures(anotherCondition);\n\n// after\n#include \"iceoryx_hoofs/cxx/requires.hpp\"\n\niox::cxx::Expects(someCondition);\niox::cxx::Ensures(anotherCondition);\n</code></pre> </li> <li> <p>Replace Creation pattern from <code>MemoryMap</code> with <code>MemoryMapBuilder</code>.</p> <pre><code>// before\nauto memoryMapResult = posix::MemoryMap::create(baseAddress, length, fileDescriptor, accessMode, flags, offset);\n\n// after\nauto memoryMapResult = posix::MemoryMapBuilder().baseAddressHint(baseAddress)\n                                                .length(length).fileDescriptor(fileDescriptor)\n                                                .accessMode(accessMode).flags(flags)\n                                                .offset(0).create();\n</code></pre> </li> <li> <p>Rename utils to hoofs:</p> <p>In CMake you need now to find and link the package <code>iceoryx_hoofs</code> instead of <code>iceoryx_utils</code></p> <pre><code># before\nfind_package(iceoryx_utils REQUIRED)\ntarget_link_libraries(${target}\n    iceoryx_utils::iceoryx_utils)\n\n# after\nfind_package(iceoryx_hoofs REQUIRED)\ntarget_link_libraries(${target}\n    iceoryx_hoofs::iceoryx_hoofs)\n</code></pre> <p>The include paths for <code>iceoryx_utils</code> are now <code>iceoryx_hoofs</code></p> <pre><code>// before\n#include \"iceoryx_utils/cxx/string.hpp\"\n\n// after\n#include \"iceoryx_hoofs/cxx/string.hpp\"\n</code></pre> </li> <li> <p>Refactoring SmartC:</p> <ul> <li>Renaming SmartC wrapper to posixCall.</li> <li>Removed <code>getErrorString()</code> from posixCall, please use <code>getHumanReadableErrnum()</code> instead.</li> <li>Enhanced posixCall to handle a common case were multiple errnos are ignored just to suppress error logging</li> </ul> <pre><code>// before\n#include \"iceoryx_utils/cxx/smart_c.hpp\"\n\nauto unlinkCallPublisher = iox::cxx::makeSmartC(\n    unlink, iox::cxx::ReturnMode::PRE_DEFINED_ERROR_CODE, {ERROR_CODE}, {ENOENT}, sockAddrPublisher.sun_path);\n\n    if (unlinkCallPublisher.hasErrors())\n    {\n        std::cout &lt;&lt; \"unlink error\" &lt;&lt; std::endl;\n        exit(1);\n    }\n\n// after\n#include \"iceoryx_utils/posix_wrapper/posix_call.hpp\"\n\niox::posix::posixCall(unlink)(sockAddrPublisher.sun_path)\n    .failureReturnValue(ERROR_CODE)\n    .ignoreErrnos(ENOENT, EBUSY) // can be a comma-separated list of errnos\n    .evaluate()\n    .or_else([](auto&amp; r) {\n        std::cout &lt;&lt; \"unlink error \" &lt;&lt; r.getHumanReadableErrnum() &lt;&lt; std::endl;\n        exit(1);\n    });\n</code></pre> </li> <li> <p>Refactoring of <code>ServiceDescription</code></p> <ul> <li>A <code>ServiceDescription</code> is now only string-based and no more wildcards are allowed.</li> <li>A well-defined <code>ServiceDescription</code> consists of three non-empty strings.</li> </ul> <pre><code>// before\nServiceDescription myServiceDescription1(1U, 2U, 3U);\nServiceDescription myServiceDescription3(\"First\", \"Second\");\nServiceDescription myServiceDescription3(iox::capro::AnyServiceString, iox::capro::AnyInstanceString, iox::capro::AnyEventString);\n\n// after\nServiceDescription myServiceDescription1(\"Foo\", \"Bar\", \"Baz\");\nServiceDescription myServiceDescription2(\"First\", \"Second\", \"DontCare\");\nServiceDescription myServiceDescription3(\"Foo\", \"Bar\", \"Baz\");\n</code></pre> </li> <li> <p>Instead of using a constructor a <code>ServiceDescription</code> is now deserialized via a    static method with error handling:</p> <pre><code>// before\niox::cxx::Serialization serializedObj;\niox::capro::ServiceDescription service(serializedObj);\n\n// after\niox::cxx::Serialization serialisedObj;\ncapro::ServiceDescription::deserialize(serialisedObj)\n    .and_then([](auto&amp; value){\n        // Do something with the deserialized object\n    })\n    .or_else([](auto&amp; error){\n        // Handle the error\n    });\n</code></pre> </li> <li> <p>The <code>InvalidIdString</code> was removed from <code>ServiceDescription</code> and the Wildcard string was replaced    with a <code>iox::cxx::nullopt</code>. With this, every string is allowed within the <code>ServiceDescription</code>.    The default <code>ServiceDescription</code> consists of empty strings.</p> </li> <li> <p>The service-related methods have been moved from <code>PoshRuntime</code> to <code>ServiceDiscovery</code>. The <code>offerService</code>    and <code>stopOfferService</code> methods have been removed and <code>findService</code> has now an additional event parameter.    Furthermore it requires a function to be provided which is applied to each <code>ServiceDescription</code> in    the search result (and can be used to collect them in a container etc.).</p> </li> </ol> <p>The <code>iox::popo::MessagingPattern</code> parameter allows to search publishers (<code>PUB_SUB</code>) or    servers (<code>REQ_RES</code>).</p> <pre><code>```cpp\n// before\n#include \"iceoryx_posh/runtime/posh_runtime.hpp\"\n\nposhRuntime.offerService(myServiceDescription);\nposhRuntime.stopOfferService(myServiceDescription);\nposhRuntime.findService({\"ServiceA\", iox::capro::AnyInstanceString});\n\n// after\n#include \"iceoryx_posh/runtime/service_discovery.hpp\"\n\nvoid printSearchResult(const iox::capro::ServiceDescription&amp; service)\n{\n    std::cout &lt;&lt; \"- \" &lt;&lt; service &lt;&lt; std::endl;\n}\n\nserviceDiscovery.findService(\"ServiceA\", Wildcard, Wildcard, printSearchResult, iox::popo::MessagingPattern::PUB_SUB);\n```\n</code></pre> <ol> <li> <p>The following classes have now an constructor marked as <code>explicit</code>:</p> <pre><code>explicit DeadlineTimer(const iox::units::Duration timeToWait);\nexplicit GenericRAII(const std::function&lt;void()&gt;&amp; cleanupFunction);\nexplicit mutex(const bool f_isRecursive);\nexplicit PosixUser(const uid_t f_id);\nexplicit PosixUser(const string_t&amp; f_name);\n</code></pre> </li> <li> <p>Renaming in <code>FileReader</code> class and logging of iceoryx_hoofs</p> <pre><code>// before\niox::cxx::FileReader reader(\"filename\");\nstd::string str;\nif(reader.IsOpen()) {\n    reader.ReadLine(str);\n}\n\nstatic auto&amp; logger = CreateLogger(\"\", \"\", iox::log::LogManager::GetLogManager().DefaultLogLevel());\n\n// after\niox::cxx::FileReader reader(\"filename\");\nstd::string str;\nif(reader.isOpen()) {\n    reader.readLine(str);\n}\n\nstatic auto&amp; logger = createLogger(\"\", \"\", iox::log::LogManager::GetLogManager().DefaultLogLevel());\n</code></pre> </li> <li> <p>The <code>iox::cxx::expected</code> has dropped the requirement for <code>INVALID_STATE</code>. With this, the    <code>ErrorTypeAdapter</code> which was necessary for non enum types was also removed. The specialization    of <code>ErrorTypeAdapter</code> for custom types must therefore also be removed in the user code.</p> </li> <li> <p>The queue port policy enums are adjusted to use them with <code>Client</code> and <code>Server</code>.</p> </li> <li> <p>The <code>QueueFullPolicy::BLOCK_PUBLISHER</code> is replaced with the more generic <code>QueueFullPolicy::BLOCK_PRODUCER</code>.</p> <pre><code>// old\niox::popo::SubscriberOptions options;\noptions.queueFullPolicy = iox::popo::QueueFullPolicy::BLOCK_PUBLISHER;\n\n// new\niox::popo::SubscriberOptions options;\noptions.queueFullPolicy = iox::popo::QueueFullPolicy::BLOCK_PRODUCER;\n</code></pre> <p>Similar, for <code>binding_c</code> it is <code>QueueFullPolicy_BLOCK_PRODUCER</code> instead of <code>QueueFullPolicy_BLOCK_PUBLISHER</code></p> <pre><code>// old\niox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.queueFullPolicy = QueueFullPolicy_BLOCK_PUBLISHER;\n\n// new\niox_sub_options_t options;\niox_sub_options_init(&amp;options);\noptions.queueFullPolicy = QueueFullPolicy_BLOCK_PRODUCER;\n</code></pre> </li> <li> <p>The <code>SubscriberTooSlowPolicy</code> is replaced with the more generic <code>ConsumerTooSlowPolicy</code> and    <code>SubscriberTooSlowPolicy::WAIT_FOR_SUBSCRIBER</code> became <code>ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER</code>.</p> <pre><code>// old\niox::popo::PublisherOptions options;\noptions.subscriberTooSlowPolicy = iox::popo::SubscriberTooSlowPolicy::WAIT_FOR_SUBSCRIBER;\n\n// new\niox::popo::PublisherOptions options;\noptions.subscriberTooSlowPolicy = iox::popo::ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER;\n</code></pre> <p>And with the <code>binding_c</code></p> <pre><code>// old\niox_pub_options_t options;\niox_pub_options_init(&amp;options);\noptions.subscriberTooSlowPolicy = SubscriberTooSlowPolicy_WAIT_FOR_SUBSCRIBER;\n\n// new\niox_pub_options_t options;\niox_pub_options_init(&amp;options);\noptions.subscriberTooSlowPolicy = ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER;\n</code></pre> </li> <li> <p>The <code>CaproMessageSubType</code> enum is renamed to <code>CaproServiceType</code> and the values are renamed from <code>NOSUBTYPE</code>,   <code>SERVICE</code>, <code>EVENT</code> and <code>FIELD</code> to <code>NONE</code>, <code>PUBLISHER</code> and <code>SERVER</code>.   This change only affects <code>InterfacePorts</code> which used this enum to communicate whether the <code>CaproMessage</code>   was from a <code>SERVICE</code>, <code>EVENT</code> or <code>FIELD</code>. This was quite ara::com specific and with the introduction of the <code>ServerPort</code>   changes were needed. The distinction between a <code>FIELD</code> and an <code>EVENT</code> can be made by checking   <code>CaproMessage::m_historyCapacity</code>.</p> <pre><code>// old\ncaproMessage.m_subType = CaproMessageSubType::EVENT;\n\n// new\ncaproMessage.m_serviceType = CaproServiceType::PUBLISHER;\n</code></pre> </li> </ol>","title":"v2.0.0 (2022-03-14)"}]}